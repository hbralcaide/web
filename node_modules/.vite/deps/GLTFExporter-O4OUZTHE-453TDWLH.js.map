{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/three@0.173.0/node_modules/three/examples/jsm/exporters/GLTFExporter.js"],
  "sourcesContent": ["import {\n\tBufferAttribute,\n\tClampToEdgeWrapping,\n\tColor,\n\tDoubleSide,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tNoColorSpace,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tMathUtils,\n\tMatrix4,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tPropertyBinding,\n\tRGBAFormat,\n\tRepeatWrapping,\n\tScene,\n\tSource,\n\tSRGBColorSpace,\n\tCompressedTexture,\n\tVector3,\n\tQuaternion,\n\tREVISION\n} from 'three';\n\n/**\n * The KHR_mesh_quantization extension allows these extra attribute component types\n *\n * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes\n */\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n\tPOSITION: [\n\t\t'byte',\n\t\t'byte normalized',\n\t\t'unsigned byte',\n\t\t'unsigned byte normalized',\n\t\t'short',\n\t\t'short normalized',\n\t\t'unsigned short',\n\t\t'unsigned short normalized',\n\t],\n\tNORMAL: [\n\t\t'byte normalized',\n\t\t'short normalized',\n\t],\n\tTANGENT: [\n\t\t'byte normalized',\n\t\t'short normalized',\n\t],\n\tTEXCOORD: [\n\t\t'byte',\n\t\t'byte normalized',\n\t\t'unsigned byte',\n\t\t'short',\n\t\t'short normalized',\n\t\t'unsigned short',\n\t],\n};\n\n\nclass GLTFExporter {\n\n\tconstructor() {\n\n\t\tthis.textureUtils = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFLightExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsUnlitExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsIorExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsSpecularExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsDispersionExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsSheenExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsAnisotropyExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsEmissiveStrengthExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsBumpExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMeshGpuInstancing( writer );\n\n\t\t} );\n\n\t}\n\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetTextureUtils( utils ) {\n\n\t\tthis.textureUtils = utils;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t *\n\t * @param  {Scene|Array<Scene>} input   Scene or Array of THREE.Scenes\n\t * @param  {Function} onDone  Callback on completed\n\t * @param  {Function} onError  Callback on errors\n\t * @param  {Object} options options\n\t */\n\tparse( input, onDone, onError, options ) {\n\n\t\tconst writer = new GLTFWriter();\n\t\tconst plugins = [];\n\n\t\tfor ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {\n\n\t\t\tplugins.push( this.pluginCallbacks[ i ]( writer ) );\n\n\t\t}\n\n\t\twriter.setPlugins( plugins );\n\t\twriter.setTextureUtils( this.textureUtils );\n\t\twriter.writeAsync( input, onDone, options ).catch( onError );\n\n\t}\n\n\tparseAsync( input, options ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( input, resolve, reject, options );\n\n\t\t} );\n\n\t}\n\n}\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n\tPOINTS: 0x0000,\n\tLINES: 0x0001,\n\tLINE_LOOP: 0x0002,\n\tLINE_STRIP: 0x0003,\n\tTRIANGLES: 0x0004,\n\tTRIANGLE_STRIP: 0x0005,\n\tTRIANGLE_FAN: 0x0006,\n\n\tBYTE: 0x1400,\n\tUNSIGNED_BYTE: 0x1401,\n\tSHORT: 0x1402,\n\tUNSIGNED_SHORT: 0x1403,\n\tINT: 0x1404,\n\tUNSIGNED_INT: 0x1405,\n\tFLOAT: 0x1406,\n\n\tARRAY_BUFFER: 0x8892,\n\tELEMENT_ARRAY_BUFFER: 0x8893,\n\n\tNEAREST: 0x2600,\n\tLINEAR: 0x2601,\n\tNEAREST_MIPMAP_NEAREST: 0x2700,\n\tLINEAR_MIPMAP_NEAREST: 0x2701,\n\tNEAREST_MIPMAP_LINEAR: 0x2702,\n\tLINEAR_MIPMAP_LINEAR: 0x2703,\n\n\tCLAMP_TO_EDGE: 33071,\n\tMIRRORED_REPEAT: 33648,\n\tREPEAT: 10497\n};\n\nconst KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';\n\nconst THREE_TO_WEBGL = {};\n\nTHREE_TO_WEBGL[ NearestFilter ] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ LinearFilter ] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[ LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n\nTHREE_TO_WEBGL[ ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[ RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[ MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\tposition: 'translation',\n\tquaternion: 'rotation',\n\tmorphTargetInfluences: 'weights'\n};\n\nconst DEFAULT_SPECULAR_COLOR = new Color();\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546C67;\nconst GLB_VERSION = 2;\n\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n * @param  {Array} array1 Array 1 to compare\n * @param  {Array} array2 Array 2 to compare\n * @return {Boolean}        Returns true if both arrays are equal\n */\nfunction equalArray( array1, array2 ) {\n\n\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\n\n\t\treturn element === array2[ index ];\n\n\t} );\n\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param  {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer( text ) {\n\n\treturn new TextEncoder().encode( text ).buffer;\n\n}\n\n/**\n * Is identity matrix\n *\n * @param {Matrix4} matrix\n * @returns {Boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix( matrix ) {\n\n\treturn equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );\n\n}\n\n/**\n * Get the min and max vectors from the given attribute\n *\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param  {Number} start Start index\n * @param  {Number} count Range to cover\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax( attribute, start, count ) {\n\n\tconst output = {\n\n\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\n\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\n\n\t};\n\n\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\tlet value;\n\n\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t} else {\n\n\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\tif ( attribute.normalized === true ) {\n\n\t\t\t\t\tvalue = MathUtils.normalize( value, attribute.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\n\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\n\n\t\t}\n\n\t}\n\n\treturn output;\n\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @param {Number} bufferSize The size the original buffer. Should be an integer.\n * @returns {Number} new buffer size with required padding as an integer.\n *\n */\nfunction getPaddedBufferSize( bufferSize ) {\n\n\treturn Math.ceil( bufferSize / 4 ) * 4;\n\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {Number} [paddingByte=0] Should be an integer\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {\n\n\tconst paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\n\n\tif ( paddedLength !== arrayBuffer.byteLength ) {\n\n\t\tconst array = new Uint8Array( paddedLength );\n\t\tarray.set( new Uint8Array( arrayBuffer ) );\n\n\t\tif ( paddingByte !== 0 ) {\n\n\t\t\tfor ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\n\n\t\t\t\tarray[ i ] = paddingByte;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn array.buffer;\n\n\t}\n\n\treturn arrayBuffer;\n\n}\n\nfunction getCanvas() {\n\n\tif ( typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined' ) {\n\n\t\treturn new OffscreenCanvas( 1, 1 );\n\n\t}\n\n\treturn document.createElement( 'canvas' );\n\n}\n\nfunction getToBlobPromise( canvas, mimeType ) {\n\n\tif ( canvas.toBlob !== undefined ) {\n\n\t\treturn new Promise( ( resolve ) => canvas.toBlob( resolve, mimeType ) );\n\n\t}\n\n\tlet quality;\n\n\t// Blink's implementation of convertToBlob seems to default to a quality level of 100%\n\t// Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n\tif ( mimeType === 'image/jpeg' ) {\n\n\t\tquality = 0.92;\n\n\t} else if ( mimeType === 'image/webp' ) {\n\n\t\tquality = 0.8;\n\n\t}\n\n\treturn canvas.convertToBlob( {\n\n\t\ttype: mimeType,\n\t\tquality: quality\n\n\t} );\n\n}\n\n/**\n * Writer\n */\nclass GLTFWriter {\n\n\tconstructor() {\n\n\t\tthis.plugins = [];\n\n\t\tthis.options = {};\n\t\tthis.pending = [];\n\t\tthis.buffers = [];\n\n\t\tthis.byteOffset = 0;\n\t\tthis.buffers = [];\n\t\tthis.nodeMap = new Map();\n\t\tthis.skins = [];\n\n\t\tthis.extensionsUsed = {};\n\t\tthis.extensionsRequired = {};\n\n\t\tthis.uids = new Map();\n\t\tthis.uid = 0;\n\n\t\tthis.json = {\n\t\t\tasset: {\n\t\t\t\tversion: '2.0',\n\t\t\t\tgenerator: 'THREE.GLTFExporter r' + REVISION\n\t\t\t}\n\t\t};\n\n\t\tthis.cache = {\n\t\t\tmeshes: new Map(),\n\t\t\tattributes: new Map(),\n\t\t\tattributesNormalized: new Map(),\n\t\t\tmaterials: new Map(),\n\t\t\ttextures: new Map(),\n\t\t\timages: new Map()\n\t\t};\n\n\t\tthis.textureUtils = null;\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\tsetTextureUtils( utils ) {\n\n\t\tthis.textureUtils = utils;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t *\n\t * @param {Scene|Array<Scene>} input Scene or Array of THREE.Scenes\n\t * @param {Function} onDone Callback on completed\n\t * @param {Object} options options\n\t */\n\tasync writeAsync( input, onDone, options = {} ) {\n\n\t\tthis.options = Object.assign( {\n\t\t\t// default options\n\t\t\tbinary: false,\n\t\t\ttrs: false,\n\t\t\tonlyVisible: true,\n\t\t\tmaxTextureSize: Infinity,\n\t\t\tanimations: [],\n\t\t\tincludeCustomExtensions: false\n\t\t}, options );\n\n\t\tif ( this.options.animations.length > 0 ) {\n\n\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\n\t\t\tthis.options.trs = true;\n\n\t\t}\n\n\t\tawait this.processInputAsync( input );\n\n\t\tawait Promise.all( this.pending );\n\n\t\tconst writer = this;\n\t\tconst buffers = writer.buffers;\n\t\tconst json = writer.json;\n\t\toptions = writer.options;\n\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\t\tconst extensionsRequired = writer.extensionsRequired;\n\n\t\t// Merge buffers.\n\t\tconst blob = new Blob( buffers, { type: 'application/octet-stream' } );\n\n\t\t// Declare extensions.\n\t\tconst extensionsUsedList = Object.keys( extensionsUsed );\n\t\tconst extensionsRequiredList = Object.keys( extensionsRequired );\n\n\t\tif ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;\n\t\tif ( extensionsRequiredList.length > 0 ) json.extensionsRequired = extensionsRequiredList;\n\n\t\t// Update bytelength of the single buffer.\n\t\tif ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;\n\n\t\tif ( options.binary === true ) {\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\t// Binary chunk.\n\t\t\t\tconst binaryChunk = getPaddedArrayBuffer( reader.result );\n\t\t\t\tconst binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\n\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\n\n\t\t\t\t// JSON chunk.\n\t\t\t\tconst jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );\n\t\t\t\tconst jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\n\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\n\n\t\t\t\t// GLB header.\n\t\t\t\tconst header = new ArrayBuffer( GLB_HEADER_BYTES );\n\t\t\t\tconst headerView = new DataView( header );\n\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\n\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\n\t\t\t\tconst totalByteLength = GLB_HEADER_BYTES\n\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\n\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\n\n\t\t\t\tconst glbBlob = new Blob( [\n\t\t\t\t\theader,\n\t\t\t\t\tjsonChunkPrefix,\n\t\t\t\t\tjsonChunk,\n\t\t\t\t\tbinaryChunkPrefix,\n\t\t\t\t\tbinaryChunk\n\t\t\t\t], { type: 'application/octet-stream' } );\n\n\t\t\t\tconst glbReader = new FileReader();\n\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\n\t\t\t\tglbReader.onloadend = function () {\n\n\t\t\t\t\tonDone( glbReader.result );\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tif ( json.buffers && json.buffers.length > 0 ) {\n\n\t\t\t\tconst reader = new FileReader();\n\t\t\t\treader.readAsDataURL( blob );\n\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\tconst base64data = reader.result;\n\t\t\t\t\tjson.buffers[ 0 ].uri = base64data;\n\t\t\t\t\tonDone( json );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tonDone( json );\n\n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\t/**\n\t * Serializes a userData.\n\t *\n\t * @param {THREE.Object3D|THREE.Material} object\n\t * @param {Object} objectDef\n\t */\n\tserializeUserData( object, objectDef ) {\n\n\t\tif ( Object.keys( object.userData ).length === 0 ) return;\n\n\t\tconst options = this.options;\n\t\tconst extensionsUsed = this.extensionsUsed;\n\n\t\ttry {\n\n\t\t\tconst json = JSON.parse( JSON.stringify( object.userData ) );\n\n\t\t\tif ( options.includeCustomExtensions && json.gltfExtensions ) {\n\n\t\t\t\tif ( objectDef.extensions === undefined ) objectDef.extensions = {};\n\n\t\t\t\tfor ( const extensionName in json.gltfExtensions ) {\n\n\t\t\t\t\tobjectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];\n\t\t\t\t\textensionsUsed[ extensionName ] = true;\n\n\t\t\t\t}\n\n\t\t\t\tdelete json.gltfExtensions;\n\n\t\t\t}\n\n\t\t\tif ( Object.keys( json ).length > 0 ) objectDef.extras = json;\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' +\n\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns ids for buffer attributes.\n\t *\n\t * @param  {Object} attribute\n\t * @param {boolean} [isRelativeCopy=false]\n\t * @return {Number} An integer\n\t */\n\tgetUID( attribute, isRelativeCopy = false ) {\n\n\t\tif ( this.uids.has( attribute ) === false ) {\n\n\t\t\tconst uids = new Map();\n\n\t\t\tuids.set( true, this.uid ++ );\n\t\t\tuids.set( false, this.uid ++ );\n\n\t\t\tthis.uids.set( attribute, uids );\n\n\t\t}\n\n\t\tconst uids = this.uids.get( attribute );\n\n\t\treturn uids.get( isRelativeCopy );\n\n\t}\n\n\t/**\n\t * Checks if normal attribute values are normalized.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {Boolean}\n\t */\n\tisNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) ) return false;\n\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = normal.count; i < il; i ++ ) {\n\n\t\t\t// 0.0005 is from glTF-validator\n\t\t\tif ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Creates normalized normal buffer attribute.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {BufferAttribute}\n\t *\n\t */\n\tcreateNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) )\treturn cache.attributesNormalized.get( normal );\n\n\t\tconst attribute = normal.clone();\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tv.fromBufferAttribute( attribute, i );\n\n\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\n\n\t\t\t\t// if values can't be normalized set (1, 0, 0)\n\t\t\t\tv.setX( 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\tv.normalize();\n\n\t\t\t}\n\n\t\t\tattribute.setXYZ( i, v.x, v.y, v.z );\n\n\t\t}\n\n\t\tcache.attributesNormalized.set( normal, attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\t/**\n\t * Applies a texture transform, if present, to the map definition. Requires\n\t * the KHR_texture_transform extension.\n\t *\n\t * @param {Object} mapDef\n\t * @param {THREE.Texture} texture\n\t */\n\tapplyTextureTransform( mapDef, texture ) {\n\n\t\tlet didTransform = false;\n\t\tconst transformDef = {};\n\n\t\tif ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {\n\n\t\t\ttransformDef.offset = texture.offset.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.rotation !== 0 ) {\n\n\t\t\ttransformDef.rotation = texture.rotation;\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {\n\n\t\t\ttransformDef.scale = texture.repeat.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( didTransform ) {\n\n\t\t\tmapDef.extensions = mapDef.extensions || {};\n\t\t\tmapDef.extensions[ 'KHR_texture_transform' ] = transformDef;\n\t\t\tthis.extensionsUsed[ 'KHR_texture_transform' ] = true;\n\n\t\t}\n\n\t}\n\n\tasync buildMetalRoughTextureAsync( metalnessMap, roughnessMap ) {\n\n\t\tif ( metalnessMap === roughnessMap ) return metalnessMap;\n\n\t\tfunction getEncodingConversion( map ) {\n\n\t\t\tif ( map.colorSpace === SRGBColorSpace ) {\n\n\t\t\t\treturn function SRGBToLinear( c ) {\n\n\t\t\t\t\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn function LinearToLinear( c ) {\n\n\t\t\t\treturn c;\n\n\t\t\t};\n\n\t\t}\n\n\t\tif ( metalnessMap instanceof CompressedTexture ) {\n\n\t\t\tmetalnessMap = await this.decompressTextureAsync( metalnessMap );\n\n\t\t}\n\n\t\tif ( roughnessMap instanceof CompressedTexture ) {\n\n\t\t\troughnessMap = await this.decompressTextureAsync( roughnessMap );\n\n\t\t}\n\n\t\tconst metalness = metalnessMap ? metalnessMap.image : null;\n\t\tconst roughness = roughnessMap ? roughnessMap.image : null;\n\n\t\tconst width = Math.max( metalness ? metalness.width : 0, roughness ? roughness.width : 0 );\n\t\tconst height = Math.max( metalness ? metalness.height : 0, roughness ? roughness.height : 0 );\n\n\t\tconst canvas = getCanvas();\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\n\t\tconst context = canvas.getContext( '2d', {\n\t\t\twillReadFrequently: true,\n\t\t} );\n\t\tcontext.fillStyle = '#00ffff';\n\t\tcontext.fillRect( 0, 0, width, height );\n\n\t\tconst composite = context.getImageData( 0, 0, width, height );\n\n\t\tif ( metalness ) {\n\n\t\t\tcontext.drawImage( metalness, 0, 0, width, height );\n\n\t\t\tconst convert = getEncodingConversion( metalnessMap );\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 2; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( roughness ) {\n\n\t\t\tcontext.drawImage( roughness, 0, 0, width, height );\n\n\t\t\tconst convert = getEncodingConversion( roughnessMap );\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 1; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcontext.putImageData( composite, 0, 0 );\n\n\t\t//\n\n\t\tconst reference = metalnessMap || roughnessMap;\n\n\t\tconst texture = reference.clone();\n\n\t\ttexture.source = new Source( canvas );\n\t\ttexture.colorSpace = NoColorSpace;\n\t\ttexture.channel = ( metalnessMap || roughnessMap ).channel;\n\n\t\tif ( metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.' );\n\n\t\t}\n\n\t\tconsole.warn( 'THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.' );\n\n\t\treturn texture;\n\n\t}\n\n\n\tasync decompressTextureAsync( texture, maxTextureSize = Infinity ) {\n\n\t\tif ( this.textureUtils === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: setTextureUtils() must be called to process compressed textures.' );\n\n\t\t}\n\n\t\treturn await this.textureUtils.decompress( texture, maxTextureSize );\n\n\t}\n\n\t/**\n\t * Process a buffer to append to the default one.\n\t * @param  {ArrayBuffer} buffer\n\t * @return {0}\n\t */\n\tprocessBuffer( buffer ) {\n\n\t\tconst json = this.json;\n\t\tconst buffers = this.buffers;\n\n\t\tif ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];\n\n\t\t// All buffers are merged before export.\n\t\tbuffers.push( buffer );\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView\n\t * @param  {BufferAttribute} attribute\n\t * @param  {number} componentType\n\t * @param  {number} start\n\t * @param  {number} count\n\t * @param  {number?} target Target usage of the BufferView\n\t * @return {Object}\n\t */\n\tprocessBufferView( attribute, componentType, start, count, target ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\t// Create a new dataview and dump the attribute's array into it\n\n\t\tlet componentSize;\n\n\t\tswitch ( componentType ) {\n\n\t\t\tcase WEBGL_CONSTANTS.BYTE:\n\t\t\tcase WEBGL_CONSTANTS.UNSIGNED_BYTE:\n\n\t\t\t\tcomponentSize = 1;\n\n\t\t\t\tbreak;\n\n\t\t\tcase WEBGL_CONSTANTS.SHORT:\n\t\t\tcase WEBGL_CONSTANTS.UNSIGNED_SHORT:\n\n\t\t\t\tcomponentSize = 2;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tcomponentSize = 4;\n\n\t\t}\n\n\t\tlet byteStride = attribute.itemSize * componentSize;\n\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t// Each element of a vertex attribute MUST be aligned to 4-byte boundaries\n\t\t\t// inside a bufferView\n\t\t\tbyteStride = Math.ceil( byteStride / 4 ) * 4;\n\n\t\t}\n\n\t\tconst byteLength = getPaddedBufferSize( count * byteStride );\n\t\tconst dataView = new DataView( new ArrayBuffer( byteLength ) );\n\t\tlet offset = 0;\n\n\t\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\tlet value;\n\n\t\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\t\tif ( attribute.normalized === true ) {\n\n\t\t\t\t\t\tvalue = MathUtils.normalize( value, attribute.array );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\n\n\t\t\t\t\tdataView.setFloat32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.INT ) {\n\n\t\t\t\t\tdataView.setInt32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\n\n\t\t\t\t\tdataView.setUint32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.SHORT ) {\n\n\t\t\t\t\tdataView.setInt16( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\tdataView.setUint16( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.BYTE ) {\n\n\t\t\t\t\tdataView.setInt8( offset, value );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\tdataView.setUint8( offset, value );\n\n\t\t\t\t}\n\n\t\t\t\toffset += componentSize;\n\n\t\t\t}\n\n\t\t\tif ( ( offset % byteStride ) !== 0 ) {\n\n\t\t\t\toffset += byteStride - ( offset % byteStride );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bufferViewDef = {\n\n\t\t\tbuffer: this.processBuffer( dataView.buffer ),\n\t\t\tbyteOffset: this.byteOffset,\n\t\t\tbyteLength: byteLength\n\n\t\t};\n\n\t\tif ( target !== undefined ) bufferViewDef.target = target;\n\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t// Only define byteStride for vertex attributes.\n\t\t\tbufferViewDef.byteStride = byteStride;\n\n\t\t}\n\n\t\tthis.byteOffset += byteLength;\n\n\t\tjson.bufferViews.push( bufferViewDef );\n\n\t\t// @TODO Merge bufferViews where possible.\n\t\tconst output = {\n\n\t\t\tid: json.bufferViews.length - 1,\n\t\t\tbyteLength: 0\n\n\t\t};\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView from an image Blob.\n\t * @param {Blob} blob\n\t * @return {Promise<Number>} An integer\n\t */\n\tprocessBufferViewImage( blob ) {\n\n\t\tconst writer = this;\n\t\tconst json = writer.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\treturn new Promise( function ( resolve ) {\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\tconst buffer = getPaddedArrayBuffer( reader.result );\n\n\t\t\t\tconst bufferViewDef = {\n\t\t\t\t\tbuffer: writer.processBuffer( buffer ),\n\t\t\t\t\tbyteOffset: writer.byteOffset,\n\t\t\t\t\tbyteLength: buffer.byteLength\n\t\t\t\t};\n\n\t\t\t\twriter.byteOffset += buffer.byteLength;\n\t\t\t\tresolve( json.bufferViews.push( bufferViewDef ) - 1 );\n\n\t\t\t};\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Process attribute to generate an accessor\n\t * @param  {BufferAttribute} attribute Attribute to process\n\t * @param  {THREE.BufferGeometry?} geometry Geometry used for truncated draw range\n\t * @param  {Number} [start=0]\n\t * @param  {Number} [count=Infinity]\n\t * @return {Number?} Index of the processed accessor on the \"accessors\" array\n\t */\n\tprocessAccessor( attribute, geometry, start, count ) {\n\n\t\tconst json = this.json;\n\n\t\tconst types = {\n\n\t\t\t1: 'SCALAR',\n\t\t\t2: 'VEC2',\n\t\t\t3: 'VEC3',\n\t\t\t4: 'VEC4',\n\t\t\t9: 'MAT3',\n\t\t\t16: 'MAT4'\n\n\t\t};\n\n\t\tlet componentType;\n\n\t\t// Detect the component type of the attribute array\n\t\tif ( attribute.array.constructor === Float32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\n\n\t\t} else if ( attribute.array.constructor === Int32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.INT;\n\n\t\t} else if ( attribute.array.constructor === Uint32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n\n\t\t} else if ( attribute.array.constructor === Int16Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.SHORT;\n\n\t\t} else if ( attribute.array.constructor === Uint16Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n\n\t\t} else if ( attribute.array.constructor === Int8Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.BYTE;\n\n\t\t} else if ( attribute.array.constructor === Uint8Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type: ' + attribute.array.constructor.name );\n\n\t\t}\n\n\t\tif ( start === undefined ) start = 0;\n\t\tif ( count === undefined || count === Infinity ) count = attribute.count;\n\n\t\t// Skip creating an accessor if the attribute doesn't have data to export\n\t\tif ( count === 0 ) return null;\n\n\t\tconst minMax = getMinMax( attribute, start, count );\n\t\tlet bufferViewTarget;\n\n\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\n\t\t// animation samplers, target must not be set.\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n\n\t\t}\n\n\t\tconst bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );\n\n\t\tconst accessorDef = {\n\n\t\t\tbufferView: bufferView.id,\n\t\t\tbyteOffset: bufferView.byteOffset,\n\t\t\tcomponentType: componentType,\n\t\t\tcount: count,\n\t\t\tmax: minMax.max,\n\t\t\tmin: minMax.min,\n\t\t\ttype: types[ attribute.itemSize ]\n\n\t\t};\n\n\t\tif ( attribute.normalized === true ) accessorDef.normalized = true;\n\t\tif ( ! json.accessors ) json.accessors = [];\n\n\t\treturn json.accessors.push( accessorDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process image\n\t * @param  {Image} image to process\n\t * @param  {Number} format Identifier of the format (RGBAFormat)\n\t * @param  {Boolean} flipY before writing out the image\n\t * @param  {String} mimeType export format\n\t * @return {Number}     Index of the processed texture in the \"images\" array\n\t */\n\tprocessImage( image, format, flipY, mimeType = 'image/png' ) {\n\n\t\tif ( image !== null ) {\n\n\t\t\tconst writer = this;\n\t\t\tconst cache = writer.cache;\n\t\t\tconst json = writer.json;\n\t\t\tconst options = writer.options;\n\t\t\tconst pending = writer.pending;\n\n\t\t\tif ( ! cache.images.has( image ) ) cache.images.set( image, {} );\n\n\t\t\tconst cachedImages = cache.images.get( image );\n\n\t\t\tconst key = mimeType + ':flipY/' + flipY.toString();\n\n\t\t\tif ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];\n\n\t\t\tif ( ! json.images ) json.images = [];\n\n\t\t\tconst imageDef = { mimeType: mimeType };\n\n\t\t\tconst canvas = getCanvas();\n\n\t\t\tcanvas.width = Math.min( image.width, options.maxTextureSize );\n\t\t\tcanvas.height = Math.min( image.height, options.maxTextureSize );\n\n\t\t\tconst ctx = canvas.getContext( '2d', {\n\t\t\t\twillReadFrequently: true,\n\t\t\t} );\n\n\t\t\tif ( flipY === true ) {\n\n\t\t\t\tctx.translate( 0, canvas.height );\n\t\t\t\tctx.scale( 1, - 1 );\n\n\t\t\t}\n\n\t\t\tif ( image.data !== undefined ) { // THREE.DataTexture\n\n\t\t\t\tif ( format !== RGBAFormat ) {\n\n\t\t\t\t\tconsole.error( 'GLTFExporter: Only RGBAFormat is supported.', format );\n\n\t\t\t\t}\n\n\t\t\t\tif ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {\n\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );\n\n\t\t\t\t}\n\n\t\t\t\tconst data = new Uint8ClampedArray( image.height * image.width * 4 );\n\n\t\t\t\tfor ( let i = 0; i < data.length; i += 4 ) {\n\n\t\t\t\t\tdata[ i + 0 ] = image.data[ i + 0 ];\n\t\t\t\t\tdata[ i + 1 ] = image.data[ i + 1 ];\n\t\t\t\t\tdata[ i + 2 ] = image.data[ i + 2 ];\n\t\t\t\t\tdata[ i + 3 ] = image.data[ i + 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ||\n\t\t\t\t\t( typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas ) ) {\n\n\t\t\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.binary === true ) {\n\n\t\t\t\tpending.push(\n\n\t\t\t\t\tgetToBlobPromise( canvas, mimeType )\n\t\t\t\t\t\t.then( blob => writer.processBufferViewImage( blob ) )\n\t\t\t\t\t\t.then( bufferViewIndex => {\n\n\t\t\t\t\t\t\timageDef.bufferView = bufferViewIndex;\n\n\t\t\t\t\t\t} )\n\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tif ( canvas.toDataURL !== undefined ) {\n\n\t\t\t\t\timageDef.uri = canvas.toDataURL( mimeType );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpending.push(\n\n\t\t\t\t\t\tgetToBlobPromise( canvas, mimeType )\n\t\t\t\t\t\t\t.then( blob => new FileReader().readAsDataURL( blob ) )\n\t\t\t\t\t\t\t.then( dataURL => {\n\n\t\t\t\t\t\t\t\timageDef.uri = dataURL;\n\n\t\t\t\t\t\t\t} )\n\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst index = json.images.push( imageDef ) - 1;\n\t\t\tcachedImages[ key ] = index;\n\t\t\treturn index;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: No valid image data found. Unable to process texture.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Process sampler\n\t * @param  {Texture} map Texture to process\n\t * @return {Number}      Index of the processed texture in the \"samplers\" array\n\t */\n\tprocessSampler( map ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.samplers ) json.samplers = [];\n\n\t\tconst samplerDef = {\n\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\n\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\n\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\n\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\n\t\t};\n\n\t\treturn json.samplers.push( samplerDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process texture\n\t * @param  {Texture} map Map to process\n\t * @return {Promise<Number>} Index of the processed texture in the \"textures\" array\n\t */\n\tasync processTextureAsync( map ) {\n\n\t\tconst writer = this;\n\t\tconst options = writer.options;\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.textures.has( map ) ) return cache.textures.get( map );\n\n\t\tif ( ! json.textures ) json.textures = [];\n\n\t\t// make non-readable textures (e.g. CompressedTexture) readable by blitting them into a new texture\n\t\tif ( map instanceof CompressedTexture ) {\n\n\t\t\tmap = await this.decompressTextureAsync( map, options.maxTextureSize );\n\n\t\t}\n\n\t\tlet mimeType = map.userData.mimeType;\n\n\t\tif ( mimeType === 'image/webp' ) mimeType = 'image/png';\n\n\t\tconst textureDef = {\n\t\t\tsampler: this.processSampler( map ),\n\t\t\tsource: this.processImage( map.image, map.format, map.flipY, mimeType )\n\t\t};\n\n\t\tif ( map.name ) textureDef.name = map.name;\n\n\t\tawait this._invokeAllAsync( async function ( ext ) {\n\n\t\t\text.writeTexture && await ext.writeTexture( map, textureDef );\n\n\t\t} );\n\n\t\tconst index = json.textures.push( textureDef ) - 1;\n\t\tcache.textures.set( map, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process material\n\t * @param  {THREE.Material} material Material to process\n\t * @return {Promise<Number|null>} Index of the processed material in the \"materials\" array\n\t */\n\tasync processMaterialAsync( material ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.materials.has( material ) ) return cache.materials.get( material );\n\n\t\tif ( material.isShaderMaterial ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( ! json.materials ) json.materials = [];\n\n\t\t// @QUESTION Should we avoid including any attribute that has the default value?\n\t\tconst materialDef = {\tpbrMetallicRoughness: {} };\n\n\t\tif ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorFactor\n\t\tconst color = material.color.toArray().concat( [ material.opacity ] );\n\n\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = color;\n\n\t\t}\n\n\t\tif ( material.isMeshStandardMaterial ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n\n\t\t} else {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 1;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.metallicRoughnessTexture\n\t\tif ( material.metalnessMap || material.roughnessMap ) {\n\n\t\t\tconst metalRoughTexture = await this.buildMetalRoughTextureAsync( material.metalnessMap, material.roughnessMap );\n\n\t\t\tconst metalRoughMapDef = {\n\t\t\t\tindex: await this.processTextureAsync( metalRoughTexture ),\n\t\t\t\ttexCoord: metalRoughTexture.channel\n\t\t\t};\n\t\t\tthis.applyTextureTransform( metalRoughMapDef, metalRoughTexture );\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorTexture\n\t\tif ( material.map ) {\n\n\t\t\tconst baseColorMapDef = {\n\t\t\t\tindex: await this.processTextureAsync( material.map ),\n\t\t\t\ttexCoord: material.map.channel\n\t\t\t};\n\t\t\tthis.applyTextureTransform( baseColorMapDef, material.map );\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\tconst emissive = material.emissive;\n\t\t\tconst maxEmissiveComponent = Math.max( emissive.r, emissive.g, emissive.b );\n\n\t\t\tif ( maxEmissiveComponent > 0 ) {\n\n\t\t\t\tmaterialDef.emissiveFactor = material.emissive.toArray();\n\n\t\t\t}\n\n\t\t\t// emissiveTexture\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tconst emissiveMapDef = {\n\t\t\t\t\tindex: await this.processTextureAsync( material.emissiveMap ),\n\t\t\t\t\ttexCoord: material.emissiveMap.channel\n\t\t\t\t};\n\t\t\t\tthis.applyTextureTransform( emissiveMapDef, material.emissiveMap );\n\t\t\t\tmaterialDef.emissiveTexture = emissiveMapDef;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// normalTexture\n\t\tif ( material.normalMap ) {\n\n\t\t\tconst normalMapDef = {\n\t\t\t\tindex: await this.processTextureAsync( material.normalMap ),\n\t\t\t\ttexCoord: material.normalMap.channel\n\t\t\t};\n\n\t\t\tif ( material.normalScale && material.normalScale.x !== 1 ) {\n\n\t\t\t\t// glTF normal scale is univariate. Ignore `y`, which may be flipped.\n\t\t\t\t// Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\tnormalMapDef.scale = material.normalScale.x;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( normalMapDef, material.normalMap );\n\t\t\tmaterialDef.normalTexture = normalMapDef;\n\n\t\t}\n\n\t\t// occlusionTexture\n\t\tif ( material.aoMap ) {\n\n\t\t\tconst occlusionMapDef = {\n\t\t\t\tindex: await this.processTextureAsync( material.aoMap ),\n\t\t\t\ttexCoord: material.aoMap.channel\n\t\t\t};\n\n\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\n\n\t\t\t\tocclusionMapDef.strength = material.aoMapIntensity;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( occlusionMapDef, material.aoMap );\n\t\t\tmaterialDef.occlusionTexture = occlusionMapDef;\n\n\t\t}\n\n\t\t// alphaMode\n\t\tif ( material.transparent ) {\n\n\t\t\tmaterialDef.alphaMode = 'BLEND';\n\n\t\t} else {\n\n\t\t\tif ( material.alphaTest > 0.0 ) {\n\n\t\t\t\tmaterialDef.alphaMode = 'MASK';\n\t\t\t\tmaterialDef.alphaCutoff = material.alphaTest;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// doubleSided\n\t\tif ( material.side === DoubleSide ) materialDef.doubleSided = true;\n\t\tif ( material.name !== '' ) materialDef.name = material.name;\n\n\t\tthis.serializeUserData( material, materialDef );\n\n\t\tawait this._invokeAllAsync( async function ( ext ) {\n\n\t\t\text.writeMaterialAsync && await ext.writeMaterialAsync( material, materialDef );\n\n\t\t} );\n\n\t\tconst index = json.materials.push( materialDef ) - 1;\n\t\tcache.materials.set( material, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process mesh\n\t * @param  {THREE.Mesh} mesh Mesh to process\n\t * @return {Promise<Number|null>} Index of the processed mesh in the \"meshes\" array\n\t */\n\tasync processMeshAsync( mesh ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tconst meshCacheKeyParts = [ mesh.geometry.uuid ];\n\n\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\tfor ( let i = 0, l = mesh.material.length; i < l; i ++ ) {\n\n\t\t\t\tmeshCacheKeyParts.push( mesh.material[ i ].uuid\t);\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmeshCacheKeyParts.push( mesh.material.uuid );\n\n\t\t}\n\n\t\tconst meshCacheKey = meshCacheKeyParts.join( ':' );\n\n\t\tif ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );\n\n\t\tconst geometry = mesh.geometry;\n\n\t\tlet mode;\n\n\t\t// Use the correct mode\n\t\tif ( mesh.isLineSegments ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINES;\n\n\t\t} else if ( mesh.isLineLoop ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\n\n\t\t} else if ( mesh.isPoints ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.POINTS;\n\n\t\t} else {\n\n\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n\n\t\t}\n\n\t\tconst meshDef = {};\n\t\tconst attributes = {};\n\t\tconst primitives = [];\n\t\tconst targets = [];\n\n\t\t// Conversion between attributes names in threejs and gltf spec\n\t\tconst nameConversion = {\n\t\t\tuv: 'TEXCOORD_0',\n\t\t\tuv1: 'TEXCOORD_1',\n\t\t\tuv2: 'TEXCOORD_2',\n\t\t\tuv3: 'TEXCOORD_3',\n\t\t\tcolor: 'COLOR_0',\n\t\t\tskinWeight: 'WEIGHTS_0',\n\t\t\tskinIndex: 'JOINTS_0'\n\t\t};\n\n\t\tconst originalNormal = geometry.getAttribute( 'normal' );\n\n\t\tif ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\n\n\t\t\tgeometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );\n\n\t\t}\n\n\t\t// @QUESTION Detect if .vertexColors = true?\n\t\t// For every attribute create an accessor\n\t\tlet modifiedAttribute = null;\n\n\t\tfor ( let attributeName in geometry.attributes ) {\n\n\t\t\t// Ignore morph target attributes, which are exported later.\n\t\t\tif ( attributeName.slice( 0, 5 ) === 'morph' ) continue;\n\n\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\n\n\t\t\t// Prefix all geometry attributes except the ones specifically\n\t\t\t// listed in the spec; non-spec attributes are considered custom.\n\t\t\tconst validVertexAttributes =\n\t\t\t\t\t/^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n\n\t\t\tif ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;\n\n\t\t\tif ( cache.attributes.has( this.getUID( attribute ) ) ) {\n\n\t\t\t\tattributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// Enforce glTF vertex attribute requirements:\n\t\t\t// - JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT\n\t\t\t// - Only custom attributes may be INT or UNSIGNED_INT\n\t\t\tmodifiedAttribute = null;\n\t\t\tconst array = attribute.array;\n\n\t\t\tif ( attributeName === 'JOINTS_0' &&\n\t\t\t\t! ( array instanceof Uint16Array ) &&\n\t\t\t\t! ( array instanceof Uint8Array ) ) {\n\n\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\n\t\t\t\tmodifiedAttribute = new BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\n\n\t\t\t} else if ( ( array instanceof Uint32Array || array instanceof Int32Array ) && ! attributeName.startsWith( '_' ) ) {\n\n\t\t\t\tconsole.warn( `GLTFExporter: Attribute \"${ attributeName }\" converted to type FLOAT.` );\n\t\t\t\tmodifiedAttribute = GLTFExporter.Utils.toFloat32BufferAttribute( attribute );\n\n\t\t\t}\n\n\t\t\tconst accessor = this.processAccessor( modifiedAttribute || attribute, geometry );\n\n\t\t\tif ( accessor !== null ) {\n\n\t\t\t\tif ( ! attributeName.startsWith( '_' ) ) {\n\n\t\t\t\t\tthis.detectMeshQuantization( attributeName, attribute );\n\n\t\t\t\t}\n\n\t\t\t\tattributes[ attributeName ] = accessor;\n\t\t\t\tcache.attributes.set( this.getUID( attribute ), accessor );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );\n\n\t\t// Skip if no exportable attributes found\n\t\tif ( Object.keys( attributes ).length === 0 ) return null;\n\n\t\t// Morph targets\n\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\n\n\t\t\tconst weights = [];\n\t\t\tconst targetNames = [];\n\t\t\tconst reverseDictionary = {};\n\n\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\n\n\t\t\t\tfor ( const key in mesh.morphTargetDictionary ) {\n\n\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\n\n\t\t\t\tconst target = {};\n\t\t\t\tlet warned = false;\n\n\t\t\t\tfor ( const attributeName in geometry.morphAttributes ) {\n\n\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n\t\t\t\t\t// Three.js doesn't support TANGENT yet.\n\n\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\n\n\t\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\n\t\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst attribute = geometry.morphAttributes[ attributeName ][ i ];\n\t\t\t\t\tconst gltfAttributeName = attributeName.toUpperCase();\n\n\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\n\t\t\t\t\t//\n\t\t\t\t\t// glTF 2.0 Specification:\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\t\t\t\t\tconst baseAttribute = geometry.attributes[ attributeName ];\n\n\t\t\t\t\tif ( cache.attributes.has( this.getUID( attribute, true ) ) ) {\n\n\t\t\t\t\t\ttarget[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute, true ) );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Clones attribute not to override\n\t\t\t\t\tconst relativeAttribute = attribute.clone();\n\n\t\t\t\t\tif ( ! geometry.morphTargetsRelative ) {\n\n\t\t\t\t\t\tfor ( let j = 0, jl = attribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\t\t\t\t\tif ( a === 0 ) relativeAttribute.setX( j, attribute.getX( j ) - baseAttribute.getX( j ) );\n\t\t\t\t\t\t\t\tif ( a === 1 ) relativeAttribute.setY( j, attribute.getY( j ) - baseAttribute.getY( j ) );\n\t\t\t\t\t\t\t\tif ( a === 2 ) relativeAttribute.setZ( j, attribute.getZ( j ) - baseAttribute.getZ( j ) );\n\t\t\t\t\t\t\t\tif ( a === 3 ) relativeAttribute.setW( j, attribute.getW( j ) - baseAttribute.getW( j ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );\n\t\t\t\t\tcache.attributes.set( this.getUID( baseAttribute, true ), target[ gltfAttributeName ] );\n\n\t\t\t\t}\n\n\t\t\t\ttargets.push( target );\n\n\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\n\n\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );\n\n\t\t\t}\n\n\t\t\tmeshDef.weights = weights;\n\n\t\t\tif ( targetNames.length > 0 ) {\n\n\t\t\t\tmeshDef.extras = {};\n\t\t\t\tmeshDef.extras.targetNames = targetNames;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst isMultiMaterial = Array.isArray( mesh.material );\n\n\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) return null;\n\n\t\tlet didForceIndices = false;\n\n\t\tif ( isMultiMaterial && geometry.index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tfor ( let i = 0, il = geometry.attributes.position.count; i < il; i ++ ) {\n\n\t\t\t\tindices[ i ] = i;\n\n\t\t\t}\n\n\t\t\tgeometry.setIndex( indices );\n\n\t\t\tdidForceIndices = true;\n\n\t\t}\n\n\t\tconst materials = isMultiMaterial ? mesh.material : [ mesh.material ];\n\t\tconst groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\n\n\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = {\n\t\t\t\tmode: mode,\n\t\t\t\tattributes: attributes,\n\t\t\t};\n\n\t\t\tthis.serializeUserData( geometry, primitive );\n\n\t\t\tif ( targets.length > 0 ) primitive.targets = targets;\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\tlet cacheKey = this.getUID( geometry.index );\n\n\t\t\t\tif ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {\n\n\t\t\t\t\tcacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;\n\n\t\t\t\t}\n\n\t\t\t\tif ( cache.attributes.has( cacheKey ) ) {\n\n\t\t\t\t\tprimitive.indices = cache.attributes.get( cacheKey );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tprimitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\n\t\t\t\t\tcache.attributes.set( cacheKey, primitive.indices );\n\n\t\t\t\t}\n\n\t\t\t\tif ( primitive.indices === null ) delete primitive.indices;\n\n\t\t\t}\n\n\t\t\tconst material = await this.processMaterialAsync( materials[ groups[ i ].materialIndex ] );\n\n\t\t\tif ( material !== null ) primitive.material = material;\n\n\t\t\tprimitives.push( primitive );\n\n\t\t}\n\n\t\tif ( didForceIndices === true ) {\n\n\t\t\tgeometry.setIndex( null );\n\n\t\t}\n\n\t\tmeshDef.primitives = primitives;\n\n\t\tif ( ! json.meshes ) json.meshes = [];\n\n\t\tawait this._invokeAllAsync( function ( ext ) {\n\n\t\t\text.writeMesh && ext.writeMesh( mesh, meshDef );\n\n\t\t} );\n\n\t\tconst index = json.meshes.push( meshDef ) - 1;\n\t\tcache.meshes.set( meshCacheKey, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * If a vertex attribute with a\n\t * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n\t * is used, it is checked whether it is a valid data type according to the\n\t * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n\t * extension.\n\t * In this case the extension is automatically added to the list of used extensions.\n\t *\n\t * @param {string} attributeName\n\t * @param {THREE.BufferAttribute} attribute\n\t */\n\tdetectMeshQuantization( attributeName, attribute ) {\n\n\t\tif ( this.extensionsUsed[ KHR_MESH_QUANTIZATION ] ) return;\n\n\t\tlet attrType = undefined;\n\n\t\tswitch ( attribute.array.constructor ) {\n\n\t\t\tcase Int8Array:\n\n\t\t\t\tattrType = 'byte';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Uint8Array:\n\n\t\t\t\tattrType = 'unsigned byte';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Int16Array:\n\n\t\t\t\tattrType = 'short';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Uint16Array:\n\n\t\t\t\tattrType = 'unsigned short';\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\treturn;\n\n\t\t}\n\n\t\tif ( attribute.normalized ) attrType += ' normalized';\n\n\t\tconst attrNamePrefix = attributeName.split( '_', 1 )[ 0 ];\n\n\t\tif ( KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ] && KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ].includes( attrType ) ) {\n\n\t\t\tthis.extensionsUsed[ KHR_MESH_QUANTIZATION ] = true;\n\t\t\tthis.extensionsRequired[ KHR_MESH_QUANTIZATION ] = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Process camera\n\t * @param  {THREE.Camera} camera Camera to process\n\t * @return {Number} Index of the processed mesh in the \"camera\" array\n\t */\n\tprocessCamera( camera ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.cameras ) json.cameras = [];\n\n\t\tconst isOrtho = camera.isOrthographicCamera;\n\n\t\tconst cameraDef = {\n\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\n\t\t};\n\n\t\tif ( isOrtho ) {\n\n\t\t\tcameraDef.orthographic = {\n\t\t\t\txmag: camera.right * 2,\n\t\t\t\tymag: camera.top * 2,\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tcameraDef.perspective = {\n\t\t\t\taspectRatio: camera.aspect,\n\t\t\t\tyfov: MathUtils.degToRad( camera.fov ),\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t}\n\n\t\t// Question: Is saving \"type\" as name intentional?\n\t\tif ( camera.name !== '' ) cameraDef.name = camera.type;\n\n\t\treturn json.cameras.push( cameraDef ) - 1;\n\n\t}\n\n\t/**\n\t * Creates glTF animation entry from AnimationClip object.\n\t *\n\t * Status:\n\t * - Only properties listed in PATH_PROPERTIES may be animated.\n\t *\n\t * @param {THREE.AnimationClip} clip\n\t * @param {THREE.Object3D} root\n\t * @return {number|null}\n\t */\n\tprocessAnimation( clip, root ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.animations ) json.animations = [];\n\n\t\tclip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );\n\n\t\tconst tracks = clip.tracks;\n\t\tconst channels = [];\n\t\tconst samplers = [];\n\n\t\tfor ( let i = 0; i < tracks.length; ++ i ) {\n\n\t\t\tconst track = tracks[ i ];\n\t\t\tconst trackBinding = PropertyBinding.parseTrackName( track.name );\n\t\t\tlet trackNode = PropertyBinding.findNode( root, trackBinding.nodeName );\n\t\t\tconst trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\n\n\t\t\tif ( trackBinding.objectName === 'bones' ) {\n\n\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\n\n\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttrackNode = undefined;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! trackNode || ! trackProperty ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Could not export animation track \"%s\".', track.name );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst inputItemSize = 1;\n\t\t\tlet outputItemSize = track.values.length / track.times.length;\n\n\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\n\n\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\n\n\t\t\t}\n\n\t\t\tlet interpolation;\n\n\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\n\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n\t\t\t// valid value from .getInterpolation().\n\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\n\n\t\t\t\tinterpolation = 'CUBICSPLINE';\n\n\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\n\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\n\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\n\t\t\t\toutputItemSize /= 3;\n\n\t\t\t} else if ( track.getInterpolation() === InterpolateDiscrete ) {\n\n\t\t\t\tinterpolation = 'STEP';\n\n\t\t\t} else {\n\n\t\t\t\tinterpolation = 'LINEAR';\n\n\t\t\t}\n\n\t\t\tsamplers.push( {\n\t\t\t\tinput: this.processAccessor( new BufferAttribute( track.times, inputItemSize ) ),\n\t\t\t\toutput: this.processAccessor( new BufferAttribute( track.values, outputItemSize ) ),\n\t\t\t\tinterpolation: interpolation\n\t\t\t} );\n\n\t\t\tchannels.push( {\n\t\t\t\tsampler: samplers.length - 1,\n\t\t\t\ttarget: {\n\t\t\t\t\tnode: nodeMap.get( trackNode ),\n\t\t\t\t\tpath: trackProperty\n\t\t\t\t}\n\t\t\t} );\n\n\t\t}\n\n\t\tjson.animations.push( {\n\t\t\tname: clip.name || 'clip_' + json.animations.length,\n\t\t\tsamplers: samplers,\n\t\t\tchannels: channels\n\t\t} );\n\n\t\treturn json.animations.length - 1;\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D} object\n\t * @return {number|null}\n\t */\n\t processSkin( object ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tconst node = json.nodes[ nodeMap.get( object ) ];\n\n\t\tconst skeleton = object.skeleton;\n\n\t\tif ( skeleton === undefined ) return null;\n\n\t\tconst rootJoint = object.skeleton.bones[ 0 ];\n\n\t\tif ( rootJoint === undefined ) return null;\n\n\t\tconst joints = [];\n\t\tconst inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\n\t\tconst temporaryBoneInverse = new Matrix4();\n\n\t\tfor ( let i = 0; i < skeleton.bones.length; ++ i ) {\n\n\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\n\t\t\ttemporaryBoneInverse.copy( skeleton.boneInverses[ i ] );\n\t\t\ttemporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( json.skins === undefined ) json.skins = [];\n\n\t\tjson.skins.push( {\n\t\t\tinverseBindMatrices: this.processAccessor( new BufferAttribute( inverseBindMatrices, 16 ) ),\n\t\t\tjoints: joints,\n\t\t\tskeleton: nodeMap.get( rootJoint )\n\t\t} );\n\n\t\tconst skinIndex = node.skin = json.skins.length - 1;\n\n\t\treturn skinIndex;\n\n\t}\n\n\t/**\n\t * Process Object3D node\n\t * @param  {THREE.Object3D} object Object3D to processNodeAsync\n\t * @return {Promise<Number>} Index of the node in the nodes list\n\t */\n\tasync processNodeAsync( object ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.nodes ) json.nodes = [];\n\n\t\tconst nodeDef = {};\n\n\t\tif ( options.trs ) {\n\n\t\t\tconst rotation = object.quaternion.toArray();\n\t\t\tconst position = object.position.toArray();\n\t\t\tconst scale = object.scale.toArray();\n\n\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\tnodeDef.rotation = rotation;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\tnodeDef.translation = position;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\n\n\t\t\t\tnodeDef.scale = scale;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( object.matrixAutoUpdate ) {\n\n\t\t\t\tobject.updateMatrix();\n\n\t\t\t}\n\n\t\t\tif ( isIdentityMatrix( object.matrix ) === false ) {\n\n\t\t\t\tnodeDef.matrix = object.matrix.elements;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// We don't export empty strings name because it represents no-name in Three.js.\n\t\tif ( object.name !== '' ) nodeDef.name = String( object.name );\n\n\t\tthis.serializeUserData( object, nodeDef );\n\n\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\tconst meshIndex = await this.processMeshAsync( object );\n\n\t\t\tif ( meshIndex !== null ) nodeDef.mesh = meshIndex;\n\n\t\t} else if ( object.isCamera ) {\n\n\t\t\tnodeDef.camera = this.processCamera( object );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) this.skins.push( object );\n\n\t\tif ( object.children.length > 0 ) {\n\n\t\t\tconst children = [];\n\n\t\t\tfor ( let i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = object.children[ i ];\n\n\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\tconst nodeIndex = await this.processNodeAsync( child );\n\n\t\t\t\t\tif ( nodeIndex !== null ) children.push( nodeIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( children.length > 0 ) nodeDef.children = children;\n\n\t\t}\n\n\t\tawait this._invokeAllAsync( function ( ext ) {\n\n\t\t\text.writeNode && ext.writeNode( object, nodeDef );\n\n\t\t} );\n\n\t\tconst nodeIndex = json.nodes.push( nodeDef ) - 1;\n\t\tnodeMap.set( object, nodeIndex );\n\t\treturn nodeIndex;\n\n\t}\n\n\t/**\n\t * Process Scene\n\t * @param  {Scene} scene Scene to process\n\t */\n\tasync processSceneAsync( scene ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( ! json.scenes ) {\n\n\t\t\tjson.scenes = [];\n\t\t\tjson.scene = 0;\n\n\t\t}\n\n\t\tconst sceneDef = {};\n\n\t\tif ( scene.name !== '' ) sceneDef.name = scene.name;\n\n\t\tjson.scenes.push( sceneDef );\n\n\t\tconst nodes = [];\n\n\t\tfor ( let i = 0, l = scene.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = scene.children[ i ];\n\n\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\tconst nodeIndex = await this.processNodeAsync( child );\n\n\t\t\t\tif ( nodeIndex !== null ) nodes.push( nodeIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( nodes.length > 0 ) sceneDef.nodes = nodes;\n\n\t\tthis.serializeUserData( scene, sceneDef );\n\n\t}\n\n\t/**\n\t * Creates a Scene to hold a list of objects and parse it\n\t * @param  {Array<THREE.Object3D>} objects List of objects to process\n\t */\n\tasync processObjectsAsync( objects ) {\n\n\t\tconst scene = new Scene();\n\t\tscene.name = 'AuxScene';\n\n\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t// We push directly to children instead of calling `add` to prevent\n\t\t\t// modify the .parent and break its original scene and hierarchy\n\t\t\tscene.children.push( objects[ i ] );\n\n\t\t}\n\n\t\tawait this.processSceneAsync( scene );\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D|Array<THREE.Object3D>} input\n\t */\n\tasync processInputAsync( input ) {\n\n\t\tconst options = this.options;\n\n\t\tinput = input instanceof Array ? input : [ input ];\n\n\t\tawait this._invokeAllAsync( function ( ext ) {\n\n\t\t\text.beforeParse && ext.beforeParse( input );\n\n\t\t} );\n\n\t\tconst objectsWithoutScene = [];\n\n\t\tfor ( let i = 0; i < input.length; i ++ ) {\n\n\t\t\tif ( input[ i ] instanceof Scene ) {\n\n\t\t\t\tawait this.processSceneAsync( input[ i ] );\n\n\t\t\t} else {\n\n\t\t\t\tobjectsWithoutScene.push( input[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( objectsWithoutScene.length > 0 ) {\n\n\t\t\tawait this.processObjectsAsync( objectsWithoutScene );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.skins.length; ++ i ) {\n\n\t\t\tthis.processSkin( this.skins[ i ] );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < options.animations.length; ++ i ) {\n\n\t\t\tthis.processAnimation( options.animations[ i ], input[ 0 ] );\n\n\t\t}\n\n\t\tawait this._invokeAllAsync( function ( ext ) {\n\n\t\t\text.afterParse && ext.afterParse( input );\n\n\t\t} );\n\n\t}\n\n\tasync _invokeAllAsync( func ) {\n\n\t\tfor ( let i = 0, il = this.plugins.length; i < il; i ++ ) {\n\n\t\t\tawait func( this.plugins[ i ] );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_lights_punctual';\n\n\t}\n\n\twriteNode( light, nodeDef ) {\n\n\t\tif ( ! light.isLight ) return;\n\n\t\tif ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst writer = this.writer;\n\t\tconst json = writer.json;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst lightDef = {};\n\n\t\tif ( light.name ) lightDef.name = light.name;\n\n\t\tlightDef.color = light.color.toArray();\n\n\t\tlightDef.intensity = light.intensity;\n\n\t\tif ( light.isDirectionalLight ) {\n\n\t\t\tlightDef.type = 'directional';\n\n\t\t} else if ( light.isPointLight ) {\n\n\t\t\tlightDef.type = 'point';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t} else if ( light.isSpotLight ) {\n\n\t\t\tlightDef.type = 'spot';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t\tlightDef.spot = {};\n\t\t\tlightDef.spot.innerConeAngle = ( 1.0 - light.penumbra ) * light.angle;\n\t\t\tlightDef.spot.outerConeAngle = light.angle;\n\n\t\t}\n\n\t\tif ( light.decay !== undefined && light.decay !== 2 ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '\n\t\t\t\t+ 'and expects light.decay=2.' );\n\n\t\t}\n\n\t\tif ( light.target\n\t\t\t\t&& ( light.target.parent !== light\n\t\t\t\t|| light.target.position.x !== 0\n\t\t\t\t|| light.target.position.y !== 0\n\t\t\t\t|| light.target.position.z !== - 1 ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '\n\t\t\t\t+ 'make light.target a child of the light with position 0,0,-1.' );\n\n\t\t}\n\n\t\tif ( ! extensionsUsed[ this.name ] ) {\n\n\t\t\tjson.extensions = json.extensions || {};\n\t\t\tjson.extensions[ this.name ] = { lights: [] };\n\t\t\textensionsUsed[ this.name ] = true;\n\n\t\t}\n\n\t\tconst lights = json.extensions[ this.name ].lights;\n\t\tlights.push( lightDef );\n\n\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\tnodeDef.extensions[ this.name ] = { light: lights.length - 1 };\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_unlit';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshBasicMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = {};\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_clearcoat';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.clearcoat === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.clearcoatFactor = material.clearcoat;\n\n\t\tif ( material.clearcoatMap ) {\n\n\t\t\tconst clearcoatMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.clearcoatMap ),\n\t\t\t\ttexCoord: material.clearcoatMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( clearcoatMapDef, material.clearcoatMap );\n\t\t\textensionDef.clearcoatTexture = clearcoatMapDef;\n\n\t\t}\n\n\t\textensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n\n\t\tif ( material.clearcoatRoughnessMap ) {\n\n\t\t\tconst clearcoatRoughnessMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.clearcoatRoughnessMap ),\n\t\t\t\ttexCoord: material.clearcoatRoughnessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( clearcoatRoughnessMapDef, material.clearcoatRoughnessMap );\n\t\t\textensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n\n\t\t}\n\n\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\tconst clearcoatNormalMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.clearcoatNormalMap ),\n\t\t\t\ttexCoord: material.clearcoatNormalMap.channel\n\t\t\t};\n\n\t\t\tif ( material.clearcoatNormalScale.x !== 1 ) clearcoatNormalMapDef.scale = material.clearcoatNormalScale.x;\n\n\t\t\twriter.applyTextureTransform( clearcoatNormalMapDef, material.clearcoatNormalMap );\n\t\t\textensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\n\t}\n\n}\n\n/**\n * Materials dispersion Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_dispersion\n */\nclass GLTFMaterialsDispersionExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_dispersion';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.dispersion === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.dispersion = material.dispersion;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_iridescence';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.iridescence === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.iridescenceFactor = material.iridescence;\n\n\t\tif ( material.iridescenceMap ) {\n\n\t\t\tconst iridescenceMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.iridescenceMap ),\n\t\t\t\ttexCoord: material.iridescenceMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( iridescenceMapDef, material.iridescenceMap );\n\t\t\textensionDef.iridescenceTexture = iridescenceMapDef;\n\n\t\t}\n\n\t\textensionDef.iridescenceIor = material.iridescenceIOR;\n\t\textensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[ 0 ];\n\t\textensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[ 1 ];\n\n\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\tconst iridescenceThicknessMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.iridescenceThicknessMap ),\n\t\t\t\ttexCoord: material.iridescenceThicknessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( iridescenceThicknessMapDef, material.iridescenceThicknessMap );\n\t\t\textensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_transmission';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.transmissionFactor = material.transmission;\n\n\t\tif ( material.transmissionMap ) {\n\n\t\t\tconst transmissionMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.transmissionMap ),\n\t\t\t\ttexCoord: material.transmissionMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( transmissionMapDef, material.transmissionMap );\n\t\t\textensionDef.transmissionTexture = transmissionMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_volume';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.thicknessFactor = material.thickness;\n\n\t\tif ( material.thicknessMap ) {\n\n\t\t\tconst thicknessMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.thicknessMap ),\n\t\t\t\ttexCoord: material.thicknessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( thicknessMapDef, material.thicknessMap );\n\t\t\textensionDef.thicknessTexture = thicknessMapDef;\n\n\t\t}\n\n\t\tif ( material.attenuationDistance !== Infinity ) {\n\n\t\t\textensionDef.attenuationDistance = material.attenuationDistance;\n\n\t\t}\n\n\t\textensionDef.attenuationColor = material.attenuationColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_ior';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.ior === 1.5 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.ior = material.ior;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_specular';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || ( material.specularIntensity === 1.0 &&\n\t\t       material.specularColor.equals( DEFAULT_SPECULAR_COLOR ) &&\n\t\t     ! material.specularIntensityMap && ! material.specularColorMap ) ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.specularIntensityMap ) {\n\n\t\t\tconst specularIntensityMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.specularIntensityMap ),\n\t\t\t\ttexCoord: material.specularIntensityMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( specularIntensityMapDef, material.specularIntensityMap );\n\t\t\textensionDef.specularTexture = specularIntensityMapDef;\n\n\t\t}\n\n\t\tif ( material.specularColorMap ) {\n\n\t\t\tconst specularColorMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.specularColorMap ),\n\t\t\t\ttexCoord: material.specularColorMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( specularColorMapDef, material.specularColorMap );\n\t\t\textensionDef.specularColorTexture = specularColorMapDef;\n\n\t\t}\n\n\t\textensionDef.specularFactor = material.specularIntensity;\n\t\textensionDef.specularColorFactor = material.specularColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_sheen';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.sheen == 0.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.sheenRoughnessMap ) {\n\n\t\t\tconst sheenRoughnessMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.sheenRoughnessMap ),\n\t\t\t\ttexCoord: material.sheenRoughnessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( sheenRoughnessMapDef, material.sheenRoughnessMap );\n\t\t\textensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n\n\t\t}\n\n\t\tif ( material.sheenColorMap ) {\n\n\t\t\tconst sheenColorMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.sheenColorMap ),\n\t\t\t\ttexCoord: material.sheenColorMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( sheenColorMapDef, material.sheenColorMap );\n\t\t\textensionDef.sheenColorTexture = sheenColorMapDef;\n\n\t\t}\n\n\t\textensionDef.sheenRoughnessFactor = material.sheenRoughness;\n\t\textensionDef.sheenColorFactor = material.sheenColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Anisotropy Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_anisotropy';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.anisotropy == 0.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.anisotropyMap ) {\n\n\t\t\tconst anisotropyMapDef = { index: await writer.processTextureAsync( material.anisotropyMap ) };\n\t\t\twriter.applyTextureTransform( anisotropyMapDef, material.anisotropyMap );\n\t\t\textensionDef.anisotropyTexture = anisotropyMapDef;\n\n\t\t}\n\n\t\textensionDef.anisotropyStrength = material.anisotropy;\n\t\textensionDef.anisotropyRotation = material.anisotropyRotation;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_emissive_strength';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshStandardMaterial || material.emissiveIntensity === 1.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.emissiveStrength = material.emissiveIntensity;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n */\nclass GLTFMaterialsBumpExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'EXT_materials_bump';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshStandardMaterial || (\n\t\t       material.bumpScale === 1 &&\n\t\t     ! material.bumpMap ) ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tconst bumpMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.bumpMap ),\n\t\t\t\ttexCoord: material.bumpMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( bumpMapDef, material.bumpMap );\n\t\t\textensionDef.bumpTexture = bumpMapDef;\n\n\t\t}\n\n\t\textensionDef.bumpFactor = material.bumpScale;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n */\nclass GLTFMeshGpuInstancing {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'EXT_mesh_gpu_instancing';\n\n\t}\n\n\twriteNode( object, nodeDef ) {\n\n\t\tif ( ! object.isInstancedMesh ) return;\n\n\t\tconst writer = this.writer;\n\n\t\tconst mesh = object;\n\n\t\tconst translationAttr = new Float32Array( mesh.count * 3 );\n\t\tconst rotationAttr = new Float32Array( mesh.count * 4 );\n\t\tconst scaleAttr = new Float32Array( mesh.count * 3 );\n\n\t\tconst matrix = new Matrix4();\n\t\tconst position = new Vector3();\n\t\tconst quaternion = new Quaternion();\n\t\tconst scale = new Vector3();\n\n\t\tfor ( let i = 0; i < mesh.count; i ++ ) {\n\n\t\t\tmesh.getMatrixAt( i, matrix );\n\t\t\tmatrix.decompose( position, quaternion, scale );\n\n\t\t\tposition.toArray( translationAttr, i * 3 );\n\t\t\tquaternion.toArray( rotationAttr, i * 4 );\n\t\t\tscale.toArray( scaleAttr, i * 3 );\n\n\t\t}\n\n\t\tconst attributes = {\n\t\t\tTRANSLATION: writer.processAccessor( new BufferAttribute( translationAttr, 3 ) ),\n\t\t\tROTATION: writer.processAccessor( new BufferAttribute( rotationAttr, 4 ) ),\n\t\t\tSCALE: writer.processAccessor( new BufferAttribute( scaleAttr, 3 ) ),\n\t\t};\n\n\t\tif ( mesh.instanceColor )\n\t\t\tattributes._COLOR_0 = writer.processAccessor( mesh.instanceColor );\n\n\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\tnodeDef.extensions[ this.name ] = { attributes };\n\n\t\twriter.extensionsUsed[ this.name ] = true;\n\t\twriter.extensionsRequired[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Static utility functions\n */\nGLTFExporter.Utils = {\n\n\tinsertKeyframe: function ( track, time ) {\n\n\t\tconst tolerance = 0.001; // 1ms\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = new track.TimeBufferType( track.times.length + 1 );\n\t\tconst values = new track.ValueBufferType( track.values.length + valueSize );\n\t\tconst interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );\n\n\t\tlet index;\n\n\t\tif ( track.times.length === 0 ) {\n\n\t\t\ttimes[ 0 ] = time;\n\n\t\t\tfor ( let i = 0; i < valueSize; i ++ ) {\n\n\t\t\t\tvalues[ i ] = 0;\n\n\t\t\t}\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time < track.times[ 0 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;\n\n\t\t\ttimes[ 0 ] = time;\n\t\t\ttimes.set( track.times, 1 );\n\n\t\t\tvalues.set( interpolant.evaluate( time ), 0 );\n\t\t\tvalues.set( track.values, valueSize );\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time > track.times[ track.times.length - 1 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {\n\n\t\t\t\treturn track.times.length - 1;\n\n\t\t\t}\n\n\t\t\ttimes[ times.length - 1 ] = time;\n\t\t\ttimes.set( track.times, 0 );\n\n\t\t\tvalues.set( track.values, 0 );\n\t\t\tvalues.set( interpolant.evaluate( time ), track.values.length );\n\n\t\t\tindex = times.length - 1;\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < track.times.length; i ++ ) {\n\n\t\t\t\tif ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;\n\n\t\t\t\tif ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {\n\n\t\t\t\t\ttimes.set( track.times.slice( 0, i + 1 ), 0 );\n\t\t\t\t\ttimes[ i + 1 ] = time;\n\t\t\t\t\ttimes.set( track.times.slice( i + 1 ), i + 2 );\n\n\t\t\t\t\tvalues.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );\n\t\t\t\t\tvalues.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );\n\t\t\t\t\tvalues.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );\n\n\t\t\t\t\tindex = i + 1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\ttrack.times = times;\n\t\ttrack.values = values;\n\n\t\treturn index;\n\n\t},\n\n\tmergeMorphTargetTracks: function ( clip, root ) {\n\n\t\tconst tracks = [];\n\t\tconst mergedTracks = {};\n\t\tconst sourceTracks = clip.tracks;\n\n\t\tfor ( let i = 0; i < sourceTracks.length; ++ i ) {\n\n\t\t\tlet sourceTrack = sourceTracks[ i ];\n\t\t\tconst sourceTrackBinding = PropertyBinding.parseTrackName( sourceTrack.name );\n\t\t\tconst sourceTrackNode = PropertyBinding.findNode( root, sourceTrackBinding.nodeName );\n\n\t\t\tif ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {\n\n\t\t\t\t// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n\t\t\t\ttracks.push( sourceTrack );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete\n\t\t\t\t&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {\n\n\t\t\t\tif ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\t\t// This should never happen, because glTF morph target animations\n\t\t\t\t\t// affect all targets already.\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );\n\n\t\t\t\tsourceTrack = sourceTrack.clone();\n\t\t\t\tsourceTrack.setInterpolation( InterpolateLinear );\n\n\t\t\t}\n\n\t\t\tconst targetCount = sourceTrackNode.morphTargetInfluences.length;\n\t\t\tconst targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];\n\n\t\t\tif ( targetIndex === undefined ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );\n\n\t\t\t}\n\n\t\t\tlet mergedTrack;\n\n\t\t\t// If this is the first time we've seen this object, create a new\n\t\t\t// track to store merged keyframe data for each morph target.\n\t\t\tif ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {\n\n\t\t\t\tmergedTrack = sourceTrack.clone();\n\n\t\t\t\tconst values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );\n\n\t\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\tvalues[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];\n\n\t\t\t\t}\n\n\t\t\t\t// We need to take into consideration the intended target node\n\t\t\t\t// of our original un-merged morphTarget animation.\n\t\t\t\tmergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';\n\t\t\t\tmergedTrack.values = values;\n\n\t\t\t\tmergedTracks[ sourceTrackNode.uuid ] = mergedTrack;\n\t\t\t\ttracks.push( mergedTrack );\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );\n\n\t\t\tmergedTrack = mergedTracks[ sourceTrackNode.uuid ];\n\n\t\t\t// For every existing keyframe of the merged track, write a (possibly\n\t\t\t// interpolated) value from the source track.\n\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\tmergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );\n\n\t\t\t}\n\n\t\t\t// For every existing keyframe of the source track, write a (possibly\n\t\t\t// new) keyframe to the merged track. Values from the previous loop may\n\t\t\t// be written again, but keyframes are de-duplicated.\n\t\t\tfor ( let j = 0; j < sourceTrack.times.length; j ++ ) {\n\n\t\t\t\tconst keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );\n\t\t\t\tmergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tclip.tracks = tracks;\n\n\t\treturn clip;\n\n\t},\n\n\ttoFloat32BufferAttribute: function ( srcAttribute ) {\n\n\t\tconst dstAttribute = new BufferAttribute( new Float32Array( srcAttribute.count * srcAttribute.itemSize ), srcAttribute.itemSize, false );\n\n\t\tif ( ! srcAttribute.normalized && ! srcAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\tdstAttribute.array.set( srcAttribute.array );\n\n\t\t\treturn dstAttribute;\n\n\t\t}\n\n\t\tfor ( let i = 0, il = srcAttribute.count; i < il; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < srcAttribute.itemSize; j ++ ) {\n\n\t\t\t\tdstAttribute.setComponent( i, j, srcAttribute.getComponent( i, j ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn dstAttribute;\n\n\t}\n\n};\n\nexport { GLTFExporter };\n"],
  "mappings": "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",
  "names": ["init_define_process", "KHR_mesh_quantization_ExtraAttrTypes", "GLTFExporter", "writer", "GLTFLightExtension", "GLTFMaterialsUnlitExtension", "GLTFMaterialsTransmissionExtension", "GLTFMaterialsVolumeExtension", "GLTFMaterialsIorExtension", "GLTFMaterialsSpecularExtension", "GLTFMaterialsClearcoatExtension", "GLTFMaterialsDispersionExtension", "GLTFMaterialsIridescenceExtension", "GLTFMaterialsSheenExtension", "GLTFMaterialsAnisotropyExtension", "GLTFMaterialsEmissiveStrengthExtension", "GLTFMaterialsBumpExtension", "GLTFMeshGpuInstancing", "callback", "utils", "input", "onDone", "onError", "options", "GLTFWriter", "plugins", "i", "il", "scope", "resolve", "reject", "WEBGL_CONSTANTS", "KHR_MESH_QUANTIZATION", "THREE_TO_WEBGL", "NearestFilter", "NearestMipmapNearestFilter", "NearestMipmapLinearFilter", "LinearFilter", "LinearMipmapNearestFilter", "LinearMipmapLinearFilter", "ClampToEdgeWrapping", "RepeatWrapping", "MirroredRepeatWrapping", "PATH_PROPERTIES", "DEFAULT_SPECULAR_COLOR", "Color", "GLB_HEADER_BYTES", "GLB_HEADER_MAGIC", "GLB_VERSION", "GLB_CHUNK_PREFIX_BYTES", "GLB_CHUNK_TYPE_JSON", "GLB_CHUNK_TYPE_BIN", "equalArray", "array1", "array2", "element", "index", "stringToArrayBuffer", "text", "isIdentityMatrix", "matrix", "getMinMax", "attribute", "start", "count", "output", "a", "value", "MathUtils", "getPaddedBufferSize", "bufferSize", "getPaddedArrayBuffer", "arrayBuffer", "paddingByte", "paddedLength", "array", "getCanvas", "getToBlobPromise", "canvas", "mimeType", "quality", "REVISION", "buffers", "json", "extensionsUsed", "extensionsRequired", "blob", "extensionsUsedList", "extensionsRequiredList", "reader", "binaryChunk", "binaryChunkPrefix", "jsonChunk", "jsonChunkPrefix", "header", "headerView", "totalByteLength", "glbBlob", "glbReader", "base64data", "object", "objectDef", "extensionName", "error", "isRelativeCopy", "uids", "normal", "v", "Vector3", "cache", "mapDef", "texture", "didTransform", "transformDef", "metalnessMap", "roughnessMap", "getEncodingConversion", "map", "SRGBColorSpace", "c", "CompressedTexture", "metalness", "roughness", "width", "height", "context", "composite", "convert", "data", "Source", "NoColorSpace", "maxTextureSize", "buffer", "componentType", "target", "componentSize", "byteStride", "byteLength", "dataView", "offset", "bufferViewDef", "geometry", "types", "minMax", "bufferViewTarget", "bufferView", "accessorDef", "image", "format", "flipY", "pending", "cachedImages", "key", "imageDef", "ctx", "RGBAFormat", "bufferViewIndex", "dataURL", "samplerDef", "textureDef", "ext", "material", "materialDef", "color", "metalRoughTexture", "metalRoughMapDef", "baseColorMapDef", "emissive", "emissiveMapDef", "normalMapDef", "occlusionMapDef", "DoubleSide", "mesh", "meshCacheKeyParts", "l", "meshCacheKey", "mode", "meshDef", "attributes", "primitives", "targets", "nameConversion", "originalNormal", "modifiedAttribute", "attributeName", "BufferAttribute", "accessor", "weights", "targetNames", "reverseDictionary", "warned", "gltfAttributeName", "baseAttribute", "relativeAttribute", "j", "jl", "isMultiMaterial", "didForceIndices", "indices", "materials", "groups", "primitive", "cacheKey", "attrType", "attrNamePrefix", "camera", "isOrtho", "cameraDef", "clip", "root", "nodeMap", "tracks", "channels", "samplers", "track", "trackBinding", "PropertyBinding", "trackNode", "trackProperty", "inputItemSize", "outputItemSize", "interpolation", "InterpolateDiscrete", "node", "skeleton", "rootJoint", "joints", "inverseBindMatrices", "temporaryBoneInverse", "Matrix4", "nodeDef", "rotation", "position", "scale", "meshIndex", "children", "child", "nodeIndex", "scene", "sceneDef", "nodes", "objects", "Scene", "objectsWithoutScene", "func", "light", "lightDef", "lights", "extensionDef", "clearcoatMapDef", "clearcoatRoughnessMapDef", "clearcoatNormalMapDef", "iridescenceMapDef", "iridescenceThicknessMapDef", "transmissionMapDef", "thicknessMapDef", "specularIntensityMapDef", "specularColorMapDef", "sheenRoughnessMapDef", "sheenColorMapDef", "anisotropyMapDef", "bumpMapDef", "translationAttr", "rotationAttr", "scaleAttr", "quaternion", "Quaternion", "time", "valueSize", "times", "values", "interpolant", "mergedTracks", "sourceTracks", "sourceTrack", "sourceTrackBinding", "sourceTrackNode", "InterpolateLinear", "targetCount", "targetIndex", "mergedTrack", "sourceInterpolant", "keyframeIndex", "srcAttribute", "dstAttribute"]
}
