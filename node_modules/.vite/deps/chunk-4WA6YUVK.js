import {
  M
} from "./chunk-QAS2ACFW.js";
import {
  $i,
  Al,
  C,
  Cr,
  Cs,
  Ie,
  Jo,
  Le,
  Ls,
  Mn,
  Nt,
  On,
  Pe,
  Ye,
  Zr,
  at,
  bn,
  cn,
  de,
  il,
  ke,
  ki,
  kt,
  ln,
  ni,
  ol,
  ps,
  ve,
  yc
} from "./chunk-X36R2MTZ.js";
import {
  q,
  r,
  s,
  t,
  u,
  v,
  w
} from "./chunk-J7CDIHLL.js";
import {
  __export
} from "./chunk-PLDDJCW6.js";

// node_modules/zod/v4/classic/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFile: () => ZodFile,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  codec: () => codec,
  coerce: () => coerce_exports,
  config: () => config,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  decode: () => decode2,
  decodeAsync: () => decodeAsync2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  encode: () => encode2,
  encodeAsync: () => encodeAsync2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse2,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeEncode: () => safeEncode2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  util: () => util_exports,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2
});

// node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCodec: () => $ZodCodec,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _check: () => _check,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _decode: () => _decode,
  _decodeAsync: () => _decodeAsync,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _encode: () => _encode,
  _encodeAsync: () => _encodeAsync,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeDecode: () => _safeDecode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeEncode: () => _safeEncode,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _superRefine: () => _superRefine,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  clone: () => clone,
  config: () => config,
  decode: () => decode,
  decodeAsync: () => decodeAsync,
  encode: () => encode,
  encodeAsync: () => encodeAsync,
  flattenError: () => flattenError,
  formatError: () => formatError,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  parse: () => parse,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version
});

// node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    var _a2;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a2 = inst._zod).traits ?? (_a2.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name);
    initializer3(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn2 of inst._zod.deferred) {
      fn2();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var $ZodEncodeError = class extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}

// node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error();
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v3) => typeof v3 === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v3]) => v3);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = Symbol("evaluating");
function defineLazy(object2, key, getter) {
  let value = void 0;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v3) {
      Object.defineProperty(object2, key, {
        value: v3
        // configurable: true,
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t63 = typeof data;
  switch (t63) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t63}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl2 = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl2._zod.parent = inst;
  return cl2;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")],
  uint64: [BigInt(0), BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: schema._zod.def.checks
  };
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el2) => el2[1]);
}
function base64ToUint8Array(base643) {
  const binaryString = atob(base643);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url3) {
  const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array(base643 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var Class = class {
  constructor(..._args) {
  }
};

// node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error46, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error46.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error46, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error47) => {
    for (const issue2 of error47.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el2 = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el2] = curr[el2] || { _errors: [] };
          } else {
            curr[el2] = curr[el2] || { _errors: [] };
            curr[el2]._errors.push(mapper(issue2));
          }
          curr = curr[el2];
          i++;
        }
      }
    }
  };
  processError(error46);
  return fieldErrors;
}
function treeifyError(error46, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = (error47, path = []) => {
    var _a2, _b2;
    for (const issue2 of error47.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el2 = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el2 === "string") {
            curr.properties ?? (curr.properties = {});
            (_a2 = curr.properties)[el2] ?? (_a2[el2] = { errors: [] });
            curr = curr.properties[el2];
          } else {
            curr.items ?? (curr.items = []);
            (_b2 = curr.items)[el2] ?? (_b2[el2] = { errors: [] });
            curr = curr.items[el2];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error46);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error46) {
  const lines = [];
  const issues = [...error46.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`✖ ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  → at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse = _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = _safeParseAsync($ZodRealError);
var _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
var encode = _encode($ZodRealError);
var _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
var decode = _decode($ZodRealError);
var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
var encodeAsync = _encodeAsync($ZodRealError);
var _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
var decodeAsync = _decodeAsync($ZodRealError);
var _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
var safeEncode = _safeEncode($ZodRealError);
var _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
var safeDecode = _safeDecode($ZodRealError);
var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
var safeEncodeAsync = _safeEncodeAsync($ZodRealError);
var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
var safeDecodeAsync = _safeDecodeAsync($ZodRealError);

// node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = uuid(4);
var uuid6 = uuid(6);
var uuid7 = uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail = unicodeEmail;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^-?\d+n?$/;
var integer = /^-?\d+$/;
var number = /^-?\d+(?:\.\d+)?/;
var boolean = /^(?:true|false)$/i;
var _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/;
var md5_base64 = fixedBase64(22, "==");
var md5_base64url = fixedBase64url(22);
var sha1_hex = /^[0-9a-fA-F]{40}$/;
var sha1_base64 = fixedBase64(27, "=");
var sha1_base64url = fixedBase64url(27);
var sha256_hex = /^[0-9a-fA-F]{64}$/;
var sha256_base64 = fixedBase64(43, "=");
var sha256_base64url = fixedBase64url(43);
var sha384_hex = /^[0-9a-fA-F]{96}$/;
var sha384_base64 = fixedBase64(64, "");
var sha384_base64url = fixedBase64url(64);
var sha512_hex = /^[0-9a-fA-F]{128}$/;
var sha512_base64 = fixedBase64(86, "==");
var sha512_base64url = fixedBase64url(86);

// node_modules/zod/v4/core/checks.js
var $ZodCheck = $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat = $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize = $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b2;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b2 = inst._zod).check ?? (_b2.check = () => {
    });
});
var $ZodCheckRegex = $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn2) {
    this.indent += 1;
    fn2(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 1,
  patch: 12
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = $constructor("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch2 of checks) {
    for (const fn2 of ch2._zod.onattach) {
      fn2(inst);
    }
  }
  if (checks.length === 0) {
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch2 of checks2) {
        if (ch2._zod.def.when) {
          const shouldRun = ch2._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch2._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r3 = safeParse(inst, value);
        return r3.success ? { value: r3.data } : { issues: r3.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r3) => r3.success ? { value: r3.data } : { issues: r3.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString = $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_3) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v3 = versionMap[def.version];
    if (v3 === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v3));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url2 = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url2.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = $constructor("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t63 = _catchall.def.type;
  for (const key of Object.keys(input)) {
    if (keySet.has(key))
      continue;
    if (t63 === "never") {
      unrecognized.push(key);
      continue;
    }
    const r3 = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r3 instanceof Promise) {
      proms.push(r3.then((r4) => handlePropertyResult(r4, payload, key, input)));
    } else {
      handlePropertyResult(r3, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject = $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc?.get) {
    const sh2 = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh2 };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v3 of field.values)
          propValues[key].add(v3);
      }
    }
    return propValues;
  });
  const isObject2 = isObject;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el2 = shape[key];
      const r3 = el2._zod.run({ value: input[key], issues: [] }, ctx);
      if (r3 instanceof Promise) {
        proms.push(r3.then((r4) => handlePropertyResult(r4, payload, key, input)));
      } else {
        handlePropertyResult(r3, payload, key, input);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id2 = ids[key];
      const k = esc(key);
      doc.write(`const ${id2} = ${parseStr(key)};`);
      doc.write(`
        if (${id2}.issues.length) {
          payload.issues = payload.issues.concat(${id2}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id2}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id2}.value;
        }
        
      `);
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn2 = doc.compile();
    return (payload, ctx) => fn2(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r3) => !aborted(r3));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv2 = option._zod.propValues;
      if (!pv2 || Object.keys(pv2).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v3] of Object.entries(pv2)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v3) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map2 = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v3 of values) {
        if (map2.has(v3)) {
          throw new Error(`Duplicate discriminator value "${String(v3)}"`);
        }
        map2.set(v3, o);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el2 of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el2,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
var $ZodOptional = $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r3) => handleOptionalResult(r3, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v3 = def.innerType._zod.values;
    return v3 ? new Set([...v3].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      }
      return handleCodecAResult(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      }
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction = $constructor("$ZodFunction", (inst, def) => {
  $ZodType.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise = $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? void 0);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? void 0);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r3 = def.fn(input);
    if (r3 instanceof Promise) {
      return r3.then((r4) => handleRefineResult(r4, payload, input, inst));
    }
    handleRefineResult(r3, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}

// node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  bg: () => bg_default,
  ca: () => ca_default,
  cs: () => cs_default,
  da: () => da_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  id: () => id_default,
  is: () => is_default,
  it: () => it_default,
  ja: () => ja_default,
  ka: () => ka_default,
  kh: () => kh_default,
  km: () => km_default,
  ko: () => ko_default,
  lt: () => lt_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  uk: () => uk_default,
  ur: () => ur_default,
  vi: () => vi_default,
  yo: () => yo_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});

// node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: { unit: "حرف", verb: "أن يحوي" },
    file: { unit: "بايت", verb: "أن يحوي" },
    array: { unit: "عنصر", verb: "أن يحوي" },
    set: { unit: "عنصر", verb: "أن يحوي" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "مدخل",
    email: "بريد إلكتروني",
    url: "رابط",
    emoji: "إيموجي",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "تاريخ ووقت بمعيار ISO",
    date: "تاريخ بمعيار ISO",
    time: "وقت بمعيار ISO",
    duration: "مدة بمعيار ISO",
    ipv4: "عنوان IPv4",
    ipv6: "عنوان IPv6",
    cidrv4: "مدى عناوين بصيغة IPv4",
    cidrv6: "مدى عناوين بصيغة IPv6",
    base64: "نَص بترميز base64-encoded",
    base64url: "نَص بترميز base64url-encoded",
    json_string: "نَص على هيئة JSON",
    e164: "رقم هاتف بمعيار E.164",
    jwt: "JWT",
    template_literal: "مدخل"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `مدخلات غير مقبولة: يفترض إدخال ${issue2.expected}، ولكن تم إدخال ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `مدخلات غير مقبولة: يفترض إدخال ${stringifyPrimitive(issue2.values[0])}`;
        return `اختيار غير مقبول: يتوقع انتقاء أحد هذه الخيارات: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` أكبر من اللازم: يفترض أن تكون ${issue2.origin ?? "القيمة"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "عنصر"}`;
        return `أكبر من اللازم: يفترض أن تكون ${issue2.origin ?? "القيمة"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `أصغر من اللازم: يفترض لـ ${issue2.origin} أن يكون ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `أصغر من اللازم: يفترض لـ ${issue2.origin} أن يكون ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `نَص غير مقبول: يجب أن يبدأ بـ "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `نَص غير مقبول: يجب أن ينتهي بـ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `نَص غير مقبول: يجب أن يتضمَّن "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `نَص غير مقبول: يجب أن يطابق النمط ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} غير مقبول`;
      }
      case "not_multiple_of":
        return `رقم غير مقبول: يجب أن يكون من مضاعفات ${issue2.divisor}`;
      case "unrecognized_keys":
        return `معرف${issue2.keys.length > 1 ? "ات" : ""} غريب${issue2.keys.length > 1 ? "ة" : ""}: ${joinValues(issue2.keys, "، ")}`;
      case "invalid_key":
        return `معرف غير مقبول في ${issue2.origin}`;
      case "invalid_union":
        return "مدخل غير مقبول";
      case "invalid_element":
        return `مدخل غير مقبول في ${issue2.origin}`;
      default:
        return "مدخل غير مقبول";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}

// node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmalıdır" },
    file: { unit: "bayt", verb: "olmalıdır" },
    array: { unit: "element", verb: "olmalıdır" },
    set: { unit: "element", verb: "olmalıdır" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Yanlış dəyər: gözlənilən ${issue2.expected}, daxil olan ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanlış dəyər: gözlənilən ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanlış seçim: aşağıdakılardan biri olmalıdır: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çox böyük: gözlənilən ${issue2.origin ?? "dəyər"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `Çox böyük: gözlənilən ${issue2.origin ?? "dəyər"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çox kiçik: gözlənilən ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Çox kiçik: gözlənilən ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanlış mətn: "${_issue.prefix}" ilə başlamalıdır`;
        if (_issue.format === "ends_with")
          return `Yanlış mətn: "${_issue.suffix}" ilə bitməlidir`;
        if (_issue.format === "includes")
          return `Yanlış mətn: "${_issue.includes}" daxil olmalıdır`;
        if (_issue.format === "regex")
          return `Yanlış mətn: ${_issue.pattern} şablonuna uyğun olmalıdır`;
        return `Yanlış ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanlış ədəd: ${issue2.divisor} ilə bölünə bilən olmalıdır`;
      case "unrecognized_keys":
        return `Tanınmayan açar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilində yanlış açar`;
      case "invalid_union":
        return "Yanlış dəyər";
      case "invalid_element":
        return `${issue2.origin} daxilində yanlış dəyər`;
      default:
        return `Yanlış dəyər`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}

// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "сімвал",
        few: "сімвалы",
        many: "сімвалаў"
      },
      verb: "мець"
    },
    array: {
      unit: {
        one: "элемент",
        few: "элементы",
        many: "элементаў"
      },
      verb: "мець"
    },
    set: {
      unit: {
        one: "элемент",
        few: "элементы",
        many: "элементаў"
      },
      verb: "мець"
    },
    file: {
      unit: {
        one: "байт",
        few: "байты",
        many: "байтаў"
      },
      verb: "мець"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "лік";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "масіў";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "увод",
    email: "email адрас",
    url: "URL",
    emoji: "эмодзі",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO дата і час",
    date: "ISO дата",
    time: "ISO час",
    duration: "ISO працягласць",
    ipv4: "IPv4 адрас",
    ipv6: "IPv6 адрас",
    cidrv4: "IPv4 дыяпазон",
    cidrv6: "IPv6 дыяпазон",
    base64: "радок у фармаце base64",
    base64url: "радок у фармаце base64url",
    json_string: "JSON радок",
    e164: "нумар E.164",
    jwt: "JWT",
    template_literal: "увод"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Няправільны ўвод: чакаўся ${issue2.expected}, атрымана ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Няправільны ўвод: чакалася ${stringifyPrimitive(issue2.values[0])}`;
        return `Няправільны варыянт: чакаўся адзін з ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Занадта вялікі: чакалася, што ${issue2.origin ?? "значэнне"} павінна ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `Занадта вялікі: чакалася, што ${issue2.origin ?? "значэнне"} павінна быць ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Занадта малы: чакалася, што ${issue2.origin} павінна ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `Занадта малы: чакалася, што ${issue2.origin} павінна быць ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Няправільны радок: павінен пачынацца з "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Няправільны радок: павінен заканчвацца на "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Няправільны радок: павінен змяшчаць "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Няправільны радок: павінен адпавядаць шаблону ${_issue.pattern}`;
        return `Няправільны ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Няправільны лік: павінен быць кратным ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Нераспазнаны ${issue2.keys.length > 1 ? "ключы" : "ключ"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Няправільны ключ у ${issue2.origin}`;
      case "invalid_union":
        return "Няправільны ўвод";
      case "invalid_element":
        return `Няправільнае значэнне ў ${issue2.origin}`;
      default:
        return `Няправільны ўвод`;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}

// node_modules/zod/v4/locales/bg.js
var parsedType = (data) => {
  const t63 = typeof data;
  switch (t63) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "число";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "масив";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t63;
};
var error4 = () => {
  const Sizable = {
    string: { unit: "символа", verb: "да съдържа" },
    file: { unit: "байта", verb: "да съдържа" },
    array: { unit: "елемента", verb: "да съдържа" },
    set: { unit: "елемента", verb: "да съдържа" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "вход",
    email: "имейл адрес",
    url: "URL",
    emoji: "емоджи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO време",
    date: "ISO дата",
    time: "ISO време",
    duration: "ISO продължителност",
    ipv4: "IPv4 адрес",
    ipv6: "IPv6 адрес",
    cidrv4: "IPv4 диапазон",
    cidrv6: "IPv6 диапазон",
    base64: "base64-кодиран низ",
    base64url: "base64url-кодиран низ",
    json_string: "JSON низ",
    e164: "E.164 номер",
    jwt: "JWT",
    template_literal: "вход"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Невалиден вход: очакван ${issue2.expected}, получен ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Невалиден вход: очакван ${stringifyPrimitive(issue2.values[0])}`;
        return `Невалидна опция: очаквано едно от ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Твърде голямо: очаква се ${issue2.origin ?? "стойност"} да съдържа ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "елемента"}`;
        return `Твърде голямо: очаква се ${issue2.origin ?? "стойност"} да бъде ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Твърде малко: очаква се ${issue2.origin} да съдържа ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Твърде малко: очаква се ${issue2.origin} да бъде ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Невалиден низ: трябва да започва с "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Невалиден низ: трябва да завършва с "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Невалиден низ: трябва да включва "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Невалиден низ: трябва да съвпада с ${_issue.pattern}`;
        let invalid_adj = "Невалиден";
        if (_issue.format === "emoji")
          invalid_adj = "Невалидно";
        if (_issue.format === "datetime")
          invalid_adj = "Невалидно";
        if (_issue.format === "date")
          invalid_adj = "Невалидна";
        if (_issue.format === "time")
          invalid_adj = "Невалидно";
        if (_issue.format === "duration")
          invalid_adj = "Невалидна";
        return `${invalid_adj} ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Невалидно число: трябва да бъде кратно на ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Неразпознат${issue2.keys.length > 1 ? "и" : ""} ключ${issue2.keys.length > 1 ? "ове" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Невалиден ключ в ${issue2.origin}`;
      case "invalid_union":
        return "Невалиден вход";
      case "invalid_element":
        return `Невалидна стойност в ${issue2.origin}`;
      default:
        return `Невалиден вход`;
    }
  };
};
function bg_default() {
  return {
    localeError: error4()
  };
}

// node_modules/zod/v4/locales/ca.js
var error5 = () => {
  const Sizable = {
    string: { unit: "caràcters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "entrada",
    email: "adreça electrònica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adreça IPv4",
    ipv6: "adreça IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipus invàlid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType8(issue2.input)}`;
      // return `Tipus invàlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor invàlid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opció invàlida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a màxim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingués ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a mínim" : "més de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingués ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format invàlid: ha de començar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format invàlid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format invàlid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format invàlid: ha de coincidir amb el patró ${_issue.pattern}`;
        return `Format invàlid per a ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Número invàlid: ha de ser múltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau invàlida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invàlida";
      // Could also be "Tipus d'unió invàlid" but "Entrada invàlida" is more general
      case "invalid_element":
        return `Element invàlid a ${issue2.origin}`;
      default:
        return `Entrada invàlida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error5()
  };
}

// node_modules/zod/v4/locales/cs.js
var error6 = () => {
  const Sizable = {
    string: { unit: "znaků", verb: "mít" },
    file: { unit: "bajtů", verb: "mít" },
    array: { unit: "prvků", verb: "mít" },
    set: { unit: "prvků", verb: "mít" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "číslo";
      }
      case "string": {
        return "řetězec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "regulární výraz",
    email: "e-mailová adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a čas ve formátu ISO",
    date: "datum ve formátu ISO",
    time: "čas ve formátu ISO",
    duration: "doba trvání ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "řetězec zakódovaný ve formátu base64",
    base64url: "řetězec zakódovaný ve formátu base64url",
    json_string: "řetězec ve formátu JSON",
    e164: "číslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neplatný vstup: očekáváno ${issue2.expected}, obdrženo ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatný vstup: očekáváno ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatná možnost: očekávána jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je příliš velká: ${issue2.origin ?? "hodnota"} musí mít ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvků"}`;
        }
        return `Hodnota je příliš velká: ${issue2.origin ?? "hodnota"} musí být ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je příliš malá: ${issue2.origin ?? "hodnota"} musí mít ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvků"}`;
        }
        return `Hodnota je příliš malá: ${issue2.origin ?? "hodnota"} musí být ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatný řetězec: musí začínat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatný řetězec: musí končit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatný řetězec: musí obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatný řetězec: musí odpovídat vzoru ${_issue.pattern}`;
        return `Neplatný formát ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatné číslo: musí být násobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neznámé klíče: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatný klíč v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatný vstup";
      case "invalid_element":
        return `Neplatná hodnota v ${issue2.origin}`;
      default:
        return `Neplatný vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error6()
  };
}

// node_modules/zod/v4/locales/da.js
var error7 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  const TypeNames = {
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "sæt",
    file: "fil"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
        return "objekt";
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslæt",
    date: "ISO-dato",
    time: "ISO-klokkeslæt",
    duration: "ISO-varighed",
    ipv4: "IPv4-område",
    ipv6: "IPv6-område",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${getTypeName(issue2.expected)}, fik ${getTypeName(parsedType8(issue2.input))}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig værdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af følgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche mønsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal være deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte nøgler" : "Ukendt nøgle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nøgle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig værdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da_default() {
  return {
    localeError: error7()
  };
}

// node_modules/zod/v4/locales/de.js
var error8 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ungültige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ungültige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ungültige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu groß: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu groß: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ungültiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ungültiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ungültiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ungültiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ungültig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ungültige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schlüssel" : "Unbekannter Schlüssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ungültiger Schlüssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ungültige Eingabe";
      case "invalid_element":
        return `Ungültiger Wert in ${issue2.origin}`;
      default:
        return `Ungültige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error8()
  };
}

// node_modules/zod/v4/locales/en.js
var parsedType2 = (data) => {
  const t63 = typeof data;
  switch (t63) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t63;
};
var error9 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error9()
  };
}

// node_modules/zod/v4/locales/eo.js
var parsedType3 = (data) => {
  const t63 = typeof data;
  switch (t63) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t63;
};
var error10 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoĝio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daŭro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nevalida enigo: atendiĝis ${issue2.expected}, riceviĝis ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendiĝis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendiĝis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendiĝis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendiĝis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendiĝis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendiĝis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenciĝi per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas finiĝi per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} ŝlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida ŝlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error10()
  };
}

// node_modules/zod/v4/locales/es.js
var error11 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  const TypeNames = {
    string: "texto",
    number: "número",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "número grande",
    symbol: "símbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "función",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeración",
    union: "unión",
    literal: "literal",
    promise: "promesa",
    void: "vacío",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
        return "object";
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "entrada",
    email: "dirección de correo electrónico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duración ISO",
    ipv4: "dirección IPv4",
    ipv6: "dirección IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrada inválida: se esperaba ${getTypeName(issue2.expected)}, recibido ${getTypeName(parsedType8(issue2.input))}`;
      // return `Entrada inválida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inválida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opción inválida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing) {
          return `Demasiado pequeño: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado pequeño: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inválida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inválida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inválida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inválida: debe coincidir con el patrón ${_issue.pattern}`;
        return `Inválido ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Número inválido: debe ser múltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inválida en ${getTypeName(issue2.origin)}`;
      case "invalid_union":
        return "Entrada inválida";
      case "invalid_element":
        return `Valor inválido en ${getTypeName(issue2.origin)}`;
      default:
        return `Entrada inválida`;
    }
  };
};
function es_default() {
  return {
    localeError: error11()
  };
}

// node_modules/zod/v4/locales/fa.js
var error12 = () => {
  const Sizable = {
    string: { unit: "کاراکتر", verb: "داشته باشد" },
    file: { unit: "بایت", verb: "داشته باشد" },
    array: { unit: "آیتم", verb: "داشته باشد" },
    set: { unit: "آیتم", verb: "داشته باشد" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "عدد";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "آرایه";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "ورودی",
    email: "آدرس ایمیل",
    url: "URL",
    emoji: "ایموجی",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "تاریخ و زمان ایزو",
    date: "تاریخ ایزو",
    time: "زمان ایزو",
    duration: "مدت زمان ایزو",
    ipv4: "IPv4 آدرس",
    ipv6: "IPv6 آدرس",
    cidrv4: "IPv4 دامنه",
    cidrv6: "IPv6 دامنه",
    base64: "base64-encoded رشته",
    base64url: "base64url-encoded رشته",
    json_string: "JSON رشته",
    e164: "E.164 عدد",
    jwt: "JWT",
    template_literal: "ورودی"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `ورودی نامعتبر: می‌بایست ${issue2.expected} می‌بود، ${parsedType8(issue2.input)} دریافت شد`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `ورودی نامعتبر: می‌بایست ${stringifyPrimitive(issue2.values[0])} می‌بود`;
        }
        return `گزینه نامعتبر: می‌بایست یکی از ${joinValues(issue2.values, "|")} می‌بود`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `خیلی بزرگ: ${issue2.origin ?? "مقدار"} باید ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "عنصر"} باشد`;
        }
        return `خیلی بزرگ: ${issue2.origin ?? "مقدار"} باید ${adj}${issue2.maximum.toString()} باشد`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `خیلی کوچک: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} ${sizing.unit} باشد`;
        }
        return `خیلی کوچک: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} باشد`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `رشته نامعتبر: باید با "${_issue.prefix}" شروع شود`;
        }
        if (_issue.format === "ends_with") {
          return `رشته نامعتبر: باید با "${_issue.suffix}" تمام شود`;
        }
        if (_issue.format === "includes") {
          return `رشته نامعتبر: باید شامل "${_issue.includes}" باشد`;
        }
        if (_issue.format === "regex") {
          return `رشته نامعتبر: باید با الگوی ${_issue.pattern} مطابقت داشته باشد`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} نامعتبر`;
      }
      case "not_multiple_of":
        return `عدد نامعتبر: باید مضرب ${issue2.divisor} باشد`;
      case "unrecognized_keys":
        return `کلید${issue2.keys.length > 1 ? "های" : ""} ناشناس: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `کلید ناشناس در ${issue2.origin}`;
      case "invalid_union":
        return `ورودی نامعتبر`;
      case "invalid_element":
        return `مقدار نامعتبر در ${issue2.origin}`;
      default:
        return `ورودی نامعتبر`;
    }
  };
};
function fa_default() {
  return {
    localeError: error12()
  };
}

// node_modules/zod/v4/locales/fi.js
var error13 = () => {
  const Sizable = {
    string: { unit: "merkkiä", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "päivämäärän" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "säännöllinen lauseke",
    email: "sähköpostiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-päivämäärä",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen syöte: täytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: täytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} täytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon täytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} täytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon täytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen syöte: täytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen syöte: täytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen syöte: täytyy sisältää "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen syöte: täytyy vastata säännöllistä lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: täytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen syöte`;
    }
  };
};
function fi_default() {
  return {
    localeError: error13()
  };
}

// node_modules/zod/v4/locales/fr.js
var error14 = () => {
  const Sizable = {
    string: { unit: "caractères", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "éléments", verb: "avoir" },
    set: { unit: "éléments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "entrée",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durée ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaîne encodée en base64",
    base64url: "chaîne encodée en base64url",
    json_string: "chaîne JSON",
    e164: "numéro E.164",
    jwt: "JWT",
    template_literal: "entrée"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrée invalide : ${issue2.expected} attendu, ${parsedType8(issue2.input)} reçu`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrée invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "élément(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit être ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit être ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chaîne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chaîne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chaîne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chaîne invalide : doit correspondre au modèle ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit être un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clé${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clé invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entrée invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entrée invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error14()
  };
}

// node_modules/zod/v4/locales/fr-CA.js
var error15 = () => {
  const Sizable = {
    string: { unit: "caractères", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "éléments", verb: "avoir" },
    set: { unit: "éléments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "entrée",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durée ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaîne encodée en base64",
    base64url: "chaîne encodée en base64url",
    json_string: "chaîne JSON",
    e164: "numéro E.164",
    jwt: "JWT",
    template_literal: "entrée"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrée invalide : attendu ${issue2.expected}, reçu ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrée invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "≤" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "≥" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Chaîne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Chaîne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chaîne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chaîne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit être un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clé${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clé invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entrée invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entrée invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error15()
  };
}

// node_modules/zod/v4/locales/he.js
var error16 = () => {
  const Sizable = {
    string: { unit: "אותיות", verb: "לכלול" },
    file: { unit: "בייטים", verb: "לכלול" },
    array: { unit: "פריטים", verb: "לכלול" },
    set: { unit: "פריטים", verb: "לכלול" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "קלט",
    email: "כתובת אימייל",
    url: "כתובת רשת",
    emoji: "אימוג'י",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "תאריך וזמן ISO",
    date: "תאריך ISO",
    time: "זמן ISO",
    duration: "משך זמן ISO",
    ipv4: "כתובת IPv4",
    ipv6: "כתובת IPv6",
    cidrv4: "טווח IPv4",
    cidrv6: "טווח IPv6",
    base64: "מחרוזת בבסיס 64",
    base64url: "מחרוזת בבסיס 64 לכתובות רשת",
    json_string: "מחרוזת JSON",
    e164: "מספר E.164",
    jwt: "JWT",
    template_literal: "קלט"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `קלט לא תקין: צריך ${issue2.expected}, התקבל ${parsedType8(issue2.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `קלט לא תקין: צריך ${stringifyPrimitive(issue2.values[0])}`;
        return `קלט לא תקין: צריך אחת מהאפשרויות  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `גדול מדי: ${issue2.origin ?? "value"} צריך להיות ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `גדול מדי: ${issue2.origin ?? "value"} צריך להיות ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `קטן מדי: ${issue2.origin} צריך להיות ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `קטן מדי: ${issue2.origin} צריך להיות ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `מחרוזת לא תקינה: חייבת להתחיל ב"${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `מחרוזת לא תקינה: חייבת להסתיים ב "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `מחרוזת לא תקינה: חייבת לכלול "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `מחרוזת לא תקינה: חייבת להתאים לתבנית ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} לא תקין`;
      }
      case "not_multiple_of":
        return `מספר לא תקין: חייב להיות מכפלה של ${issue2.divisor}`;
      case "unrecognized_keys":
        return `מפתח${issue2.keys.length > 1 ? "ות" : ""} לא מזוה${issue2.keys.length > 1 ? "ים" : "ה"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `מפתח לא תקין ב${issue2.origin}`;
      case "invalid_union":
        return "קלט לא תקין";
      case "invalid_element":
        return `ערך לא תקין ב${issue2.origin}`;
      default:
        return `קלט לא תקין`;
    }
  };
};
function he_default() {
  return {
    localeError: error16()
  };
}

// node_modules/zod/v4/locales/hu.js
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "szám";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tömb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email cím",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO időbélyeg",
    date: "ISO dátum",
    time: "ISO idő",
    duration: "ISO időintervallum",
    ipv4: "IPv4 cím",
    ipv6: "IPv6 cím",
    cidrv4: "IPv4 tartomány",
    cidrv6: "IPv6 tartomány",
    base64: "base64-kódolt string",
    base64url: "base64url-kódolt string",
    json_string: "JSON string",
    e164: "E.164 szám",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Érvénytelen bemenet: a várt érték ${issue2.expected}, a kapott érték ${parsedType8(issue2.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Érvénytelen bemenet: a várt érték ${stringifyPrimitive(issue2.values[0])}`;
        return `Érvénytelen opció: valamelyik érték várt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Túl nagy: ${issue2.origin ?? "érték"} mérete túl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `Túl nagy: a bemeneti érték ${issue2.origin ?? "érték"} túl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Túl kicsi: a bemeneti érték ${issue2.origin} mérete túl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Túl kicsi: a bemeneti érték ${issue2.origin} túl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Érvénytelen string: "${_issue.prefix}" értékkel kell kezdődnie`;
        if (_issue.format === "ends_with")
          return `Érvénytelen string: "${_issue.suffix}" értékkel kell végződnie`;
        if (_issue.format === "includes")
          return `Érvénytelen string: "${_issue.includes}" értéket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `Érvénytelen string: ${_issue.pattern} mintának kell megfelelnie`;
        return `Érvénytelen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Érvénytelen szám: ${issue2.divisor} többszörösének kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Érvénytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "Érvénytelen bemenet";
      case "invalid_element":
        return `Érvénytelen érték: ${issue2.origin}`;
      default:
        return `Érvénytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error17()
  };
}

// node_modules/zod/v4/locales/id.js
var error18 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error18()
  };
}

// node_modules/zod/v4/locales/is.js
var parsedType4 = (data) => {
  const t63 = typeof data;
  switch (t63) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "númer";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "fylki";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t63;
};
var error19 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "að hafa" },
    file: { unit: "bæti", verb: "að hafa" },
    array: { unit: "hluti", verb: "að hafa" },
    set: { unit: "hluti", verb: "að hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "gildi",
    email: "netfang",
    url: "vefslóð",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og tími",
    date: "ISO dagsetning",
    time: "ISO tími",
    duration: "ISO tímalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 tölugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Rangt gildi: Þú slóst inn ${parsedType4(issue2.input)} þar sem á að vera ${issue2.expected}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert ráð fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `Ógilt val: má vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of stórt: gert er ráð fyrir að ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of stórt: gert er ráð fyrir að ${issue2.origin ?? "gildi"} sé ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of lítið: gert er ráð fyrir að ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of lítið: gert er ráð fyrir að ${issue2.origin} sé ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ógildur strengur: verður að byrja á "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ógildur strengur: verður að enda á "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ógildur strengur: verður að innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ógildur strengur: verður að fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Röng tala: verður að vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Óþekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill í ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi í ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is_default() {
  return {
    localeError: error19()
  };
}

// node_modules/zod/v4/locales/it.js
var error20 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType8(issue2.input)}`;
      // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error20()
  };
}

// node_modules/zod/v4/locales/ja.js
var error21 = () => {
  const Sizable = {
    string: { unit: "文字", verb: "である" },
    file: { unit: "バイト", verb: "である" },
    array: { unit: "要素", verb: "である" },
    set: { unit: "要素", verb: "である" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "数値";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "配列";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "入力値",
    email: "メールアドレス",
    url: "URL",
    emoji: "絵文字",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO日時",
    date: "ISO日付",
    time: "ISO時刻",
    duration: "ISO期間",
    ipv4: "IPv4アドレス",
    ipv6: "IPv6アドレス",
    cidrv4: "IPv4範囲",
    cidrv6: "IPv6範囲",
    base64: "base64エンコード文字列",
    base64url: "base64urlエンコード文字列",
    json_string: "JSON文字列",
    e164: "E.164番号",
    jwt: "JWT",
    template_literal: "入力値"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `無効な入力: ${issue2.expected}が期待されましたが、${parsedType8(issue2.input)}が入力されました`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `無効な入力: ${stringifyPrimitive(issue2.values[0])}が期待されました`;
        return `無効な選択: ${joinValues(issue2.values, "、")}のいずれかである必要があります`;
      case "too_big": {
        const adj = issue2.inclusive ? "以下である" : "より小さい";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `大きすぎる値: ${issue2.origin ?? "値"}は${issue2.maximum.toString()}${sizing.unit ?? "要素"}${adj}必要があります`;
        return `大きすぎる値: ${issue2.origin ?? "値"}は${issue2.maximum.toString()}${adj}必要があります`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "以上である" : "より大きい";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `小さすぎる値: ${issue2.origin}は${issue2.minimum.toString()}${sizing.unit}${adj}必要があります`;
        return `小さすぎる値: ${issue2.origin}は${issue2.minimum.toString()}${adj}必要があります`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `無効な文字列: "${_issue.prefix}"で始まる必要があります`;
        if (_issue.format === "ends_with")
          return `無効な文字列: "${_issue.suffix}"で終わる必要があります`;
        if (_issue.format === "includes")
          return `無効な文字列: "${_issue.includes}"を含む必要があります`;
        if (_issue.format === "regex")
          return `無効な文字列: パターン${_issue.pattern}に一致する必要があります`;
        return `無効な${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `無効な数値: ${issue2.divisor}の倍数である必要があります`;
      case "unrecognized_keys":
        return `認識されていないキー${issue2.keys.length > 1 ? "群" : ""}: ${joinValues(issue2.keys, "、")}`;
      case "invalid_key":
        return `${issue2.origin}内の無効なキー`;
      case "invalid_union":
        return "無効な入力";
      case "invalid_element":
        return `${issue2.origin}内の無効な値`;
      default:
        return `無効な入力`;
    }
  };
};
function ja_default() {
  return {
    localeError: error21()
  };
}

// node_modules/zod/v4/locales/ka.js
var parsedType5 = (data) => {
  const t63 = typeof data;
  switch (t63) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "რიცხვი";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "მასივი";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  const typeMap = {
    string: "სტრინგი",
    boolean: "ბულეანი",
    undefined: "undefined",
    bigint: "bigint",
    symbol: "symbol",
    function: "ფუნქცია"
  };
  return typeMap[t63] ?? t63;
};
var error22 = () => {
  const Sizable = {
    string: { unit: "სიმბოლო", verb: "უნდა შეიცავდეს" },
    file: { unit: "ბაიტი", verb: "უნდა შეიცავდეს" },
    array: { unit: "ელემენტი", verb: "უნდა შეიცავდეს" },
    set: { unit: "ელემენტი", verb: "უნდა შეიცავდეს" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "შეყვანა",
    email: "ელ-ფოსტის მისამართი",
    url: "URL",
    emoji: "ემოჯი",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "თარიღი-დრო",
    date: "თარიღი",
    time: "დრო",
    duration: "ხანგრძლივობა",
    ipv4: "IPv4 მისამართი",
    ipv6: "IPv6 მისამართი",
    cidrv4: "IPv4 დიაპაზონი",
    cidrv6: "IPv6 დიაპაზონი",
    base64: "base64-კოდირებული სტრინგი",
    base64url: "base64url-კოდირებული სტრინგი",
    json_string: "JSON სტრინგი",
    e164: "E.164 ნომერი",
    jwt: "JWT",
    template_literal: "შეყვანა"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `არასწორი შეყვანა: მოსალოდნელი ${issue2.expected}, მიღებული ${parsedType5(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `არასწორი შეყვანა: მოსალოდნელი ${stringifyPrimitive(issue2.values[0])}`;
        return `არასწორი ვარიანტი: მოსალოდნელია ერთ-ერთი ${joinValues(issue2.values, "|")}-დან`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ზედმეტად დიდი: მოსალოდნელი ${issue2.origin ?? "მნიშვნელობა"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `ზედმეტად დიდი: მოსალოდნელი ${issue2.origin ?? "მნიშვნელობა"} იყოს ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `ზედმეტად პატარა: მოსალოდნელი ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `ზედმეტად პატარა: მოსალოდნელი ${issue2.origin} იყოს ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `არასწორი სტრინგი: უნდა იწყებოდეს "${_issue.prefix}"-ით`;
        }
        if (_issue.format === "ends_with")
          return `არასწორი სტრინგი: უნდა მთავრდებოდეს "${_issue.suffix}"-ით`;
        if (_issue.format === "includes")
          return `არასწორი სტრინგი: უნდა შეიცავდეს "${_issue.includes}"-ს`;
        if (_issue.format === "regex")
          return `არასწორი სტრინგი: უნდა შეესაბამებოდეს შაბლონს ${_issue.pattern}`;
        return `არასწორი ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `არასწორი რიცხვი: უნდა იყოს ${issue2.divisor}-ის ჯერადი`;
      case "unrecognized_keys":
        return `უცნობი გასაღებ${issue2.keys.length > 1 ? "ები" : "ი"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `არასწორი გასაღები ${issue2.origin}-ში`;
      case "invalid_union":
        return "არასწორი შეყვანა";
      case "invalid_element":
        return `არასწორი მნიშვნელობა ${issue2.origin}-ში`;
      default:
        return `არასწორი შეყვანა`;
    }
  };
};
function ka_default() {
  return {
    localeError: error22()
  };
}

// node_modules/zod/v4/locales/km.js
var error23 = () => {
  const Sizable = {
    string: { unit: "តួអក្សរ", verb: "គួរមាន" },
    file: { unit: "បៃ", verb: "គួរមាន" },
    array: { unit: "ធាតុ", verb: "គួរមាន" },
    set: { unit: "ធាតុ", verb: "គួរមាន" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "មិនមែនជាលេខ (NaN)" : "លេខ";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "អារេ (Array)";
        }
        if (data === null) {
          return "គ្មានតម្លៃ (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "ទិន្នន័យបញ្ចូល",
    email: "អាសយដ្ឋានអ៊ីមែល",
    url: "URL",
    emoji: "សញ្ញាអារម្មណ៍",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "កាលបរិច្ឆេទ និងម៉ោង ISO",
    date: "កាលបរិច្ឆេទ ISO",
    time: "ម៉ោង ISO",
    duration: "រយៈពេល ISO",
    ipv4: "អាសយដ្ឋាន IPv4",
    ipv6: "អាសយដ្ឋាន IPv6",
    cidrv4: "ដែនអាសយដ្ឋាន IPv4",
    cidrv6: "ដែនអាសយដ្ឋាន IPv6",
    base64: "ខ្សែអក្សរអ៊ិកូដ base64",
    base64url: "ខ្សែអក្សរអ៊ិកូដ base64url",
    json_string: "ខ្សែអក្សរ JSON",
    e164: "លេខ E.164",
    jwt: "JWT",
    template_literal: "ទិន្នន័យបញ្ចូល"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${issue2.expected} ប៉ុន្តែទទួលបាន ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${stringifyPrimitive(issue2.values[0])}`;
        return `ជម្រើសមិនត្រឹមត្រូវ៖ ត្រូវជាមួយក្នុងចំណោម ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ធំពេក៖ ត្រូវការ ${issue2.origin ?? "តម្លៃ"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "ធាតុ"}`;
        return `ធំពេក៖ ត្រូវការ ${issue2.origin ?? "តម្លៃ"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `តូចពេក៖ ត្រូវការ ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `តូចពេក៖ ត្រូវការ ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវចាប់ផ្តើមដោយ "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវបញ្ចប់ដោយ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវមាន "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវតែផ្គូផ្គងនឹងទម្រង់ដែលបានកំណត់ ${_issue.pattern}`;
        return `មិនត្រឹមត្រូវ៖ ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `លេខមិនត្រឹមត្រូវ៖ ត្រូវតែជាពហុគុណនៃ ${issue2.divisor}`;
      case "unrecognized_keys":
        return `រកឃើញសោមិនស្គាល់៖ ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `សោមិនត្រឹមត្រូវនៅក្នុង ${issue2.origin}`;
      case "invalid_union":
        return `ទិន្នន័យមិនត្រឹមត្រូវ`;
      case "invalid_element":
        return `ទិន្នន័យមិនត្រឹមត្រូវនៅក្នុង ${issue2.origin}`;
      default:
        return `ទិន្នន័យមិនត្រឹមត្រូវ`;
    }
  };
};
function km_default() {
  return {
    localeError: error23()
  };
}

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}

// node_modules/zod/v4/locales/ko.js
var error24 = () => {
  const Sizable = {
    string: { unit: "문자", verb: "to have" },
    file: { unit: "바이트", verb: "to have" },
    array: { unit: "개", verb: "to have" },
    set: { unit: "개", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "입력",
    email: "이메일 주소",
    url: "URL",
    emoji: "이모지",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO 날짜시간",
    date: "ISO 날짜",
    time: "ISO 시간",
    duration: "ISO 기간",
    ipv4: "IPv4 주소",
    ipv6: "IPv6 주소",
    cidrv4: "IPv4 범위",
    cidrv6: "IPv6 범위",
    base64: "base64 인코딩 문자열",
    base64url: "base64url 인코딩 문자열",
    json_string: "JSON 문자열",
    e164: "E.164 번호",
    jwt: "JWT",
    template_literal: "입력"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `잘못된 입력: 예상 타입은 ${issue2.expected}, 받은 타입은 ${parsedType8(issue2.input)}입니다`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `잘못된 입력: 값은 ${stringifyPrimitive(issue2.values[0])} 이어야 합니다`;
        return `잘못된 옵션: ${joinValues(issue2.values, "또는 ")} 중 하나여야 합니다`;
      case "too_big": {
        const adj = issue2.inclusive ? "이하" : "미만";
        const suffix = adj === "미만" ? "이어야 합니다" : "여야 합니다";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "요소";
        if (sizing)
          return `${issue2.origin ?? "값"}이 너무 큽니다: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "값"}이 너무 큽니다: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "이상" : "초과";
        const suffix = adj === "이상" ? "이어야 합니다" : "여야 합니다";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "요소";
        if (sizing) {
          return `${issue2.origin ?? "값"}이 너무 작습니다: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "값"}이 너무 작습니다: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `잘못된 문자열: "${_issue.prefix}"(으)로 시작해야 합니다`;
        }
        if (_issue.format === "ends_with")
          return `잘못된 문자열: "${_issue.suffix}"(으)로 끝나야 합니다`;
        if (_issue.format === "includes")
          return `잘못된 문자열: "${_issue.includes}"을(를) 포함해야 합니다`;
        if (_issue.format === "regex")
          return `잘못된 문자열: 정규식 ${_issue.pattern} 패턴과 일치해야 합니다`;
        return `잘못된 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `잘못된 숫자: ${issue2.divisor}의 배수여야 합니다`;
      case "unrecognized_keys":
        return `인식할 수 없는 키: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `잘못된 키: ${issue2.origin}`;
      case "invalid_union":
        return `잘못된 입력`;
      case "invalid_element":
        return `잘못된 값: ${issue2.origin}`;
      default:
        return `잘못된 입력`;
    }
  };
};
function ko_default() {
  return {
    localeError: error24()
  };
}

// node_modules/zod/v4/locales/lt.js
var parsedType6 = (data) => {
  const t63 = typeof data;
  return parsedTypeFromType(t63, data);
};
var parsedTypeFromType = (t63, data = void 0) => {
  switch (t63) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "skaičius";
    }
    case "bigint": {
      return "sveikasis skaičius";
    }
    case "string": {
      return "eilutė";
    }
    case "boolean": {
      return "loginė reikšmė";
    }
    case "undefined":
    case "void": {
      return "neapibrėžta reikšmė";
    }
    case "function": {
      return "funkcija";
    }
    case "symbol": {
      return "simbolis";
    }
    case "object": {
      if (data === void 0)
        return "nežinomas objektas";
      if (data === null)
        return "nulinė reikšmė";
      if (Array.isArray(data))
        return "masyvas";
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
      return "objektas";
    }
    //Zod types below
    case "null": {
      return "nulinė reikšmė";
    }
  }
  return t63;
};
var capitalizeFirstCharacter = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber(number4) {
  const abs = Math.abs(number4);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
var error25 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simbolių"
      },
      verb: {
        smaller: {
          inclusive: "turi būti ne ilgesnė kaip",
          notInclusive: "turi būti trumpesnė kaip"
        },
        bigger: {
          inclusive: "turi būti ne trumpesnė kaip",
          notInclusive: "turi būti ilgesnė kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "baitų"
      },
      verb: {
        smaller: {
          inclusive: "turi būti ne didesnis kaip",
          notInclusive: "turi būti mažesnis kaip"
        },
        bigger: {
          inclusive: "turi būti ne mažesnis kaip",
          notInclusive: "turi būti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "elementą",
        few: "elementus",
        many: "elementų"
      },
      verb: {
        smaller: {
          inclusive: "turi turėti ne daugiau kaip",
          notInclusive: "turi turėti mažiau kaip"
        },
        bigger: {
          inclusive: "turi turėti ne mažiau kaip",
          notInclusive: "turi turėti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "elementą",
        few: "elementus",
        many: "elementų"
      },
      verb: {
        smaller: {
          inclusive: "turi turėti ne daugiau kaip",
          notInclusive: "turi turėti mažiau kaip"
        },
        bigger: {
          inclusive: "turi turėti ne mažiau kaip",
          notInclusive: "turi turėti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const Nouns = {
    regex: "įvestis",
    email: "el. pašto adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukmė",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 užkoduota eilutė",
    base64url: "base64url užkoduota eilutė",
    json_string: "JSON eilutė",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "įvestis"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Gautas tipas ${parsedType6(issue2.input)}, o tikėtasi - ${parsedTypeFromType(issue2.expected)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo būti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo būti vienas iš ${joinValues(issue2.values, "|")} pasirinkimų`;
      case "too_big": {
        const origin = parsedTypeFromType(issue2.origin);
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikšmė")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "elementų"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "mažesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikšmė")} turi būti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = parsedTypeFromType(issue2.origin);
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikšmė")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "elementų"}`;
        const adj = issue2.inclusive ? "ne mažesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikšmė")} turi būti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilutė privalo prasidėti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilutė privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilutė privalo įtraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilutė privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skaičius privalo būti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpažint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga įvestis";
      case "invalid_element": {
        const origin = parsedTypeFromType(issue2.origin);
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikšmė")} turi klaidingą įvestį`;
      }
      default:
        return "Klaidinga įvestis";
    }
  };
};
function lt_default() {
  return {
    localeError: error25()
  };
}

// node_modules/zod/v4/locales/mk.js
var error26 = () => {
  const Sizable = {
    string: { unit: "знаци", verb: "да имаат" },
    file: { unit: "бајти", verb: "да имаат" },
    array: { unit: "ставки", verb: "да имаат" },
    set: { unit: "ставки", verb: "да имаат" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "број";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "низа";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "внес",
    email: "адреса на е-пошта",
    url: "URL",
    emoji: "емоџи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO датум и време",
    date: "ISO датум",
    time: "ISO време",
    duration: "ISO времетраење",
    ipv4: "IPv4 адреса",
    ipv6: "IPv6 адреса",
    cidrv4: "IPv4 опсег",
    cidrv6: "IPv6 опсег",
    base64: "base64-енкодирана низа",
    base64url: "base64url-енкодирана низа",
    json_string: "JSON низа",
    e164: "E.164 број",
    jwt: "JWT",
    template_literal: "внес"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Грешен внес: се очекува ${issue2.expected}, примено ${parsedType8(issue2.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Грешана опција: се очекува една ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Премногу голем: се очекува ${issue2.origin ?? "вредноста"} да има ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "елементи"}`;
        return `Премногу голем: се очекува ${issue2.origin ?? "вредноста"} да биде ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Премногу мал: се очекува ${issue2.origin} да има ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Премногу мал: се очекува ${issue2.origin} да биде ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Неважечка низа: мора да започнува со "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Неважечка низа: мора да завршува со "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Неважечка низа: мора да вклучува "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Неважечка низа: мора да одгоара на патернот ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Грешен број: мора да биде делив со ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Непрепознаени клучеви" : "Непрепознаен клуч"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Грешен клуч во ${issue2.origin}`;
      case "invalid_union":
        return "Грешен внес";
      case "invalid_element":
        return `Грешна вредност во ${issue2.origin}`;
      default:
        return `Грешен внес`;
    }
  };
};
function mk_default() {
  return {
    localeError: error26()
  };
}

// node_modules/zod/v4/locales/ms.js
var error27 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error27()
  };
}

// node_modules/zod/v4/locales/nl.js
var error28 = () => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht één van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error28()
  };
}

// node_modules/zod/v4/locales/no.js
var error29 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "å ha" },
    file: { unit: "bytes", verb: "å ha" },
    array: { unit: "elementer", verb: "å inneholde" },
    set: { unit: "elementer", verb: "å inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-område",
    ipv6: "IPv6-område",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til å ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til å ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til å ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til å ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: må starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: må ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: må inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: må matche mønsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: må være et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente nøkler" : "Ukjent nøkkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nøkkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error29()
  };
}

// node_modules/zod/v4/locales/ota.js
var error30 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmalıdır" },
    file: { unit: "bayt", verb: "olmalıdır" },
    array: { unit: "unsur", verb: "olmalıdır" },
    set: { unit: "unsur", verb: "olmalıdır" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "giren",
    email: "epostagâh",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengâmı",
    date: "ISO tarihi",
    time: "ISO zamanı",
    duration: "ISO müddeti",
    ipv4: "IPv4 nişânı",
    ipv6: "IPv6 nişânı",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-şifreli metin",
    base64url: "base64url-şifreli metin",
    json_string: "JSON metin",
    e164: "E.164 sayısı",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Fâsit giren: umulan ${issue2.expected}, alınan ${parsedType8(issue2.input)}`;
      // return `Fâsit giren: umulan ${issue.expected}, alınan ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Fâsit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `Fâsit tercih: mûteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla büyük: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalıydı.`;
        return `Fazla büyük: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmalıydı.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla küçük: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmalıydı.`;
        }
        return `Fazla küçük: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmalıydı.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Fâsit metin: "${_issue.prefix}" ile başlamalı.`;
        if (_issue.format === "ends_with")
          return `Fâsit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `Fâsit metin: "${_issue.includes}" ihtivâ etmeli.`;
        if (_issue.format === "regex")
          return `Fâsit metin: ${_issue.pattern} nakşına uymalı.`;
        return `Fâsit ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Fâsit sayı: ${issue2.divisor} katı olmalıydı.`;
      case "unrecognized_keys":
        return `Tanınmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} için tanınmayan anahtar var.`;
      case "invalid_union":
        return "Giren tanınamadı.";
      case "invalid_element":
        return `${issue2.origin} için tanınmayan kıymet var.`;
      default:
        return `Kıymet tanınamadı.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error30()
  };
}

// node_modules/zod/v4/locales/ps.js
var error31 = () => {
  const Sizable = {
    string: { unit: "توکي", verb: "ولري" },
    file: { unit: "بایټس", verb: "ولري" },
    array: { unit: "توکي", verb: "ولري" },
    set: { unit: "توکي", verb: "ولري" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "عدد";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "ارې";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "ورودي",
    email: "بریښنالیک",
    url: "یو آر ال",
    emoji: "ایموجي",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "نیټه او وخت",
    date: "نېټه",
    time: "وخت",
    duration: "موده",
    ipv4: "د IPv4 پته",
    ipv6: "د IPv6 پته",
    cidrv4: "د IPv4 ساحه",
    cidrv6: "د IPv6 ساحه",
    base64: "base64-encoded متن",
    base64url: "base64url-encoded متن",
    json_string: "JSON متن",
    e164: "د E.164 شمېره",
    jwt: "JWT",
    template_literal: "ورودي"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `ناسم ورودي: باید ${issue2.expected} وای, مګر ${parsedType8(issue2.input)} ترلاسه شو`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `ناسم ورودي: باید ${stringifyPrimitive(issue2.values[0])} وای`;
        }
        return `ناسم انتخاب: باید یو له ${joinValues(issue2.values, "|")} څخه وای`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `ډیر لوی: ${issue2.origin ?? "ارزښت"} باید ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "عنصرونه"} ولري`;
        }
        return `ډیر لوی: ${issue2.origin ?? "ارزښت"} باید ${adj}${issue2.maximum.toString()} وي`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `ډیر کوچنی: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} ${sizing.unit} ولري`;
        }
        return `ډیر کوچنی: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} وي`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `ناسم متن: باید د "${_issue.prefix}" سره پیل شي`;
        }
        if (_issue.format === "ends_with") {
          return `ناسم متن: باید د "${_issue.suffix}" سره پای ته ورسيږي`;
        }
        if (_issue.format === "includes") {
          return `ناسم متن: باید "${_issue.includes}" ولري`;
        }
        if (_issue.format === "regex") {
          return `ناسم متن: باید د ${_issue.pattern} سره مطابقت ولري`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} ناسم دی`;
      }
      case "not_multiple_of":
        return `ناسم عدد: باید د ${issue2.divisor} مضرب وي`;
      case "unrecognized_keys":
        return `ناسم ${issue2.keys.length > 1 ? "کلیډونه" : "کلیډ"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `ناسم کلیډ په ${issue2.origin} کې`;
      case "invalid_union":
        return `ناسمه ورودي`;
      case "invalid_element":
        return `ناسم عنصر په ${issue2.origin} کې`;
      default:
        return `ناسمه ورودي`;
    }
  };
};
function ps_default() {
  return {
    localeError: error31()
  };
}

// node_modules/zod/v4/locales/pl.js
var error32 = () => {
  const Sizable = {
    string: { unit: "znaków", verb: "mieć" },
    file: { unit: "bajtów", verb: "mieć" },
    array: { unit: "elementów", verb: "mieć" },
    set: { unit: "elementów", verb: "mieć" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "wyrażenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ciąg znaków zakodowany w formacie base64",
    base64url: "ciąg znaków zakodowany w formacie base64url",
    json_string: "ciąg znaków w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejście"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nieprawidłowe dane wejściowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawidłowe dane wejściowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawidłowa opcja: oczekiwano jednej z wartości ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za duża wartość: oczekiwano, że ${issue2.origin ?? "wartość"} będzie mieć ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementów"}`;
        }
        return `Zbyt duż(y/a/e): oczekiwano, że ${issue2.origin ?? "wartość"} będzie wynosić ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za mała wartość: oczekiwano, że ${issue2.origin ?? "wartość"} będzie mieć ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "elementów"}`;
        }
        return `Zbyt mał(y/a/e): oczekiwano, że ${issue2.origin ?? "wartość"} będzie wynosić ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawidłowy ciąg znaków: musi zaczynać się od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawidłowy ciąg znaków: musi kończyć się na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawidłowy ciąg znaków: musi zawierać "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawidłowy ciąg znaków: musi odpowiadać wzorcowi ${_issue.pattern}`;
        return `Nieprawidłow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidłowa liczba: musi być wielokrotnością ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidłowy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawidłowe dane wejściowe";
      case "invalid_element":
        return `Nieprawidłowa wartość w ${issue2.origin}`;
      default:
        return `Nieprawidłowe dane wejściowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error32()
  };
}

// node_modules/zod/v4/locales/pt.js
var error33 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "número";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "padrão",
    email: "endereço de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "duração ISO",
    ipv4: "endereço IPv4",
    ipv6: "endereço IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipo inválido: esperado ${issue2.expected}, recebido ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inválida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Opção inválida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inválido: deve começar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inválido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inválido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inválido: deve corresponder ao padrão ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} inválido`;
      }
      case "not_multiple_of":
        return `Número inválido: deve ser múltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inválida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inválida";
      case "invalid_element":
        return `Valor inválido em ${issue2.origin}`;
      default:
        return `Campo inválido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error33()
  };
}

// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error34 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "символ",
        few: "символа",
        many: "символов"
      },
      verb: "иметь"
    },
    file: {
      unit: {
        one: "байт",
        few: "байта",
        many: "байт"
      },
      verb: "иметь"
    },
    array: {
      unit: {
        one: "элемент",
        few: "элемента",
        many: "элементов"
      },
      verb: "иметь"
    },
    set: {
      unit: {
        one: "элемент",
        few: "элемента",
        many: "элементов"
      },
      verb: "иметь"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "число";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "массив";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "ввод",
    email: "email адрес",
    url: "URL",
    emoji: "эмодзи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO дата и время",
    date: "ISO дата",
    time: "ISO время",
    duration: "ISO длительность",
    ipv4: "IPv4 адрес",
    ipv6: "IPv6 адрес",
    cidrv4: "IPv4 диапазон",
    cidrv6: "IPv6 диапазон",
    base64: "строка в формате base64",
    base64url: "строка в формате base64url",
    json_string: "JSON строка",
    e164: "номер E.164",
    jwt: "JWT",
    template_literal: "ввод"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Неверный ввод: ожидалось ${issue2.expected}, получено ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Неверный ввод: ожидалось ${stringifyPrimitive(issue2.values[0])}`;
        return `Неверный вариант: ожидалось одно из ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Слишком большое значение: ожидалось, что ${issue2.origin ?? "значение"} будет иметь ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `Слишком большое значение: ожидалось, что ${issue2.origin ?? "значение"} будет ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Слишком маленькое значение: ожидалось, что ${issue2.origin} будет иметь ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `Слишком маленькое значение: ожидалось, что ${issue2.origin} будет ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Неверная строка: должна начинаться с "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Неверная строка: должна заканчиваться на "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Неверная строка: должна содержать "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Неверная строка: должна соответствовать шаблону ${_issue.pattern}`;
        return `Неверный ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Неверное число: должно быть кратным ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Нераспознанн${issue2.keys.length > 1 ? "ые" : "ый"} ключ${issue2.keys.length > 1 ? "и" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Неверный ключ в ${issue2.origin}`;
      case "invalid_union":
        return "Неверные входные данные";
      case "invalid_element":
        return `Неверное значение в ${issue2.origin}`;
      default:
        return `Неверные входные данные`;
    }
  };
};
function ru_default() {
  return {
    localeError: error34()
  };
}

// node_modules/zod/v4/locales/sl.js
var error35 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "število";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-poštni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in čas",
    date: "ISO datum",
    time: "ISO čas",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 številka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neveljaven vnos: pričakovano ${issue2.expected}, prejeto ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pričakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna možnost: pričakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pričakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pričakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pričakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pričakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se začeti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se končati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno število: mora biti večkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i ključi" : " ključ"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven ključ v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error35()
  };
}

// node_modules/zod/v4/locales/sv.js
var error36 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehålla" },
    set: { unit: "objekt", verb: "att innehålla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "reguljärt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad sträng",
    base64url: "base64url-kodad sträng",
    json_string: "JSON-sträng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ogiltig inmatning: förväntat ${issue2.expected}, fick ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: förväntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: förväntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `För stor(t): förväntade ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `För stor(t): förväntat ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `För lite(t): förväntade ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `För lite(t): förväntade ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig sträng: måste börja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig sträng: måste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig sträng: måste innehålla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig sträng: måste matcha mönstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: måste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Okända nycklar" : "Okänd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "värdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt värde i ${issue2.origin ?? "värdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error36()
  };
}

// node_modules/zod/v4/locales/ta.js
var error37 = () => {
  const Sizable = {
    string: { unit: "எழுத்துக்கள்", verb: "கொண்டிருக்க வேண்டும்" },
    file: { unit: "பைட்டுகள்", verb: "கொண்டிருக்க வேண்டும்" },
    array: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" },
    set: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "எண் அல்லாதது" : "எண்";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "அணி";
        }
        if (data === null) {
          return "வெறுமை";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "உள்ளீடு",
    email: "மின்னஞ்சல் முகவரி",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO தேதி நேரம்",
    date: "ISO தேதி",
    time: "ISO நேரம்",
    duration: "ISO கால அளவு",
    ipv4: "IPv4 முகவரி",
    ipv6: "IPv6 முகவரி",
    cidrv4: "IPv4 வரம்பு",
    cidrv6: "IPv6 வரம்பு",
    base64: "base64-encoded சரம்",
    base64url: "base64url-encoded சரம்",
    json_string: "JSON சரம்",
    e164: "E.164 எண்",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${issue2.expected}, பெறப்பட்டது ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${stringifyPrimitive(issue2.values[0])}`;
        return `தவறான விருப்பம்: எதிர்பார்க்கப்பட்டது ${joinValues(issue2.values, "|")} இல் ஒன்று`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${issue2.origin ?? "மதிப்பு"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "உறுப்புகள்"} ஆக இருக்க வேண்டும்`;
        }
        return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${issue2.origin ?? "மதிப்பு"} ${adj}${issue2.maximum.toString()} ஆக இருக்க வேண்டும்`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ஆக இருக்க வேண்டும்`;
        }
        return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${issue2.origin} ${adj}${issue2.minimum.toString()} ஆக இருக்க வேண்டும்`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `தவறான சரம்: "${_issue.prefix}" இல் தொடங்க வேண்டும்`;
        if (_issue.format === "ends_with")
          return `தவறான சரம்: "${_issue.suffix}" இல் முடிவடைய வேண்டும்`;
        if (_issue.format === "includes")
          return `தவறான சரம்: "${_issue.includes}" ஐ உள்ளடக்க வேண்டும்`;
        if (_issue.format === "regex")
          return `தவறான சரம்: ${_issue.pattern} முறைபாட்டுடன் பொருந்த வேண்டும்`;
        return `தவறான ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `தவறான எண்: ${issue2.divisor} இன் பலமாக இருக்க வேண்டும்`;
      case "unrecognized_keys":
        return `அடையாளம் தெரியாத விசை${issue2.keys.length > 1 ? "கள்" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} இல் தவறான விசை`;
      case "invalid_union":
        return "தவறான உள்ளீடு";
      case "invalid_element":
        return `${issue2.origin} இல் தவறான மதிப்பு`;
      default:
        return `தவறான உள்ளீடு`;
    }
  };
};
function ta_default() {
  return {
    localeError: error37()
  };
}

// node_modules/zod/v4/locales/th.js
var error38 = () => {
  const Sizable = {
    string: { unit: "ตัวอักษร", verb: "ควรมี" },
    file: { unit: "ไบต์", verb: "ควรมี" },
    array: { unit: "รายการ", verb: "ควรมี" },
    set: { unit: "รายการ", verb: "ควรมี" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "ไม่ใช่ตัวเลข (NaN)" : "ตัวเลข";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "อาร์เรย์ (Array)";
        }
        if (data === null) {
          return "ไม่มีค่า (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "ข้อมูลที่ป้อน",
    email: "ที่อยู่อีเมล",
    url: "URL",
    emoji: "อิโมจิ",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "วันที่เวลาแบบ ISO",
    date: "วันที่แบบ ISO",
    time: "เวลาแบบ ISO",
    duration: "ช่วงเวลาแบบ ISO",
    ipv4: "ที่อยู่ IPv4",
    ipv6: "ที่อยู่ IPv6",
    cidrv4: "ช่วง IP แบบ IPv4",
    cidrv6: "ช่วง IP แบบ IPv6",
    base64: "ข้อความแบบ Base64",
    base64url: "ข้อความแบบ Base64 สำหรับ URL",
    json_string: "ข้อความแบบ JSON",
    e164: "เบอร์โทรศัพท์ระหว่างประเทศ (E.164)",
    jwt: "โทเคน JWT",
    template_literal: "ข้อมูลที่ป้อน"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `ประเภทข้อมูลไม่ถูกต้อง: ควรเป็น ${issue2.expected} แต่ได้รับ ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `ค่าไม่ถูกต้อง: ควรเป็น ${stringifyPrimitive(issue2.values[0])}`;
        return `ตัวเลือกไม่ถูกต้อง: ควรเป็นหนึ่งใน ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "ไม่เกิน" : "น้อยกว่า";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `เกินกำหนด: ${issue2.origin ?? "ค่า"} ควรมี${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "รายการ"}`;
        return `เกินกำหนด: ${issue2.origin ?? "ค่า"} ควรมี${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "อย่างน้อย" : "มากกว่า";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `น้อยกว่ากำหนด: ${issue2.origin} ควรมี${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `น้อยกว่ากำหนด: ${issue2.origin} ควรมี${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `รูปแบบไม่ถูกต้อง: ข้อความต้องขึ้นต้นด้วย "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `รูปแบบไม่ถูกต้อง: ข้อความต้องลงท้ายด้วย "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `รูปแบบไม่ถูกต้อง: ข้อความต้องมี "${_issue.includes}" อยู่ในข้อความ`;
        if (_issue.format === "regex")
          return `รูปแบบไม่ถูกต้อง: ต้องตรงกับรูปแบบที่กำหนด ${_issue.pattern}`;
        return `รูปแบบไม่ถูกต้อง: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `ตัวเลขไม่ถูกต้อง: ต้องเป็นจำนวนที่หารด้วย ${issue2.divisor} ได้ลงตัว`;
      case "unrecognized_keys":
        return `พบคีย์ที่ไม่รู้จัก: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `คีย์ไม่ถูกต้องใน ${issue2.origin}`;
      case "invalid_union":
        return "ข้อมูลไม่ถูกต้อง: ไม่ตรงกับรูปแบบยูเนียนที่กำหนดไว้";
      case "invalid_element":
        return `ข้อมูลไม่ถูกต้องใน ${issue2.origin}`;
      default:
        return `ข้อมูลไม่ถูกต้อง`;
    }
  };
};
function th_default() {
  return {
    localeError: error38()
  };
}

// node_modules/zod/v4/locales/tr.js
var parsedType7 = (data) => {
  const t63 = typeof data;
  switch (t63) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t63;
};
var error39 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmalı" },
    file: { unit: "bayt", verb: "olmalı" },
    array: { unit: "öğe", verb: "olmalı" },
    set: { unit: "öğe", verb: "olmalı" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO süre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aralığı",
    cidrv6: "IPv6 aralığı",
    base64: "base64 ile şifrelenmiş metin",
    base64url: "base64url ile şifrelenmiş metin",
    json_string: "JSON dizesi",
    e164: "E.164 sayısı",
    jwt: "JWT",
    template_literal: "Şablon dizesi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Geçersiz değer: beklenen ${issue2.expected}, alınan ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Geçersiz değer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Geçersiz seçenek: aşağıdakilerden biri olmalı: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çok büyük: beklenen ${issue2.origin ?? "değer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "öğe"}`;
        return `Çok büyük: beklenen ${issue2.origin ?? "değer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çok küçük: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Çok küçük: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Geçersiz metin: "${_issue.prefix}" ile başlamalı`;
        if (_issue.format === "ends_with")
          return `Geçersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Geçersiz metin: "${_issue.includes}" içermeli`;
        if (_issue.format === "regex")
          return `Geçersiz metin: ${_issue.pattern} desenine uymalı`;
        return `Geçersiz ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Geçersiz sayı: ${issue2.divisor} ile tam bölünebilmeli`;
      case "unrecognized_keys":
        return `Tanınmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} içinde geçersiz anahtar`;
      case "invalid_union":
        return "Geçersiz değer";
      case "invalid_element":
        return `${issue2.origin} içinde geçersiz değer`;
      default:
        return `Geçersiz değer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error39()
  };
}

// node_modules/zod/v4/locales/uk.js
var error40 = () => {
  const Sizable = {
    string: { unit: "символів", verb: "матиме" },
    file: { unit: "байтів", verb: "матиме" },
    array: { unit: "елементів", verb: "матиме" },
    set: { unit: "елементів", verb: "матиме" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "число";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "масив";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "вхідні дані",
    email: "адреса електронної пошти",
    url: "URL",
    emoji: "емодзі",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "дата та час ISO",
    date: "дата ISO",
    time: "час ISO",
    duration: "тривалість ISO",
    ipv4: "адреса IPv4",
    ipv6: "адреса IPv6",
    cidrv4: "діапазон IPv4",
    cidrv6: "діапазон IPv6",
    base64: "рядок у кодуванні base64",
    base64url: "рядок у кодуванні base64url",
    json_string: "рядок JSON",
    e164: "номер E.164",
    jwt: "JWT",
    template_literal: "вхідні дані"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Неправильні вхідні дані: очікується ${issue2.expected}, отримано ${parsedType8(issue2.input)}`;
      // return `Неправильні вхідні дані: очікується ${issue.expected}, отримано ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Неправильні вхідні дані: очікується ${stringifyPrimitive(issue2.values[0])}`;
        return `Неправильна опція: очікується одне з ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Занадто велике: очікується, що ${issue2.origin ?? "значення"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "елементів"}`;
        return `Занадто велике: очікується, що ${issue2.origin ?? "значення"} буде ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Занадто мале: очікується, що ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Занадто мале: очікується, що ${issue2.origin} буде ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Неправильний рядок: повинен починатися з "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Неправильний рядок: повинен закінчуватися на "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Неправильний рядок: повинен містити "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Неправильний рядок: повинен відповідати шаблону ${_issue.pattern}`;
        return `Неправильний ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Неправильне число: повинно бути кратним ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Нерозпізнаний ключ${issue2.keys.length > 1 ? "і" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Неправильний ключ у ${issue2.origin}`;
      case "invalid_union":
        return "Неправильні вхідні дані";
      case "invalid_element":
        return `Неправильне значення у ${issue2.origin}`;
      default:
        return `Неправильні вхідні дані`;
    }
  };
};
function uk_default() {
  return {
    localeError: error40()
  };
}

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}

// node_modules/zod/v4/locales/ur.js
var error41 = () => {
  const Sizable = {
    string: { unit: "حروف", verb: "ہونا" },
    file: { unit: "بائٹس", verb: "ہونا" },
    array: { unit: "آئٹمز", verb: "ہونا" },
    set: { unit: "آئٹمز", verb: "ہونا" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "نمبر";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "آرے";
        }
        if (data === null) {
          return "نل";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "ان پٹ",
    email: "ای میل ایڈریس",
    url: "یو آر ایل",
    emoji: "ایموجی",
    uuid: "یو یو آئی ڈی",
    uuidv4: "یو یو آئی ڈی وی 4",
    uuidv6: "یو یو آئی ڈی وی 6",
    nanoid: "نینو آئی ڈی",
    guid: "جی یو آئی ڈی",
    cuid: "سی یو آئی ڈی",
    cuid2: "سی یو آئی ڈی 2",
    ulid: "یو ایل آئی ڈی",
    xid: "ایکس آئی ڈی",
    ksuid: "کے ایس یو آئی ڈی",
    datetime: "آئی ایس او ڈیٹ ٹائم",
    date: "آئی ایس او تاریخ",
    time: "آئی ایس او وقت",
    duration: "آئی ایس او مدت",
    ipv4: "آئی پی وی 4 ایڈریس",
    ipv6: "آئی پی وی 6 ایڈریس",
    cidrv4: "آئی پی وی 4 رینج",
    cidrv6: "آئی پی وی 6 رینج",
    base64: "بیس 64 ان کوڈڈ سٹرنگ",
    base64url: "بیس 64 یو آر ایل ان کوڈڈ سٹرنگ",
    json_string: "جے ایس او این سٹرنگ",
    e164: "ای 164 نمبر",
    jwt: "جے ڈبلیو ٹی",
    template_literal: "ان پٹ"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `غلط ان پٹ: ${issue2.expected} متوقع تھا، ${parsedType8(issue2.input)} موصول ہوا`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `غلط ان پٹ: ${stringifyPrimitive(issue2.values[0])} متوقع تھا`;
        return `غلط آپشن: ${joinValues(issue2.values, "|")} میں سے ایک متوقع تھا`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `بہت بڑا: ${issue2.origin ?? "ویلیو"} کے ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "عناصر"} ہونے متوقع تھے`;
        return `بہت بڑا: ${issue2.origin ?? "ویلیو"} کا ${adj}${issue2.maximum.toString()} ہونا متوقع تھا`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `بہت چھوٹا: ${issue2.origin} کے ${adj}${issue2.minimum.toString()} ${sizing.unit} ہونے متوقع تھے`;
        }
        return `بہت چھوٹا: ${issue2.origin} کا ${adj}${issue2.minimum.toString()} ہونا متوقع تھا`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `غلط سٹرنگ: "${_issue.prefix}" سے شروع ہونا چاہیے`;
        }
        if (_issue.format === "ends_with")
          return `غلط سٹرنگ: "${_issue.suffix}" پر ختم ہونا چاہیے`;
        if (_issue.format === "includes")
          return `غلط سٹرنگ: "${_issue.includes}" شامل ہونا چاہیے`;
        if (_issue.format === "regex")
          return `غلط سٹرنگ: پیٹرن ${_issue.pattern} سے میچ ہونا چاہیے`;
        return `غلط ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `غلط نمبر: ${issue2.divisor} کا مضاعف ہونا چاہیے`;
      case "unrecognized_keys":
        return `غیر تسلیم شدہ کی${issue2.keys.length > 1 ? "ز" : ""}: ${joinValues(issue2.keys, "، ")}`;
      case "invalid_key":
        return `${issue2.origin} میں غلط کی`;
      case "invalid_union":
        return "غلط ان پٹ";
      case "invalid_element":
        return `${issue2.origin} میں غلط ویلیو`;
      default:
        return `غلط ان پٹ`;
    }
  };
};
function ur_default() {
  return {
    localeError: error41()
  };
}

// node_modules/zod/v4/locales/vi.js
var error42 = () => {
  const Sizable = {
    string: { unit: "ký tự", verb: "có" },
    file: { unit: "byte", verb: "có" },
    array: { unit: "phần tử", verb: "có" },
    set: { unit: "phần tử", verb: "có" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "số";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "mảng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "đầu vào",
    email: "địa chỉ email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngày giờ ISO",
    date: "ngày ISO",
    time: "giờ ISO",
    duration: "khoảng thời gian ISO",
    ipv4: "địa chỉ IPv4",
    ipv6: "địa chỉ IPv6",
    cidrv4: "dải IPv4",
    cidrv6: "dải IPv6",
    base64: "chuỗi mã hóa base64",
    base64url: "chuỗi mã hóa base64url",
    json_string: "chuỗi JSON",
    e164: "số E.164",
    jwt: "JWT",
    template_literal: "đầu vào"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Đầu vào không hợp lệ: mong đợi ${issue2.expected}, nhận được ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Đầu vào không hợp lệ: mong đợi ${stringifyPrimitive(issue2.values[0])}`;
        return `Tùy chọn không hợp lệ: mong đợi một trong các giá trị ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Quá lớn: mong đợi ${issue2.origin ?? "giá trị"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "phần tử"}`;
        return `Quá lớn: mong đợi ${issue2.origin ?? "giá trị"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Quá nhỏ: mong đợi ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Quá nhỏ: mong đợi ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chuỗi không hợp lệ: phải bắt đầu bằng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chuỗi không hợp lệ: phải kết thúc bằng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chuỗi không hợp lệ: phải bao gồm "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chuỗi không hợp lệ: phải khớp với mẫu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} không hợp lệ`;
      }
      case "not_multiple_of":
        return `Số không hợp lệ: phải là bội số của ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Khóa không được nhận dạng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Khóa không hợp lệ trong ${issue2.origin}`;
      case "invalid_union":
        return "Đầu vào không hợp lệ";
      case "invalid_element":
        return `Giá trị không hợp lệ trong ${issue2.origin}`;
      default:
        return `Đầu vào không hợp lệ`;
    }
  };
};
function vi_default() {
  return {
    localeError: error42()
  };
}

// node_modules/zod/v4/locales/zh-CN.js
var error43 = () => {
  const Sizable = {
    string: { unit: "字符", verb: "包含" },
    file: { unit: "字节", verb: "包含" },
    array: { unit: "项", verb: "包含" },
    set: { unit: "项", verb: "包含" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "非数字(NaN)" : "数字";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "数组";
        }
        if (data === null) {
          return "空值(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "输入",
    email: "电子邮件",
    url: "URL",
    emoji: "表情符号",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO日期时间",
    date: "ISO日期",
    time: "ISO时间",
    duration: "ISO时长",
    ipv4: "IPv4地址",
    ipv6: "IPv6地址",
    cidrv4: "IPv4网段",
    cidrv6: "IPv6网段",
    base64: "base64编码字符串",
    base64url: "base64url编码字符串",
    json_string: "JSON字符串",
    e164: "E.164号码",
    jwt: "JWT",
    template_literal: "输入"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `无效输入：期望 ${issue2.expected}，实际接收 ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `无效输入：期望 ${stringifyPrimitive(issue2.values[0])}`;
        return `无效选项：期望以下之一 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `数值过大：期望 ${issue2.origin ?? "值"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "个元素"}`;
        return `数值过大：期望 ${issue2.origin ?? "值"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `数值过小：期望 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `数值过小：期望 ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `无效字符串：必须以 "${_issue.prefix}" 开头`;
        if (_issue.format === "ends_with")
          return `无效字符串：必须以 "${_issue.suffix}" 结尾`;
        if (_issue.format === "includes")
          return `无效字符串：必须包含 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `无效字符串：必须满足正则表达式 ${_issue.pattern}`;
        return `无效${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `无效数字：必须是 ${issue2.divisor} 的倍数`;
      case "unrecognized_keys":
        return `出现未知的键(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} 中的键(key)无效`;
      case "invalid_union":
        return "无效输入";
      case "invalid_element":
        return `${issue2.origin} 中包含无效值(value)`;
      default:
        return `无效输入`;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error43()
  };
}

// node_modules/zod/v4/locales/zh-TW.js
var error44 = () => {
  const Sizable = {
    string: { unit: "字元", verb: "擁有" },
    file: { unit: "位元組", verb: "擁有" },
    array: { unit: "項目", verb: "擁有" },
    set: { unit: "項目", verb: "擁有" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "輸入",
    email: "郵件地址",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO 日期時間",
    date: "ISO 日期",
    time: "ISO 時間",
    duration: "ISO 期間",
    ipv4: "IPv4 位址",
    ipv6: "IPv6 位址",
    cidrv4: "IPv4 範圍",
    cidrv6: "IPv6 範圍",
    base64: "base64 編碼字串",
    base64url: "base64url 編碼字串",
    json_string: "JSON 字串",
    e164: "E.164 數值",
    jwt: "JWT",
    template_literal: "輸入"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `無效的輸入值：預期為 ${issue2.expected}，但收到 ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `無效的輸入值：預期為 ${stringifyPrimitive(issue2.values[0])}`;
        return `無效的選項：預期為以下其中之一 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `數值過大：預期 ${issue2.origin ?? "值"} 應為 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "個元素"}`;
        return `數值過大：預期 ${issue2.origin ?? "值"} 應為 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `數值過小：預期 ${issue2.origin} 應為 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `數值過小：預期 ${issue2.origin} 應為 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `無效的字串：必須以 "${_issue.prefix}" 開頭`;
        }
        if (_issue.format === "ends_with")
          return `無效的字串：必須以 "${_issue.suffix}" 結尾`;
        if (_issue.format === "includes")
          return `無效的字串：必須包含 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `無效的字串：必須符合格式 ${_issue.pattern}`;
        return `無效的 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `無效的數字：必須為 ${issue2.divisor} 的倍數`;
      case "unrecognized_keys":
        return `無法識別的鍵值${issue2.keys.length > 1 ? "們" : ""}：${joinValues(issue2.keys, "、")}`;
      case "invalid_key":
        return `${issue2.origin} 中有無效的鍵值`;
      case "invalid_union":
        return "無效的輸入值";
      case "invalid_element":
        return `${issue2.origin} 中有無效的值`;
      default:
        return `無效的輸入值`;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error44()
  };
}

// node_modules/zod/v4/locales/yo.js
var error45 = () => {
  const Sizable = {
    string: { unit: "àmi", verb: "ní" },
    file: { unit: "bytes", verb: "ní" },
    array: { unit: "nkan", verb: "ní" },
    set: { unit: "nkan", verb: "ní" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t63 = typeof data;
    switch (t63) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nọ́mbà";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "akopọ";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t63;
  };
  const Nouns = {
    regex: "ẹ̀rọ ìbáwọlé",
    email: "àdírẹ́sì ìmẹ́lì",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "àkókò ISO",
    date: "ọjọ́ ISO",
    time: "àkókò ISO",
    duration: "àkókò tó pé ISO",
    ipv4: "àdírẹ́sì IPv4",
    ipv6: "àdírẹ́sì IPv6",
    cidrv4: "àgbègbè IPv4",
    cidrv6: "àgbègbè IPv6",
    base64: "ọ̀rọ̀ tí a kọ́ ní base64",
    base64url: "ọ̀rọ̀ base64url",
    json_string: "ọ̀rọ̀ JSON",
    e164: "nọ́mbà E.164",
    jwt: "JWT",
    template_literal: "ẹ̀rọ ìbáwọlé"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ìbáwọlé aṣìṣe: a ní láti fi ${issue2.expected}, àmọ̀ a rí ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ìbáwọlé aṣìṣe: a ní láti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `Àṣàyàn aṣìṣe: yan ọ̀kan lára ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tó pọ̀ jù: a ní láti jẹ́ pé ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `Tó pọ̀ jù: a ní láti jẹ́ ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Kéré ju: a ní láti jẹ́ pé ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `Kéré ju: a ní láti jẹ́ ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ bẹ̀rẹ̀ pẹ̀lú "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ parí pẹ̀lú "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ ní "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ bá àpẹẹrẹ mu ${_issue.pattern}`;
        return `Aṣìṣe: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nọ́mbà aṣìṣe: gbọ́dọ̀ jẹ́ èyà pípín ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Bọtìnì àìmọ̀: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Bọtìnì aṣìṣe nínú ${issue2.origin}`;
      case "invalid_union":
        return "Ìbáwọlé aṣìṣe";
      case "invalid_element":
        return `Iye aṣìṣe nínú ${issue2.origin}`;
      default:
        return "Ìbáwọlé aṣìṣe";
    }
  };
};
function yo_default() {
  return {
    localeError: error45()
  };
}

// node_modules/zod/v4/core/registries.js
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm2 = { ...this.get(p) ?? {} };
      delete pm2.id;
      const f = { ...pm2, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
var globalRegistry = registry();

// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch2 = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch2;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx2) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx: tx2
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v3) => [v3, v3])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn2) {
  return new Class2({
    type: "transform",
    transform: fn2
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn2, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn: fn2,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn2, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn: fn2,
    ...normalizeParams(_params)
  });
  return schema;
}
function _superRefine(fn2) {
  const ch2 = _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch2._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch2);
        _issue.continue ?? (_issue.continue = !ch2._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn2(payload.value, payload);
  });
  return ch2;
}
function _check(fn2, params) {
  const ch2 = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch2._zod.check = fn2;
  return ch2;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v3) => typeof v3 === "string" ? v3.toLowerCase() : v3);
    falsyArray = falsyArray.map((v3) => typeof v3 === "string" ? v3.toLowerCase() : v3);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: ((input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    }),
    reverseTransform: ((input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    }),
    error: params.error
  });
  return codec2;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}

// node_modules/zod/v4/core/to-json-schema.js
var JSONSchemaGenerator = class {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {
    });
    this.io = params?.io ?? "output";
    this.seen = /* @__PURE__ */ new Map();
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a2;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json2 = _json;
            json2.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minLength = minimum;
            if (typeof maximum === "number")
              json2.maxLength = maximum;
            if (format) {
              json2.format = formatMap[format] ?? format;
              if (json2.format === "")
                delete json2.format;
            }
            if (contentEncoding)
              json2.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json2.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json2 = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json2.type = "integer";
            else
              json2.type = "number";
            if (typeof exclusiveMinimum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.minimum = exclusiveMinimum;
                json2.exclusiveMinimum = true;
              } else {
                json2.exclusiveMinimum = exclusiveMinimum;
              }
            }
            if (typeof minimum === "number") {
              json2.minimum = minimum;
              if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                if (exclusiveMinimum >= minimum)
                  delete json2.minimum;
                else
                  delete json2.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.maximum = exclusiveMaximum;
                json2.exclusiveMaximum = true;
              } else {
                json2.exclusiveMaximum = exclusiveMaximum;
              }
            }
            if (typeof maximum === "number") {
              json2.maximum = maximum;
              if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                if (exclusiveMaximum <= maximum)
                  delete json2.maximum;
                else
                  delete json2.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json2.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            if (this.target === "openapi-3.0") {
              _json.type = "string";
              _json.nullable = true;
              _json.enum = [null];
            } else
              _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json2 = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minItems = minimum;
            if (typeof maximum === "number")
              json2.maxItems = maximum;
            json2.type = "array";
            json2.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json2 = _json;
            json2.type = "object";
            json2.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json2.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v3 = def.shape[key]._zod;
              if (this.io === "input") {
                return v3.optin === void 0;
              } else {
                return v3.optout === void 0;
              }
            }));
            if (requiredKeys.size > 0) {
              json2.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json2.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json2.additionalProperties = false;
            } else if (def.catchall) {
              json2.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json2 = _json;
            const options = def.options.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, "anyOf", i]
            }));
            json2.anyOf = options;
            break;
          }
          case "intersection": {
            const json2 = _json;
            const a = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [a],
              ...isSimpleIntersection(b) ? b.allOf : [b]
            ];
            json2.allOf = allOf;
            break;
          }
          case "tuple": {
            const json2 = _json;
            json2.type = "array";
            const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
            const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
            const prefixItems = def.items.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, prefixPath, i]
            }));
            const rest = def.rest ? this.process(def.rest, {
              ...params,
              path: [...params.path, restPath, ...this.target === "openapi-3.0" ? [def.items.length] : []]
            }) : null;
            if (this.target === "draft-2020-12") {
              json2.prefixItems = prefixItems;
              if (rest) {
                json2.items = rest;
              }
            } else if (this.target === "openapi-3.0") {
              json2.items = {
                anyOf: prefixItems
              };
              if (rest) {
                json2.items.anyOf.push(rest);
              }
              json2.minItems = prefixItems.length;
              if (!rest) {
                json2.maxItems = prefixItems.length;
              }
            } else {
              json2.items = prefixItems;
              if (rest) {
                json2.additionalItems = rest;
              }
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minItems = minimum;
            if (typeof maximum === "number")
              json2.maxItems = maximum;
            break;
          }
          case "record": {
            const json2 = _json;
            json2.type = "object";
            if (this.target === "draft-7" || this.target === "draft-2020-12") {
              json2.propertyNames = this.process(def.keyType, {
                ...params,
                path: [...params.path, "propertyNames"]
              });
            }
            json2.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json2 = _json;
            const values = getEnumValues(def.entries);
            if (values.every((v3) => typeof v3 === "number"))
              json2.type = "number";
            if (values.every((v3) => typeof v3 === "string"))
              json2.type = "string";
            json2.enum = values;
            break;
          }
          case "literal": {
            const json2 = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === void 0) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {
                }
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {
            } else if (vals.length === 1) {
              const val = vals[0];
              json2.type = val === null ? "null" : typeof val;
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.enum = [val];
              } else {
                json2.const = val;
              }
            } else {
              if (vals.every((v3) => typeof v3 === "number"))
                json2.type = "number";
              if (vals.every((v3) => typeof v3 === "string"))
                json2.type = "string";
              if (vals.every((v3) => typeof v3 === "boolean"))
                json2.type = "string";
              if (vals.every((v3) => v3 === null))
                json2.type = "null";
              json2.enum = vals;
            }
            break;
          }
          case "file": {
            const json2 = _json;
            const file2 = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== void 0)
              file2.minLength = minimum;
            if (maximum !== void 0)
              file2.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file2.contentMediaType = mime[0];
                Object.assign(json2, file2);
              } else {
                json2.anyOf = mime.map((m) => {
                  const mFile = { ...file2, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json2, file2);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            if (this.target === "openapi-3.0") {
              result.ref = def.innerType;
              _json.nullable = true;
            } else {
              _json.anyOf = [inner, { type: "null" }];
            }
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json2 = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json2.type = "string";
            json2.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          // passthrough types
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw") {
              throw new Error("Function types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {
            def;
          }
        }
      }
    }
    const meta = this.metadataRegistry.get(schema);
    if (meta)
      Object.assign(result.schema, meta);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: _params?.external ?? void 0
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry[0])?.id;
        const uriGenerator = params.external.uri ?? ((id3) => id3);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id2 = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id2;
        return { defId: id2, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id2}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id2 = this.metadataRegistry.get(entry[0])?.id;
      if (id2) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && (params2.target === "draft-7" || params2.target === "draft-4" || params2.target === "openapi-3.0")) {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (this.target === "draft-4") {
      result.$schema = "http://json-schema.org/draft-04/schema#";
    } else if (this.target === "openapi-3.0") {
    } else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id2 = params.external.registry.get(schema)?.id;
      if (!id2)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id2);
    }
    Object.assign(result, root.def);
    const defs = params.external?.defs ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {
    } else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
};
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    // inner types
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    case "function": {
      return false;
    }
    default:
      def;
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}

// node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};

// node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodISODateTime = $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse2 = _parse(ZodRealError);
var parseAsync2 = _parseAsync(ZodRealError);
var safeParse2 = _safeParse(ZodRealError);
var safeParseAsync2 = _safeParseAsync(ZodRealError);
var encode2 = _encode(ZodRealError);
var decode2 = _decode(ZodRealError);
var encodeAsync2 = _encodeAsync(ZodRealError);
var decodeAsync2 = _decodeAsync(ZodRealError);
var safeEncode2 = _safeEncode(ZodRealError);
var safeDecode2 = _safeDecode(ZodRealError);
var safeEncodeAsync2 = _safeEncodeAsync(ZodRealError);
var safeDecodeAsync2 = _safeDecodeAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType = $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(util_exports.mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch2) => typeof ch2 === "function" ? { _zod: { check: ch2, def: { check: "custom" }, onattach: [] } } : ch2)
      ]
    }));
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta) => {
    reg.add(inst, meta);
    return inst;
  });
  inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode2(inst, data, params);
  inst.decode = (data, params) => decode2(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn2) => inst.check(_overwrite(fn2));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx2) => pipe(inst, transform(tx2));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl2 = inst.clone();
    globalRegistry.add(cl2, { description });
    return cl2;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl2 = inst.clone();
    globalRegistry.add(cl2, args[0]);
    return cl2;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString = $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEmoji = $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodIPv6 = $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = regexes_exports[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
var ZodNumber = $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
var ZodObject = $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  util_exports.defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return util_exports.safeExtend(inst, incoming);
  };
  inst.merge = (other) => util_exports.merge(inst, other);
  inst.pick = (mask) => util_exports.pick(inst, mask);
  inst.omit = (mask) => util_exports.omit(inst, mask);
  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
var ZodUnion = $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
var ZodIntersection = $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
var ZodRecord = $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = void 0;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMap = $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSet = $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEnum = $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v3) => [v3, v3])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLiteral = $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
var ZodFile = $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn2) {
  return new ZodTransform({
    type: "transform",
    transform: fn2
  });
}
var ZodOptional = $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault = $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional = $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSuccess = $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
var ZodCodec = $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly = $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLazy = $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodFunction = $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodType.init(inst, def);
});
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
var ZodCustom = $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check(fn2) {
  const ch2 = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch2._zod.check = fn2;
  return ch2;
}
function custom(fn2, _params) {
  return _custom(ZodCustom, fn2 ?? (() => true), _params);
}
function refine(fn2, _params = {}) {
  return _refine(ZodCustom, fn2, _params);
}
function superRefine(fn2) {
  return _superRefine(fn2);
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
var stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean,
  String: ZodString
}, ...args);
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn2, schema) {
  return pipe(transform(fn2), schema);
}

// node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodFirstPartyTypeKind;
/* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

// node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/zod/v4/classic/external.js
config(en_default());

// node_modules/zod/index.js
var zod_default = external_exports;

// node_modules/@mappedin/mappedin-js/lib/esm/chunk-UOCWYBVK.js
var fe = q((SN, zx) => {
  "use strict";
  $i();
  zx.exports = ko;
  function ko(t63, e) {
    this.x = t63, this.y = e;
  }
  ko.prototype = { clone: function() {
    return new ko(this.x, this.y);
  }, add: function(t63) {
    return this.clone()._add(t63);
  }, sub: function(t63) {
    return this.clone()._sub(t63);
  }, multByPoint: function(t63) {
    return this.clone()._multByPoint(t63);
  }, divByPoint: function(t63) {
    return this.clone()._divByPoint(t63);
  }, mult: function(t63) {
    return this.clone()._mult(t63);
  }, div: function(t63) {
    return this.clone()._div(t63);
  }, rotate: function(t63) {
    return this.clone()._rotate(t63);
  }, rotateAround: function(t63, e) {
    return this.clone()._rotateAround(t63, e);
  }, matMult: function(t63) {
    return this.clone()._matMult(t63);
  }, unit: function() {
    return this.clone()._unit();
  }, perp: function() {
    return this.clone()._perp();
  }, round: function() {
    return this.clone()._round();
  }, mag: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, equals: function(t63) {
    return this.x === t63.x && this.y === t63.y;
  }, dist: function(t63) {
    return Math.sqrt(this.distSqr(t63));
  }, distSqr: function(t63) {
    var e = t63.x - this.x, r3 = t63.y - this.y;
    return e * e + r3 * r3;
  }, angle: function() {
    return Math.atan2(this.y, this.x);
  }, angleTo: function(t63) {
    return Math.atan2(this.y - t63.y, this.x - t63.x);
  }, angleWith: function(t63) {
    return this.angleWithSep(t63.x, t63.y);
  }, angleWithSep: function(t63, e) {
    return Math.atan2(this.x * e - this.y * t63, this.x * t63 + this.y * e);
  }, _matMult: function(t63) {
    var e = t63[0] * this.x + t63[1] * this.y, r3 = t63[2] * this.x + t63[3] * this.y;
    return this.x = e, this.y = r3, this;
  }, _add: function(t63) {
    return this.x += t63.x, this.y += t63.y, this;
  }, _sub: function(t63) {
    return this.x -= t63.x, this.y -= t63.y, this;
  }, _mult: function(t63) {
    return this.x *= t63, this.y *= t63, this;
  }, _div: function(t63) {
    return this.x /= t63, this.y /= t63, this;
  }, _multByPoint: function(t63) {
    return this.x *= t63.x, this.y *= t63.y, this;
  }, _divByPoint: function(t63) {
    return this.x /= t63.x, this.y /= t63.y, this;
  }, _unit: function() {
    return this._div(this.mag()), this;
  }, _perp: function() {
    var t63 = this.y;
    return this.y = this.x, this.x = -t63, this;
  }, _rotate: function(t63) {
    var e = Math.cos(t63), r3 = Math.sin(t63), n = e * this.x - r3 * this.y, i = r3 * this.x + e * this.y;
    return this.x = n, this.y = i, this;
  }, _rotateAround: function(t63, e) {
    var r3 = Math.cos(t63), n = Math.sin(t63), i = e.x + r3 * (this.x - e.x) - n * (this.y - e.y), o = e.y + n * (this.x - e.x) + r3 * (this.y - e.y);
    return this.x = i, this.y = o, this;
  }, _round: function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  } };
  ko.convert = function(t63) {
    return t63 instanceof ko ? t63 : Array.isArray(t63) ? new ko(t63[0], t63[1]) : t63;
  };
});
var Nx = q((MN, Ux) => {
  "use strict";
  $i();
  Ux.exports = Vx;
  function Vx(t63, e, r3, n) {
    this.cx = 3 * t63, this.bx = 3 * (r3 - t63) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t63, this.p1y = e, this.p2x = r3, this.p2y = n;
  }
  Vx.prototype = { sampleCurveX: function(t63) {
    return ((this.ax * t63 + this.bx) * t63 + this.cx) * t63;
  }, sampleCurveY: function(t63) {
    return ((this.ay * t63 + this.by) * t63 + this.cy) * t63;
  }, sampleCurveDerivativeX: function(t63) {
    return (3 * this.ax * t63 + 2 * this.bx) * t63 + this.cx;
  }, solveCurveX: function(t63, e) {
    if (e === void 0 && (e = 1e-6), t63 < 0) return 0;
    if (t63 > 1) return 1;
    for (var r3 = t63, n = 0; n < 8; n++) {
      var i = this.sampleCurveX(r3) - t63;
      if (Math.abs(i) < e) return r3;
      var o = this.sampleCurveDerivativeX(r3);
      if (Math.abs(o) < 1e-6) break;
      r3 = r3 - i / o;
    }
    var a = 0, s3 = 1;
    for (r3 = t63, n = 0; n < 20 && (i = this.sampleCurveX(r3), !(Math.abs(i - t63) < e)); n++) t63 > i ? a = r3 : s3 = r3, r3 = (s3 - a) * 0.5 + a;
    return r3;
  }, solve: function(t63, e) {
    return this.sampleCurveY(this.solveCurveX(t63, e));
  } };
});
var Iv = q((WG, Yd) => {
  $i();
  function ek(t63, e) {
    var r3, n, i, o, a, s3, l, u3, c, p;
    for (r3 = t63.length & 3, n = t63.length - r3, i = e, a = 3432918353, l = 461845907, p = 0; p < n; ) c = t63.charCodeAt(p) & 255 | (t63.charCodeAt(++p) & 255) << 8 | (t63.charCodeAt(++p) & 255) << 16 | (t63.charCodeAt(++p) & 255) << 24, ++p, c = (c & 65535) * a + (((c >>> 16) * a & 65535) << 16) & 4294967295, c = c << 15 | c >>> 17, c = (c & 65535) * l + (((c >>> 16) * l & 65535) << 16) & 4294967295, i ^= c, i = i << 13 | i >>> 19, o = (i & 65535) * 5 + (((i >>> 16) * 5 & 65535) << 16) & 4294967295, i = (o & 65535) + 27492 + (((o >>> 16) + 58964 & 65535) << 16);
    switch (c = 0, r3) {
      case 3:
        c ^= (t63.charCodeAt(p + 2) & 255) << 16;
      case 2:
        c ^= (t63.charCodeAt(p + 1) & 255) << 8;
      case 1:
        c ^= t63.charCodeAt(p) & 255, c = (c & 65535) * a + (((c >>> 16) * a & 65535) << 16) & 4294967295, c = c << 15 | c >>> 17, c = (c & 65535) * l + (((c >>> 16) * l & 65535) << 16) & 4294967295, i ^= c;
    }
    return i ^= t63.length, i ^= i >>> 16, i = (i & 65535) * 2246822507 + (((i >>> 16) * 2246822507 & 65535) << 16) & 4294967295, i ^= i >>> 13, i = (i & 65535) * 3266489909 + (((i >>> 16) * 3266489909 & 65535) << 16) & 4294967295, i ^= i >>> 16, i >>> 0;
  }
  typeof Yd < "u" && (Yd.exports = ek);
});
var Av = q((KG, Wd) => {
  $i();
  function tk(t63, e) {
    for (var r3 = t63.length, n = e ^ r3, i = 0, o; r3 >= 4; ) o = t63.charCodeAt(i) & 255 | (t63.charCodeAt(++i) & 255) << 8 | (t63.charCodeAt(++i) & 255) << 16 | (t63.charCodeAt(++i) & 255) << 24, o = (o & 65535) * 1540483477 + (((o >>> 16) * 1540483477 & 65535) << 16), o ^= o >>> 24, o = (o & 65535) * 1540483477 + (((o >>> 16) * 1540483477 & 65535) << 16), n = (n & 65535) * 1540483477 + (((n >>> 16) * 1540483477 & 65535) << 16) ^ o, r3 -= 4, ++i;
    switch (r3) {
      case 3:
        n ^= (t63.charCodeAt(i + 2) & 255) << 16;
      case 2:
        n ^= (t63.charCodeAt(i + 1) & 255) << 8;
      case 1:
        n ^= t63.charCodeAt(i) & 255, n = (n & 65535) * 1540483477 + (((n >>> 16) * 1540483477 & 65535) << 16);
    }
    return n ^= n >>> 13, n = (n & 65535) * 1540483477 + (((n >>> 16) * 1540483477 & 65535) << 16), n ^= n >>> 15, n >>> 0;
  }
  typeof Wd !== void 0 && (Wd.exports = tk);
});
var $d = q((QG, hp) => {
  $i();
  var Ev = Iv(), rk = Av();
  hp.exports = Ev;
  hp.exports.murmur3 = Ev;
  hp.exports.murmur2 = rk;
});
var cy = q((_X, y0) => {
  "use strict";
  $i();
  var Hk = fe();
  y0.exports = la;
  function la(t63, e, r3, n, i) {
    this.properties = {}, this.extent = r3, this.type = 0, this._pbf = t63, this._geometry = -1, this._keys = n, this._values = i, t63.readFields(Xk, this, e);
  }
  function Xk(t63, e, r3) {
    t63 == 1 ? e.id = r3.readVarint() : t63 == 2 ? Zk(r3, e) : t63 == 3 ? e.type = r3.readVarint() : t63 == 4 && (e._geometry = r3.pos);
  }
  function Zk(t63, e) {
    for (var r3 = t63.readVarint() + t63.pos; t63.pos < r3; ) {
      var n = e._keys[t63.readVarint()], i = e._values[t63.readVarint()];
      e.properties[n] = i;
    }
  }
  la.types = ["Unknown", "Point", "LineString", "Polygon"];
  la.prototype.loadGeometry = function() {
    var t63 = this._pbf;
    t63.pos = this._geometry;
    for (var e = t63.readVarint() + t63.pos, r3 = 1, n = 0, i = 0, o = 0, a = [], s3; t63.pos < e; ) {
      if (n <= 0) {
        var l = t63.readVarint();
        r3 = l & 7, n = l >> 3;
      }
      if (n--, r3 === 1 || r3 === 2) i += t63.readSVarint(), o += t63.readSVarint(), r3 === 1 && (s3 && a.push(s3), s3 = []), s3.push(new Hk(i, o));
      else if (r3 === 7) s3 && s3.push(s3[0].clone());
      else throw new Error("unknown command " + r3);
    }
    return s3 && a.push(s3), a;
  };
  la.prototype.bbox = function() {
    var t63 = this._pbf;
    t63.pos = this._geometry;
    for (var e = t63.readVarint() + t63.pos, r3 = 1, n = 0, i = 0, o = 0, a = 1 / 0, s3 = -1 / 0, l = 1 / 0, u3 = -1 / 0; t63.pos < e; ) {
      if (n <= 0) {
        var c = t63.readVarint();
        r3 = c & 7, n = c >> 3;
      }
      if (n--, r3 === 1 || r3 === 2) i += t63.readSVarint(), o += t63.readSVarint(), i < a && (a = i), i > s3 && (s3 = i), o < l && (l = o), o > u3 && (u3 = o);
      else if (r3 !== 7) throw new Error("unknown command " + r3);
    }
    return [a, l, s3, u3];
  };
  la.prototype.toGeoJSON = function(t63, e, r3) {
    var n = this.extent * Math.pow(2, r3), i = this.extent * t63, o = this.extent * e, a = this.loadGeometry(), s3 = la.types[this.type], l, u3;
    function c(f) {
      for (var d = 0; d < f.length; d++) {
        var g = f[d], x = 180 - (g.y + o) * 360 / n;
        f[d] = [(g.x + i) * 360 / n - 180, 360 / Math.PI * Math.atan(Math.exp(x * Math.PI / 180)) - 90];
      }
    }
    switch (this.type) {
      case 1:
        var p = [];
        for (l = 0; l < a.length; l++) p[l] = a[l][0];
        a = p, c(a);
        break;
      case 2:
        for (l = 0; l < a.length; l++) c(a[l]);
        break;
      case 3:
        for (a = qk(a), l = 0; l < a.length; l++) for (u3 = 0; u3 < a[l].length; u3++) c(a[l][u3]);
        break;
    }
    a.length === 1 ? a = a[0] : s3 = "Multi" + s3;
    var h = { type: "Feature", geometry: { type: s3, coordinates: a }, properties: this.properties };
    return "id" in this && (h.id = this.id), h;
  };
  function qk(t63) {
    var e = t63.length;
    if (e <= 1) return [t63];
    for (var r3 = [], n, i, o = 0; o < e; o++) {
      var a = Yk(t63[o]);
      a !== 0 && (i === void 0 && (i = a < 0), i === a < 0 ? (n && r3.push(n), n = [t63[o]]) : n.push(t63[o]));
    }
    return n && r3.push(n), r3;
  }
  function Yk(t63) {
    for (var e = 0, r3 = 0, n = t63.length, i = n - 1, o, a; r3 < n; i = r3++) o = t63[r3], a = t63[i], e += (a.x - o.x) * (o.y + a.y);
    return e;
  }
});
var py = q((PX, x0) => {
  "use strict";
  $i();
  var Wk = cy();
  x0.exports = g0;
  function g0(t63, e) {
    this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t63, this._keys = [], this._values = [], this._features = [], t63.readFields($k, this, e), this.length = this._features.length;
  }
  function $k(t63, e, r3) {
    t63 === 15 ? e.version = r3.readVarint() : t63 === 1 ? e.name = r3.readString() : t63 === 5 ? e.extent = r3.readVarint() : t63 === 2 ? e._features.push(r3.pos) : t63 === 3 ? e._keys.push(r3.readString()) : t63 === 4 && e._values.push(Kk(r3));
  }
  function Kk(t63) {
    for (var e = null, r3 = t63.readVarint() + t63.pos; t63.pos < r3; ) {
      var n = t63.readVarint() >> 3;
      e = n === 1 ? t63.readString() : n === 2 ? t63.readFloat() : n === 3 ? t63.readDouble() : n === 4 ? t63.readVarint64() : n === 5 ? t63.readVarint() : n === 6 ? t63.readSVarint() : n === 7 ? t63.readBoolean() : null;
    }
    return e;
  }
  g0.prototype.feature = function(t63) {
    if (t63 < 0 || t63 >= this._features.length) throw new Error("feature index out of bounds");
    this._pbf.pos = this._features[t63];
    var e = this._pbf.readVarint() + this._pbf.pos;
    return new Wk(this._pbf, e, this.extent, this._keys, this._values);
  };
});
var _0 = q((TX, b0) => {
  "use strict";
  $i();
  var Jk = py();
  b0.exports = Qk;
  function Qk(t63, e) {
    this.layers = t63.readFields(eF, {}, e);
  }
  function eF(t63, e, r3) {
    if (t63 === 3) {
      var n = new Jk(r3, r3.readVarint() + r3.pos);
      n.length && (e[n.name] = n);
    }
  }
});
var bl = q((CX, Ap) => {
  $i();
  Ap.exports.VectorTile = _0();
  Ap.exports.VectorTileFeature = cy();
  Ap.exports.VectorTileLayer = py();
});
var H0 = q((yy) => {
  $i();
  yy.read = function(t63, e, r3, n, i) {
    var o, a, s3 = i * 8 - n - 1, l = (1 << s3) - 1, u3 = l >> 1, c = -7, p = r3 ? i - 1 : 0, h = r3 ? -1 : 1, f = t63[e + p];
    for (p += h, o = f & (1 << -c) - 1, f >>= -c, c += s3; c > 0; o = o * 256 + t63[e + p], p += h, c -= 8) ;
    for (a = o & (1 << -c) - 1, o >>= -c, c += n; c > 0; a = a * 256 + t63[e + p], p += h, c -= 8) ;
    if (o === 0) o = 1 - u3;
    else {
      if (o === l) return a ? NaN : (f ? -1 : 1) * (1 / 0);
      a = a + Math.pow(2, n), o = o - u3;
    }
    return (f ? -1 : 1) * a * Math.pow(2, o - n);
  };
  yy.write = function(t63, e, r3, n, i, o) {
    var a, s3, l, u3 = o * 8 - i - 1, c = (1 << u3) - 1, p = c >> 1, h = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = n ? 0 : o - 1, d = n ? 1 : -1, g = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s3 = isNaN(e) ? 1 : 0, a = c) : (a = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), a + p >= 1 ? e += h / l : e += h * Math.pow(2, 1 - p), e * l >= 2 && (a++, l /= 2), a + p >= c ? (s3 = 0, a = c) : a + p >= 1 ? (s3 = (e * l - 1) * Math.pow(2, i), a = a + p) : (s3 = e * Math.pow(2, p - 1) * Math.pow(2, i), a = 0)); i >= 8; t63[r3 + f] = s3 & 255, f += d, s3 /= 256, i -= 8) ;
    for (a = a << i | s3, u3 += i; u3 > 0; t63[r3 + f] = a & 255, f += d, a /= 256, u3 -= 8) ;
    t63[r3 + f - d] |= g * 128;
  };
});
var xy = q((xq, W0) => {
  "use strict";
  $i();
  W0.exports = je;
  var kp = H0();
  function je(t63) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t63) ? t63 : new Uint8Array(t63 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
  }
  je.Varint = 0;
  je.Fixed64 = 1;
  je.Bytes = 2;
  je.Fixed32 = 5;
  var gy = 65536 * 65536, X0 = 1 / gy, bF = 12, Y0 = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
  je.prototype = { destroy: function() {
    this.buf = null;
  }, readFields: function(t63, e, r3) {
    for (r3 = r3 || this.length; this.pos < r3; ) {
      var n = this.readVarint(), i = n >> 3, o = this.pos;
      this.type = n & 7, t63(i, e, this), this.pos === o && this.skip(n);
    }
    return e;
  }, readMessage: function(t63, e) {
    return this.readFields(t63, e, this.readVarint() + this.pos);
  }, readFixed32: function() {
    var t63 = Fp(this.buf, this.pos);
    return this.pos += 4, t63;
  }, readSFixed32: function() {
    var t63 = q0(this.buf, this.pos);
    return this.pos += 4, t63;
  }, readFixed64: function() {
    var t63 = Fp(this.buf, this.pos) + Fp(this.buf, this.pos + 4) * gy;
    return this.pos += 8, t63;
  }, readSFixed64: function() {
    var t63 = Fp(this.buf, this.pos) + q0(this.buf, this.pos + 4) * gy;
    return this.pos += 8, t63;
  }, readFloat: function() {
    var t63 = kp.read(this.buf, this.pos, true, 23, 4);
    return this.pos += 4, t63;
  }, readDouble: function() {
    var t63 = kp.read(this.buf, this.pos, true, 52, 8);
    return this.pos += 8, t63;
  }, readVarint: function(t63) {
    var e = this.buf, r3, n;
    return n = e[this.pos++], r3 = n & 127, n < 128 || (n = e[this.pos++], r3 |= (n & 127) << 7, n < 128) || (n = e[this.pos++], r3 |= (n & 127) << 14, n < 128) || (n = e[this.pos++], r3 |= (n & 127) << 21, n < 128) ? r3 : (n = e[this.pos], r3 |= (n & 15) << 28, _F(r3, t63, this));
  }, readVarint64: function() {
    return this.readVarint(true);
  }, readSVarint: function() {
    var t63 = this.readVarint();
    return t63 % 2 === 1 ? (t63 + 1) / -2 : t63 / 2;
  }, readBoolean: function() {
    return !!this.readVarint();
  }, readString: function() {
    var t63 = this.readVarint() + this.pos, e = this.pos;
    return this.pos = t63, t63 - e >= bF && Y0 ? kF(this.buf, e, t63) : RF(this.buf, e, t63);
  }, readBytes: function() {
    var t63 = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, t63);
    return this.pos = t63, e;
  }, readPackedVarint: function(t63, e) {
    if (this.type !== je.Bytes) return t63.push(this.readVarint(e));
    var r3 = Ln(this);
    for (t63 = t63 || []; this.pos < r3; ) t63.push(this.readVarint(e));
    return t63;
  }, readPackedSVarint: function(t63) {
    if (this.type !== je.Bytes) return t63.push(this.readSVarint());
    var e = Ln(this);
    for (t63 = t63 || []; this.pos < e; ) t63.push(this.readSVarint());
    return t63;
  }, readPackedBoolean: function(t63) {
    if (this.type !== je.Bytes) return t63.push(this.readBoolean());
    var e = Ln(this);
    for (t63 = t63 || []; this.pos < e; ) t63.push(this.readBoolean());
    return t63;
  }, readPackedFloat: function(t63) {
    if (this.type !== je.Bytes) return t63.push(this.readFloat());
    var e = Ln(this);
    for (t63 = t63 || []; this.pos < e; ) t63.push(this.readFloat());
    return t63;
  }, readPackedDouble: function(t63) {
    if (this.type !== je.Bytes) return t63.push(this.readDouble());
    var e = Ln(this);
    for (t63 = t63 || []; this.pos < e; ) t63.push(this.readDouble());
    return t63;
  }, readPackedFixed32: function(t63) {
    if (this.type !== je.Bytes) return t63.push(this.readFixed32());
    var e = Ln(this);
    for (t63 = t63 || []; this.pos < e; ) t63.push(this.readFixed32());
    return t63;
  }, readPackedSFixed32: function(t63) {
    if (this.type !== je.Bytes) return t63.push(this.readSFixed32());
    var e = Ln(this);
    for (t63 = t63 || []; this.pos < e; ) t63.push(this.readSFixed32());
    return t63;
  }, readPackedFixed64: function(t63) {
    if (this.type !== je.Bytes) return t63.push(this.readFixed64());
    var e = Ln(this);
    for (t63 = t63 || []; this.pos < e; ) t63.push(this.readFixed64());
    return t63;
  }, readPackedSFixed64: function(t63) {
    if (this.type !== je.Bytes) return t63.push(this.readSFixed64());
    var e = Ln(this);
    for (t63 = t63 || []; this.pos < e; ) t63.push(this.readSFixed64());
    return t63;
  }, skip: function(t63) {
    var e = t63 & 7;
    if (e === je.Varint) for (; this.buf[this.pos++] > 127; ) ;
    else if (e === je.Bytes) this.pos = this.readVarint() + this.pos;
    else if (e === je.Fixed32) this.pos += 4;
    else if (e === je.Fixed64) this.pos += 8;
    else throw new Error("Unimplemented type: " + e);
  }, writeTag: function(t63, e) {
    this.writeVarint(t63 << 3 | e);
  }, realloc: function(t63) {
    for (var e = this.length || 16; e < this.pos + t63; ) e *= 2;
    if (e !== this.length) {
      var r3 = new Uint8Array(e);
      r3.set(this.buf), this.buf = r3, this.length = e;
    }
  }, finish: function() {
    return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
  }, writeFixed32: function(t63) {
    this.realloc(4), ca(this.buf, t63, this.pos), this.pos += 4;
  }, writeSFixed32: function(t63) {
    this.realloc(4), ca(this.buf, t63, this.pos), this.pos += 4;
  }, writeFixed64: function(t63) {
    this.realloc(8), ca(this.buf, t63 & -1, this.pos), ca(this.buf, Math.floor(t63 * X0), this.pos + 4), this.pos += 8;
  }, writeSFixed64: function(t63) {
    this.realloc(8), ca(this.buf, t63 & -1, this.pos), ca(this.buf, Math.floor(t63 * X0), this.pos + 4), this.pos += 8;
  }, writeVarint: function(t63) {
    if (t63 = +t63 || 0, t63 > 268435455 || t63 < 0) {
      vF(t63, this);
      return;
    }
    this.realloc(4), this.buf[this.pos++] = t63 & 127 | (t63 > 127 ? 128 : 0), !(t63 <= 127) && (this.buf[this.pos++] = (t63 >>>= 7) & 127 | (t63 > 127 ? 128 : 0), !(t63 <= 127) && (this.buf[this.pos++] = (t63 >>>= 7) & 127 | (t63 > 127 ? 128 : 0), !(t63 <= 127) && (this.buf[this.pos++] = t63 >>> 7 & 127)));
  }, writeSVarint: function(t63) {
    this.writeVarint(t63 < 0 ? -t63 * 2 - 1 : t63 * 2);
  }, writeBoolean: function(t63) {
    this.writeVarint(!!t63);
  }, writeString: function(t63) {
    t63 = String(t63), this.realloc(t63.length * 4), this.pos++;
    var e = this.pos;
    this.pos = FF(this.buf, t63, this.pos);
    var r3 = this.pos - e;
    r3 >= 128 && Z0(e, r3, this), this.pos = e - 1, this.writeVarint(r3), this.pos += r3;
  }, writeFloat: function(t63) {
    this.realloc(4), kp.write(this.buf, t63, this.pos, true, 23, 4), this.pos += 4;
  }, writeDouble: function(t63) {
    this.realloc(8), kp.write(this.buf, t63, this.pos, true, 52, 8), this.pos += 8;
  }, writeBytes: function(t63) {
    var e = t63.length;
    this.writeVarint(e), this.realloc(e);
    for (var r3 = 0; r3 < e; r3++) this.buf[this.pos++] = t63[r3];
  }, writeRawMessage: function(t63, e) {
    this.pos++;
    var r3 = this.pos;
    t63(e, this);
    var n = this.pos - r3;
    n >= 128 && Z0(r3, n, this), this.pos = r3 - 1, this.writeVarint(n), this.pos += n;
  }, writeMessage: function(t63, e, r3) {
    this.writeTag(t63, je.Bytes), this.writeRawMessage(e, r3);
  }, writePackedVarint: function(t63, e) {
    e.length && this.writeMessage(t63, TF, e);
  }, writePackedSVarint: function(t63, e) {
    e.length && this.writeMessage(t63, SF, e);
  }, writePackedBoolean: function(t63, e) {
    e.length && this.writeMessage(t63, IF, e);
  }, writePackedFloat: function(t63, e) {
    e.length && this.writeMessage(t63, CF, e);
  }, writePackedDouble: function(t63, e) {
    e.length && this.writeMessage(t63, MF, e);
  }, writePackedFixed32: function(t63, e) {
    e.length && this.writeMessage(t63, AF, e);
  }, writePackedSFixed32: function(t63, e) {
    e.length && this.writeMessage(t63, EF, e);
  }, writePackedFixed64: function(t63, e) {
    e.length && this.writeMessage(t63, LF, e);
  }, writePackedSFixed64: function(t63, e) {
    e.length && this.writeMessage(t63, DF, e);
  }, writeBytesField: function(t63, e) {
    this.writeTag(t63, je.Bytes), this.writeBytes(e);
  }, writeFixed32Field: function(t63, e) {
    this.writeTag(t63, je.Fixed32), this.writeFixed32(e);
  }, writeSFixed32Field: function(t63, e) {
    this.writeTag(t63, je.Fixed32), this.writeSFixed32(e);
  }, writeFixed64Field: function(t63, e) {
    this.writeTag(t63, je.Fixed64), this.writeFixed64(e);
  }, writeSFixed64Field: function(t63, e) {
    this.writeTag(t63, je.Fixed64), this.writeSFixed64(e);
  }, writeVarintField: function(t63, e) {
    this.writeTag(t63, je.Varint), this.writeVarint(e);
  }, writeSVarintField: function(t63, e) {
    this.writeTag(t63, je.Varint), this.writeSVarint(e);
  }, writeStringField: function(t63, e) {
    this.writeTag(t63, je.Bytes), this.writeString(e);
  }, writeFloatField: function(t63, e) {
    this.writeTag(t63, je.Fixed32), this.writeFloat(e);
  }, writeDoubleField: function(t63, e) {
    this.writeTag(t63, je.Fixed64), this.writeDouble(e);
  }, writeBooleanField: function(t63, e) {
    this.writeVarintField(t63, !!e);
  } };
  function _F(t63, e, r3) {
    var n = r3.buf, i, o;
    if (o = n[r3.pos++], i = (o & 112) >> 4, o < 128 || (o = n[r3.pos++], i |= (o & 127) << 3, o < 128) || (o = n[r3.pos++], i |= (o & 127) << 10, o < 128) || (o = n[r3.pos++], i |= (o & 127) << 17, o < 128) || (o = n[r3.pos++], i |= (o & 127) << 24, o < 128) || (o = n[r3.pos++], i |= (o & 1) << 31, o < 128)) return ua(t63, i, e);
    throw new Error("Expected varint not more than 10 bytes");
  }
  function Ln(t63) {
    return t63.type === je.Bytes ? t63.readVarint() + t63.pos : t63.pos + 1;
  }
  function ua(t63, e, r3) {
    return r3 ? e * 4294967296 + (t63 >>> 0) : (e >>> 0) * 4294967296 + (t63 >>> 0);
  }
  function vF(t63, e) {
    var r3, n;
    if (t63 >= 0 ? (r3 = t63 % 4294967296 | 0, n = t63 / 4294967296 | 0) : (r3 = ~(-t63 % 4294967296), n = ~(-t63 / 4294967296), r3 ^ 4294967295 ? r3 = r3 + 1 | 0 : (r3 = 0, n = n + 1 | 0)), t63 >= 18446744073709552e3 || t63 < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
    e.realloc(10), PF(r3, n, e), wF(n, e);
  }
  function PF(t63, e, r3) {
    r3.buf[r3.pos++] = t63 & 127 | 128, t63 >>>= 7, r3.buf[r3.pos++] = t63 & 127 | 128, t63 >>>= 7, r3.buf[r3.pos++] = t63 & 127 | 128, t63 >>>= 7, r3.buf[r3.pos++] = t63 & 127 | 128, t63 >>>= 7, r3.buf[r3.pos] = t63 & 127;
  }
  function wF(t63, e) {
    var r3 = (t63 & 7) << 4;
    e.buf[e.pos++] |= r3 | ((t63 >>>= 3) ? 128 : 0), t63 && (e.buf[e.pos++] = t63 & 127 | ((t63 >>>= 7) ? 128 : 0), t63 && (e.buf[e.pos++] = t63 & 127 | ((t63 >>>= 7) ? 128 : 0), t63 && (e.buf[e.pos++] = t63 & 127 | ((t63 >>>= 7) ? 128 : 0), t63 && (e.buf[e.pos++] = t63 & 127 | ((t63 >>>= 7) ? 128 : 0), t63 && (e.buf[e.pos++] = t63 & 127)))));
  }
  function Z0(t63, e, r3) {
    var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (Math.LN2 * 7));
    r3.realloc(n);
    for (var i = r3.pos - 1; i >= t63; i--) r3.buf[i + n] = r3.buf[i];
  }
  function TF(t63, e) {
    for (var r3 = 0; r3 < t63.length; r3++) e.writeVarint(t63[r3]);
  }
  function SF(t63, e) {
    for (var r3 = 0; r3 < t63.length; r3++) e.writeSVarint(t63[r3]);
  }
  function CF(t63, e) {
    for (var r3 = 0; r3 < t63.length; r3++) e.writeFloat(t63[r3]);
  }
  function MF(t63, e) {
    for (var r3 = 0; r3 < t63.length; r3++) e.writeDouble(t63[r3]);
  }
  function IF(t63, e) {
    for (var r3 = 0; r3 < t63.length; r3++) e.writeBoolean(t63[r3]);
  }
  function AF(t63, e) {
    for (var r3 = 0; r3 < t63.length; r3++) e.writeFixed32(t63[r3]);
  }
  function EF(t63, e) {
    for (var r3 = 0; r3 < t63.length; r3++) e.writeSFixed32(t63[r3]);
  }
  function LF(t63, e) {
    for (var r3 = 0; r3 < t63.length; r3++) e.writeFixed64(t63[r3]);
  }
  function DF(t63, e) {
    for (var r3 = 0; r3 < t63.length; r3++) e.writeSFixed64(t63[r3]);
  }
  function Fp(t63, e) {
    return (t63[e] | t63[e + 1] << 8 | t63[e + 2] << 16) + t63[e + 3] * 16777216;
  }
  function ca(t63, e, r3) {
    t63[r3] = e, t63[r3 + 1] = e >>> 8, t63[r3 + 2] = e >>> 16, t63[r3 + 3] = e >>> 24;
  }
  function q0(t63, e) {
    return (t63[e] | t63[e + 1] << 8 | t63[e + 2] << 16) + (t63[e + 3] << 24);
  }
  function RF(t63, e, r3) {
    for (var n = "", i = e; i < r3; ) {
      var o = t63[i], a = null, s3 = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
      if (i + s3 > r3) break;
      var l, u3, c;
      s3 === 1 ? o < 128 && (a = o) : s3 === 2 ? (l = t63[i + 1], (l & 192) === 128 && (a = (o & 31) << 6 | l & 63, a <= 127 && (a = null))) : s3 === 3 ? (l = t63[i + 1], u3 = t63[i + 2], (l & 192) === 128 && (u3 & 192) === 128 && (a = (o & 15) << 12 | (l & 63) << 6 | u3 & 63, (a <= 2047 || a >= 55296 && a <= 57343) && (a = null))) : s3 === 4 && (l = t63[i + 1], u3 = t63[i + 2], c = t63[i + 3], (l & 192) === 128 && (u3 & 192) === 128 && (c & 192) === 128 && (a = (o & 15) << 18 | (l & 63) << 12 | (u3 & 63) << 6 | c & 63, (a <= 65535 || a >= 1114112) && (a = null))), a === null ? (a = 65533, s3 = 1) : a > 65535 && (a -= 65536, n += String.fromCharCode(a >>> 10 & 1023 | 55296), a = 56320 | a & 1023), n += String.fromCharCode(a), i += s3;
    }
    return n;
  }
  function kF(t63, e, r3) {
    return Y0.decode(t63.subarray(e, r3));
  }
  function FF(t63, e, r3) {
    for (var n = 0, i, o; n < e.length; n++) {
      if (i = e.charCodeAt(n), i > 55295 && i < 57344) if (o) if (i < 56320) {
        t63[r3++] = 239, t63[r3++] = 191, t63[r3++] = 189, o = i;
        continue;
      } else i = o - 55296 << 10 | i - 56320 | 65536, o = null;
      else {
        i > 56319 || n + 1 === e.length ? (t63[r3++] = 239, t63[r3++] = 191, t63[r3++] = 189) : o = i;
        continue;
      }
      else o && (t63[r3++] = 239, t63[r3++] = 191, t63[r3++] = 189, o = null);
      i < 128 ? t63[r3++] = i : (i < 2048 ? t63[r3++] = i >> 6 | 192 : (i < 65536 ? t63[r3++] = i >> 12 | 224 : (t63[r3++] = i >> 18 | 240, t63[r3++] = i >> 12 & 63 | 128), t63[r3++] = i >> 6 & 63 | 128), t63[r3++] = i & 63 | 128);
    }
    return r3;
  }
});
var jC = q((Tu, Va) => {
  $i();
  var Oz = 200, TC = "__lodash_hash_undefined__", Bz = 800, zz = 16, SC = 9007199254740991, CC = "[object Arguments]", Vz = "[object Array]", Uz = "[object AsyncFunction]", Nz = "[object Boolean]", Gz = "[object Date]", jz = "[object Error]", MC = "[object Function]", Hz = "[object GeneratorFunction]", Xz = "[object Map]", Zz = "[object Number]", qz = "[object Null]", IC = "[object Object]", Yz = "[object Proxy]", Wz = "[object RegExp]", $z = "[object Set]", Kz = "[object String]", Jz = "[object Undefined]", Qz = "[object WeakMap]", e3 = "[object ArrayBuffer]", t310 = "[object DataView]", r3 = "[object Float32Array]", n3 = "[object Float64Array]", i3 = "[object Int8Array]", o3 = "[object Int16Array]", a3 = "[object Int32Array]", s3 = "[object Uint8Array]", l3 = "[object Uint8ClampedArray]", u3 = "[object Uint16Array]", c3 = "[object Uint32Array]", p3 = /[\\^$.*+?()[\]{}|]/g, h3 = /^\[object .+?Constructor\]$/, f3 = /^(?:0|[1-9]\d*)$/, et = {};
  et[r3] = et[n3] = et[i3] = et[o3] = et[a3] = et[s3] = et[l3] = et[u3] = et[c3] = true;
  et[CC] = et[Vz] = et[e3] = et[Nz] = et[t310] = et[Gz] = et[jz] = et[MC] = et[Xz] = et[Zz] = et[IC] = et[Wz] = et[$z] = et[Kz] = et[Qz] = false;
  var AC = typeof global == "object" && global && global.Object === Object && global, m3 = typeof self == "object" && self && self.Object === Object && self, Mu = AC || m3 || Function("return this")(), EC = typeof Tu == "object" && Tu && !Tu.nodeType && Tu, Su = EC && typeof Va == "object" && Va && !Va.nodeType && Va, LC = Su && Su.exports === EC, Fg = LC && AC.process, dC = (function() {
    try {
      var t63 = Su && Su.require && Su.require("util").types;
      return t63 || Fg && Fg.binding && Fg.binding("util");
    } catch {
    }
  })(), yC = dC && dC.isTypedArray;
  function d3(t63, e, r4) {
    switch (r4.length) {
      case 0:
        return t63.call(e);
      case 1:
        return t63.call(e, r4[0]);
      case 2:
        return t63.call(e, r4[0], r4[1]);
      case 3:
        return t63.call(e, r4[0], r4[1], r4[2]);
    }
    return t63.apply(e, r4);
  }
  function y3(t63, e) {
    for (var r4 = -1, n = Array(t63); ++r4 < t63; ) n[r4] = e(r4);
    return n;
  }
  function g3(t63) {
    return function(e) {
      return t63(e);
    };
  }
  function x3(t63, e) {
    return t63?.[e];
  }
  function b3(t63, e) {
    return function(r4) {
      return t63(e(r4));
    };
  }
  var _3 = Array.prototype, v3 = Function.prototype, rm = Object.prototype, Og = Mu["__core-js_shared__"], nm = v3.toString, Un = rm.hasOwnProperty, gC = (function() {
    var t63 = /[^.]+$/.exec(Og && Og.keys && Og.keys.IE_PROTO || "");
    return t63 ? "Symbol(src)_1." + t63 : "";
  })(), DC = rm.toString, P3 = nm.call(Object), w3 = RegExp("^" + nm.call(Un).replace(p3, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), em = LC ? Mu.Buffer : void 0, xC = Mu.Symbol, bC = Mu.Uint8Array, _C = em ? em.allocUnsafe : void 0, RC = b3(Object.getPrototypeOf, Object), vC = Object.create, T3 = rm.propertyIsEnumerable, S3 = _3.splice, wo = xC ? xC.toStringTag : void 0, tm = (function() {
    try {
      var t63 = Gg(Object, "defineProperty");
      return t63({}, "", {}), t63;
    } catch {
    }
  })(), C3 = em ? em.isBuffer : void 0, PC = Math.max, M3 = Date.now, kC = Gg(Mu, "Map"), Cu = Gg(Object, "create"), I3 = /* @__PURE__ */ (function() {
    function t63() {
    }
    return function(e) {
      if (!So(e)) return {};
      if (vC) return vC(e);
      t63.prototype = e;
      var r4 = new t63();
      return t63.prototype = void 0, r4;
    };
  })();
  function To(t63) {
    var e = -1, r4 = t63 == null ? 0 : t63.length;
    for (this.clear(); ++e < r4; ) {
      var n = t63[e];
      this.set(n[0], n[1]);
    }
  }
  function A3() {
    this.__data__ = Cu ? Cu(null) : {}, this.size = 0;
  }
  function E3(t63) {
    var e = this.has(t63) && delete this.__data__[t63];
    return this.size -= e ? 1 : 0, e;
  }
  function L3(t63) {
    var e = this.__data__;
    if (Cu) {
      var r4 = e[t63];
      return r4 === TC ? void 0 : r4;
    }
    return Un.call(e, t63) ? e[t63] : void 0;
  }
  function D3(t63) {
    var e = this.__data__;
    return Cu ? e[t63] !== void 0 : Un.call(e, t63);
  }
  function R3(t63, e) {
    var r4 = this.__data__;
    return this.size += this.has(t63) ? 0 : 1, r4[t63] = Cu && e === void 0 ? TC : e, this;
  }
  To.prototype.clear = A3;
  To.prototype.delete = E3;
  To.prototype.get = L3;
  To.prototype.has = D3;
  To.prototype.set = R3;
  function Nn(t63) {
    var e = -1, r4 = t63 == null ? 0 : t63.length;
    for (this.clear(); ++e < r4; ) {
      var n = t63[e];
      this.set(n[0], n[1]);
    }
  }
  function k3() {
    this.__data__ = [], this.size = 0;
  }
  function F3(t63) {
    var e = this.__data__, r4 = im(e, t63);
    if (r4 < 0) return false;
    var n = e.length - 1;
    return r4 == n ? e.pop() : S3.call(e, r4, 1), --this.size, true;
  }
  function O3(t63) {
    var e = this.__data__, r4 = im(e, t63);
    return r4 < 0 ? void 0 : e[r4][1];
  }
  function B3(t63) {
    return im(this.__data__, t63) > -1;
  }
  function z3(t63, e) {
    var r4 = this.__data__, n = im(r4, t63);
    return n < 0 ? (++this.size, r4.push([t63, e])) : r4[n][1] = e, this;
  }
  Nn.prototype.clear = k3;
  Nn.prototype.delete = F3;
  Nn.prototype.get = O3;
  Nn.prototype.has = B3;
  Nn.prototype.set = z3;
  function Ua(t63) {
    var e = -1, r4 = t63 == null ? 0 : t63.length;
    for (this.clear(); ++e < r4; ) {
      var n = t63[e];
      this.set(n[0], n[1]);
    }
  }
  function V3() {
    this.size = 0, this.__data__ = { hash: new To(), map: new (kC || Nn)(), string: new To() };
  }
  function U3(t63) {
    var e = am(this, t63).delete(t63);
    return this.size -= e ? 1 : 0, e;
  }
  function N3(t63) {
    return am(this, t63).get(t63);
  }
  function G3(t63) {
    return am(this, t63).has(t63);
  }
  function j3(t63, e) {
    var r4 = am(this, t63), n = r4.size;
    return r4.set(t63, e), this.size += r4.size == n ? 0 : 1, this;
  }
  Ua.prototype.clear = V3;
  Ua.prototype.delete = U3;
  Ua.prototype.get = N3;
  Ua.prototype.has = G3;
  Ua.prototype.set = j3;
  function Na(t63) {
    var e = this.__data__ = new Nn(t63);
    this.size = e.size;
  }
  function H3() {
    this.__data__ = new Nn(), this.size = 0;
  }
  function X3(t63) {
    var e = this.__data__, r4 = e.delete(t63);
    return this.size = e.size, r4;
  }
  function Z3(t63) {
    return this.__data__.get(t63);
  }
  function q32(t63) {
    return this.__data__.has(t63);
  }
  function Y3(t63, e) {
    var r4 = this.__data__;
    if (r4 instanceof Nn) {
      var n = r4.__data__;
      if (!kC || n.length < Oz - 1) return n.push([t63, e]), this.size = ++r4.size, this;
      r4 = this.__data__ = new Ua(n);
    }
    return r4.set(t63, e), this.size = r4.size, this;
  }
  Na.prototype.clear = H3;
  Na.prototype.delete = X3;
  Na.prototype.get = Z3;
  Na.prototype.has = q32;
  Na.prototype.set = Y3;
  function W3(t63, e) {
    var r4 = Ug(t63), n = !r4 && Vg(t63), i = !r4 && !n && zC(t63), o = !r4 && !n && !i && UC(t63), a = r4 || n || i || o, s4 = a ? y3(t63.length, String) : [], l = s4.length;
    for (var u4 in t63) (e || Un.call(t63, u4)) && !(a && (u4 == "length" || i && (u4 == "offset" || u4 == "parent") || o && (u4 == "buffer" || u4 == "byteLength" || u4 == "byteOffset") || OC(u4, l))) && s4.push(u4);
    return s4;
  }
  function Bg(t63, e, r4) {
    (r4 !== void 0 && !sm(t63[e], r4) || r4 === void 0 && !(e in t63)) && Ng(t63, e, r4);
  }
  function $3(t63, e, r4) {
    var n = t63[e];
    (!(Un.call(t63, e) && sm(n, r4)) || r4 === void 0 && !(e in t63)) && Ng(t63, e, r4);
  }
  function im(t63, e) {
    for (var r4 = t63.length; r4--; ) if (sm(t63[r4][0], e)) return r4;
    return -1;
  }
  function Ng(t63, e, r4) {
    e == "__proto__" && tm ? tm(t63, e, { configurable: true, enumerable: true, value: r4, writable: true }) : t63[e] = r4;
  }
  var K3 = cV();
  function om(t63) {
    return t63 == null ? t63 === void 0 ? Jz : qz : wo && wo in Object(t63) ? pV(t63) : gV(t63);
  }
  function wC(t63) {
    return Iu(t63) && om(t63) == CC;
  }
  function J3(t63) {
    if (!So(t63) || dV(t63)) return false;
    var e = Hg(t63) ? w3 : h3;
    return e.test(vV(t63));
  }
  function Q3(t63) {
    return Iu(t63) && VC(t63.length) && !!et[om(t63)];
  }
  function eV(t63) {
    if (!So(t63)) return yV(t63);
    var e = BC(t63), r4 = [];
    for (var n in t63) n == "constructor" && (e || !Un.call(t63, n)) || r4.push(n);
    return r4;
  }
  function FC(t63, e, r4, n, i) {
    t63 !== e && K3(e, function(o, a) {
      if (i || (i = new Na()), So(o)) tV(t63, e, a, r4, FC, n, i);
      else {
        var s4 = n ? n(zg(t63, a), o, a + "", t63, e, i) : void 0;
        s4 === void 0 && (s4 = o), Bg(t63, a, s4);
      }
    }, NC);
  }
  function tV(t63, e, r4, n, i, o, a) {
    var s4 = zg(t63, r4), l = zg(e, r4), u4 = a.get(l);
    if (u4) {
      Bg(t63, r4, u4);
      return;
    }
    var c = o ? o(s4, l, r4 + "", t63, e, a) : void 0, p = c === void 0;
    if (p) {
      var h = Ug(l), f = !h && zC(l), d = !h && !f && UC(l);
      c = l, h || f || d ? Ug(s4) ? c = s4 : PV(s4) ? c = sV(s4) : f ? (p = false, c = iV(l, true)) : d ? (p = false, c = aV(l, true)) : c = [] : wV(l) || Vg(l) ? (c = s4, Vg(s4) ? c = TV(s4) : (!So(s4) || Hg(s4)) && (c = hV(l))) : p = false;
    }
    p && (a.set(l, c), i(c, l, n, o, a), a.delete(l)), Bg(t63, r4, c);
  }
  function rV(t63, e) {
    return bV(xV(t63, e, GC), t63 + "");
  }
  var nV = tm ? function(t63, e) {
    return tm(t63, "toString", { configurable: true, enumerable: false, value: CV(e), writable: true });
  } : GC;
  function iV(t63, e) {
    if (e) return t63.slice();
    var r4 = t63.length, n = _C ? _C(r4) : new t63.constructor(r4);
    return t63.copy(n), n;
  }
  function oV(t63) {
    var e = new t63.constructor(t63.byteLength);
    return new bC(e).set(new bC(t63)), e;
  }
  function aV(t63, e) {
    var r4 = e ? oV(t63.buffer) : t63.buffer;
    return new t63.constructor(r4, t63.byteOffset, t63.length);
  }
  function sV(t63, e) {
    var r4 = -1, n = t63.length;
    for (e || (e = Array(n)); ++r4 < n; ) e[r4] = t63[r4];
    return e;
  }
  function lV(t63, e, r4, n) {
    var i = !r4;
    r4 || (r4 = {});
    for (var o = -1, a = e.length; ++o < a; ) {
      var s4 = e[o], l = n ? n(r4[s4], t63[s4], s4, r4, t63) : void 0;
      l === void 0 && (l = t63[s4]), i ? Ng(r4, s4, l) : $3(r4, s4, l);
    }
    return r4;
  }
  function uV(t63) {
    return rV(function(e, r4) {
      var n = -1, i = r4.length, o = i > 1 ? r4[i - 1] : void 0, a = i > 2 ? r4[2] : void 0;
      for (o = t63.length > 3 && typeof o == "function" ? (i--, o) : void 0, a && fV(r4[0], r4[1], a) && (o = i < 3 ? void 0 : o, i = 1), e = Object(e); ++n < i; ) {
        var s4 = r4[n];
        s4 && t63(e, s4, n, o);
      }
      return e;
    });
  }
  function cV(t63) {
    return function(e, r4, n) {
      for (var i = -1, o = Object(e), a = n(e), s4 = a.length; s4--; ) {
        var l = a[t63 ? s4 : ++i];
        if (r4(o[l], l, o) === false) break;
      }
      return e;
    };
  }
  function am(t63, e) {
    var r4 = t63.__data__;
    return mV(e) ? r4[typeof e == "string" ? "string" : "hash"] : r4.map;
  }
  function Gg(t63, e) {
    var r4 = x3(t63, e);
    return J3(r4) ? r4 : void 0;
  }
  function pV(t63) {
    var e = Un.call(t63, wo), r4 = t63[wo];
    try {
      t63[wo] = void 0;
      var n = true;
    } catch {
    }
    var i = DC.call(t63);
    return n && (e ? t63[wo] = r4 : delete t63[wo]), i;
  }
  function hV(t63) {
    return typeof t63.constructor == "function" && !BC(t63) ? I3(RC(t63)) : {};
  }
  function OC(t63, e) {
    var r4 = typeof t63;
    return e = e ?? SC, !!e && (r4 == "number" || r4 != "symbol" && f3.test(t63)) && t63 > -1 && t63 % 1 == 0 && t63 < e;
  }
  function fV(t63, e, r4) {
    if (!So(r4)) return false;
    var n = typeof e;
    return (n == "number" ? jg(r4) && OC(e, r4.length) : n == "string" && e in r4) ? sm(r4[e], t63) : false;
  }
  function mV(t63) {
    var e = typeof t63;
    return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t63 !== "__proto__" : t63 === null;
  }
  function dV(t63) {
    return !!gC && gC in t63;
  }
  function BC(t63) {
    var e = t63 && t63.constructor, r4 = typeof e == "function" && e.prototype || rm;
    return t63 === r4;
  }
  function yV(t63) {
    var e = [];
    if (t63 != null) for (var r4 in Object(t63)) e.push(r4);
    return e;
  }
  function gV(t63) {
    return DC.call(t63);
  }
  function xV(t63, e, r4) {
    return e = PC(e === void 0 ? t63.length - 1 : e, 0), function() {
      for (var n = arguments, i = -1, o = PC(n.length - e, 0), a = Array(o); ++i < o; ) a[i] = n[e + i];
      i = -1;
      for (var s4 = Array(e + 1); ++i < e; ) s4[i] = n[i];
      return s4[e] = r4(a), d3(t63, this, s4);
    };
  }
  function zg(t63, e) {
    if (!(e === "constructor" && typeof t63[e] == "function") && e != "__proto__") return t63[e];
  }
  var bV = _V(nV);
  function _V(t63) {
    var e = 0, r4 = 0;
    return function() {
      var n = M3(), i = zz - (n - r4);
      if (r4 = n, i > 0) {
        if (++e >= Bz) return arguments[0];
      } else e = 0;
      return t63.apply(void 0, arguments);
    };
  }
  function vV(t63) {
    if (t63 != null) {
      try {
        return nm.call(t63);
      } catch {
      }
      try {
        return t63 + "";
      } catch {
      }
    }
    return "";
  }
  function sm(t63, e) {
    return t63 === e || t63 !== t63 && e !== e;
  }
  var Vg = wC(/* @__PURE__ */ (function() {
    return arguments;
  })()) ? wC : function(t63) {
    return Iu(t63) && Un.call(t63, "callee") && !T3.call(t63, "callee");
  }, Ug = Array.isArray;
  function jg(t63) {
    return t63 != null && VC(t63.length) && !Hg(t63);
  }
  function PV(t63) {
    return Iu(t63) && jg(t63);
  }
  var zC = C3 || MV;
  function Hg(t63) {
    if (!So(t63)) return false;
    var e = om(t63);
    return e == MC || e == Hz || e == Uz || e == Yz;
  }
  function VC(t63) {
    return typeof t63 == "number" && t63 > -1 && t63 % 1 == 0 && t63 <= SC;
  }
  function So(t63) {
    var e = typeof t63;
    return t63 != null && (e == "object" || e == "function");
  }
  function Iu(t63) {
    return t63 != null && typeof t63 == "object";
  }
  function wV(t63) {
    if (!Iu(t63) || om(t63) != IC) return false;
    var e = RC(t63);
    if (e === null) return true;
    var r4 = Un.call(e, "constructor") && e.constructor;
    return typeof r4 == "function" && r4 instanceof r4 && nm.call(r4) == P3;
  }
  var UC = yC ? g3(yC) : Q3;
  function TV(t63) {
    return lV(t63, NC(t63));
  }
  function NC(t63) {
    return jg(t63) ? W3(t63, true) : eV(t63);
  }
  var SV = uV(function(t63, e, r4) {
    FC(t63, e, r4);
  });
  function CV(t63) {
    return function() {
      return t63;
    };
  }
  function GC(t63) {
    return t63;
  }
  function MV() {
    return false;
  }
  Va.exports = SV;
});
var gM = q((X1e, Fu) => {
  "use strict";
  $i();
  var qV = false, Mo = false, cM = true, pM = false, y = {}, hM = false;
  typeof Fu < "u" && Fu.exports ? (Fu.exports = y, hM = true) : typeof document < "u" ? window.ClipperLib = y : self.ClipperLib = y;
  var ym;
  hM ? (St = "chrome", ym = "Netscape") : (St = navigator.userAgent.toString().toLowerCase(), ym = navigator.appName);
  var St, Me = {};
  St.indexOf("chrome") != -1 && St.indexOf("chromium") == -1 ? Me.chrome = 1 : Me.chrome = 0;
  St.indexOf("chromium") != -1 ? Me.chromium = 1 : Me.chromium = 0;
  St.indexOf("safari") != -1 && St.indexOf("chrome") == -1 && St.indexOf("chromium") == -1 ? Me.safari = 1 : Me.safari = 0;
  St.indexOf("firefox") != -1 ? Me.firefox = 1 : Me.firefox = 0;
  St.indexOf("firefox/17") != -1 ? Me.firefox17 = 1 : Me.firefox17 = 0;
  St.indexOf("firefox/15") != -1 ? Me.firefox15 = 1 : Me.firefox15 = 0;
  St.indexOf("firefox/3") != -1 ? Me.firefox3 = 1 : Me.firefox3 = 0;
  St.indexOf("opera") != -1 ? Me.opera = 1 : Me.opera = 0;
  St.indexOf("msie 10") != -1 ? Me.msie10 = 1 : Me.msie10 = 0;
  St.indexOf("msie 9") != -1 ? Me.msie9 = 1 : Me.msie9 = 0;
  St.indexOf("msie 8") != -1 ? Me.msie8 = 1 : Me.msie8 = 0;
  St.indexOf("msie 7") != -1 ? Me.msie7 = 1 : Me.msie7 = 0;
  St.indexOf("msie ") != -1 ? Me.msie = 1 : Me.msie = 0;
  y.biginteger_used = null;
  var Ai, YV = 244837814094590, lM = (YV & 16777215) == 15715070;
  function j(t63, e, r3) {
    y.biginteger_used = 1, t63 != null && (typeof t63 == "number" && typeof e > "u" ? this.fromInt(t63) : typeof t63 == "number" ? this.fromNumber(t63, e, r3) : e == null && typeof t63 != "string" ? this.fromString(t63, 256) : this.fromString(t63, e));
  }
  function ke2() {
    return new j(null);
  }
  function WV(t63, e, r3, n, i, o) {
    for (; --o >= 0; ) {
      var a = e * this[t63++] + r3[n] + i;
      i = Math.floor(a / 67108864), r3[n++] = a & 67108863;
    }
    return i;
  }
  function $V(t63, e, r3, n, i, o) {
    for (var a = e & 32767, s3 = e >> 15; --o >= 0; ) {
      var l = this[t63] & 32767, u3 = this[t63++] >> 15, c = s3 * l + u3 * a;
      l = a * l + ((c & 32767) << 15) + r3[n] + (i & 1073741823), i = (l >>> 30) + (c >>> 15) + s3 * u3 + (i >>> 30), r3[n++] = l & 1073741823;
    }
    return i;
  }
  function KV(t63, e, r3, n, i, o) {
    for (var a = e & 16383, s3 = e >> 14; --o >= 0; ) {
      var l = this[t63] & 16383, u3 = this[t63++] >> 14, c = s3 * l + u3 * a;
      l = a * l + ((c & 16383) << 14) + r3[n] + i, i = (l >> 28) + (c >> 14) + s3 * u3, r3[n++] = l & 268435455;
    }
    return i;
  }
  lM && ym == "Microsoft Internet Explorer" ? (j.prototype.am = $V, Ai = 30) : lM && ym != "Netscape" ? (j.prototype.am = WV, Ai = 26) : (j.prototype.am = KV, Ai = 28);
  j.prototype.DB = Ai;
  j.prototype.DM = (1 << Ai) - 1;
  j.prototype.DV = 1 << Ai;
  var Qg = 52;
  j.prototype.FV = Math.pow(2, Qg);
  j.prototype.F1 = Qg - Ai;
  j.prototype.F2 = 2 * Ai - Qg;
  var JV = "0123456789abcdefghijklmnopqrstuvwxyz", xm = new Array(), Za, Nr;
  Za = 48;
  for (Nr = 0; Nr <= 9; ++Nr) xm[Za++] = Nr;
  Za = 97;
  for (Nr = 10; Nr < 36; ++Nr) xm[Za++] = Nr;
  Za = 65;
  for (Nr = 10; Nr < 36; ++Nr) xm[Za++] = Nr;
  function uM(t63) {
    return JV.charAt(t63);
  }
  function fM(t63, e) {
    var r3 = xm[t63.charCodeAt(e)];
    return r3 ?? -1;
  }
  function QV(t63) {
    for (var e = this.t - 1; e >= 0; --e) t63[e] = this[e];
    t63.t = this.t, t63.s = this.s;
  }
  function eU(t63) {
    this.t = 1, this.s = t63 < 0 ? -1 : 0, t63 > 0 ? this[0] = t63 : t63 < -1 ? this[0] = t63 + this.DV : this.t = 0;
  }
  function Ii(t63) {
    var e = ke2();
    return e.fromInt(t63), e;
  }
  function tU(t63, e) {
    var r3;
    if (e == 16) r3 = 4;
    else if (e == 8) r3 = 3;
    else if (e == 256) r3 = 8;
    else if (e == 2) r3 = 1;
    else if (e == 32) r3 = 5;
    else if (e == 4) r3 = 2;
    else {
      this.fromRadix(t63, e);
      return;
    }
    this.t = 0, this.s = 0;
    for (var n = t63.length, i = false, o = 0; --n >= 0; ) {
      var a = r3 == 8 ? t63[n] & 255 : fM(t63, n);
      if (a < 0) {
        t63.charAt(n) == "-" && (i = true);
        continue;
      }
      i = false, o == 0 ? this[this.t++] = a : o + r3 > this.DB ? (this[this.t - 1] |= (a & (1 << this.DB - o) - 1) << o, this[this.t++] = a >> this.DB - o) : this[this.t - 1] |= a << o, o += r3, o >= this.DB && (o -= this.DB);
    }
    r3 == 8 && (t63[0] & 128) != 0 && (this.s = -1, o > 0 && (this[this.t - 1] |= (1 << this.DB - o) - 1 << o)), this.clamp(), i && j.ZERO.subTo(this, this);
  }
  function rU() {
    for (var t63 = this.s & this.DM; this.t > 0 && this[this.t - 1] == t63; ) --this.t;
  }
  function nU(t63) {
    if (this.s < 0) return "-" + this.negate().toString(t63);
    var e;
    if (t63 == 16) e = 4;
    else if (t63 == 8) e = 3;
    else if (t63 == 2) e = 1;
    else if (t63 == 32) e = 5;
    else if (t63 == 4) e = 2;
    else return this.toRadix(t63);
    var r3 = (1 << e) - 1, n, i = false, o = "", a = this.t, s3 = this.DB - a * this.DB % e;
    if (a-- > 0) for (s3 < this.DB && (n = this[a] >> s3) > 0 && (i = true, o = uM(n)); a >= 0; ) s3 < e ? (n = (this[a] & (1 << s3) - 1) << e - s3, n |= this[--a] >> (s3 += this.DB - e)) : (n = this[a] >> (s3 -= e) & r3, s3 <= 0 && (s3 += this.DB, --a)), n > 0 && (i = true), i && (o += uM(n));
    return i ? o : "0";
  }
  function iU() {
    var t63 = ke2();
    return j.ZERO.subTo(this, t63), t63;
  }
  function oU() {
    return this.s < 0 ? this.negate() : this;
  }
  function aU(t63) {
    var e = this.s - t63.s;
    if (e != 0) return e;
    var r3 = this.t;
    if (e = r3 - t63.t, e != 0) return this.s < 0 ? -e : e;
    for (; --r3 >= 0; ) if ((e = this[r3] - t63[r3]) != 0) return e;
    return 0;
  }
  function bm(t63) {
    var e = 1, r3;
    return (r3 = t63 >>> 16) != 0 && (t63 = r3, e += 16), (r3 = t63 >> 8) != 0 && (t63 = r3, e += 8), (r3 = t63 >> 4) != 0 && (t63 = r3, e += 4), (r3 = t63 >> 2) != 0 && (t63 = r3, e += 2), (r3 = t63 >> 1) != 0 && (t63 = r3, e += 1), e;
  }
  function sU() {
    return this.t <= 0 ? 0 : this.DB * (this.t - 1) + bm(this[this.t - 1] ^ this.s & this.DM);
  }
  function lU(t63, e) {
    var r3;
    for (r3 = this.t - 1; r3 >= 0; --r3) e[r3 + t63] = this[r3];
    for (r3 = t63 - 1; r3 >= 0; --r3) e[r3] = 0;
    e.t = this.t + t63, e.s = this.s;
  }
  function uU(t63, e) {
    for (var r3 = t63; r3 < this.t; ++r3) e[r3 - t63] = this[r3];
    e.t = Math.max(this.t - t63, 0), e.s = this.s;
  }
  function cU(t63, e) {
    var r3 = t63 % this.DB, n = this.DB - r3, i = (1 << n) - 1, o = Math.floor(t63 / this.DB), a = this.s << r3 & this.DM, s3;
    for (s3 = this.t - 1; s3 >= 0; --s3) e[s3 + o + 1] = this[s3] >> n | a, a = (this[s3] & i) << r3;
    for (s3 = o - 1; s3 >= 0; --s3) e[s3] = 0;
    e[o] = a, e.t = this.t + o + 1, e.s = this.s, e.clamp();
  }
  function pU(t63, e) {
    e.s = this.s;
    var r3 = Math.floor(t63 / this.DB);
    if (r3 >= this.t) {
      e.t = 0;
      return;
    }
    var n = t63 % this.DB, i = this.DB - n, o = (1 << n) - 1;
    e[0] = this[r3] >> n;
    for (var a = r3 + 1; a < this.t; ++a) e[a - r3 - 1] |= (this[a] & o) << i, e[a - r3] = this[a] >> n;
    n > 0 && (e[this.t - r3 - 1] |= (this.s & o) << i), e.t = this.t - r3, e.clamp();
  }
  function hU(t63, e) {
    for (var r3 = 0, n = 0, i = Math.min(t63.t, this.t); r3 < i; ) n += this[r3] - t63[r3], e[r3++] = n & this.DM, n >>= this.DB;
    if (t63.t < this.t) {
      for (n -= t63.s; r3 < this.t; ) n += this[r3], e[r3++] = n & this.DM, n >>= this.DB;
      n += this.s;
    } else {
      for (n += this.s; r3 < t63.t; ) n -= t63[r3], e[r3++] = n & this.DM, n >>= this.DB;
      n -= t63.s;
    }
    e.s = n < 0 ? -1 : 0, n < -1 ? e[r3++] = this.DV + n : n > 0 && (e[r3++] = n), e.t = r3, e.clamp();
  }
  function fU(t63, e) {
    var r3 = this.abs(), n = t63.abs(), i = r3.t;
    for (e.t = i + n.t; --i >= 0; ) e[i] = 0;
    for (i = 0; i < n.t; ++i) e[i + r3.t] = r3.am(0, n[i], e, i, 0, r3.t);
    e.s = 0, e.clamp(), this.s != t63.s && j.ZERO.subTo(e, e);
  }
  function mU(t63) {
    for (var e = this.abs(), r3 = t63.t = 2 * e.t; --r3 >= 0; ) t63[r3] = 0;
    for (r3 = 0; r3 < e.t - 1; ++r3) {
      var n = e.am(r3, e[r3], t63, 2 * r3, 0, 1);
      (t63[r3 + e.t] += e.am(r3 + 1, 2 * e[r3], t63, 2 * r3 + 1, n, e.t - r3 - 1)) >= e.DV && (t63[r3 + e.t] -= e.DV, t63[r3 + e.t + 1] = 1);
    }
    t63.t > 0 && (t63[t63.t - 1] += e.am(r3, e[r3], t63, 2 * r3, 0, 1)), t63.s = 0, t63.clamp();
  }
  function dU(t63, e, r3) {
    var n = t63.abs();
    if (!(n.t <= 0)) {
      var i = this.abs();
      if (i.t < n.t) {
        e?.fromInt(0), r3 != null && this.copyTo(r3);
        return;
      }
      r3 == null && (r3 = ke2());
      var o = ke2(), a = this.s, s3 = t63.s, l = this.DB - bm(n[n.t - 1]);
      l > 0 ? (n.lShiftTo(l, o), i.lShiftTo(l, r3)) : (n.copyTo(o), i.copyTo(r3));
      var u3 = o.t, c = o[u3 - 1];
      if (c != 0) {
        var p = c * (1 << this.F1) + (u3 > 1 ? o[u3 - 2] >> this.F2 : 0), h = this.FV / p, f = (1 << this.F1) / p, d = 1 << this.F2, g = r3.t, x = g - u3, b = e ?? ke2();
        for (o.dlShiftTo(x, b), r3.compareTo(b) >= 0 && (r3[r3.t++] = 1, r3.subTo(b, r3)), j.ONE.dlShiftTo(u3, b), b.subTo(o, o); o.t < u3; ) o[o.t++] = 0;
        for (; --x >= 0; ) {
          var v3 = r3[--g] == c ? this.DM : Math.floor(r3[g] * h + (r3[g - 1] + d) * f);
          if ((r3[g] += o.am(0, v3, r3, x, 0, u3)) < v3) for (o.dlShiftTo(x, b), r3.subTo(b, r3); r3[g] < --v3; ) r3.subTo(b, r3);
        }
        e != null && (r3.drShiftTo(u3, e), a != s3 && j.ZERO.subTo(e, e)), r3.t = u3, r3.clamp(), l > 0 && r3.rShiftTo(l, r3), a < 0 && j.ZERO.subTo(r3, r3);
      }
    }
  }
  function yU(t63) {
    var e = ke2();
    return this.abs().divRemTo(t63, null, e), this.s < 0 && e.compareTo(j.ZERO) > 0 && t63.subTo(e, e), e;
  }
  function Io(t63) {
    this.m = t63;
  }
  function gU(t63) {
    return t63.s < 0 || t63.compareTo(this.m) >= 0 ? t63.mod(this.m) : t63;
  }
  function xU(t63) {
    return t63;
  }
  function bU(t63) {
    t63.divRemTo(this.m, null, t63);
  }
  function _U(t63, e, r3) {
    t63.multiplyTo(e, r3), this.reduce(r3);
  }
  function vU(t63, e) {
    t63.squareTo(e), this.reduce(e);
  }
  Io.prototype.convert = gU;
  Io.prototype.revert = xU;
  Io.prototype.reduce = bU;
  Io.prototype.mulTo = _U;
  Io.prototype.sqrTo = vU;
  function PU() {
    if (this.t < 1) return 0;
    var t63 = this[0];
    if ((t63 & 1) == 0) return 0;
    var e = t63 & 3;
    return e = e * (2 - (t63 & 15) * e) & 15, e = e * (2 - (t63 & 255) * e) & 255, e = e * (2 - ((t63 & 65535) * e & 65535)) & 65535, e = e * (2 - t63 * e % this.DV) % this.DV, e > 0 ? this.DV - e : -e;
  }
  function Ao(t63) {
    this.m = t63, this.mp = t63.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << t63.DB - 15) - 1, this.mt2 = 2 * t63.t;
  }
  function wU(t63) {
    var e = ke2();
    return t63.abs().dlShiftTo(this.m.t, e), e.divRemTo(this.m, null, e), t63.s < 0 && e.compareTo(j.ZERO) > 0 && this.m.subTo(e, e), e;
  }
  function TU(t63) {
    var e = ke2();
    return t63.copyTo(e), this.reduce(e), e;
  }
  function SU(t63) {
    for (; t63.t <= this.mt2; ) t63[t63.t++] = 0;
    for (var e = 0; e < this.m.t; ++e) {
      var r3 = t63[e] & 32767, n = r3 * this.mpl + ((r3 * this.mph + (t63[e] >> 15) * this.mpl & this.um) << 15) & t63.DM;
      for (r3 = e + this.m.t, t63[r3] += this.m.am(0, n, t63, e, 0, this.m.t); t63[r3] >= t63.DV; ) t63[r3] -= t63.DV, t63[++r3]++;
    }
    t63.clamp(), t63.drShiftTo(this.m.t, t63), t63.compareTo(this.m) >= 0 && t63.subTo(this.m, t63);
  }
  function CU(t63, e) {
    t63.squareTo(e), this.reduce(e);
  }
  function MU(t63, e, r3) {
    t63.multiplyTo(e, r3), this.reduce(r3);
  }
  Ao.prototype.convert = wU;
  Ao.prototype.revert = TU;
  Ao.prototype.reduce = SU;
  Ao.prototype.mulTo = MU;
  Ao.prototype.sqrTo = CU;
  function IU() {
    return (this.t > 0 ? this[0] & 1 : this.s) == 0;
  }
  function AU(t63, e) {
    if (t63 > 4294967295 || t63 < 1) return j.ONE;
    var r3 = ke2(), n = ke2(), i = e.convert(this), o = bm(t63) - 1;
    for (i.copyTo(r3); --o >= 0; ) if (e.sqrTo(r3, n), (t63 & 1 << o) > 0) e.mulTo(n, i, r3);
    else {
      var a = r3;
      r3 = n, n = a;
    }
    return e.revert(r3);
  }
  function EU(t63, e) {
    var r3;
    return t63 < 256 || e.isEven() ? r3 = new Io(e) : r3 = new Ao(e), this.exp(t63, r3);
  }
  j.prototype.copyTo = QV;
  j.prototype.fromInt = eU;
  j.prototype.fromString = tU;
  j.prototype.clamp = rU;
  j.prototype.dlShiftTo = lU;
  j.prototype.drShiftTo = uU;
  j.prototype.lShiftTo = cU;
  j.prototype.rShiftTo = pU;
  j.prototype.subTo = hU;
  j.prototype.multiplyTo = fU;
  j.prototype.squareTo = mU;
  j.prototype.divRemTo = dU;
  j.prototype.invDigit = PU;
  j.prototype.isEven = IU;
  j.prototype.exp = AU;
  j.prototype.toString = nU;
  j.prototype.negate = iU;
  j.prototype.abs = oU;
  j.prototype.compareTo = aU;
  j.prototype.bitLength = sU;
  j.prototype.mod = yU;
  j.prototype.modPowInt = EU;
  j.ZERO = Ii(0);
  j.ONE = Ii(1);
  function LU() {
    var t63 = ke2();
    return this.copyTo(t63), t63;
  }
  function DU() {
    if (this.s < 0) {
      if (this.t == 1) return this[0] - this.DV;
      if (this.t == 0) return -1;
    } else {
      if (this.t == 1) return this[0];
      if (this.t == 0) return 0;
    }
    return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
  }
  function RU() {
    return this.t == 0 ? this.s : this[0] << 24 >> 24;
  }
  function kU() {
    return this.t == 0 ? this.s : this[0] << 16 >> 16;
  }
  function FU(t63) {
    return Math.floor(Math.LN2 * this.DB / Math.log(t63));
  }
  function OU() {
    return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this[0] <= 0 ? 0 : 1;
  }
  function BU(t63) {
    if (t63 == null && (t63 = 10), this.signum() == 0 || t63 < 2 || t63 > 36) return "0";
    var e = this.chunkSize(t63), r3 = Math.pow(t63, e), n = Ii(r3), i = ke2(), o = ke2(), a = "";
    for (this.divRemTo(n, i, o); i.signum() > 0; ) a = (r3 + o.intValue()).toString(t63).substr(1) + a, i.divRemTo(n, i, o);
    return o.intValue().toString(t63) + a;
  }
  function zU(t63, e) {
    this.fromInt(0), e == null && (e = 10);
    for (var r3 = this.chunkSize(e), n = Math.pow(e, r3), i = false, o = 0, a = 0, s3 = 0; s3 < t63.length; ++s3) {
      var l = fM(t63, s3);
      if (l < 0) {
        t63.charAt(s3) == "-" && this.signum() == 0 && (i = true);
        continue;
      }
      a = e * a + l, ++o >= r3 && (this.dMultiply(n), this.dAddOffset(a, 0), o = 0, a = 0);
    }
    o > 0 && (this.dMultiply(Math.pow(e, o)), this.dAddOffset(a, 0)), i && j.ZERO.subTo(this, this);
  }
  function VU(t63, e, r3) {
    if (typeof e == "number") if (t63 < 2) this.fromInt(1);
    else for (this.fromNumber(t63, r3), this.testBit(t63 - 1) || this.bitwiseTo(j.ONE.shiftLeft(t63 - 1), ex, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(e); ) this.dAddOffset(2, 0), this.bitLength() > t63 && this.subTo(j.ONE.shiftLeft(t63 - 1), this);
    else {
      var n = new Array(), i = t63 & 7;
      n.length = (t63 >> 3) + 1, e.nextBytes(n), i > 0 ? n[0] &= (1 << i) - 1 : n[0] = 0, this.fromString(n, 256);
    }
  }
  function UU() {
    var t63 = this.t, e = new Array();
    e[0] = this.s;
    var r3 = this.DB - t63 * this.DB % 8, n, i = 0;
    if (t63-- > 0) for (r3 < this.DB && (n = this[t63] >> r3) != (this.s & this.DM) >> r3 && (e[i++] = n | this.s << this.DB - r3); t63 >= 0; ) r3 < 8 ? (n = (this[t63] & (1 << r3) - 1) << 8 - r3, n |= this[--t63] >> (r3 += this.DB - 8)) : (n = this[t63] >> (r3 -= 8) & 255, r3 <= 0 && (r3 += this.DB, --t63)), (n & 128) != 0 && (n |= -256), i == 0 && (this.s & 128) != (n & 128) && ++i, (i > 0 || n != this.s) && (e[i++] = n);
    return e;
  }
  function NU(t63) {
    return this.compareTo(t63) == 0;
  }
  function GU(t63) {
    return this.compareTo(t63) < 0 ? this : t63;
  }
  function jU(t63) {
    return this.compareTo(t63) > 0 ? this : t63;
  }
  function HU(t63, e, r3) {
    var n, i, o = Math.min(t63.t, this.t);
    for (n = 0; n < o; ++n) r3[n] = e(this[n], t63[n]);
    if (t63.t < this.t) {
      for (i = t63.s & this.DM, n = o; n < this.t; ++n) r3[n] = e(this[n], i);
      r3.t = this.t;
    } else {
      for (i = this.s & this.DM, n = o; n < t63.t; ++n) r3[n] = e(i, t63[n]);
      r3.t = t63.t;
    }
    r3.s = e(this.s, t63.s), r3.clamp();
  }
  function XU(t63, e) {
    return t63 & e;
  }
  function ZU(t63) {
    var e = ke2();
    return this.bitwiseTo(t63, XU, e), e;
  }
  function ex(t63, e) {
    return t63 | e;
  }
  function qU(t63) {
    var e = ke2();
    return this.bitwiseTo(t63, ex, e), e;
  }
  function mM(t63, e) {
    return t63 ^ e;
  }
  function YU(t63) {
    var e = ke2();
    return this.bitwiseTo(t63, mM, e), e;
  }
  function dM(t63, e) {
    return t63 & ~e;
  }
  function WU(t63) {
    var e = ke2();
    return this.bitwiseTo(t63, dM, e), e;
  }
  function $U() {
    for (var t63 = ke2(), e = 0; e < this.t; ++e) t63[e] = this.DM & ~this[e];
    return t63.t = this.t, t63.s = ~this.s, t63;
  }
  function KU(t63) {
    var e = ke2();
    return t63 < 0 ? this.rShiftTo(-t63, e) : this.lShiftTo(t63, e), e;
  }
  function JU(t63) {
    var e = ke2();
    return t63 < 0 ? this.lShiftTo(-t63, e) : this.rShiftTo(t63, e), e;
  }
  function QU(t63) {
    if (t63 == 0) return -1;
    var e = 0;
    return (t63 & 65535) == 0 && (t63 >>= 16, e += 16), (t63 & 255) == 0 && (t63 >>= 8, e += 8), (t63 & 15) == 0 && (t63 >>= 4, e += 4), (t63 & 3) == 0 && (t63 >>= 2, e += 2), (t63 & 1) == 0 && ++e, e;
  }
  function e4() {
    for (var t63 = 0; t63 < this.t; ++t63) if (this[t63] != 0) return t63 * this.DB + QU(this[t63]);
    return this.s < 0 ? this.t * this.DB : -1;
  }
  function t410(t63) {
    for (var e = 0; t63 != 0; ) t63 &= t63 - 1, ++e;
    return e;
  }
  function r4() {
    for (var t63 = 0, e = this.s & this.DM, r3 = 0; r3 < this.t; ++r3) t63 += t410(this[r3] ^ e);
    return t63;
  }
  function n4(t63) {
    var e = Math.floor(t63 / this.DB);
    return e >= this.t ? this.s != 0 : (this[e] & 1 << t63 % this.DB) != 0;
  }
  function i4(t63, e) {
    var r3 = j.ONE.shiftLeft(t63);
    return this.bitwiseTo(r3, e, r3), r3;
  }
  function o4(t63) {
    return this.changeBit(t63, ex);
  }
  function a4(t63) {
    return this.changeBit(t63, dM);
  }
  function s4(t63) {
    return this.changeBit(t63, mM);
  }
  function l4(t63, e) {
    for (var r3 = 0, n = 0, i = Math.min(t63.t, this.t); r3 < i; ) n += this[r3] + t63[r3], e[r3++] = n & this.DM, n >>= this.DB;
    if (t63.t < this.t) {
      for (n += t63.s; r3 < this.t; ) n += this[r3], e[r3++] = n & this.DM, n >>= this.DB;
      n += this.s;
    } else {
      for (n += this.s; r3 < t63.t; ) n += t63[r3], e[r3++] = n & this.DM, n >>= this.DB;
      n += t63.s;
    }
    e.s = n < 0 ? -1 : 0, n > 0 ? e[r3++] = n : n < -1 && (e[r3++] = this.DV + n), e.t = r3, e.clamp();
  }
  function u4(t63) {
    var e = ke2();
    return this.addTo(t63, e), e;
  }
  function c4(t63) {
    var e = ke2();
    return this.subTo(t63, e), e;
  }
  function p4(t63) {
    var e = ke2();
    return this.multiplyTo(t63, e), e;
  }
  function h4() {
    var t63 = ke2();
    return this.squareTo(t63), t63;
  }
  function f4(t63) {
    var e = ke2();
    return this.divRemTo(t63, e, null), e;
  }
  function m4(t63) {
    var e = ke2();
    return this.divRemTo(t63, null, e), e;
  }
  function d4(t63) {
    var e = ke2(), r3 = ke2();
    return this.divRemTo(t63, e, r3), new Array(e, r3);
  }
  function y4(t63) {
    this[this.t] = this.am(0, t63 - 1, this, 0, 0, this.t), ++this.t, this.clamp();
  }
  function g4(t63, e) {
    if (t63 != 0) {
      for (; this.t <= e; ) this[this.t++] = 0;
      for (this[e] += t63; this[e] >= this.DV; ) this[e] -= this.DV, ++e >= this.t && (this[this.t++] = 0), ++this[e];
    }
  }
  function Ou() {
  }
  function yM(t63) {
    return t63;
  }
  function x4(t63, e, r3) {
    t63.multiplyTo(e, r3);
  }
  function b4(t63, e) {
    t63.squareTo(e);
  }
  Ou.prototype.convert = yM;
  Ou.prototype.revert = yM;
  Ou.prototype.mulTo = x4;
  Ou.prototype.sqrTo = b4;
  function _4(t63) {
    return this.exp(t63, new Ou());
  }
  function v4(t63, e, r3) {
    var n = Math.min(this.t + t63.t, e);
    for (r3.s = 0, r3.t = n; n > 0; ) r3[--n] = 0;
    var i;
    for (i = r3.t - this.t; n < i; ++n) r3[n + this.t] = this.am(0, t63[n], r3, n, 0, this.t);
    for (i = Math.min(t63.t, e); n < i; ++n) this.am(0, t63[n], r3, n, 0, e - n);
    r3.clamp();
  }
  function P4(t63, e, r3) {
    --e;
    var n = r3.t = this.t + t63.t - e;
    for (r3.s = 0; --n >= 0; ) r3[n] = 0;
    for (n = Math.max(e - this.t, 0); n < t63.t; ++n) r3[this.t + n - e] = this.am(e - n, t63[n], r3, 0, 0, this.t + n - e);
    r3.clamp(), r3.drShiftTo(1, r3);
  }
  function qa(t63) {
    this.r2 = ke2(), this.q3 = ke2(), j.ONE.dlShiftTo(2 * t63.t, this.r2), this.mu = this.r2.divide(t63), this.m = t63;
  }
  function w4(t63) {
    if (t63.s < 0 || t63.t > 2 * this.m.t) return t63.mod(this.m);
    if (t63.compareTo(this.m) < 0) return t63;
    var e = ke2();
    return t63.copyTo(e), this.reduce(e), e;
  }
  function T4(t63) {
    return t63;
  }
  function S4(t63) {
    for (t63.drShiftTo(this.m.t - 1, this.r2), t63.t > this.m.t + 1 && (t63.t = this.m.t + 1, t63.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); t63.compareTo(this.r2) < 0; ) t63.dAddOffset(1, this.m.t + 1);
    for (t63.subTo(this.r2, t63); t63.compareTo(this.m) >= 0; ) t63.subTo(this.m, t63);
  }
  function C4(t63, e) {
    t63.squareTo(e), this.reduce(e);
  }
  function M4(t63, e, r3) {
    t63.multiplyTo(e, r3), this.reduce(r3);
  }
  qa.prototype.convert = w4;
  qa.prototype.revert = T4;
  qa.prototype.reduce = S4;
  qa.prototype.mulTo = M4;
  qa.prototype.sqrTo = C4;
  function I4(t63, e) {
    var r3 = t63.bitLength(), n, i = Ii(1), o;
    if (r3 <= 0) return i;
    r3 < 18 ? n = 1 : r3 < 48 ? n = 3 : r3 < 144 ? n = 4 : r3 < 768 ? n = 5 : n = 6, r3 < 8 ? o = new Io(e) : e.isEven() ? o = new qa(e) : o = new Ao(e);
    var a = new Array(), s3 = 3, l = n - 1, u3 = (1 << n) - 1;
    if (a[1] = o.convert(this), n > 1) {
      var c = ke2();
      for (o.sqrTo(a[1], c); s3 <= u3; ) a[s3] = ke2(), o.mulTo(c, a[s3 - 2], a[s3]), s3 += 2;
    }
    var p = t63.t - 1, h, f = true, d = ke2(), g;
    for (r3 = bm(t63[p]) - 1; p >= 0; ) {
      for (r3 >= l ? h = t63[p] >> r3 - l & u3 : (h = (t63[p] & (1 << r3 + 1) - 1) << l - r3, p > 0 && (h |= t63[p - 1] >> this.DB + r3 - l)), s3 = n; (h & 1) == 0; ) h >>= 1, --s3;
      if ((r3 -= s3) < 0 && (r3 += this.DB, --p), f) a[h].copyTo(i), f = false;
      else {
        for (; s3 > 1; ) o.sqrTo(i, d), o.sqrTo(d, i), s3 -= 2;
        s3 > 0 ? o.sqrTo(i, d) : (g = i, i = d, d = g), o.mulTo(d, a[h], i);
      }
      for (; p >= 0 && (t63[p] & 1 << r3) == 0; ) o.sqrTo(i, d), g = i, i = d, d = g, --r3 < 0 && (r3 = this.DB - 1, --p);
    }
    return o.revert(i);
  }
  function A4(t63) {
    var e = this.s < 0 ? this.negate() : this.clone(), r3 = t63.s < 0 ? t63.negate() : t63.clone();
    if (e.compareTo(r3) < 0) {
      var n = e;
      e = r3, r3 = n;
    }
    var i = e.getLowestSetBit(), o = r3.getLowestSetBit();
    if (o < 0) return e;
    for (i < o && (o = i), o > 0 && (e.rShiftTo(o, e), r3.rShiftTo(o, r3)); e.signum() > 0; ) (i = e.getLowestSetBit()) > 0 && e.rShiftTo(i, e), (i = r3.getLowestSetBit()) > 0 && r3.rShiftTo(i, r3), e.compareTo(r3) >= 0 ? (e.subTo(r3, e), e.rShiftTo(1, e)) : (r3.subTo(e, r3), r3.rShiftTo(1, r3));
    return o > 0 && r3.lShiftTo(o, r3), r3;
  }
  function E4(t63) {
    if (t63 <= 0) return 0;
    var e = this.DV % t63, r3 = this.s < 0 ? t63 - 1 : 0;
    if (this.t > 0) if (e == 0) r3 = this[0] % t63;
    else for (var n = this.t - 1; n >= 0; --n) r3 = (e * r3 + this[n]) % t63;
    return r3;
  }
  function L4(t63) {
    var e = t63.isEven();
    if (this.isEven() && e || t63.signum() == 0) return j.ZERO;
    for (var r3 = t63.clone(), n = this.clone(), i = Ii(1), o = Ii(0), a = Ii(0), s3 = Ii(1); r3.signum() != 0; ) {
      for (; r3.isEven(); ) r3.rShiftTo(1, r3), e ? ((!i.isEven() || !o.isEven()) && (i.addTo(this, i), o.subTo(t63, o)), i.rShiftTo(1, i)) : o.isEven() || o.subTo(t63, o), o.rShiftTo(1, o);
      for (; n.isEven(); ) n.rShiftTo(1, n), e ? ((!a.isEven() || !s3.isEven()) && (a.addTo(this, a), s3.subTo(t63, s3)), a.rShiftTo(1, a)) : s3.isEven() || s3.subTo(t63, s3), s3.rShiftTo(1, s3);
      r3.compareTo(n) >= 0 ? (r3.subTo(n, r3), e && i.subTo(a, i), o.subTo(s3, o)) : (n.subTo(r3, n), e && a.subTo(i, a), s3.subTo(o, s3));
    }
    if (n.compareTo(j.ONE) != 0) return j.ZERO;
    if (s3.compareTo(t63) >= 0) return s3.subtract(t63);
    if (s3.signum() < 0) s3.addTo(t63, s3);
    else return s3;
    return s3.signum() < 0 ? s3.add(t63) : s3;
  }
  var Xt = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997], D4 = (1 << 26) / Xt[Xt.length - 1];
  function R4(t63) {
    var e, r3 = this.abs();
    if (r3.t == 1 && r3[0] <= Xt[Xt.length - 1]) {
      for (e = 0; e < Xt.length; ++e) if (r3[0] == Xt[e]) return true;
      return false;
    }
    if (r3.isEven()) return false;
    for (e = 1; e < Xt.length; ) {
      for (var n = Xt[e], i = e + 1; i < Xt.length && n < D4; ) n *= Xt[i++];
      for (n = r3.modInt(n); e < i; ) if (n % Xt[e++] == 0) return false;
    }
    return r3.millerRabin(t63);
  }
  function k4(t63) {
    var e = this.subtract(j.ONE), r3 = e.getLowestSetBit();
    if (r3 <= 0) return false;
    var n = e.shiftRight(r3);
    t63 = t63 + 1 >> 1, t63 > Xt.length && (t63 = Xt.length);
    for (var i = ke2(), o = 0; o < t63; ++o) {
      i.fromInt(Xt[Math.floor(Math.random() * Xt.length)]);
      var a = i.modPow(n, this);
      if (a.compareTo(j.ONE) != 0 && a.compareTo(e) != 0) {
        for (var s3 = 1; s3++ < r3 && a.compareTo(e) != 0; ) if (a = a.modPowInt(2, this), a.compareTo(j.ONE) == 0) return false;
        if (a.compareTo(e) != 0) return false;
      }
    }
    return true;
  }
  j.prototype.chunkSize = FU;
  j.prototype.toRadix = BU;
  j.prototype.fromRadix = zU;
  j.prototype.fromNumber = VU;
  j.prototype.bitwiseTo = HU;
  j.prototype.changeBit = i4;
  j.prototype.addTo = l4;
  j.prototype.dMultiply = y4;
  j.prototype.dAddOffset = g4;
  j.prototype.multiplyLowerTo = v4;
  j.prototype.multiplyUpperTo = P4;
  j.prototype.modInt = E4;
  j.prototype.millerRabin = k4;
  j.prototype.clone = LU;
  j.prototype.intValue = DU;
  j.prototype.byteValue = RU;
  j.prototype.shortValue = kU;
  j.prototype.signum = OU;
  j.prototype.toByteArray = UU;
  j.prototype.equals = NU;
  j.prototype.min = GU;
  j.prototype.max = jU;
  j.prototype.and = ZU;
  j.prototype.or = qU;
  j.prototype.xor = YU;
  j.prototype.andNot = WU;
  j.prototype.not = $U;
  j.prototype.shiftLeft = KU;
  j.prototype.shiftRight = JU;
  j.prototype.getLowestSetBit = e4;
  j.prototype.bitCount = r4;
  j.prototype.testBit = n4;
  j.prototype.setBit = o4;
  j.prototype.clearBit = a4;
  j.prototype.flipBit = s4;
  j.prototype.add = u4;
  j.prototype.subtract = c4;
  j.prototype.multiply = p4;
  j.prototype.divide = f4;
  j.prototype.remainder = m4;
  j.prototype.divideAndRemainder = d4;
  j.prototype.modPow = I4;
  j.prototype.modInverse = L4;
  j.prototype.pow = _4;
  j.prototype.gcd = A4;
  j.prototype.isProbablePrime = R4;
  j.prototype.square = h4;
  var Ce = j;
  Ce.prototype.IsNegative = function() {
    return this.compareTo(Ce.ZERO) == -1;
  };
  Ce.op_Equality = function(t63, e) {
    return t63.compareTo(e) == 0;
  };
  Ce.op_Inequality = function(t63, e) {
    return t63.compareTo(e) != 0;
  };
  Ce.op_GreaterThan = function(t63, e) {
    return t63.compareTo(e) > 0;
  };
  Ce.op_LessThan = function(t63, e) {
    return t63.compareTo(e) < 0;
  };
  Ce.op_Addition = function(t63, e) {
    return new Ce(t63).add(new Ce(e));
  };
  Ce.op_Subtraction = function(t63, e) {
    return new Ce(t63).subtract(new Ce(e));
  };
  Ce.Int128Mul = function(t63, e) {
    return new Ce(t63).multiply(new Ce(e));
  };
  Ce.op_Division = function(t63, e) {
    return t63.divide(e);
  };
  Ce.prototype.ToDouble = function() {
    return parseFloat(this.toString());
  };
  typeof gm > "u" && (gm = function(t63, e) {
    var r3;
    if (typeof Object.getOwnPropertyNames > "u") {
      for (r3 in e.prototype) (typeof t63.prototype[r3] > "u" || t63.prototype[r3] == Object.prototype[r3]) && (t63.prototype[r3] = e.prototype[r3]);
      for (r3 in e) typeof t63[r3] > "u" && (t63[r3] = e[r3]);
      t63.$baseCtor = e;
    } else {
      for (var n = Object.getOwnPropertyNames(e.prototype), i = 0; i < n.length; i++) typeof Object.getOwnPropertyDescriptor(t63.prototype, n[i]) > "u" && Object.defineProperty(t63.prototype, n[i], Object.getOwnPropertyDescriptor(e.prototype, n[i]));
      for (r3 in e) typeof t63[r3] > "u" && (t63[r3] = e[r3]);
      t63.$baseCtor = e;
    }
  });
  var gm;
  y.Path = function() {
    return [];
  };
  y.Paths = function() {
    return [];
  };
  y.DoublePoint = function() {
    var t63 = arguments;
    this.X = 0, this.Y = 0, t63.length == 1 ? (this.X = t63[0].X, this.Y = t63[0].Y) : t63.length == 2 && (this.X = t63[0], this.Y = t63[1]);
  };
  y.DoublePoint0 = function() {
    this.X = 0, this.Y = 0;
  };
  y.DoublePoint1 = function(t63) {
    this.X = t63.X, this.Y = t63.Y;
  };
  y.DoublePoint2 = function(t63, e) {
    this.X = t63, this.Y = e;
  };
  y.PolyNode = function() {
    this.m_Parent = null, this.m_polygon = new y.Path(), this.m_Index = 0, this.m_jointype = 0, this.m_endtype = 0, this.m_Childs = [], this.IsOpen = false;
  };
  y.PolyNode.prototype.IsHoleNode = function() {
    for (var t63 = true, e = this.m_Parent; e !== null; ) t63 = !t63, e = e.m_Parent;
    return t63;
  };
  y.PolyNode.prototype.ChildCount = function() {
    return this.m_Childs.length;
  };
  y.PolyNode.prototype.Contour = function() {
    return this.m_polygon;
  };
  y.PolyNode.prototype.AddChild = function(t63) {
    var e = this.m_Childs.length;
    this.m_Childs.push(t63), t63.m_Parent = this, t63.m_Index = e;
  };
  y.PolyNode.prototype.GetNext = function() {
    return this.m_Childs.length > 0 ? this.m_Childs[0] : this.GetNextSiblingUp();
  };
  y.PolyNode.prototype.GetNextSiblingUp = function() {
    return this.m_Parent === null ? null : this.m_Index == this.m_Parent.m_Childs.length - 1 ? this.m_Parent.GetNextSiblingUp() : this.m_Parent.m_Childs[this.m_Index + 1];
  };
  y.PolyNode.prototype.Childs = function() {
    return this.m_Childs;
  };
  y.PolyNode.prototype.Parent = function() {
    return this.m_Parent;
  };
  y.PolyNode.prototype.IsHole = function() {
    return this.IsHoleNode();
  };
  y.PolyTree = function() {
    this.m_AllPolys = [], y.PolyNode.call(this);
  };
  y.PolyTree.prototype.Clear = function() {
    for (var t63 = 0, e = this.m_AllPolys.length; t63 < e; t63++) this.m_AllPolys[t63] = null;
    this.m_AllPolys.length = 0, this.m_Childs.length = 0;
  };
  y.PolyTree.prototype.GetFirst = function() {
    return this.m_Childs.length > 0 ? this.m_Childs[0] : null;
  };
  y.PolyTree.prototype.Total = function() {
    return this.m_AllPolys.length;
  };
  gm(y.PolyTree, y.PolyNode);
  y.Math_Abs_Int64 = y.Math_Abs_Int32 = y.Math_Abs_Double = function(t63) {
    return Math.abs(t63);
  };
  y.Math_Max_Int32_Int32 = function(t63, e) {
    return Math.max(t63, e);
  };
  Me.msie || Me.opera || Me.safari ? y.Cast_Int32 = function(t63) {
    return t63 | 0;
  } : y.Cast_Int32 = function(t63) {
    return ~~t63;
  };
  Me.chrome ? y.Cast_Int64 = function(t63) {
    return t63 < -2147483648 || t63 > 2147483647 ? t63 < 0 ? Math.ceil(t63) : Math.floor(t63) : ~~t63;
  } : Me.firefox && typeof Number.toInteger == "function" ? y.Cast_Int64 = function(t63) {
    return Number.toInteger(t63);
  } : Me.msie7 || Me.msie8 ? y.Cast_Int64 = function(t63) {
    return parseInt(t63, 10);
  } : Me.msie ? y.Cast_Int64 = function(t63) {
    return t63 < -2147483648 || t63 > 2147483647 ? t63 < 0 ? Math.ceil(t63) : Math.floor(t63) : t63 | 0;
  } : y.Cast_Int64 = function(t63) {
    return t63 < 0 ? Math.ceil(t63) : Math.floor(t63);
  };
  y.Clear = function(t63) {
    t63.length = 0;
  };
  y.PI = 3.141592653589793;
  y.PI2 = 2 * 3.141592653589793;
  y.IntPoint = function() {
    var t63 = arguments, e = t63.length;
    if (this.X = 0, this.Y = 0, Mo) if (this.Z = 0, e == 3) this.X = t63[0], this.Y = t63[1], this.Z = t63[2];
    else if (e == 2) this.X = t63[0], this.Y = t63[1], this.Z = 0;
    else if (e == 1) if (t63[0] instanceof y.DoublePoint) {
      var r3 = t63[0];
      this.X = y.Clipper.Round(r3.X), this.Y = y.Clipper.Round(r3.Y), this.Z = 0;
    } else {
      var n = t63[0];
      typeof n.Z > "u" && (n.Z = 0), this.X = n.X, this.Y = n.Y, this.Z = n.Z;
    }
    else this.X = 0, this.Y = 0, this.Z = 0;
    else if (e == 2) this.X = t63[0], this.Y = t63[1];
    else if (e == 1) if (t63[0] instanceof y.DoublePoint) {
      var r3 = t63[0];
      this.X = y.Clipper.Round(r3.X), this.Y = y.Clipper.Round(r3.Y);
    } else {
      var n = t63[0];
      this.X = n.X, this.Y = n.Y;
    }
    else this.X = 0, this.Y = 0;
  };
  y.IntPoint.op_Equality = function(t63, e) {
    return t63.X == e.X && t63.Y == e.Y;
  };
  y.IntPoint.op_Inequality = function(t63, e) {
    return t63.X != e.X || t63.Y != e.Y;
  };
  Mo ? (y.IntPoint0 = function() {
    this.X = 0, this.Y = 0, this.Z = 0;
  }, y.IntPoint1 = function(t63) {
    this.X = t63.X, this.Y = t63.Y, this.Z = t63.Z;
  }, y.IntPoint1dp = function(t63) {
    this.X = y.Clipper.Round(t63.X), this.Y = y.Clipper.Round(t63.Y), this.Z = 0;
  }, y.IntPoint2 = function(t63, e) {
    this.X = t63, this.Y = e, this.Z = 0;
  }, y.IntPoint3 = function(t63, e, r3) {
    this.X = t63, this.Y = e, this.Z = r3;
  }) : (y.IntPoint0 = function() {
    this.X = 0, this.Y = 0;
  }, y.IntPoint1 = function(t63) {
    this.X = t63.X, this.Y = t63.Y;
  }, y.IntPoint1dp = function(t63) {
    this.X = y.Clipper.Round(t63.X), this.Y = y.Clipper.Round(t63.Y);
  }, y.IntPoint2 = function(t63, e) {
    this.X = t63, this.Y = e;
  });
  y.IntRect = function() {
    var t63 = arguments, e = t63.length;
    e == 4 ? (this.left = t63[0], this.top = t63[1], this.right = t63[2], this.bottom = t63[3]) : e == 1 ? (this.left = ir.left, this.top = ir.top, this.right = ir.right, this.bottom = ir.bottom) : (this.left = 0, this.top = 0, this.right = 0, this.bottom = 0);
  };
  y.IntRect0 = function() {
    this.left = 0, this.top = 0, this.right = 0, this.bottom = 0;
  };
  y.IntRect1 = function(t63) {
    this.left = t63.left, this.top = t63.top, this.right = t63.right, this.bottom = t63.bottom;
  };
  y.IntRect4 = function(t63, e, r3, n) {
    this.left = t63, this.top = e, this.right = r3, this.bottom = n;
  };
  y.ClipType = { ctIntersection: 0, ctUnion: 1, ctDifference: 2, ctXor: 3 };
  y.PolyType = { ptSubject: 0, ptClip: 1 };
  y.PolyFillType = { pftEvenOdd: 0, pftNonZero: 1, pftPositive: 2, pftNegative: 3 };
  y.JoinType = { jtSquare: 0, jtRound: 1, jtMiter: 2 };
  y.EndType = { etOpenSquare: 0, etOpenRound: 1, etOpenButt: 2, etClosedLine: 3, etClosedPolygon: 4 };
  pM && (y.EndType_ = { etSquare: 0, etRound: 1, etButt: 2, etClosed: 3 });
  y.EdgeSide = { esLeft: 0, esRight: 1 };
  y.Direction = { dRightToLeft: 0, dLeftToRight: 1 };
  y.TEdge = function() {
    this.Bot = new y.IntPoint(), this.Curr = new y.IntPoint(), this.Top = new y.IntPoint(), this.Delta = new y.IntPoint(), this.Dx = 0, this.PolyTyp = y.PolyType.ptSubject, this.Side = y.EdgeSide.esLeft, this.WindDelta = 0, this.WindCnt = 0, this.WindCnt2 = 0, this.OutIdx = 0, this.Next = null, this.Prev = null, this.NextInLML = null, this.NextInAEL = null, this.PrevInAEL = null, this.NextInSEL = null, this.PrevInSEL = null;
  };
  y.IntersectNode = function() {
    this.Edge1 = null, this.Edge2 = null, this.Pt = new y.IntPoint();
  };
  y.MyIntersectNodeSort = function() {
  };
  y.MyIntersectNodeSort.Compare = function(t63, e) {
    return e.Pt.Y - t63.Pt.Y;
  };
  y.LocalMinima = function() {
    this.Y = 0, this.LeftBound = null, this.RightBound = null, this.Next = null;
  };
  y.Scanbeam = function() {
    this.Y = 0, this.Next = null;
  };
  y.OutRec = function() {
    this.Idx = 0, this.IsHole = false, this.IsOpen = false, this.FirstLeft = null, this.Pts = null, this.BottomPt = null, this.PolyNode = null;
  };
  y.OutPt = function() {
    this.Idx = 0, this.Pt = new y.IntPoint(), this.Next = null, this.Prev = null;
  };
  y.Join = function() {
    this.OutPt1 = null, this.OutPt2 = null, this.OffPt = new y.IntPoint();
  };
  y.ClipperBase = function() {
    this.m_MinimaList = null, this.m_CurrentLM = null, this.m_edges = new Array(), this.m_UseFullRange = false, this.m_HasOpenPaths = false, this.PreserveCollinear = false, this.m_MinimaList = null, this.m_CurrentLM = null, this.m_UseFullRange = false, this.m_HasOpenPaths = false;
  };
  y.ClipperBase.horizontal = -9007199254740992;
  y.ClipperBase.Skip = -2;
  y.ClipperBase.Unassigned = -1;
  y.ClipperBase.tolerance = 1e-20;
  qV ? (y.ClipperBase.loRange = 46340, y.ClipperBase.hiRange = 46340) : (y.ClipperBase.loRange = 47453132, y.ClipperBase.hiRange = 4503599627370495);
  y.ClipperBase.near_zero = function(t63) {
    return t63 > -y.ClipperBase.tolerance && t63 < y.ClipperBase.tolerance;
  };
  y.ClipperBase.IsHorizontal = function(t63) {
    return t63.Delta.Y === 0;
  };
  y.ClipperBase.prototype.PointIsVertex = function(t63, e) {
    var r3 = e;
    do {
      if (y.IntPoint.op_Equality(r3.Pt, t63)) return true;
      r3 = r3.Next;
    } while (r3 != e);
    return false;
  };
  y.ClipperBase.prototype.PointOnLineSegment = function(t63, e, r3, n) {
    return n ? t63.X == e.X && t63.Y == e.Y || t63.X == r3.X && t63.Y == r3.Y || t63.X > e.X == t63.X < r3.X && t63.Y > e.Y == t63.Y < r3.Y && Ce.op_Equality(Ce.Int128Mul(t63.X - e.X, r3.Y - e.Y), Ce.Int128Mul(r3.X - e.X, t63.Y - e.Y)) : t63.X == e.X && t63.Y == e.Y || t63.X == r3.X && t63.Y == r3.Y || t63.X > e.X == t63.X < r3.X && t63.Y > e.Y == t63.Y < r3.Y && (t63.X - e.X) * (r3.Y - e.Y) == (r3.X - e.X) * (t63.Y - e.Y);
  };
  y.ClipperBase.prototype.PointOnPolygon = function(t63, e, r3) {
    for (var n = e; ; ) {
      if (this.PointOnLineSegment(t63, n.Pt, n.Next.Pt, r3)) return true;
      if (n = n.Next, n == e) break;
    }
    return false;
  };
  y.ClipperBase.prototype.SlopesEqual = y.ClipperBase.SlopesEqual = function() {
    var t63 = arguments, e = t63.length, r3, n, i, o, a, s3, l;
    return e == 3 ? (r3 = t63[0], n = t63[1], l = t63[2], l ? Ce.op_Equality(Ce.Int128Mul(r3.Delta.Y, n.Delta.X), Ce.Int128Mul(r3.Delta.X, n.Delta.Y)) : y.Cast_Int64(r3.Delta.Y * n.Delta.X) == y.Cast_Int64(r3.Delta.X * n.Delta.Y)) : e == 4 ? (i = t63[0], o = t63[1], a = t63[2], l = t63[3], l ? Ce.op_Equality(Ce.Int128Mul(i.Y - o.Y, o.X - a.X), Ce.Int128Mul(i.X - o.X, o.Y - a.Y)) : y.Cast_Int64((i.Y - o.Y) * (o.X - a.X)) - y.Cast_Int64((i.X - o.X) * (o.Y - a.Y)) === 0) : (i = t63[0], o = t63[1], a = t63[2], s3 = t63[3], l = t63[4], l ? Ce.op_Equality(Ce.Int128Mul(i.Y - o.Y, a.X - s3.X), Ce.Int128Mul(i.X - o.X, a.Y - s3.Y)) : y.Cast_Int64((i.Y - o.Y) * (a.X - s3.X)) - y.Cast_Int64((i.X - o.X) * (a.Y - s3.Y)) === 0);
  };
  y.ClipperBase.SlopesEqual3 = function(t63, e, r3) {
    return r3 ? Ce.op_Equality(Ce.Int128Mul(t63.Delta.Y, e.Delta.X), Ce.Int128Mul(t63.Delta.X, e.Delta.Y)) : y.Cast_Int64(t63.Delta.Y * e.Delta.X) == y.Cast_Int64(t63.Delta.X * e.Delta.Y);
  };
  y.ClipperBase.SlopesEqual4 = function(t63, e, r3, n) {
    return n ? Ce.op_Equality(Ce.Int128Mul(t63.Y - e.Y, e.X - r3.X), Ce.Int128Mul(t63.X - e.X, e.Y - r3.Y)) : y.Cast_Int64((t63.Y - e.Y) * (e.X - r3.X)) - y.Cast_Int64((t63.X - e.X) * (e.Y - r3.Y)) === 0;
  };
  y.ClipperBase.SlopesEqual5 = function(t63, e, r3, n, i) {
    return i ? Ce.op_Equality(Ce.Int128Mul(t63.Y - e.Y, r3.X - n.X), Ce.Int128Mul(t63.X - e.X, r3.Y - n.Y)) : y.Cast_Int64((t63.Y - e.Y) * (r3.X - n.X)) - y.Cast_Int64((t63.X - e.X) * (r3.Y - n.Y)) === 0;
  };
  y.ClipperBase.prototype.Clear = function() {
    this.DisposeLocalMinimaList();
    for (var t63 = 0, e = this.m_edges.length; t63 < e; ++t63) {
      for (var r3 = 0, n = this.m_edges[t63].length; r3 < n; ++r3) this.m_edges[t63][r3] = null;
      y.Clear(this.m_edges[t63]);
    }
    y.Clear(this.m_edges), this.m_UseFullRange = false, this.m_HasOpenPaths = false;
  };
  y.ClipperBase.prototype.DisposeLocalMinimaList = function() {
    for (; this.m_MinimaList !== null; ) {
      var t63 = this.m_MinimaList.Next;
      this.m_MinimaList = null, this.m_MinimaList = t63;
    }
    this.m_CurrentLM = null;
  };
  y.ClipperBase.prototype.RangeTest = function(t63, e) {
    e.Value ? (t63.X > y.ClipperBase.hiRange || t63.Y > y.ClipperBase.hiRange || -t63.X > y.ClipperBase.hiRange || -t63.Y > y.ClipperBase.hiRange) && y.Error("Coordinate outside allowed range in RangeTest().") : (t63.X > y.ClipperBase.loRange || t63.Y > y.ClipperBase.loRange || -t63.X > y.ClipperBase.loRange || -t63.Y > y.ClipperBase.loRange) && (e.Value = true, this.RangeTest(t63, e));
  };
  y.ClipperBase.prototype.InitEdge = function(t63, e, r3, n) {
    t63.Next = e, t63.Prev = r3, t63.Curr.X = n.X, t63.Curr.Y = n.Y, t63.OutIdx = -1;
  };
  y.ClipperBase.prototype.InitEdge2 = function(t63, e) {
    t63.Curr.Y >= t63.Next.Curr.Y ? (t63.Bot.X = t63.Curr.X, t63.Bot.Y = t63.Curr.Y, t63.Top.X = t63.Next.Curr.X, t63.Top.Y = t63.Next.Curr.Y) : (t63.Top.X = t63.Curr.X, t63.Top.Y = t63.Curr.Y, t63.Bot.X = t63.Next.Curr.X, t63.Bot.Y = t63.Next.Curr.Y), this.SetDx(t63), t63.PolyTyp = e;
  };
  y.ClipperBase.prototype.FindNextLocMin = function(t63) {
    for (var e; ; ) {
      for (; y.IntPoint.op_Inequality(t63.Bot, t63.Prev.Bot) || y.IntPoint.op_Equality(t63.Curr, t63.Top); ) t63 = t63.Next;
      if (t63.Dx != y.ClipperBase.horizontal && t63.Prev.Dx != y.ClipperBase.horizontal) break;
      for (; t63.Prev.Dx == y.ClipperBase.horizontal; ) t63 = t63.Prev;
      for (e = t63; t63.Dx == y.ClipperBase.horizontal; ) t63 = t63.Next;
      if (t63.Top.Y != t63.Prev.Bot.Y) {
        e.Prev.Bot.X < t63.Bot.X && (t63 = e);
        break;
      }
    }
    return t63;
  };
  y.ClipperBase.prototype.ProcessBound = function(t63, e) {
    var r3 = t63, n = t63, i, o;
    if (t63.Dx == y.ClipperBase.horizontal && (e ? o = t63.Prev.Bot.X : o = t63.Next.Bot.X, t63.Bot.X != o && this.ReverseHorizontal(t63)), n.OutIdx != y.ClipperBase.Skip) if (e) {
      for (; n.Top.Y == n.Next.Bot.Y && n.Next.OutIdx != y.ClipperBase.Skip; ) n = n.Next;
      if (n.Dx == y.ClipperBase.horizontal && n.Next.OutIdx != y.ClipperBase.Skip) {
        for (i = n; i.Prev.Dx == y.ClipperBase.horizontal; ) i = i.Prev;
        i.Prev.Top.X == n.Next.Top.X ? e || (n = i.Prev) : i.Prev.Top.X > n.Next.Top.X && (n = i.Prev);
      }
      for (; t63 != n; ) t63.NextInLML = t63.Next, t63.Dx == y.ClipperBase.horizontal && t63 != r3 && t63.Bot.X != t63.Prev.Top.X && this.ReverseHorizontal(t63), t63 = t63.Next;
      t63.Dx == y.ClipperBase.horizontal && t63 != r3 && t63.Bot.X != t63.Prev.Top.X && this.ReverseHorizontal(t63), n = n.Next;
    } else {
      for (; n.Top.Y == n.Prev.Bot.Y && n.Prev.OutIdx != y.ClipperBase.Skip; ) n = n.Prev;
      if (n.Dx == y.ClipperBase.horizontal && n.Prev.OutIdx != y.ClipperBase.Skip) {
        for (i = n; i.Next.Dx == y.ClipperBase.horizontal; ) i = i.Next;
        i.Next.Top.X == n.Prev.Top.X ? e || (n = i.Next) : i.Next.Top.X > n.Prev.Top.X && (n = i.Next);
      }
      for (; t63 != n; ) t63.NextInLML = t63.Prev, t63.Dx == y.ClipperBase.horizontal && t63 != r3 && t63.Bot.X != t63.Next.Top.X && this.ReverseHorizontal(t63), t63 = t63.Prev;
      t63.Dx == y.ClipperBase.horizontal && t63 != r3 && t63.Bot.X != t63.Next.Top.X && this.ReverseHorizontal(t63), n = n.Prev;
    }
    if (n.OutIdx == y.ClipperBase.Skip) {
      if (t63 = n, e) {
        for (; t63.Top.Y == t63.Next.Bot.Y; ) t63 = t63.Next;
        for (; t63 != n && t63.Dx == y.ClipperBase.horizontal; ) t63 = t63.Prev;
      } else {
        for (; t63.Top.Y == t63.Prev.Bot.Y; ) t63 = t63.Prev;
        for (; t63 != n && t63.Dx == y.ClipperBase.horizontal; ) t63 = t63.Next;
      }
      if (t63 == n) e ? n = t63.Next : n = t63.Prev;
      else {
        e ? t63 = n.Next : t63 = n.Prev;
        var a = new y.LocalMinima();
        a.Next = null, a.Y = t63.Bot.Y, a.LeftBound = null, a.RightBound = t63, a.RightBound.WindDelta = 0, n = this.ProcessBound(a.RightBound, e), this.InsertLocalMinima(a);
      }
    }
    return n;
  };
  y.ClipperBase.prototype.AddPath = function(t63, e, r3) {
    cM ? !r3 && e == y.PolyType.ptClip && y.Error("AddPath: Open paths must be subject.") : r3 || y.Error("AddPath: Open paths have been disabled.");
    var n = t63.length - 1;
    if (r3) for (; n > 0 && y.IntPoint.op_Equality(t63[n], t63[0]); ) --n;
    for (; n > 0 && y.IntPoint.op_Equality(t63[n], t63[n - 1]); ) --n;
    if (r3 && n < 2 || !r3 && n < 1) return false;
    for (var i = new Array(), o = 0; o <= n; o++) i.push(new y.TEdge());
    var a = true;
    i[1].Curr.X = t63[1].X, i[1].Curr.Y = t63[1].Y;
    var s3 = { Value: this.m_UseFullRange };
    this.RangeTest(t63[0], s3), this.m_UseFullRange = s3.Value, s3.Value = this.m_UseFullRange, this.RangeTest(t63[n], s3), this.m_UseFullRange = s3.Value, this.InitEdge(i[0], i[1], i[n], t63[0]), this.InitEdge(i[n], i[0], i[n - 1], t63[n]);
    for (var o = n - 1; o >= 1; --o) s3.Value = this.m_UseFullRange, this.RangeTest(t63[o], s3), this.m_UseFullRange = s3.Value, this.InitEdge(i[o], i[o + 1], i[o - 1], t63[o]);
    for (var l = i[0], u3 = l, c = l; ; ) {
      if (y.IntPoint.op_Equality(u3.Curr, u3.Next.Curr)) {
        if (u3 == u3.Next) break;
        u3 == l && (l = u3.Next), u3 = this.RemoveEdge(u3), c = u3;
        continue;
      }
      if (u3.Prev == u3.Next) break;
      if (r3 && y.ClipperBase.SlopesEqual(u3.Prev.Curr, u3.Curr, u3.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(u3.Prev.Curr, u3.Curr, u3.Next.Curr))) {
        u3 == l && (l = u3.Next), u3 = this.RemoveEdge(u3), u3 = u3.Prev, c = u3;
        continue;
      }
      if (u3 = u3.Next, u3 == c) break;
    }
    if (!r3 && u3 == u3.Next || r3 && u3.Prev == u3.Next) return false;
    r3 || (this.m_HasOpenPaths = true, l.Prev.OutIdx = y.ClipperBase.Skip);
    var p = l;
    u3 = l;
    do
      this.InitEdge2(u3, e), u3 = u3.Next, a && u3.Curr.Y != l.Curr.Y && (a = false);
    while (u3 != l);
    if (a) {
      if (r3) return false;
      u3.Prev.OutIdx = y.ClipperBase.Skip, u3.Prev.Bot.X < u3.Prev.Top.X && this.ReverseHorizontal(u3.Prev);
      var h = new y.LocalMinima();
      for (h.Next = null, h.Y = u3.Bot.Y, h.LeftBound = null, h.RightBound = u3, h.RightBound.Side = y.EdgeSide.esRight, h.RightBound.WindDelta = 0; u3.Next.OutIdx != y.ClipperBase.Skip; ) u3.NextInLML = u3.Next, u3.Bot.X != u3.Prev.Top.X && this.ReverseHorizontal(u3), u3 = u3.Next;
      return this.InsertLocalMinima(h), this.m_edges.push(i), true;
    }
    this.m_edges.push(i);
    for (var f, d = null; u3 = this.FindNextLocMin(u3), u3 != d; ) {
      d == null && (d = u3);
      var h = new y.LocalMinima();
      h.Next = null, h.Y = u3.Bot.Y, u3.Dx < u3.Prev.Dx ? (h.LeftBound = u3.Prev, h.RightBound = u3, f = false) : (h.LeftBound = u3, h.RightBound = u3.Prev, f = true), h.LeftBound.Side = y.EdgeSide.esLeft, h.RightBound.Side = y.EdgeSide.esRight, r3 ? h.LeftBound.Next == h.RightBound ? h.LeftBound.WindDelta = -1 : h.LeftBound.WindDelta = 1 : h.LeftBound.WindDelta = 0, h.RightBound.WindDelta = -h.LeftBound.WindDelta, u3 = this.ProcessBound(h.LeftBound, f);
      var g = this.ProcessBound(h.RightBound, !f);
      h.LeftBound.OutIdx == y.ClipperBase.Skip ? h.LeftBound = null : h.RightBound.OutIdx == y.ClipperBase.Skip && (h.RightBound = null), this.InsertLocalMinima(h), f || (u3 = g);
    }
    return true;
  };
  y.ClipperBase.prototype.AddPaths = function(t63, e, r3) {
    for (var n = false, i = 0, o = t63.length; i < o; ++i) this.AddPath(t63[i], e, r3) && (n = true);
    return n;
  };
  y.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function(t63, e, r3) {
    return y.IntPoint.op_Equality(t63, r3) || y.IntPoint.op_Equality(t63, e) || y.IntPoint.op_Equality(r3, e) ? false : t63.X != r3.X ? e.X > t63.X == e.X < r3.X : e.Y > t63.Y == e.Y < r3.Y;
  };
  y.ClipperBase.prototype.RemoveEdge = function(t63) {
    t63.Prev.Next = t63.Next, t63.Next.Prev = t63.Prev;
    var e = t63.Next;
    return t63.Prev = null, e;
  };
  y.ClipperBase.prototype.SetDx = function(t63) {
    t63.Delta.X = t63.Top.X - t63.Bot.X, t63.Delta.Y = t63.Top.Y - t63.Bot.Y, t63.Delta.Y === 0 ? t63.Dx = y.ClipperBase.horizontal : t63.Dx = t63.Delta.X / t63.Delta.Y;
  };
  y.ClipperBase.prototype.InsertLocalMinima = function(t63) {
    if (this.m_MinimaList === null) this.m_MinimaList = t63;
    else if (t63.Y >= this.m_MinimaList.Y) t63.Next = this.m_MinimaList, this.m_MinimaList = t63;
    else {
      for (var e = this.m_MinimaList; e.Next !== null && t63.Y < e.Next.Y; ) e = e.Next;
      t63.Next = e.Next, e.Next = t63;
    }
  };
  y.ClipperBase.prototype.PopLocalMinima = function() {
    this.m_CurrentLM !== null && (this.m_CurrentLM = this.m_CurrentLM.Next);
  };
  y.ClipperBase.prototype.ReverseHorizontal = function(t63) {
    var e = t63.Top.X;
    t63.Top.X = t63.Bot.X, t63.Bot.X = e, Mo && (e = t63.Top.Z, t63.Top.Z = t63.Bot.Z, t63.Bot.Z = e);
  };
  y.ClipperBase.prototype.Reset = function() {
    if (this.m_CurrentLM = this.m_MinimaList, this.m_CurrentLM != null) for (var t63 = this.m_MinimaList; t63 != null; ) {
      var e = t63.LeftBound;
      e != null && (e.Curr.X = e.Bot.X, e.Curr.Y = e.Bot.Y, e.Side = y.EdgeSide.esLeft, e.OutIdx = y.ClipperBase.Unassigned), e = t63.RightBound, e != null && (e.Curr.X = e.Bot.X, e.Curr.Y = e.Bot.Y, e.Side = y.EdgeSide.esRight, e.OutIdx = y.ClipperBase.Unassigned), t63 = t63.Next;
    }
  };
  y.Clipper = function(t63) {
    typeof t63 > "u" && (t63 = 0), this.m_PolyOuts = null, this.m_ClipType = y.ClipType.ctIntersection, this.m_Scanbeam = null, this.m_ActiveEdges = null, this.m_SortedEdges = null, this.m_IntersectList = null, this.m_IntersectNodeComparer = null, this.m_ExecuteLocked = false, this.m_ClipFillType = y.PolyFillType.pftEvenOdd, this.m_SubjFillType = y.PolyFillType.pftEvenOdd, this.m_Joins = null, this.m_GhostJoins = null, this.m_UsingPolyTree = false, this.ReverseSolution = false, this.StrictlySimple = false, y.ClipperBase.call(this), this.m_Scanbeam = null, this.m_ActiveEdges = null, this.m_SortedEdges = null, this.m_IntersectList = new Array(), this.m_IntersectNodeComparer = y.MyIntersectNodeSort.Compare, this.m_ExecuteLocked = false, this.m_UsingPolyTree = false, this.m_PolyOuts = new Array(), this.m_Joins = new Array(), this.m_GhostJoins = new Array(), this.ReverseSolution = (1 & t63) !== 0, this.StrictlySimple = (2 & t63) !== 0, this.PreserveCollinear = (4 & t63) !== 0, Mo && (this.ZFillFunction = null);
  };
  y.Clipper.ioReverseSolution = 1;
  y.Clipper.ioStrictlySimple = 2;
  y.Clipper.ioPreserveCollinear = 4;
  y.Clipper.prototype.Clear = function() {
    this.m_edges.length !== 0 && (this.DisposeAllPolyPts(), y.ClipperBase.prototype.Clear.call(this));
  };
  y.Clipper.prototype.DisposeScanbeamList = function() {
    for (; this.m_Scanbeam !== null; ) {
      var t63 = this.m_Scanbeam.Next;
      this.m_Scanbeam = null, this.m_Scanbeam = t63;
    }
  };
  y.Clipper.prototype.Reset = function() {
    y.ClipperBase.prototype.Reset.call(this), this.m_Scanbeam = null, this.m_ActiveEdges = null, this.m_SortedEdges = null;
    for (var t63 = this.m_MinimaList; t63 !== null; ) this.InsertScanbeam(t63.Y), t63 = t63.Next;
  };
  y.Clipper.prototype.InsertScanbeam = function(t63) {
    if (this.m_Scanbeam === null) this.m_Scanbeam = new y.Scanbeam(), this.m_Scanbeam.Next = null, this.m_Scanbeam.Y = t63;
    else if (t63 > this.m_Scanbeam.Y) {
      var e = new y.Scanbeam();
      e.Y = t63, e.Next = this.m_Scanbeam, this.m_Scanbeam = e;
    } else {
      for (var r3 = this.m_Scanbeam; r3.Next !== null && t63 <= r3.Next.Y; ) r3 = r3.Next;
      if (t63 == r3.Y) return;
      var e = new y.Scanbeam();
      e.Y = t63, e.Next = r3.Next, r3.Next = e;
    }
  };
  y.Clipper.prototype.Execute = function() {
    var t63 = arguments, e = t63.length, r3 = t63[1] instanceof y.PolyTree;
    if (e == 4 && !r3) {
      var n = t63[0], i = t63[1], o = t63[2], a = t63[3];
      if (this.m_ExecuteLocked) return false;
      this.m_HasOpenPaths && y.Error("Error: PolyTree struct is need for open path clipping."), this.m_ExecuteLocked = true, y.Clear(i), this.m_SubjFillType = o, this.m_ClipFillType = a, this.m_ClipType = n, this.m_UsingPolyTree = false;
      try {
        var s3 = this.ExecuteInternal();
        s3 && this.BuildResult(i);
      } finally {
        this.DisposeAllPolyPts(), this.m_ExecuteLocked = false;
      }
      return s3;
    } else if (e == 4 && r3) {
      var n = t63[0], l = t63[1], o = t63[2], a = t63[3];
      if (this.m_ExecuteLocked) return false;
      this.m_ExecuteLocked = true, this.m_SubjFillType = o, this.m_ClipFillType = a, this.m_ClipType = n, this.m_UsingPolyTree = true;
      try {
        var s3 = this.ExecuteInternal();
        s3 && this.BuildResult2(l);
      } finally {
        this.DisposeAllPolyPts(), this.m_ExecuteLocked = false;
      }
      return s3;
    } else if (e == 2 && !r3) {
      var n = t63[0], i = t63[1];
      return this.Execute(n, i, y.PolyFillType.pftEvenOdd, y.PolyFillType.pftEvenOdd);
    } else if (e == 2 && r3) {
      var n = t63[0], l = t63[1];
      return this.Execute(n, l, y.PolyFillType.pftEvenOdd, y.PolyFillType.pftEvenOdd);
    }
  };
  y.Clipper.prototype.FixHoleLinkage = function(t63) {
    if (!(t63.FirstLeft === null || t63.IsHole != t63.FirstLeft.IsHole && t63.FirstLeft.Pts !== null)) {
      for (var e = t63.FirstLeft; e !== null && (e.IsHole == t63.IsHole || e.Pts === null); ) e = e.FirstLeft;
      t63.FirstLeft = e;
    }
  };
  y.Clipper.prototype.ExecuteInternal = function() {
    try {
      if (this.Reset(), this.m_CurrentLM === null) return false;
      var t63 = this.PopScanbeam();
      do {
        if (this.InsertLocalMinimaIntoAEL(t63), y.Clear(this.m_GhostJoins), this.ProcessHorizontals(false), this.m_Scanbeam === null) break;
        var e = this.PopScanbeam();
        if (!this.ProcessIntersections(t63, e)) return false;
        this.ProcessEdgesAtTopOfScanbeam(e), t63 = e;
      } while (this.m_Scanbeam !== null || this.m_CurrentLM !== null);
      for (var r3 = 0, n = this.m_PolyOuts.length; r3 < n; r3++) {
        var i = this.m_PolyOuts[r3];
        i.Pts === null || i.IsOpen || (i.IsHole ^ this.ReverseSolution) == this.Area(i) > 0 && this.ReversePolyPtLinks(i.Pts);
      }
      this.JoinCommonEdges();
      for (var r3 = 0, n = this.m_PolyOuts.length; r3 < n; r3++) {
        var i = this.m_PolyOuts[r3];
        i.Pts !== null && !i.IsOpen && this.FixupOutPolygon(i);
      }
      return this.StrictlySimple && this.DoSimplePolygons(), true;
    } finally {
      y.Clear(this.m_Joins), y.Clear(this.m_GhostJoins);
    }
  };
  y.Clipper.prototype.PopScanbeam = function() {
    var t63 = this.m_Scanbeam.Y, e = this.m_Scanbeam;
    return this.m_Scanbeam = this.m_Scanbeam.Next, e = null, t63;
  };
  y.Clipper.prototype.DisposeAllPolyPts = function() {
    for (var t63 = 0, e = this.m_PolyOuts.length; t63 < e; ++t63) this.DisposeOutRec(t63);
    y.Clear(this.m_PolyOuts);
  };
  y.Clipper.prototype.DisposeOutRec = function(t63) {
    var e = this.m_PolyOuts[t63];
    e.Pts !== null && this.DisposeOutPts(e.Pts), e = null, this.m_PolyOuts[t63] = null;
  };
  y.Clipper.prototype.DisposeOutPts = function(t63) {
    if (t63 !== null) {
      var e = null;
      for (t63.Prev.Next = null; t63 !== null; ) e = t63, t63 = t63.Next, e = null;
    }
  };
  y.Clipper.prototype.AddJoin = function(t63, e, r3) {
    var n = new y.Join();
    n.OutPt1 = t63, n.OutPt2 = e, n.OffPt.X = r3.X, n.OffPt.Y = r3.Y, this.m_Joins.push(n);
  };
  y.Clipper.prototype.AddGhostJoin = function(t63, e) {
    var r3 = new y.Join();
    r3.OutPt1 = t63, r3.OffPt.X = e.X, r3.OffPt.Y = e.Y, this.m_GhostJoins.push(r3);
  };
  Mo && (y.Clipper.prototype.SetZ = function(t63, e) {
    t63.Z = 0, this.ZFillFunction !== null && (e.OutIdx < 0 ? this.ZFillFunction(e.Bot, e.Top, t63) : this.ZFillFunction(e.Top, e.Bot, t63));
  });
  y.Clipper.prototype.InsertLocalMinimaIntoAEL = function(t63) {
    for (; this.m_CurrentLM !== null && this.m_CurrentLM.Y == t63; ) {
      var e = this.m_CurrentLM.LeftBound, r3 = this.m_CurrentLM.RightBound;
      this.PopLocalMinima();
      var n = null;
      if (e === null ? (this.InsertEdgeIntoAEL(r3, null), this.SetWindingCount(r3), this.IsContributing(r3) && (n = this.AddOutPt(r3, r3.Bot))) : r3 == null ? (this.InsertEdgeIntoAEL(e, null), this.SetWindingCount(e), this.IsContributing(e) && (n = this.AddOutPt(e, e.Bot)), this.InsertScanbeam(e.Top.Y)) : (this.InsertEdgeIntoAEL(e, null), this.InsertEdgeIntoAEL(r3, e), this.SetWindingCount(e), r3.WindCnt = e.WindCnt, r3.WindCnt2 = e.WindCnt2, this.IsContributing(e) && (n = this.AddLocalMinPoly(e, r3, e.Bot)), this.InsertScanbeam(e.Top.Y)), r3 != null && (y.ClipperBase.IsHorizontal(r3) ? this.AddEdgeToSEL(r3) : this.InsertScanbeam(r3.Top.Y)), !(e == null || r3 == null)) {
        if (n !== null && y.ClipperBase.IsHorizontal(r3) && this.m_GhostJoins.length > 0 && r3.WindDelta !== 0) for (var i = 0, o = this.m_GhostJoins.length; i < o; i++) {
          var a = this.m_GhostJoins[i];
          this.HorzSegmentsOverlap(a.OutPt1.Pt, a.OffPt, r3.Bot, r3.Top) && this.AddJoin(a.OutPt1, n, a.OffPt);
        }
        if (e.OutIdx >= 0 && e.PrevInAEL !== null && e.PrevInAEL.Curr.X == e.Bot.X && e.PrevInAEL.OutIdx >= 0 && y.ClipperBase.SlopesEqual(e.PrevInAEL, e, this.m_UseFullRange) && e.WindDelta !== 0 && e.PrevInAEL.WindDelta !== 0) {
          var s3 = this.AddOutPt(e.PrevInAEL, e.Bot);
          this.AddJoin(n, s3, e.Top);
        }
        if (e.NextInAEL != r3) {
          if (r3.OutIdx >= 0 && r3.PrevInAEL.OutIdx >= 0 && y.ClipperBase.SlopesEqual(r3.PrevInAEL, r3, this.m_UseFullRange) && r3.WindDelta !== 0 && r3.PrevInAEL.WindDelta !== 0) {
            var s3 = this.AddOutPt(r3.PrevInAEL, r3.Bot);
            this.AddJoin(n, s3, r3.Top);
          }
          var l = e.NextInAEL;
          if (l !== null) for (; l != r3; ) this.IntersectEdges(r3, l, e.Curr, false), l = l.NextInAEL;
        }
      }
    }
  };
  y.Clipper.prototype.InsertEdgeIntoAEL = function(t63, e) {
    if (this.m_ActiveEdges === null) t63.PrevInAEL = null, t63.NextInAEL = null, this.m_ActiveEdges = t63;
    else if (e === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, t63)) t63.PrevInAEL = null, t63.NextInAEL = this.m_ActiveEdges, this.m_ActiveEdges.PrevInAEL = t63, this.m_ActiveEdges = t63;
    else {
      for (e === null && (e = this.m_ActiveEdges); e.NextInAEL !== null && !this.E2InsertsBeforeE1(e.NextInAEL, t63); ) e = e.NextInAEL;
      t63.NextInAEL = e.NextInAEL, e.NextInAEL !== null && (e.NextInAEL.PrevInAEL = t63), t63.PrevInAEL = e, e.NextInAEL = t63;
    }
  };
  y.Clipper.prototype.E2InsertsBeforeE1 = function(t63, e) {
    return e.Curr.X == t63.Curr.X ? e.Top.Y > t63.Top.Y ? e.Top.X < y.Clipper.TopX(t63, e.Top.Y) : t63.Top.X > y.Clipper.TopX(e, t63.Top.Y) : e.Curr.X < t63.Curr.X;
  };
  y.Clipper.prototype.IsEvenOddFillType = function(t63) {
    return t63.PolyTyp == y.PolyType.ptSubject ? this.m_SubjFillType == y.PolyFillType.pftEvenOdd : this.m_ClipFillType == y.PolyFillType.pftEvenOdd;
  };
  y.Clipper.prototype.IsEvenOddAltFillType = function(t63) {
    return t63.PolyTyp == y.PolyType.ptSubject ? this.m_ClipFillType == y.PolyFillType.pftEvenOdd : this.m_SubjFillType == y.PolyFillType.pftEvenOdd;
  };
  y.Clipper.prototype.IsContributing = function(t63) {
    var e, r3;
    switch (t63.PolyTyp == y.PolyType.ptSubject ? (e = this.m_SubjFillType, r3 = this.m_ClipFillType) : (e = this.m_ClipFillType, r3 = this.m_SubjFillType), e) {
      case y.PolyFillType.pftEvenOdd:
        if (t63.WindDelta === 0 && t63.WindCnt != 1) return false;
        break;
      case y.PolyFillType.pftNonZero:
        if (Math.abs(t63.WindCnt) != 1) return false;
        break;
      case y.PolyFillType.pftPositive:
        if (t63.WindCnt != 1) return false;
        break;
      default:
        if (t63.WindCnt != -1) return false;
        break;
    }
    switch (this.m_ClipType) {
      case y.ClipType.ctIntersection:
        switch (r3) {
          case y.PolyFillType.pftEvenOdd:
          case y.PolyFillType.pftNonZero:
            return t63.WindCnt2 !== 0;
          case y.PolyFillType.pftPositive:
            return t63.WindCnt2 > 0;
          default:
            return t63.WindCnt2 < 0;
        }
      case y.ClipType.ctUnion:
        switch (r3) {
          case y.PolyFillType.pftEvenOdd:
          case y.PolyFillType.pftNonZero:
            return t63.WindCnt2 === 0;
          case y.PolyFillType.pftPositive:
            return t63.WindCnt2 <= 0;
          default:
            return t63.WindCnt2 >= 0;
        }
      case y.ClipType.ctDifference:
        if (t63.PolyTyp == y.PolyType.ptSubject) switch (r3) {
          case y.PolyFillType.pftEvenOdd:
          case y.PolyFillType.pftNonZero:
            return t63.WindCnt2 === 0;
          case y.PolyFillType.pftPositive:
            return t63.WindCnt2 <= 0;
          default:
            return t63.WindCnt2 >= 0;
        }
        else switch (r3) {
          case y.PolyFillType.pftEvenOdd:
          case y.PolyFillType.pftNonZero:
            return t63.WindCnt2 !== 0;
          case y.PolyFillType.pftPositive:
            return t63.WindCnt2 > 0;
          default:
            return t63.WindCnt2 < 0;
        }
      case y.ClipType.ctXor:
        if (t63.WindDelta === 0) switch (r3) {
          case y.PolyFillType.pftEvenOdd:
          case y.PolyFillType.pftNonZero:
            return t63.WindCnt2 === 0;
          case y.PolyFillType.pftPositive:
            return t63.WindCnt2 <= 0;
          default:
            return t63.WindCnt2 >= 0;
        }
        else return true;
    }
    return true;
  };
  y.Clipper.prototype.SetWindingCount = function(t63) {
    for (var e = t63.PrevInAEL; e !== null && (e.PolyTyp != t63.PolyTyp || e.WindDelta === 0); ) e = e.PrevInAEL;
    if (e === null) t63.WindCnt = t63.WindDelta === 0 ? 1 : t63.WindDelta, t63.WindCnt2 = 0, e = this.m_ActiveEdges;
    else if (t63.WindDelta === 0 && this.m_ClipType != y.ClipType.ctUnion) t63.WindCnt = 1, t63.WindCnt2 = e.WindCnt2, e = e.NextInAEL;
    else if (this.IsEvenOddFillType(t63)) {
      if (t63.WindDelta === 0) {
        for (var r3 = true, n = e.PrevInAEL; n !== null; ) n.PolyTyp == e.PolyTyp && n.WindDelta !== 0 && (r3 = !r3), n = n.PrevInAEL;
        t63.WindCnt = r3 ? 0 : 1;
      } else t63.WindCnt = t63.WindDelta;
      t63.WindCnt2 = e.WindCnt2, e = e.NextInAEL;
    } else e.WindCnt * e.WindDelta < 0 ? Math.abs(e.WindCnt) > 1 ? e.WindDelta * t63.WindDelta < 0 ? t63.WindCnt = e.WindCnt : t63.WindCnt = e.WindCnt + t63.WindDelta : t63.WindCnt = t63.WindDelta === 0 ? 1 : t63.WindDelta : t63.WindDelta === 0 ? t63.WindCnt = e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1 : e.WindDelta * t63.WindDelta < 0 ? t63.WindCnt = e.WindCnt : t63.WindCnt = e.WindCnt + t63.WindDelta, t63.WindCnt2 = e.WindCnt2, e = e.NextInAEL;
    if (this.IsEvenOddAltFillType(t63)) for (; e != t63; ) e.WindDelta !== 0 && (t63.WindCnt2 = t63.WindCnt2 === 0 ? 1 : 0), e = e.NextInAEL;
    else for (; e != t63; ) t63.WindCnt2 += e.WindDelta, e = e.NextInAEL;
  };
  y.Clipper.prototype.AddEdgeToSEL = function(t63) {
    this.m_SortedEdges === null ? (this.m_SortedEdges = t63, t63.PrevInSEL = null, t63.NextInSEL = null) : (t63.NextInSEL = this.m_SortedEdges, t63.PrevInSEL = null, this.m_SortedEdges.PrevInSEL = t63, this.m_SortedEdges = t63);
  };
  y.Clipper.prototype.CopyAELToSEL = function() {
    var t63 = this.m_ActiveEdges;
    for (this.m_SortedEdges = t63; t63 !== null; ) t63.PrevInSEL = t63.PrevInAEL, t63.NextInSEL = t63.NextInAEL, t63 = t63.NextInAEL;
  };
  y.Clipper.prototype.SwapPositionsInAEL = function(t63, e) {
    if (!(t63.NextInAEL == t63.PrevInAEL || e.NextInAEL == e.PrevInAEL)) {
      if (t63.NextInAEL == e) {
        var r3 = e.NextInAEL;
        r3 !== null && (r3.PrevInAEL = t63);
        var n = t63.PrevInAEL;
        n !== null && (n.NextInAEL = e), e.PrevInAEL = n, e.NextInAEL = t63, t63.PrevInAEL = e, t63.NextInAEL = r3;
      } else if (e.NextInAEL == t63) {
        var r3 = t63.NextInAEL;
        r3 !== null && (r3.PrevInAEL = e);
        var n = e.PrevInAEL;
        n !== null && (n.NextInAEL = t63), t63.PrevInAEL = n, t63.NextInAEL = e, e.PrevInAEL = t63, e.NextInAEL = r3;
      } else {
        var r3 = t63.NextInAEL, n = t63.PrevInAEL;
        t63.NextInAEL = e.NextInAEL, t63.NextInAEL !== null && (t63.NextInAEL.PrevInAEL = t63), t63.PrevInAEL = e.PrevInAEL, t63.PrevInAEL !== null && (t63.PrevInAEL.NextInAEL = t63), e.NextInAEL = r3, e.NextInAEL !== null && (e.NextInAEL.PrevInAEL = e), e.PrevInAEL = n, e.PrevInAEL !== null && (e.PrevInAEL.NextInAEL = e);
      }
      t63.PrevInAEL === null ? this.m_ActiveEdges = t63 : e.PrevInAEL === null && (this.m_ActiveEdges = e);
    }
  };
  y.Clipper.prototype.SwapPositionsInSEL = function(t63, e) {
    if (!(t63.NextInSEL === null && t63.PrevInSEL === null) && !(e.NextInSEL === null && e.PrevInSEL === null)) {
      if (t63.NextInSEL == e) {
        var r3 = e.NextInSEL;
        r3 !== null && (r3.PrevInSEL = t63);
        var n = t63.PrevInSEL;
        n !== null && (n.NextInSEL = e), e.PrevInSEL = n, e.NextInSEL = t63, t63.PrevInSEL = e, t63.NextInSEL = r3;
      } else if (e.NextInSEL == t63) {
        var r3 = t63.NextInSEL;
        r3 !== null && (r3.PrevInSEL = e);
        var n = e.PrevInSEL;
        n !== null && (n.NextInSEL = t63), t63.PrevInSEL = n, t63.NextInSEL = e, e.PrevInSEL = t63, e.NextInSEL = r3;
      } else {
        var r3 = t63.NextInSEL, n = t63.PrevInSEL;
        t63.NextInSEL = e.NextInSEL, t63.NextInSEL !== null && (t63.NextInSEL.PrevInSEL = t63), t63.PrevInSEL = e.PrevInSEL, t63.PrevInSEL !== null && (t63.PrevInSEL.NextInSEL = t63), e.NextInSEL = r3, e.NextInSEL !== null && (e.NextInSEL.PrevInSEL = e), e.PrevInSEL = n, e.PrevInSEL !== null && (e.PrevInSEL.NextInSEL = e);
      }
      t63.PrevInSEL === null ? this.m_SortedEdges = t63 : e.PrevInSEL === null && (this.m_SortedEdges = e);
    }
  };
  y.Clipper.prototype.AddLocalMaxPoly = function(t63, e, r3) {
    this.AddOutPt(t63, r3), e.WindDelta == 0 && this.AddOutPt(e, r3), t63.OutIdx == e.OutIdx ? (t63.OutIdx = -1, e.OutIdx = -1) : t63.OutIdx < e.OutIdx ? this.AppendPolygon(t63, e) : this.AppendPolygon(e, t63);
  };
  y.Clipper.prototype.AddLocalMinPoly = function(t63, e, r3) {
    var n, i, o;
    if (y.ClipperBase.IsHorizontal(e) || t63.Dx > e.Dx ? (n = this.AddOutPt(t63, r3), e.OutIdx = t63.OutIdx, t63.Side = y.EdgeSide.esLeft, e.Side = y.EdgeSide.esRight, i = t63, i.PrevInAEL == e ? o = e.PrevInAEL : o = i.PrevInAEL) : (n = this.AddOutPt(e, r3), t63.OutIdx = e.OutIdx, t63.Side = y.EdgeSide.esRight, e.Side = y.EdgeSide.esLeft, i = e, i.PrevInAEL == t63 ? o = t63.PrevInAEL : o = i.PrevInAEL), o !== null && o.OutIdx >= 0 && y.Clipper.TopX(o, r3.Y) == y.Clipper.TopX(i, r3.Y) && y.ClipperBase.SlopesEqual(i, o, this.m_UseFullRange) && i.WindDelta !== 0 && o.WindDelta !== 0) {
      var a = this.AddOutPt(o, r3);
      this.AddJoin(n, a, i.Top);
    }
    return n;
  };
  y.Clipper.prototype.CreateOutRec = function() {
    var t63 = new y.OutRec();
    return t63.Idx = -1, t63.IsHole = false, t63.IsOpen = false, t63.FirstLeft = null, t63.Pts = null, t63.BottomPt = null, t63.PolyNode = null, this.m_PolyOuts.push(t63), t63.Idx = this.m_PolyOuts.length - 1, t63;
  };
  y.Clipper.prototype.AddOutPt = function(t63, e) {
    var r3 = t63.Side == y.EdgeSide.esLeft;
    if (t63.OutIdx < 0) {
      var n = this.CreateOutRec();
      n.IsOpen = t63.WindDelta === 0;
      var i = new y.OutPt();
      return n.Pts = i, i.Idx = n.Idx, i.Pt.X = e.X, i.Pt.Y = e.Y, i.Next = i, i.Prev = i, n.IsOpen || this.SetHoleState(t63, n), Mo && (y.IntPoint.op_Equality(e, t63.Bot) ? (i.Pt.X = t63.Bot.X, i.Pt.Y = t63.Bot.Y, i.Pt.Z = t63.Bot.Z) : y.IntPoint.op_Equality(e, t63.Top) ? (i.Pt.X = t63.Top.X, i.Pt.Y = t63.Top.Y, i.Pt.Z = t63.Top.Z) : this.SetZ(i.Pt, t63)), t63.OutIdx = n.Idx, i;
    } else {
      var n = this.m_PolyOuts[t63.OutIdx], o = n.Pts;
      if (r3 && y.IntPoint.op_Equality(e, o.Pt)) return o;
      if (!r3 && y.IntPoint.op_Equality(e, o.Prev.Pt)) return o.Prev;
      var i = new y.OutPt();
      return i.Idx = n.Idx, i.Pt.X = e.X, i.Pt.Y = e.Y, i.Next = o, i.Prev = o.Prev, i.Prev.Next = i, o.Prev = i, r3 && (n.Pts = i), Mo && (y.IntPoint.op_Equality(e, t63.Bot) ? (i.Pt.X = t63.Bot.X, i.Pt.Y = t63.Bot.Y, i.Pt.Z = t63.Bot.Z) : y.IntPoint.op_Equality(e, t63.Top) ? (i.Pt.X = t63.Top.X, i.Pt.Y = t63.Top.Y, i.Pt.Z = t63.Top.Z) : this.SetZ(i.Pt, t63)), i;
    }
  };
  y.Clipper.prototype.SwapPoints = function(t63, e) {
    var r3 = new y.IntPoint(t63.Value);
    t63.Value.X = e.Value.X, t63.Value.Y = e.Value.Y, e.Value.X = r3.X, e.Value.Y = r3.Y;
  };
  y.Clipper.prototype.HorzSegmentsOverlap = function(t63, e, r3, n) {
    return t63.X > r3.X == t63.X < n.X || e.X > r3.X == e.X < n.X || r3.X > t63.X == r3.X < e.X || n.X > t63.X == n.X < e.X || t63.X == r3.X && e.X == n.X ? true : t63.X == n.X && e.X == r3.X;
  };
  y.Clipper.prototype.InsertPolyPtBetween = function(t63, e, r3) {
    var n = new y.OutPt();
    return n.Pt.X = r3.X, n.Pt.Y = r3.Y, e == t63.Next ? (t63.Next = n, e.Prev = n, n.Next = e, n.Prev = t63) : (e.Next = n, t63.Prev = n, n.Next = t63, n.Prev = e), n;
  };
  y.Clipper.prototype.SetHoleState = function(t63, e) {
    for (var r3 = false, n = t63.PrevInAEL; n !== null; ) n.OutIdx >= 0 && n.WindDelta != 0 && (r3 = !r3, e.FirstLeft === null && (e.FirstLeft = this.m_PolyOuts[n.OutIdx])), n = n.PrevInAEL;
    r3 && (e.IsHole = true);
  };
  y.Clipper.prototype.GetDx = function(t63, e) {
    return t63.Y == e.Y ? y.ClipperBase.horizontal : (e.X - t63.X) / (e.Y - t63.Y);
  };
  y.Clipper.prototype.FirstIsBottomPt = function(t63, e) {
    for (var r3 = t63.Prev; y.IntPoint.op_Equality(r3.Pt, t63.Pt) && r3 != t63; ) r3 = r3.Prev;
    var n = Math.abs(this.GetDx(t63.Pt, r3.Pt));
    for (r3 = t63.Next; y.IntPoint.op_Equality(r3.Pt, t63.Pt) && r3 != t63; ) r3 = r3.Next;
    var i = Math.abs(this.GetDx(t63.Pt, r3.Pt));
    for (r3 = e.Prev; y.IntPoint.op_Equality(r3.Pt, e.Pt) && r3 != e; ) r3 = r3.Prev;
    var o = Math.abs(this.GetDx(e.Pt, r3.Pt));
    for (r3 = e.Next; y.IntPoint.op_Equality(r3.Pt, e.Pt) && r3 != e; ) r3 = r3.Next;
    var a = Math.abs(this.GetDx(e.Pt, r3.Pt));
    return n >= o && n >= a || i >= o && i >= a;
  };
  y.Clipper.prototype.GetBottomPt = function(t63) {
    for (var e = null, r3 = t63.Next; r3 != t63; ) r3.Pt.Y > t63.Pt.Y ? (t63 = r3, e = null) : r3.Pt.Y == t63.Pt.Y && r3.Pt.X <= t63.Pt.X && (r3.Pt.X < t63.Pt.X ? (e = null, t63 = r3) : r3.Next != t63 && r3.Prev != t63 && (e = r3)), r3 = r3.Next;
    if (e !== null) for (; e != r3; ) for (this.FirstIsBottomPt(r3, e) || (t63 = e), e = e.Next; y.IntPoint.op_Inequality(e.Pt, t63.Pt); ) e = e.Next;
    return t63;
  };
  y.Clipper.prototype.GetLowermostRec = function(t63, e) {
    t63.BottomPt === null && (t63.BottomPt = this.GetBottomPt(t63.Pts)), e.BottomPt === null && (e.BottomPt = this.GetBottomPt(e.Pts));
    var r3 = t63.BottomPt, n = e.BottomPt;
    return r3.Pt.Y > n.Pt.Y ? t63 : r3.Pt.Y < n.Pt.Y ? e : r3.Pt.X < n.Pt.X ? t63 : r3.Pt.X > n.Pt.X || r3.Next == r3 ? e : n.Next == n || this.FirstIsBottomPt(r3, n) ? t63 : e;
  };
  y.Clipper.prototype.Param1RightOfParam2 = function(t63, e) {
    do
      if (t63 = t63.FirstLeft, t63 == e) return true;
    while (t63 !== null);
    return false;
  };
  y.Clipper.prototype.GetOutRec = function(t63) {
    for (var e = this.m_PolyOuts[t63]; e != this.m_PolyOuts[e.Idx]; ) e = this.m_PolyOuts[e.Idx];
    return e;
  };
  y.Clipper.prototype.AppendPolygon = function(t63, e) {
    var r3 = this.m_PolyOuts[t63.OutIdx], n = this.m_PolyOuts[e.OutIdx], i;
    this.Param1RightOfParam2(r3, n) ? i = n : this.Param1RightOfParam2(n, r3) ? i = r3 : i = this.GetLowermostRec(r3, n);
    var o = r3.Pts, a = o.Prev, s3 = n.Pts, l = s3.Prev, u3;
    t63.Side == y.EdgeSide.esLeft ? (e.Side == y.EdgeSide.esLeft ? (this.ReversePolyPtLinks(s3), s3.Next = o, o.Prev = s3, a.Next = l, l.Prev = a, r3.Pts = l) : (l.Next = o, o.Prev = l, s3.Prev = a, a.Next = s3, r3.Pts = s3), u3 = y.EdgeSide.esLeft) : (e.Side == y.EdgeSide.esRight ? (this.ReversePolyPtLinks(s3), a.Next = l, l.Prev = a, s3.Next = o, o.Prev = s3) : (a.Next = s3, s3.Prev = a, o.Prev = l, l.Next = o), u3 = y.EdgeSide.esRight), r3.BottomPt = null, i == n && (n.FirstLeft != r3 && (r3.FirstLeft = n.FirstLeft), r3.IsHole = n.IsHole), n.Pts = null, n.BottomPt = null, n.FirstLeft = r3;
    var c = t63.OutIdx, p = e.OutIdx;
    t63.OutIdx = -1, e.OutIdx = -1;
    for (var h = this.m_ActiveEdges; h !== null; ) {
      if (h.OutIdx == p) {
        h.OutIdx = c, h.Side = u3;
        break;
      }
      h = h.NextInAEL;
    }
    n.Idx = r3.Idx;
  };
  y.Clipper.prototype.ReversePolyPtLinks = function(t63) {
    if (t63 !== null) {
      var e, r3;
      e = t63;
      do
        r3 = e.Next, e.Next = e.Prev, e.Prev = r3, e = r3;
      while (e != t63);
    }
  };
  y.Clipper.SwapSides = function(t63, e) {
    var r3 = t63.Side;
    t63.Side = e.Side, e.Side = r3;
  };
  y.Clipper.SwapPolyIndexes = function(t63, e) {
    var r3 = t63.OutIdx;
    t63.OutIdx = e.OutIdx, e.OutIdx = r3;
  };
  y.Clipper.prototype.IntersectEdges = function(t63, e, r3, n) {
    var i = !n && t63.NextInLML === null && t63.Top.X == r3.X && t63.Top.Y == r3.Y, o = !n && e.NextInLML === null && e.Top.X == r3.X && e.Top.Y == r3.Y, a = t63.OutIdx >= 0, s3 = e.OutIdx >= 0;
    if (cM && (t63.WindDelta === 0 || e.WindDelta === 0)) {
      t63.WindDelta === 0 && e.WindDelta === 0 ? (i || o) && a && s3 && this.AddLocalMaxPoly(t63, e, r3) : t63.PolyTyp == e.PolyTyp && t63.WindDelta != e.WindDelta && this.m_ClipType == y.ClipType.ctUnion ? t63.WindDelta === 0 ? s3 && (this.AddOutPt(t63, r3), a && (t63.OutIdx = -1)) : a && (this.AddOutPt(e, r3), s3 && (e.OutIdx = -1)) : t63.PolyTyp != e.PolyTyp && (t63.WindDelta === 0 && Math.abs(e.WindCnt) == 1 && (this.m_ClipType != y.ClipType.ctUnion || e.WindCnt2 === 0) ? (this.AddOutPt(t63, r3), a && (t63.OutIdx = -1)) : e.WindDelta === 0 && Math.abs(t63.WindCnt) == 1 && (this.m_ClipType != y.ClipType.ctUnion || t63.WindCnt2 === 0) && (this.AddOutPt(e, r3), s3 && (e.OutIdx = -1))), i && (t63.OutIdx < 0 ? this.DeleteFromAEL(t63) : y.Error("Error intersecting polylines")), o && (e.OutIdx < 0 ? this.DeleteFromAEL(e) : y.Error("Error intersecting polylines"));
      return;
    }
    if (t63.PolyTyp == e.PolyTyp) if (this.IsEvenOddFillType(t63)) {
      var l = t63.WindCnt;
      t63.WindCnt = e.WindCnt, e.WindCnt = l;
    } else t63.WindCnt + e.WindDelta === 0 ? t63.WindCnt = -t63.WindCnt : t63.WindCnt += e.WindDelta, e.WindCnt - t63.WindDelta === 0 ? e.WindCnt = -e.WindCnt : e.WindCnt -= t63.WindDelta;
    else this.IsEvenOddFillType(e) ? t63.WindCnt2 = t63.WindCnt2 === 0 ? 1 : 0 : t63.WindCnt2 += e.WindDelta, this.IsEvenOddFillType(t63) ? e.WindCnt2 = e.WindCnt2 === 0 ? 1 : 0 : e.WindCnt2 -= t63.WindDelta;
    var u3, c, p, h;
    t63.PolyTyp == y.PolyType.ptSubject ? (u3 = this.m_SubjFillType, p = this.m_ClipFillType) : (u3 = this.m_ClipFillType, p = this.m_SubjFillType), e.PolyTyp == y.PolyType.ptSubject ? (c = this.m_SubjFillType, h = this.m_ClipFillType) : (c = this.m_ClipFillType, h = this.m_SubjFillType);
    var f, d;
    switch (u3) {
      case y.PolyFillType.pftPositive:
        f = t63.WindCnt;
        break;
      case y.PolyFillType.pftNegative:
        f = -t63.WindCnt;
        break;
      default:
        f = Math.abs(t63.WindCnt);
        break;
    }
    switch (c) {
      case y.PolyFillType.pftPositive:
        d = e.WindCnt;
        break;
      case y.PolyFillType.pftNegative:
        d = -e.WindCnt;
        break;
      default:
        d = Math.abs(e.WindCnt);
        break;
    }
    if (a && s3) i || o || f !== 0 && f != 1 || d !== 0 && d != 1 || t63.PolyTyp != e.PolyTyp && this.m_ClipType != y.ClipType.ctXor ? this.AddLocalMaxPoly(t63, e, r3) : (this.AddOutPt(t63, r3), this.AddOutPt(e, r3), y.Clipper.SwapSides(t63, e), y.Clipper.SwapPolyIndexes(t63, e));
    else if (a) (d === 0 || d == 1) && (this.AddOutPt(t63, r3), y.Clipper.SwapSides(t63, e), y.Clipper.SwapPolyIndexes(t63, e));
    else if (s3) (f === 0 || f == 1) && (this.AddOutPt(e, r3), y.Clipper.SwapSides(t63, e), y.Clipper.SwapPolyIndexes(t63, e));
    else if ((f === 0 || f == 1) && (d === 0 || d == 1) && !i && !o) {
      var g, x;
      switch (p) {
        case y.PolyFillType.pftPositive:
          g = t63.WindCnt2;
          break;
        case y.PolyFillType.pftNegative:
          g = -t63.WindCnt2;
          break;
        default:
          g = Math.abs(t63.WindCnt2);
          break;
      }
      switch (h) {
        case y.PolyFillType.pftPositive:
          x = e.WindCnt2;
          break;
        case y.PolyFillType.pftNegative:
          x = -e.WindCnt2;
          break;
        default:
          x = Math.abs(e.WindCnt2);
          break;
      }
      if (t63.PolyTyp != e.PolyTyp) this.AddLocalMinPoly(t63, e, r3);
      else if (f == 1 && d == 1) switch (this.m_ClipType) {
        case y.ClipType.ctIntersection:
          g > 0 && x > 0 && this.AddLocalMinPoly(t63, e, r3);
          break;
        case y.ClipType.ctUnion:
          g <= 0 && x <= 0 && this.AddLocalMinPoly(t63, e, r3);
          break;
        case y.ClipType.ctDifference:
          (t63.PolyTyp == y.PolyType.ptClip && g > 0 && x > 0 || t63.PolyTyp == y.PolyType.ptSubject && g <= 0 && x <= 0) && this.AddLocalMinPoly(t63, e, r3);
          break;
        case y.ClipType.ctXor:
          this.AddLocalMinPoly(t63, e, r3);
          break;
      }
      else y.Clipper.SwapSides(t63, e);
    }
    i != o && (i && t63.OutIdx >= 0 || o && e.OutIdx >= 0) && (y.Clipper.SwapSides(t63, e), y.Clipper.SwapPolyIndexes(t63, e)), i && this.DeleteFromAEL(t63), o && this.DeleteFromAEL(e);
  };
  y.Clipper.prototype.DeleteFromAEL = function(t63) {
    var e = t63.PrevInAEL, r3 = t63.NextInAEL;
    e === null && r3 === null && t63 != this.m_ActiveEdges || (e !== null ? e.NextInAEL = r3 : this.m_ActiveEdges = r3, r3 !== null && (r3.PrevInAEL = e), t63.NextInAEL = null, t63.PrevInAEL = null);
  };
  y.Clipper.prototype.DeleteFromSEL = function(t63) {
    var e = t63.PrevInSEL, r3 = t63.NextInSEL;
    e === null && r3 === null && t63 != this.m_SortedEdges || (e !== null ? e.NextInSEL = r3 : this.m_SortedEdges = r3, r3 !== null && (r3.PrevInSEL = e), t63.NextInSEL = null, t63.PrevInSEL = null);
  };
  y.Clipper.prototype.UpdateEdgeIntoAEL = function(t63) {
    t63.NextInLML === null && y.Error("UpdateEdgeIntoAEL: invalid call");
    var e = t63.PrevInAEL, r3 = t63.NextInAEL;
    return t63.NextInLML.OutIdx = t63.OutIdx, e !== null ? e.NextInAEL = t63.NextInLML : this.m_ActiveEdges = t63.NextInLML, r3 !== null && (r3.PrevInAEL = t63.NextInLML), t63.NextInLML.Side = t63.Side, t63.NextInLML.WindDelta = t63.WindDelta, t63.NextInLML.WindCnt = t63.WindCnt, t63.NextInLML.WindCnt2 = t63.WindCnt2, t63 = t63.NextInLML, t63.Curr.X = t63.Bot.X, t63.Curr.Y = t63.Bot.Y, t63.PrevInAEL = e, t63.NextInAEL = r3, y.ClipperBase.IsHorizontal(t63) || this.InsertScanbeam(t63.Top.Y), t63;
  };
  y.Clipper.prototype.ProcessHorizontals = function(t63) {
    for (var e = this.m_SortedEdges; e !== null; ) this.DeleteFromSEL(e), this.ProcessHorizontal(e, t63), e = this.m_SortedEdges;
  };
  y.Clipper.prototype.GetHorzDirection = function(t63, e) {
    t63.Bot.X < t63.Top.X ? (e.Left = t63.Bot.X, e.Right = t63.Top.X, e.Dir = y.Direction.dLeftToRight) : (e.Left = t63.Top.X, e.Right = t63.Bot.X, e.Dir = y.Direction.dRightToLeft);
  };
  y.Clipper.prototype.PrepareHorzJoins = function(t63, e) {
    var r3 = this.m_PolyOuts[t63.OutIdx].Pts;
    t63.Side != y.EdgeSide.esLeft && (r3 = r3.Prev), e && (y.IntPoint.op_Equality(r3.Pt, t63.Top) ? this.AddGhostJoin(r3, t63.Bot) : this.AddGhostJoin(r3, t63.Top));
  };
  y.Clipper.prototype.ProcessHorizontal = function(t63, e) {
    var r3 = { Dir: null, Left: null, Right: null };
    this.GetHorzDirection(t63, r3);
    for (var n = r3.Dir, i = r3.Left, o = r3.Right, a = t63, s3 = null; a.NextInLML !== null && y.ClipperBase.IsHorizontal(a.NextInLML); ) a = a.NextInLML;
    for (a.NextInLML === null && (s3 = this.GetMaximaPair(a)); ; ) {
      for (var l = t63 == a, u3 = this.GetNextInAEL(t63, n); u3 !== null && !(u3.Curr.X == t63.Top.X && t63.NextInLML !== null && u3.Dx < t63.NextInLML.Dx); ) {
        var c = this.GetNextInAEL(u3, n);
        if (n == y.Direction.dLeftToRight && u3.Curr.X <= o || n == y.Direction.dRightToLeft && u3.Curr.X >= i) {
          if (t63.OutIdx >= 0 && t63.WindDelta != 0 && this.PrepareHorzJoins(t63, e), u3 == s3 && l) {
            n == y.Direction.dLeftToRight ? this.IntersectEdges(t63, u3, u3.Top, false) : this.IntersectEdges(u3, t63, u3.Top, false), s3.OutIdx >= 0 && y.Error("ProcessHorizontal error");
            return;
          } else if (n == y.Direction.dLeftToRight) {
            var p = new y.IntPoint(u3.Curr.X, t63.Curr.Y);
            this.IntersectEdges(t63, u3, p, true);
          } else {
            var p = new y.IntPoint(u3.Curr.X, t63.Curr.Y);
            this.IntersectEdges(u3, t63, p, true);
          }
          this.SwapPositionsInAEL(t63, u3);
        } else if (n == y.Direction.dLeftToRight && u3.Curr.X >= o || n == y.Direction.dRightToLeft && u3.Curr.X <= i) break;
        u3 = c;
      }
      if (t63.OutIdx >= 0 && t63.WindDelta !== 0 && this.PrepareHorzJoins(t63, e), t63.NextInLML !== null && y.ClipperBase.IsHorizontal(t63.NextInLML)) {
        t63 = this.UpdateEdgeIntoAEL(t63), t63.OutIdx >= 0 && this.AddOutPt(t63, t63.Bot);
        var r3 = { Dir: n, Left: i, Right: o };
        this.GetHorzDirection(t63, r3), n = r3.Dir, i = r3.Left, o = r3.Right;
      } else break;
    }
    if (t63.NextInLML !== null) if (t63.OutIdx >= 0) {
      var h = this.AddOutPt(t63, t63.Top);
      if (t63 = this.UpdateEdgeIntoAEL(t63), t63.WindDelta === 0) return;
      var f = t63.PrevInAEL, c = t63.NextInAEL;
      if (f !== null && f.Curr.X == t63.Bot.X && f.Curr.Y == t63.Bot.Y && f.WindDelta !== 0 && f.OutIdx >= 0 && f.Curr.Y > f.Top.Y && y.ClipperBase.SlopesEqual(t63, f, this.m_UseFullRange)) {
        var d = this.AddOutPt(f, t63.Bot);
        this.AddJoin(h, d, t63.Top);
      } else if (c !== null && c.Curr.X == t63.Bot.X && c.Curr.Y == t63.Bot.Y && c.WindDelta !== 0 && c.OutIdx >= 0 && c.Curr.Y > c.Top.Y && y.ClipperBase.SlopesEqual(t63, c, this.m_UseFullRange)) {
        var d = this.AddOutPt(c, t63.Bot);
        this.AddJoin(h, d, t63.Top);
      }
    } else t63 = this.UpdateEdgeIntoAEL(t63);
    else s3 !== null ? s3.OutIdx >= 0 ? (n == y.Direction.dLeftToRight ? this.IntersectEdges(t63, s3, t63.Top, false) : this.IntersectEdges(s3, t63, t63.Top, false), s3.OutIdx >= 0 && y.Error("ProcessHorizontal error")) : (this.DeleteFromAEL(t63), this.DeleteFromAEL(s3)) : (t63.OutIdx >= 0 && this.AddOutPt(t63, t63.Top), this.DeleteFromAEL(t63));
  };
  y.Clipper.prototype.GetNextInAEL = function(t63, e) {
    return e == y.Direction.dLeftToRight ? t63.NextInAEL : t63.PrevInAEL;
  };
  y.Clipper.prototype.IsMinima = function(t63) {
    return t63 !== null && t63.Prev.NextInLML != t63 && t63.Next.NextInLML != t63;
  };
  y.Clipper.prototype.IsMaxima = function(t63, e) {
    return t63 !== null && t63.Top.Y == e && t63.NextInLML === null;
  };
  y.Clipper.prototype.IsIntermediate = function(t63, e) {
    return t63.Top.Y == e && t63.NextInLML !== null;
  };
  y.Clipper.prototype.GetMaximaPair = function(t63) {
    var e = null;
    return y.IntPoint.op_Equality(t63.Next.Top, t63.Top) && t63.Next.NextInLML === null ? e = t63.Next : y.IntPoint.op_Equality(t63.Prev.Top, t63.Top) && t63.Prev.NextInLML === null && (e = t63.Prev), e !== null && (e.OutIdx == -2 || e.NextInAEL == e.PrevInAEL && !y.ClipperBase.IsHorizontal(e)) ? null : e;
  };
  y.Clipper.prototype.ProcessIntersections = function(t63, e) {
    if (this.m_ActiveEdges == null) return true;
    try {
      if (this.BuildIntersectList(t63, e), this.m_IntersectList.length == 0) return true;
      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder()) this.ProcessIntersectList();
      else return false;
    } catch {
      this.m_SortedEdges = null, this.m_IntersectList.length = 0, y.Error("ProcessIntersections error");
    }
    return this.m_SortedEdges = null, true;
  };
  y.Clipper.prototype.BuildIntersectList = function(t63, e) {
    if (this.m_ActiveEdges !== null) {
      var r3 = this.m_ActiveEdges;
      for (this.m_SortedEdges = r3; r3 !== null; ) r3.PrevInSEL = r3.PrevInAEL, r3.NextInSEL = r3.NextInAEL, r3.Curr.X = y.Clipper.TopX(r3, e), r3 = r3.NextInAEL;
      for (var n = true; n && this.m_SortedEdges !== null; ) {
        for (n = false, r3 = this.m_SortedEdges; r3.NextInSEL !== null; ) {
          var i = r3.NextInSEL, o = new y.IntPoint();
          if (r3.Curr.X > i.Curr.X) {
            !this.IntersectPoint(r3, i, o) && r3.Curr.X > i.Curr.X + 1 && y.Error("Intersection error"), o.Y > t63 && (o.Y = t63, Math.abs(r3.Dx) > Math.abs(i.Dx) ? o.X = y.Clipper.TopX(i, t63) : o.X = y.Clipper.TopX(r3, t63));
            var a = new y.IntersectNode();
            a.Edge1 = r3, a.Edge2 = i, a.Pt.X = o.X, a.Pt.Y = o.Y, this.m_IntersectList.push(a), this.SwapPositionsInSEL(r3, i), n = true;
          } else r3 = i;
        }
        if (r3.PrevInSEL !== null) r3.PrevInSEL.NextInSEL = null;
        else break;
      }
      this.m_SortedEdges = null;
    }
  };
  y.Clipper.prototype.EdgesAdjacent = function(t63) {
    return t63.Edge1.NextInSEL == t63.Edge2 || t63.Edge1.PrevInSEL == t63.Edge2;
  };
  y.Clipper.IntersectNodeSort = function(t63, e) {
    return e.Pt.Y - t63.Pt.Y;
  };
  y.Clipper.prototype.FixupIntersectionOrder = function() {
    this.m_IntersectList.sort(this.m_IntersectNodeComparer), this.CopyAELToSEL();
    for (var t63 = this.m_IntersectList.length, e = 0; e < t63; e++) {
      if (!this.EdgesAdjacent(this.m_IntersectList[e])) {
        for (var r3 = e + 1; r3 < t63 && !this.EdgesAdjacent(this.m_IntersectList[r3]); ) r3++;
        if (r3 == t63) return false;
        var n = this.m_IntersectList[e];
        this.m_IntersectList[e] = this.m_IntersectList[r3], this.m_IntersectList[r3] = n;
      }
      this.SwapPositionsInSEL(this.m_IntersectList[e].Edge1, this.m_IntersectList[e].Edge2);
    }
    return true;
  };
  y.Clipper.prototype.ProcessIntersectList = function() {
    for (var t63 = 0, e = this.m_IntersectList.length; t63 < e; t63++) {
      var r3 = this.m_IntersectList[t63];
      this.IntersectEdges(r3.Edge1, r3.Edge2, r3.Pt, true), this.SwapPositionsInAEL(r3.Edge1, r3.Edge2);
    }
    this.m_IntersectList.length = 0;
  };
  var F4 = function(t63) {
    return t63 < 0 ? Math.ceil(t63 - 0.5) : Math.round(t63);
  }, O4 = function(t63) {
    return t63 < 0 ? Math.ceil(t63 - 0.5) : Math.floor(t63 + 0.5);
  }, B4 = function(t63) {
    return t63 < 0 ? -Math.round(Math.abs(t63)) : Math.round(t63);
  }, z4 = function(t63) {
    return t63 < 0 ? (t63 -= 0.5, t63 < -2147483648 ? Math.ceil(t63) : t63 | 0) : (t63 += 0.5, t63 > 2147483647 ? Math.floor(t63) : t63 | 0);
  };
  Me.msie ? y.Clipper.Round = F4 : Me.chromium ? y.Clipper.Round = B4 : Me.safari ? y.Clipper.Round = z4 : y.Clipper.Round = O4;
  y.Clipper.TopX = function(t63, e) {
    return e == t63.Top.Y ? t63.Top.X : t63.Bot.X + y.Clipper.Round(t63.Dx * (e - t63.Bot.Y));
  };
  y.Clipper.prototype.IntersectPoint = function(t63, e, r3) {
    r3.X = 0, r3.Y = 0;
    var n, i;
    if (y.ClipperBase.SlopesEqual(t63, e, this.m_UseFullRange) || t63.Dx == e.Dx) return e.Bot.Y > t63.Bot.Y ? (r3.X = e.Bot.X, r3.Y = e.Bot.Y) : (r3.X = t63.Bot.X, r3.Y = t63.Bot.Y), false;
    if (t63.Delta.X === 0) r3.X = t63.Bot.X, y.ClipperBase.IsHorizontal(e) ? r3.Y = e.Bot.Y : (i = e.Bot.Y - e.Bot.X / e.Dx, r3.Y = y.Clipper.Round(r3.X / e.Dx + i));
    else if (e.Delta.X === 0) r3.X = e.Bot.X, y.ClipperBase.IsHorizontal(t63) ? r3.Y = t63.Bot.Y : (n = t63.Bot.Y - t63.Bot.X / t63.Dx, r3.Y = y.Clipper.Round(r3.X / t63.Dx + n));
    else {
      n = t63.Bot.X - t63.Bot.Y * t63.Dx, i = e.Bot.X - e.Bot.Y * e.Dx;
      var o = (i - n) / (t63.Dx - e.Dx);
      r3.Y = y.Clipper.Round(o), Math.abs(t63.Dx) < Math.abs(e.Dx) ? r3.X = y.Clipper.Round(t63.Dx * o + n) : r3.X = y.Clipper.Round(e.Dx * o + i);
    }
    if (r3.Y < t63.Top.Y || r3.Y < e.Top.Y) {
      if (t63.Top.Y > e.Top.Y) return r3.Y = t63.Top.Y, r3.X = y.Clipper.TopX(e, t63.Top.Y), r3.X < t63.Top.X;
      r3.Y = e.Top.Y, Math.abs(t63.Dx) < Math.abs(e.Dx) ? r3.X = y.Clipper.TopX(t63, r3.Y) : r3.X = y.Clipper.TopX(e, r3.Y);
    }
    return true;
  };
  y.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function(t63) {
    for (var e = this.m_ActiveEdges; e !== null; ) {
      var r3 = this.IsMaxima(e, t63);
      if (r3) {
        var n = this.GetMaximaPair(e);
        r3 = n === null || !y.ClipperBase.IsHorizontal(n);
      }
      if (r3) {
        var i = e.PrevInAEL;
        this.DoMaxima(e), i === null ? e = this.m_ActiveEdges : e = i.NextInAEL;
      } else {
        if (this.IsIntermediate(e, t63) && y.ClipperBase.IsHorizontal(e.NextInLML) ? (e = this.UpdateEdgeIntoAEL(e), e.OutIdx >= 0 && this.AddOutPt(e, e.Bot), this.AddEdgeToSEL(e)) : (e.Curr.X = y.Clipper.TopX(e, t63), e.Curr.Y = t63), this.StrictlySimple) {
          var i = e.PrevInAEL;
          if (e.OutIdx >= 0 && e.WindDelta !== 0 && i !== null && i.OutIdx >= 0 && i.Curr.X == e.Curr.X && i.WindDelta !== 0) {
            var o = this.AddOutPt(i, e.Curr), a = this.AddOutPt(e, e.Curr);
            this.AddJoin(o, a, e.Curr);
          }
        }
        e = e.NextInAEL;
      }
    }
    for (this.ProcessHorizontals(true), e = this.m_ActiveEdges; e !== null; ) {
      if (this.IsIntermediate(e, t63)) {
        var o = null;
        e.OutIdx >= 0 && (o = this.AddOutPt(e, e.Top)), e = this.UpdateEdgeIntoAEL(e);
        var i = e.PrevInAEL, s3 = e.NextInAEL;
        if (i !== null && i.Curr.X == e.Bot.X && i.Curr.Y == e.Bot.Y && o !== null && i.OutIdx >= 0 && i.Curr.Y > i.Top.Y && y.ClipperBase.SlopesEqual(e, i, this.m_UseFullRange) && e.WindDelta !== 0 && i.WindDelta !== 0) {
          var a = this.AddOutPt(i, e.Bot);
          this.AddJoin(o, a, e.Top);
        } else if (s3 !== null && s3.Curr.X == e.Bot.X && s3.Curr.Y == e.Bot.Y && o !== null && s3.OutIdx >= 0 && s3.Curr.Y > s3.Top.Y && y.ClipperBase.SlopesEqual(e, s3, this.m_UseFullRange) && e.WindDelta !== 0 && s3.WindDelta !== 0) {
          var a = this.AddOutPt(s3, e.Bot);
          this.AddJoin(o, a, e.Top);
        }
      }
      e = e.NextInAEL;
    }
  };
  y.Clipper.prototype.DoMaxima = function(t63) {
    var e = this.GetMaximaPair(t63);
    if (e === null) {
      t63.OutIdx >= 0 && this.AddOutPt(t63, t63.Top), this.DeleteFromAEL(t63);
      return;
    }
    for (var r3 = t63.NextInAEL, n = true; r3 !== null && r3 != e; ) this.IntersectEdges(t63, r3, t63.Top, true), this.SwapPositionsInAEL(t63, r3), r3 = t63.NextInAEL;
    t63.OutIdx == -1 && e.OutIdx == -1 ? (this.DeleteFromAEL(t63), this.DeleteFromAEL(e)) : t63.OutIdx >= 0 && e.OutIdx >= 0 ? this.IntersectEdges(t63, e, t63.Top, false) : n && t63.WindDelta === 0 ? (t63.OutIdx >= 0 && (this.AddOutPt(t63, t63.Top), t63.OutIdx = -1), this.DeleteFromAEL(t63), e.OutIdx >= 0 && (this.AddOutPt(e, t63.Top), e.OutIdx = -1), this.DeleteFromAEL(e)) : y.Error("DoMaxima error");
  };
  y.Clipper.ReversePaths = function(t63) {
    for (var e = 0, r3 = t63.length; e < r3; e++) t63[e].reverse();
  };
  y.Clipper.Orientation = function(t63) {
    return y.Clipper.Area(t63) >= 0;
  };
  y.Clipper.prototype.PointCount = function(t63) {
    if (t63 === null) return 0;
    var e = 0, r3 = t63;
    do
      e++, r3 = r3.Next;
    while (r3 != t63);
    return e;
  };
  y.Clipper.prototype.BuildResult = function(t63) {
    y.Clear(t63);
    for (var e = 0, r3 = this.m_PolyOuts.length; e < r3; e++) {
      var n = this.m_PolyOuts[e];
      if (n.Pts !== null) {
        var i = n.Pts.Prev, o = this.PointCount(i);
        if (!(o < 2)) {
          for (var a = new Array(o), s3 = 0; s3 < o; s3++) a[s3] = i.Pt, i = i.Prev;
          t63.push(a);
        }
      }
    }
  };
  y.Clipper.prototype.BuildResult2 = function(t63) {
    t63.Clear();
    for (var e = 0, r3 = this.m_PolyOuts.length; e < r3; e++) {
      var n = this.m_PolyOuts[e], i = this.PointCount(n.Pts);
      if (!(n.IsOpen && i < 2 || !n.IsOpen && i < 3)) {
        this.FixHoleLinkage(n);
        var o = new y.PolyNode();
        t63.m_AllPolys.push(o), n.PolyNode = o, o.m_polygon.length = i;
        for (var a = n.Pts.Prev, s3 = 0; s3 < i; s3++) o.m_polygon[s3] = a.Pt, a = a.Prev;
      }
    }
    for (var e = 0, r3 = this.m_PolyOuts.length; e < r3; e++) {
      var n = this.m_PolyOuts[e];
      n.PolyNode !== null && (n.IsOpen ? (n.PolyNode.IsOpen = true, t63.AddChild(n.PolyNode)) : n.FirstLeft !== null && n.FirstLeft.PolyNode != null ? n.FirstLeft.PolyNode.AddChild(n.PolyNode) : t63.AddChild(n.PolyNode));
    }
  };
  y.Clipper.prototype.FixupOutPolygon = function(t63) {
    var e = null;
    t63.BottomPt = null;
    for (var r3 = t63.Pts; ; ) {
      if (r3.Prev == r3 || r3.Prev == r3.Next) {
        this.DisposeOutPts(r3), t63.Pts = null;
        return;
      }
      if (y.IntPoint.op_Equality(r3.Pt, r3.Next.Pt) || y.IntPoint.op_Equality(r3.Pt, r3.Prev.Pt) || y.ClipperBase.SlopesEqual(r3.Prev.Pt, r3.Pt, r3.Next.Pt, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(r3.Prev.Pt, r3.Pt, r3.Next.Pt))) {
        e = null;
        var n = r3;
        r3.Prev.Next = r3.Next, r3.Next.Prev = r3.Prev, r3 = r3.Prev, n = null;
      } else {
        if (r3 == e) break;
        e === null && (e = r3), r3 = r3.Next;
      }
    }
    t63.Pts = r3;
  };
  y.Clipper.prototype.DupOutPt = function(t63, e) {
    var r3 = new y.OutPt();
    return r3.Pt.X = t63.Pt.X, r3.Pt.Y = t63.Pt.Y, r3.Idx = t63.Idx, e ? (r3.Next = t63.Next, r3.Prev = t63, t63.Next.Prev = r3, t63.Next = r3) : (r3.Prev = t63.Prev, r3.Next = t63, t63.Prev.Next = r3, t63.Prev = r3), r3;
  };
  y.Clipper.prototype.GetOverlap = function(t63, e, r3, n, i) {
    return t63 < e ? r3 < n ? (i.Left = Math.max(t63, r3), i.Right = Math.min(e, n)) : (i.Left = Math.max(t63, n), i.Right = Math.min(e, r3)) : r3 < n ? (i.Left = Math.max(e, r3), i.Right = Math.min(t63, n)) : (i.Left = Math.max(e, n), i.Right = Math.min(t63, r3)), i.Left < i.Right;
  };
  y.Clipper.prototype.JoinHorz = function(t63, e, r3, n, i, o) {
    var a = t63.Pt.X > e.Pt.X ? y.Direction.dRightToLeft : y.Direction.dLeftToRight, s3 = r3.Pt.X > n.Pt.X ? y.Direction.dRightToLeft : y.Direction.dLeftToRight;
    if (a == s3) return false;
    if (a == y.Direction.dLeftToRight) {
      for (; t63.Next.Pt.X <= i.X && t63.Next.Pt.X >= t63.Pt.X && t63.Next.Pt.Y == i.Y; ) t63 = t63.Next;
      o && t63.Pt.X != i.X && (t63 = t63.Next), e = this.DupOutPt(t63, !o), y.IntPoint.op_Inequality(e.Pt, i) && (t63 = e, t63.Pt.X = i.X, t63.Pt.Y = i.Y, e = this.DupOutPt(t63, !o));
    } else {
      for (; t63.Next.Pt.X >= i.X && t63.Next.Pt.X <= t63.Pt.X && t63.Next.Pt.Y == i.Y; ) t63 = t63.Next;
      !o && t63.Pt.X != i.X && (t63 = t63.Next), e = this.DupOutPt(t63, o), y.IntPoint.op_Inequality(e.Pt, i) && (t63 = e, t63.Pt.X = i.X, t63.Pt.Y = i.Y, e = this.DupOutPt(t63, o));
    }
    if (s3 == y.Direction.dLeftToRight) {
      for (; r3.Next.Pt.X <= i.X && r3.Next.Pt.X >= r3.Pt.X && r3.Next.Pt.Y == i.Y; ) r3 = r3.Next;
      o && r3.Pt.X != i.X && (r3 = r3.Next), n = this.DupOutPt(r3, !o), y.IntPoint.op_Inequality(n.Pt, i) && (r3 = n, r3.Pt.X = i.X, r3.Pt.Y = i.Y, n = this.DupOutPt(r3, !o));
    } else {
      for (; r3.Next.Pt.X >= i.X && r3.Next.Pt.X <= r3.Pt.X && r3.Next.Pt.Y == i.Y; ) r3 = r3.Next;
      !o && r3.Pt.X != i.X && (r3 = r3.Next), n = this.DupOutPt(r3, o), y.IntPoint.op_Inequality(n.Pt, i) && (r3 = n, r3.Pt.X = i.X, r3.Pt.Y = i.Y, n = this.DupOutPt(r3, o));
    }
    return a == y.Direction.dLeftToRight == o ? (t63.Prev = r3, r3.Next = t63, e.Next = n, n.Prev = e) : (t63.Next = r3, r3.Prev = t63, e.Prev = n, n.Next = e), true;
  };
  y.Clipper.prototype.JoinPoints = function(t63, e, r3) {
    var n = t63.OutPt1, i = new y.OutPt(), o = t63.OutPt2, a = new y.OutPt(), s3 = t63.OutPt1.Pt.Y == t63.OffPt.Y;
    if (s3 && y.IntPoint.op_Equality(t63.OffPt, t63.OutPt1.Pt) && y.IntPoint.op_Equality(t63.OffPt, t63.OutPt2.Pt)) {
      for (i = t63.OutPt1.Next; i != n && y.IntPoint.op_Equality(i.Pt, t63.OffPt); ) i = i.Next;
      var l = i.Pt.Y > t63.OffPt.Y;
      for (a = t63.OutPt2.Next; a != o && y.IntPoint.op_Equality(a.Pt, t63.OffPt); ) a = a.Next;
      var u3 = a.Pt.Y > t63.OffPt.Y;
      return l == u3 ? false : l ? (i = this.DupOutPt(n, false), a = this.DupOutPt(o, true), n.Prev = o, o.Next = n, i.Next = a, a.Prev = i, t63.OutPt1 = n, t63.OutPt2 = i, true) : (i = this.DupOutPt(n, true), a = this.DupOutPt(o, false), n.Next = o, o.Prev = n, i.Prev = a, a.Next = i, t63.OutPt1 = n, t63.OutPt2 = i, true);
    } else if (s3) {
      for (i = n; n.Prev.Pt.Y == n.Pt.Y && n.Prev != i && n.Prev != o; ) n = n.Prev;
      for (; i.Next.Pt.Y == i.Pt.Y && i.Next != n && i.Next != o; ) i = i.Next;
      if (i.Next == n || i.Next == o) return false;
      for (a = o; o.Prev.Pt.Y == o.Pt.Y && o.Prev != a && o.Prev != i; ) o = o.Prev;
      for (; a.Next.Pt.Y == a.Pt.Y && a.Next != o && a.Next != n; ) a = a.Next;
      if (a.Next == o || a.Next == n) return false;
      var c = { Left: null, Right: null };
      if (!this.GetOverlap(n.Pt.X, i.Pt.X, o.Pt.X, a.Pt.X, c)) return false;
      var p = c.Left, h = c.Right, f = new y.IntPoint(), d;
      return n.Pt.X >= p && n.Pt.X <= h ? (f.X = n.Pt.X, f.Y = n.Pt.Y, d = n.Pt.X > i.Pt.X) : o.Pt.X >= p && o.Pt.X <= h ? (f.X = o.Pt.X, f.Y = o.Pt.Y, d = o.Pt.X > a.Pt.X) : i.Pt.X >= p && i.Pt.X <= h ? (f.X = i.Pt.X, f.Y = i.Pt.Y, d = i.Pt.X > n.Pt.X) : (f.X = a.Pt.X, f.Y = a.Pt.Y, d = a.Pt.X > o.Pt.X), t63.OutPt1 = n, t63.OutPt2 = o, this.JoinHorz(n, i, o, a, f, d);
    } else {
      for (i = n.Next; y.IntPoint.op_Equality(i.Pt, n.Pt) && i != n; ) i = i.Next;
      var g = i.Pt.Y > n.Pt.Y || !y.ClipperBase.SlopesEqual(n.Pt, i.Pt, t63.OffPt, this.m_UseFullRange);
      if (g) {
        for (i = n.Prev; y.IntPoint.op_Equality(i.Pt, n.Pt) && i != n; ) i = i.Prev;
        if (i.Pt.Y > n.Pt.Y || !y.ClipperBase.SlopesEqual(n.Pt, i.Pt, t63.OffPt, this.m_UseFullRange)) return false;
      }
      for (a = o.Next; y.IntPoint.op_Equality(a.Pt, o.Pt) && a != o; ) a = a.Next;
      var x = a.Pt.Y > o.Pt.Y || !y.ClipperBase.SlopesEqual(o.Pt, a.Pt, t63.OffPt, this.m_UseFullRange);
      if (x) {
        for (a = o.Prev; y.IntPoint.op_Equality(a.Pt, o.Pt) && a != o; ) a = a.Prev;
        if (a.Pt.Y > o.Pt.Y || !y.ClipperBase.SlopesEqual(o.Pt, a.Pt, t63.OffPt, this.m_UseFullRange)) return false;
      }
      return i == n || a == o || i == a || e == r3 && g == x ? false : g ? (i = this.DupOutPt(n, false), a = this.DupOutPt(o, true), n.Prev = o, o.Next = n, i.Next = a, a.Prev = i, t63.OutPt1 = n, t63.OutPt2 = i, true) : (i = this.DupOutPt(n, true), a = this.DupOutPt(o, false), n.Next = o, o.Prev = n, i.Prev = a, a.Next = i, t63.OutPt1 = n, t63.OutPt2 = i, true);
    }
  };
  y.Clipper.GetBounds = function(t63) {
    for (var e = 0, r3 = t63.length; e < r3 && t63[e].length == 0; ) e++;
    if (e == r3) return new y.IntRect(0, 0, 0, 0);
    var n = new y.IntRect();
    for (n.left = t63[e][0].X, n.right = n.left, n.top = t63[e][0].Y, n.bottom = n.top; e < r3; e++) for (var i = 0, o = t63[e].length; i < o; i++) t63[e][i].X < n.left ? n.left = t63[e][i].X : t63[e][i].X > n.right && (n.right = t63[e][i].X), t63[e][i].Y < n.top ? n.top = t63[e][i].Y : t63[e][i].Y > n.bottom && (n.bottom = t63[e][i].Y);
    return n;
  };
  y.Clipper.prototype.GetBounds2 = function(t63) {
    var e = t63, r3 = new y.IntRect();
    for (r3.left = t63.Pt.X, r3.right = t63.Pt.X, r3.top = t63.Pt.Y, r3.bottom = t63.Pt.Y, t63 = t63.Next; t63 != e; ) t63.Pt.X < r3.left && (r3.left = t63.Pt.X), t63.Pt.X > r3.right && (r3.right = t63.Pt.X), t63.Pt.Y < r3.top && (r3.top = t63.Pt.Y), t63.Pt.Y > r3.bottom && (r3.bottom = t63.Pt.Y), t63 = t63.Next;
    return r3;
  };
  y.Clipper.PointInPolygon = function(t63, e) {
    var r3 = 0, n = e.length;
    if (n < 3) return 0;
    for (var i = e[0], o = 1; o <= n; ++o) {
      var a = o == n ? e[0] : e[o];
      if (a.Y == t63.Y && (a.X == t63.X || i.Y == t63.Y && a.X > t63.X == i.X < t63.X)) return -1;
      if (i.Y < t63.Y != a.Y < t63.Y) {
        if (i.X >= t63.X) if (a.X > t63.X) r3 = 1 - r3;
        else {
          var s3 = (i.X - t63.X) * (a.Y - t63.Y) - (a.X - t63.X) * (i.Y - t63.Y);
          if (s3 == 0) return -1;
          s3 > 0 == a.Y > i.Y && (r3 = 1 - r3);
        }
        else if (a.X > t63.X) {
          var s3 = (i.X - t63.X) * (a.Y - t63.Y) - (a.X - t63.X) * (i.Y - t63.Y);
          if (s3 == 0) return -1;
          s3 > 0 == a.Y > i.Y && (r3 = 1 - r3);
        }
      }
      i = a;
    }
    return r3;
  };
  y.Clipper.prototype.PointInPolygon = function(t63, e) {
    for (var r3 = 0, n = e; ; ) {
      var i = e.Pt.X, o = e.Pt.Y, a = e.Next.Pt.X, s3 = e.Next.Pt.Y;
      if (s3 == t63.Y && (a == t63.X || o == t63.Y && a > t63.X == i < t63.X)) return -1;
      if (o < t63.Y != s3 < t63.Y) {
        if (i >= t63.X) if (a > t63.X) r3 = 1 - r3;
        else {
          var l = (i - t63.X) * (s3 - t63.Y) - (a - t63.X) * (o - t63.Y);
          if (l == 0) return -1;
          l > 0 == s3 > o && (r3 = 1 - r3);
        }
        else if (a > t63.X) {
          var l = (i - t63.X) * (s3 - t63.Y) - (a - t63.X) * (o - t63.Y);
          if (l == 0) return -1;
          l > 0 == s3 > o && (r3 = 1 - r3);
        }
      }
      if (e = e.Next, n == e) break;
    }
    return r3;
  };
  y.Clipper.prototype.Poly2ContainsPoly1 = function(t63, e) {
    var r3 = t63;
    do {
      var n = this.PointInPolygon(r3.Pt, e);
      if (n >= 0) return n != 0;
      r3 = r3.Next;
    } while (r3 != t63);
    return true;
  };
  y.Clipper.prototype.FixupFirstLefts1 = function(t63, e) {
    for (var r3 = 0, n = this.m_PolyOuts.length; r3 < n; r3++) {
      var i = this.m_PolyOuts[r3];
      i.Pts !== null && i.FirstLeft == t63 && this.Poly2ContainsPoly1(i.Pts, e.Pts) && (i.FirstLeft = e);
    }
  };
  y.Clipper.prototype.FixupFirstLefts2 = function(t63, e) {
    for (var r3 = 0, n = this.m_PolyOuts, i = n.length, o = n[r3]; r3 < i; r3++, o = n[r3]) o.FirstLeft == t63 && (o.FirstLeft = e);
  };
  y.Clipper.ParseFirstLeft = function(t63) {
    for (; t63 != null && t63.Pts == null; ) t63 = t63.FirstLeft;
    return t63;
  };
  y.Clipper.prototype.JoinCommonEdges = function() {
    for (var t63 = 0, e = this.m_Joins.length; t63 < e; t63++) {
      var r3 = this.m_Joins[t63], n = this.GetOutRec(r3.OutPt1.Idx), i = this.GetOutRec(r3.OutPt2.Idx);
      if (!(n.Pts == null || i.Pts == null)) {
        var o;
        if (n == i ? o = n : this.Param1RightOfParam2(n, i) ? o = i : this.Param1RightOfParam2(i, n) ? o = n : o = this.GetLowermostRec(n, i), !!this.JoinPoints(r3, n, i)) if (n == i) {
          if (n.Pts = r3.OutPt1, n.BottomPt = null, i = this.CreateOutRec(), i.Pts = r3.OutPt2, this.UpdateOutPtIdxs(i), this.m_UsingPolyTree) for (var a = 0, s3 = this.m_PolyOuts.length; a < s3 - 1; a++) {
            var l = this.m_PolyOuts[a];
            l.Pts == null || y.Clipper.ParseFirstLeft(l.FirstLeft) != n || l.IsHole == n.IsHole || this.Poly2ContainsPoly1(l.Pts, r3.OutPt2) && (l.FirstLeft = i);
          }
          this.Poly2ContainsPoly1(i.Pts, n.Pts) ? (i.IsHole = !n.IsHole, i.FirstLeft = n, this.m_UsingPolyTree && this.FixupFirstLefts2(i, n), (i.IsHole ^ this.ReverseSolution) == this.Area(i) > 0 && this.ReversePolyPtLinks(i.Pts)) : this.Poly2ContainsPoly1(n.Pts, i.Pts) ? (i.IsHole = n.IsHole, n.IsHole = !i.IsHole, i.FirstLeft = n.FirstLeft, n.FirstLeft = i, this.m_UsingPolyTree && this.FixupFirstLefts2(n, i), (n.IsHole ^ this.ReverseSolution) == this.Area(n) > 0 && this.ReversePolyPtLinks(n.Pts)) : (i.IsHole = n.IsHole, i.FirstLeft = n.FirstLeft, this.m_UsingPolyTree && this.FixupFirstLefts1(n, i));
        } else i.Pts = null, i.BottomPt = null, i.Idx = n.Idx, n.IsHole = o.IsHole, o == i && (n.FirstLeft = i.FirstLeft), i.FirstLeft = n, this.m_UsingPolyTree && this.FixupFirstLefts2(i, n);
      }
    }
  };
  y.Clipper.prototype.UpdateOutPtIdxs = function(t63) {
    var e = t63.Pts;
    do
      e.Idx = t63.Idx, e = e.Prev;
    while (e != t63.Pts);
  };
  y.Clipper.prototype.DoSimplePolygons = function() {
    for (var t63 = 0; t63 < this.m_PolyOuts.length; ) {
      var e = this.m_PolyOuts[t63++], r3 = e.Pts;
      if (r3 !== null) do {
        for (var n = r3.Next; n != e.Pts; ) {
          if (y.IntPoint.op_Equality(r3.Pt, n.Pt) && n.Next != r3 && n.Prev != r3) {
            var i = r3.Prev, o = n.Prev;
            r3.Prev = o, o.Next = r3, n.Prev = i, i.Next = n, e.Pts = r3;
            var a = this.CreateOutRec();
            a.Pts = n, this.UpdateOutPtIdxs(a), this.Poly2ContainsPoly1(a.Pts, e.Pts) ? (a.IsHole = !e.IsHole, a.FirstLeft = e) : this.Poly2ContainsPoly1(e.Pts, a.Pts) ? (a.IsHole = e.IsHole, e.IsHole = !a.IsHole, a.FirstLeft = e.FirstLeft, e.FirstLeft = a) : (a.IsHole = e.IsHole, a.FirstLeft = e.FirstLeft), n = r3;
          }
          n = n.Next;
        }
        r3 = r3.Next;
      } while (r3 != e.Pts);
    }
  };
  y.Clipper.Area = function(t63) {
    var e = t63.length;
    if (e < 3) return 0;
    for (var r3 = 0, n = 0, i = e - 1; n < e; ++n) r3 += (t63[i].X + t63[n].X) * (t63[i].Y - t63[n].Y), i = n;
    return -r3 * 0.5;
  };
  y.Clipper.prototype.Area = function(t63) {
    var e = t63.Pts;
    if (e == null) return 0;
    var r3 = 0;
    do
      r3 = r3 + (e.Prev.Pt.X + e.Pt.X) * (e.Prev.Pt.Y - e.Pt.Y), e = e.Next;
    while (e != t63.Pts);
    return r3 * 0.5;
  };
  pM && (y.Clipper.OffsetPaths = function(t63, e, r3, n, i) {
    var o = new y.Paths(), a = new y.ClipperOffset(i, i);
    return a.AddPaths(t63, r3, n), a.Execute(o, e), o;
  });
  y.Clipper.SimplifyPolygon = function(t63, e) {
    var r3 = new Array(), n = new y.Clipper(0);
    return n.StrictlySimple = true, n.AddPath(t63, y.PolyType.ptSubject, true), n.Execute(y.ClipType.ctUnion, r3, e, e), r3;
  };
  y.Clipper.SimplifyPolygons = function(t63, e) {
    typeof e > "u" && (e = y.PolyFillType.pftEvenOdd);
    var r3 = new Array(), n = new y.Clipper(0);
    return n.StrictlySimple = true, n.AddPaths(t63, y.PolyType.ptSubject, true), n.Execute(y.ClipType.ctUnion, r3, e, e), r3;
  };
  y.Clipper.DistanceSqrd = function(t63, e) {
    var r3 = t63.X - e.X, n = t63.Y - e.Y;
    return r3 * r3 + n * n;
  };
  y.Clipper.DistanceFromLineSqrd = function(t63, e, r3) {
    var n = e.Y - r3.Y, i = r3.X - e.X, o = n * e.X + i * e.Y;
    return o = n * t63.X + i * t63.Y - o, o * o / (n * n + i * i);
  };
  y.Clipper.SlopesNearCollinear = function(t63, e, r3, n) {
    return y.Clipper.DistanceFromLineSqrd(e, t63, r3) < n;
  };
  y.Clipper.PointsAreClose = function(t63, e, r3) {
    var n = t63.X - e.X, i = t63.Y - e.Y;
    return n * n + i * i <= r3;
  };
  y.Clipper.ExcludeOp = function(t63) {
    var e = t63.Prev;
    return e.Next = t63.Next, t63.Next.Prev = e, e.Idx = 0, e;
  };
  y.Clipper.CleanPolygon = function(t63, e) {
    typeof e > "u" && (e = 1.415);
    var r3 = t63.length;
    if (r3 == 0) return new Array();
    for (var n = new Array(r3), i = 0; i < r3; ++i) n[i] = new y.OutPt();
    for (var i = 0; i < r3; ++i) n[i].Pt = t63[i], n[i].Next = n[(i + 1) % r3], n[i].Next.Prev = n[i], n[i].Idx = 0;
    for (var o = e * e, a = n[0]; a.Idx == 0 && a.Next != a.Prev; ) y.Clipper.PointsAreClose(a.Pt, a.Prev.Pt, o) ? (a = y.Clipper.ExcludeOp(a), r3--) : y.Clipper.PointsAreClose(a.Prev.Pt, a.Next.Pt, o) ? (y.Clipper.ExcludeOp(a.Next), a = y.Clipper.ExcludeOp(a), r3 -= 2) : y.Clipper.SlopesNearCollinear(a.Prev.Pt, a.Pt, a.Next.Pt, o) ? (a = y.Clipper.ExcludeOp(a), r3--) : (a.Idx = 1, a = a.Next);
    r3 < 3 && (r3 = 0);
    for (var s3 = new Array(r3), i = 0; i < r3; ++i) s3[i] = new y.IntPoint(a.Pt), a = a.Next;
    return n = null, s3;
  };
  y.Clipper.CleanPolygons = function(t63, e) {
    for (var r3 = new Array(t63.length), n = 0, i = t63.length; n < i; n++) r3[n] = y.Clipper.CleanPolygon(t63[n], e);
    return r3;
  };
  y.Clipper.Minkowski = function(t63, e, r3, n) {
    var i = n ? 1 : 0, o = t63.length, a = e.length, s3 = new Array();
    if (r3) for (var l = 0; l < a; l++) {
      for (var u3 = new Array(o), c = 0, p = t63.length, h = t63[c]; c < p; c++, h = t63[c]) u3[c] = new y.IntPoint(e[l].X + h.X, e[l].Y + h.Y);
      s3.push(u3);
    }
    else for (var l = 0; l < a; l++) {
      for (var u3 = new Array(o), c = 0, p = t63.length, h = t63[c]; c < p; c++, h = t63[c]) u3[c] = new y.IntPoint(e[l].X - h.X, e[l].Y - h.Y);
      s3.push(u3);
    }
    for (var f = new Array(), l = 0; l < a - 1 + i; l++) for (var c = 0; c < o; c++) {
      var d = new Array();
      d.push(s3[l % a][c % o]), d.push(s3[(l + 1) % a][c % o]), d.push(s3[(l + 1) % a][(c + 1) % o]), d.push(s3[l % a][(c + 1) % o]), y.Clipper.Orientation(d) || d.reverse(), f.push(d);
    }
    var g = new y.Clipper(0);
    return g.AddPaths(f, y.PolyType.ptSubject, true), g.Execute(y.ClipType.ctUnion, s3, y.PolyFillType.pftNonZero, y.PolyFillType.pftNonZero), s3;
  };
  y.Clipper.MinkowskiSum = function() {
    var t63 = arguments, e = t63.length;
    if (e == 3) {
      var r3 = t63[0], n = t63[1], i = t63[2];
      return y.Clipper.Minkowski(r3, n, true, i);
    } else if (e == 4) {
      for (var r3 = t63[0], o = t63[1], a = t63[2], i = t63[3], s3 = new y.Clipper(), l, u3 = 0, c = o.length; u3 < c; ++u3) {
        var l = y.Clipper.Minkowski(r3, o[u3], true, i);
        s3.AddPaths(l, y.PolyType.ptSubject, true);
      }
      i && s3.AddPaths(o, y.PolyType.ptClip, true);
      var p = new y.Paths();
      return s3.Execute(y.ClipType.ctUnion, p, a, a), p;
    }
  };
  y.Clipper.MinkowskiDiff = function(t63, e, r3) {
    return y.Clipper.Minkowski(t63, e, false, r3);
  };
  y.Clipper.PolyTreeToPaths = function(t63) {
    var e = new Array();
    return y.Clipper.AddPolyNodeToPaths(t63, y.Clipper.NodeType.ntAny, e), e;
  };
  y.Clipper.AddPolyNodeToPaths = function(t63, e, r3) {
    var n = true;
    switch (e) {
      case y.Clipper.NodeType.ntOpen:
        return;
      case y.Clipper.NodeType.ntClosed:
        n = !t63.IsOpen;
        break;
      default:
        break;
    }
    t63.m_polygon.length > 0 && n && r3.push(t63.m_polygon);
    for (var i = 0, o = t63.Childs(), a = o.length, s3 = o[i]; i < a; i++, s3 = o[i]) y.Clipper.AddPolyNodeToPaths(s3, e, r3);
  };
  y.Clipper.OpenPathsFromPolyTree = function(t63) {
    for (var e = new y.Paths(), r3 = 0, n = t63.ChildCount(); r3 < n; r3++) t63.Childs()[r3].IsOpen && e.push(t63.Childs()[r3].m_polygon);
    return e;
  };
  y.Clipper.ClosedPathsFromPolyTree = function(t63) {
    var e = new y.Paths();
    return y.Clipper.AddPolyNodeToPaths(t63, y.Clipper.NodeType.ntClosed, e), e;
  };
  gm(y.Clipper, y.ClipperBase);
  y.Clipper.NodeType = { ntAny: 0, ntOpen: 1, ntClosed: 2 };
  y.ClipperOffset = function(t63, e) {
    typeof t63 > "u" && (t63 = 2), typeof e > "u" && (e = y.ClipperOffset.def_arc_tolerance), this.m_destPolys = new y.Paths(), this.m_srcPoly = new y.Path(), this.m_destPoly = new y.Path(), this.m_normals = new Array(), this.m_delta = 0, this.m_sinA = 0, this.m_sin = 0, this.m_cos = 0, this.m_miterLim = 0, this.m_StepsPerRad = 0, this.m_lowest = new y.IntPoint(), this.m_polyNodes = new y.PolyNode(), this.MiterLimit = t63, this.ArcTolerance = e, this.m_lowest.X = -1;
  };
  y.ClipperOffset.two_pi = 6.28318530717959;
  y.ClipperOffset.def_arc_tolerance = 0.25;
  y.ClipperOffset.prototype.Clear = function() {
    y.Clear(this.m_polyNodes.Childs()), this.m_lowest.X = -1;
  };
  y.ClipperOffset.Round = y.Clipper.Round;
  y.ClipperOffset.prototype.AddPath = function(t63, e, r3) {
    var n = t63.length - 1;
    if (!(n < 0)) {
      var i = new y.PolyNode();
      if (i.m_jointype = e, i.m_endtype = r3, r3 == y.EndType.etClosedLine || r3 == y.EndType.etClosedPolygon) for (; n > 0 && y.IntPoint.op_Equality(t63[0], t63[n]); ) n--;
      i.m_polygon.push(t63[0]);
      for (var o = 0, a = 0, s3 = 1; s3 <= n; s3++) y.IntPoint.op_Inequality(i.m_polygon[o], t63[s3]) && (o++, i.m_polygon.push(t63[s3]), (t63[s3].Y > i.m_polygon[a].Y || t63[s3].Y == i.m_polygon[a].Y && t63[s3].X < i.m_polygon[a].X) && (a = o));
      if (!(r3 == y.EndType.etClosedPolygon && o < 2 || r3 != y.EndType.etClosedPolygon && o < 0) && (this.m_polyNodes.AddChild(i), r3 == y.EndType.etClosedPolygon)) if (this.m_lowest.X < 0) this.m_lowest = new y.IntPoint(0, a);
      else {
        var l = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];
        (i.m_polygon[a].Y > l.Y || i.m_polygon[a].Y == l.Y && i.m_polygon[a].X < l.X) && (this.m_lowest = new y.IntPoint(this.m_polyNodes.ChildCount() - 1, a));
      }
    }
  };
  y.ClipperOffset.prototype.AddPaths = function(t63, e, r3) {
    for (var n = 0, i = t63.length; n < i; n++) this.AddPath(t63[n], e, r3);
  };
  y.ClipperOffset.prototype.FixOrientations = function() {
    if (this.m_lowest.X >= 0 && !y.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon)) for (var t63 = 0; t63 < this.m_polyNodes.ChildCount(); t63++) {
      var e = this.m_polyNodes.Childs()[t63];
      (e.m_endtype == y.EndType.etClosedPolygon || e.m_endtype == y.EndType.etClosedLine && y.Clipper.Orientation(e.m_polygon)) && e.m_polygon.reverse();
    }
    else for (var t63 = 0; t63 < this.m_polyNodes.ChildCount(); t63++) {
      var e = this.m_polyNodes.Childs()[t63];
      e.m_endtype == y.EndType.etClosedLine && !y.Clipper.Orientation(e.m_polygon) && e.m_polygon.reverse();
    }
  };
  y.ClipperOffset.GetUnitNormal = function(t63, e) {
    var r3 = e.X - t63.X, n = e.Y - t63.Y;
    if (r3 == 0 && n == 0) return new y.DoublePoint(0, 0);
    var i = 1 / Math.sqrt(r3 * r3 + n * n);
    return r3 *= i, n *= i, new y.DoublePoint(n, -r3);
  };
  y.ClipperOffset.prototype.DoOffset = function(t63) {
    if (this.m_destPolys = new Array(), this.m_delta = t63, y.ClipperBase.near_zero(t63)) {
      for (var e = 0; e < this.m_polyNodes.ChildCount(); e++) {
        var r3 = this.m_polyNodes.Childs()[e];
        r3.m_endtype == y.EndType.etClosedPolygon && this.m_destPolys.push(r3.m_polygon);
      }
      return;
    }
    this.MiterLimit > 2 ? this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit) : this.m_miterLim = 0.5;
    var n;
    this.ArcTolerance <= 0 ? n = y.ClipperOffset.def_arc_tolerance : this.ArcTolerance > Math.abs(t63) * y.ClipperOffset.def_arc_tolerance ? n = Math.abs(t63) * y.ClipperOffset.def_arc_tolerance : n = this.ArcTolerance;
    var i = 3.14159265358979 / Math.acos(1 - n / Math.abs(t63));
    this.m_sin = Math.sin(y.ClipperOffset.two_pi / i), this.m_cos = Math.cos(y.ClipperOffset.two_pi / i), this.m_StepsPerRad = i / y.ClipperOffset.two_pi, t63 < 0 && (this.m_sin = -this.m_sin);
    for (var e = 0; e < this.m_polyNodes.ChildCount(); e++) {
      var r3 = this.m_polyNodes.Childs()[e];
      this.m_srcPoly = r3.m_polygon;
      var o = this.m_srcPoly.length;
      if (!(o == 0 || t63 <= 0 && (o < 3 || r3.m_endtype != y.EndType.etClosedPolygon))) {
        if (this.m_destPoly = new Array(), o == 1) {
          if (r3.m_jointype == y.JoinType.jtRound) for (var a = 1, s3 = 0, l = 1; l <= i; l++) {
            this.m_destPoly.push(new y.IntPoint(y.ClipperOffset.Round(this.m_srcPoly[0].X + a * t63), y.ClipperOffset.Round(this.m_srcPoly[0].Y + s3 * t63)));
            var u3 = a;
            a = a * this.m_cos - this.m_sin * s3, s3 = u3 * this.m_sin + s3 * this.m_cos;
          }
          else for (var a = -1, s3 = -1, l = 0; l < 4; ++l) this.m_destPoly.push(new y.IntPoint(y.ClipperOffset.Round(this.m_srcPoly[0].X + a * t63), y.ClipperOffset.Round(this.m_srcPoly[0].Y + s3 * t63))), a < 0 ? a = 1 : s3 < 0 ? s3 = 1 : a = -1;
          this.m_destPolys.push(this.m_destPoly);
          continue;
        }
        this.m_normals.length = 0;
        for (var l = 0; l < o - 1; l++) this.m_normals.push(y.ClipperOffset.GetUnitNormal(this.m_srcPoly[l], this.m_srcPoly[l + 1]));
        if (r3.m_endtype == y.EndType.etClosedLine || r3.m_endtype == y.EndType.etClosedPolygon ? this.m_normals.push(y.ClipperOffset.GetUnitNormal(this.m_srcPoly[o - 1], this.m_srcPoly[0])) : this.m_normals.push(new y.DoublePoint(this.m_normals[o - 2])), r3.m_endtype == y.EndType.etClosedPolygon) {
          for (var c = o - 1, l = 0; l < o; l++) c = this.OffsetPoint(l, c, r3.m_jointype);
          this.m_destPolys.push(this.m_destPoly);
        } else if (r3.m_endtype == y.EndType.etClosedLine) {
          for (var c = o - 1, l = 0; l < o; l++) c = this.OffsetPoint(l, c, r3.m_jointype);
          this.m_destPolys.push(this.m_destPoly), this.m_destPoly = new Array();
          for (var p = this.m_normals[o - 1], l = o - 1; l > 0; l--) this.m_normals[l] = new y.DoublePoint(-this.m_normals[l - 1].X, -this.m_normals[l - 1].Y);
          this.m_normals[0] = new y.DoublePoint(-p.X, -p.Y), c = 0;
          for (var l = o - 1; l >= 0; l--) c = this.OffsetPoint(l, c, r3.m_jointype);
          this.m_destPolys.push(this.m_destPoly);
        } else {
          for (var c = 0, l = 1; l < o - 1; ++l) c = this.OffsetPoint(l, c, r3.m_jointype);
          var h;
          if (r3.m_endtype == y.EndType.etOpenButt) {
            var l = o - 1;
            h = new y.IntPoint(y.ClipperOffset.Round(this.m_srcPoly[l].X + this.m_normals[l].X * t63), y.ClipperOffset.Round(this.m_srcPoly[l].Y + this.m_normals[l].Y * t63)), this.m_destPoly.push(h), h = new y.IntPoint(y.ClipperOffset.Round(this.m_srcPoly[l].X - this.m_normals[l].X * t63), y.ClipperOffset.Round(this.m_srcPoly[l].Y - this.m_normals[l].Y * t63)), this.m_destPoly.push(h);
          } else {
            var l = o - 1;
            c = o - 2, this.m_sinA = 0, this.m_normals[l] = new y.DoublePoint(-this.m_normals[l].X, -this.m_normals[l].Y), r3.m_endtype == y.EndType.etOpenSquare ? this.DoSquare(l, c) : this.DoRound(l, c);
          }
          for (var l = o - 1; l > 0; l--) this.m_normals[l] = new y.DoublePoint(-this.m_normals[l - 1].X, -this.m_normals[l - 1].Y);
          this.m_normals[0] = new y.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y), c = o - 1;
          for (var l = c - 1; l > 0; --l) c = this.OffsetPoint(l, c, r3.m_jointype);
          r3.m_endtype == y.EndType.etOpenButt ? (h = new y.IntPoint(y.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * t63), y.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * t63)), this.m_destPoly.push(h), h = new y.IntPoint(y.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * t63), y.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * t63)), this.m_destPoly.push(h)) : (c = 1, this.m_sinA = 0, r3.m_endtype == y.EndType.etOpenSquare ? this.DoSquare(0, 1) : this.DoRound(0, 1)), this.m_destPolys.push(this.m_destPoly);
        }
      }
    }
  };
  y.ClipperOffset.prototype.Execute = function() {
    var t63 = arguments, e = t63[0] instanceof y.PolyTree;
    if (e) {
      var r3 = t63[0], n = t63[1];
      r3.Clear(), this.FixOrientations(), this.DoOffset(n);
      var i = new y.Clipper(0);
      if (i.AddPaths(this.m_destPolys, y.PolyType.ptSubject, true), n > 0) i.Execute(y.ClipType.ctUnion, r3, y.PolyFillType.pftPositive, y.PolyFillType.pftPositive);
      else {
        var o = y.Clipper.GetBounds(this.m_destPolys), a = new y.Path();
        if (a.push(new y.IntPoint(o.left - 10, o.bottom + 10)), a.push(new y.IntPoint(o.right + 10, o.bottom + 10)), a.push(new y.IntPoint(o.right + 10, o.top - 10)), a.push(new y.IntPoint(o.left - 10, o.top - 10)), i.AddPath(a, y.PolyType.ptSubject, true), i.ReverseSolution = true, i.Execute(y.ClipType.ctUnion, r3, y.PolyFillType.pftNegative, y.PolyFillType.pftNegative), r3.ChildCount() == 1 && r3.Childs()[0].ChildCount() > 0) {
          var s3 = r3.Childs()[0];
          r3.Childs()[0] = s3.Childs()[0];
          for (var l = 1; l < s3.ChildCount(); l++) r3.AddChild(s3.Childs()[l]);
        } else r3.Clear();
      }
    } else {
      var r3 = t63[0], n = t63[1];
      y.Clear(r3), this.FixOrientations(), this.DoOffset(n);
      var i = new y.Clipper(0);
      if (i.AddPaths(this.m_destPolys, y.PolyType.ptSubject, true), n > 0) i.Execute(y.ClipType.ctUnion, r3, y.PolyFillType.pftPositive, y.PolyFillType.pftPositive);
      else {
        var o = y.Clipper.GetBounds(this.m_destPolys), a = new y.Path();
        a.push(new y.IntPoint(o.left - 10, o.bottom + 10)), a.push(new y.IntPoint(o.right + 10, o.bottom + 10)), a.push(new y.IntPoint(o.right + 10, o.top - 10)), a.push(new y.IntPoint(o.left - 10, o.top - 10)), i.AddPath(a, y.PolyType.ptSubject, true), i.ReverseSolution = true, i.Execute(y.ClipType.ctUnion, r3, y.PolyFillType.pftNegative, y.PolyFillType.pftNegative), r3.length > 0 && r3.splice(0, 1);
      }
    }
  };
  y.ClipperOffset.prototype.OffsetPoint = function(t63, e, r3) {
    if (this.m_sinA = this.m_normals[e].X * this.m_normals[t63].Y - this.m_normals[t63].X * this.m_normals[e].Y, this.m_sinA < 5e-5 && this.m_sinA > -5e-5) return e;
    if (this.m_sinA > 1 ? this.m_sinA = 1 : this.m_sinA < -1 && (this.m_sinA = -1), this.m_sinA * this.m_delta < 0) this.m_destPoly.push(new y.IntPoint(y.ClipperOffset.Round(this.m_srcPoly[t63].X + this.m_normals[e].X * this.m_delta), y.ClipperOffset.Round(this.m_srcPoly[t63].Y + this.m_normals[e].Y * this.m_delta))), this.m_destPoly.push(new y.IntPoint(this.m_srcPoly[t63])), this.m_destPoly.push(new y.IntPoint(y.ClipperOffset.Round(this.m_srcPoly[t63].X + this.m_normals[t63].X * this.m_delta), y.ClipperOffset.Round(this.m_srcPoly[t63].Y + this.m_normals[t63].Y * this.m_delta)));
    else switch (r3) {
      case y.JoinType.jtMiter: {
        var n = 1 + (this.m_normals[t63].X * this.m_normals[e].X + this.m_normals[t63].Y * this.m_normals[e].Y);
        n >= this.m_miterLim ? this.DoMiter(t63, e, n) : this.DoSquare(t63, e);
        break;
      }
      case y.JoinType.jtSquare:
        this.DoSquare(t63, e);
        break;
      case y.JoinType.jtRound:
        this.DoRound(t63, e);
        break;
    }
    return e = t63, e;
  };
  y.ClipperOffset.prototype.DoSquare = function(t63, e) {
    var r3 = Math.tan(Math.atan2(this.m_sinA, this.m_normals[e].X * this.m_normals[t63].X + this.m_normals[e].Y * this.m_normals[t63].Y) / 4);
    this.m_destPoly.push(new y.IntPoint(y.ClipperOffset.Round(this.m_srcPoly[t63].X + this.m_delta * (this.m_normals[e].X - this.m_normals[e].Y * r3)), y.ClipperOffset.Round(this.m_srcPoly[t63].Y + this.m_delta * (this.m_normals[e].Y + this.m_normals[e].X * r3)))), this.m_destPoly.push(new y.IntPoint(y.ClipperOffset.Round(this.m_srcPoly[t63].X + this.m_delta * (this.m_normals[t63].X + this.m_normals[t63].Y * r3)), y.ClipperOffset.Round(this.m_srcPoly[t63].Y + this.m_delta * (this.m_normals[t63].Y - this.m_normals[t63].X * r3))));
  };
  y.ClipperOffset.prototype.DoMiter = function(t63, e, r3) {
    var n = this.m_delta / r3;
    this.m_destPoly.push(new y.IntPoint(y.ClipperOffset.Round(this.m_srcPoly[t63].X + (this.m_normals[e].X + this.m_normals[t63].X) * n), y.ClipperOffset.Round(this.m_srcPoly[t63].Y + (this.m_normals[e].Y + this.m_normals[t63].Y) * n)));
  };
  y.ClipperOffset.prototype.DoRound = function(t63, e) {
    for (var r3 = Math.atan2(this.m_sinA, this.m_normals[e].X * this.m_normals[t63].X + this.m_normals[e].Y * this.m_normals[t63].Y), n = y.Cast_Int32(y.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(r3))), i = this.m_normals[e].X, o = this.m_normals[e].Y, a, s3 = 0; s3 < n; ++s3) this.m_destPoly.push(new y.IntPoint(y.ClipperOffset.Round(this.m_srcPoly[t63].X + i * this.m_delta), y.ClipperOffset.Round(this.m_srcPoly[t63].Y + o * this.m_delta))), a = i, i = i * this.m_cos - this.m_sin * o, o = a * this.m_sin + o * this.m_cos;
    this.m_destPoly.push(new y.IntPoint(y.ClipperOffset.Round(this.m_srcPoly[t63].X + this.m_normals[t63].X * this.m_delta), y.ClipperOffset.Round(this.m_srcPoly[t63].Y + this.m_normals[t63].Y * this.m_delta)));
  };
  y.Error = function(t63) {
    try {
      throw new Error(t63);
    } catch (e) {
      alert(e.message);
    }
  };
  y.JS = {};
  y.JS.AreaOfPolygon = function(t63, e) {
    return e || (e = 1), y.Clipper.Area(t63) / (e * e);
  };
  y.JS.AreaOfPolygons = function(t63, e) {
    e || (e = 1);
    for (var r3 = 0, n = 0; n < t63.length; n++) r3 += y.Clipper.Area(t63[n]);
    return r3 / (e * e);
  };
  y.JS.BoundsOfPath = function(t63, e) {
    return y.JS.BoundsOfPaths([t63], e);
  };
  y.JS.BoundsOfPaths = function(t63, e) {
    e || (e = 1);
    var r3 = y.Clipper.GetBounds(t63);
    return r3.left /= e, r3.bottom /= e, r3.right /= e, r3.top /= e, r3;
  };
  y.JS.Clean = function(n, e) {
    if (!(n instanceof Array)) return [];
    var r3 = n[0] instanceof Array, n = y.JS.Clone(n);
    if (typeof e != "number" || e === null) return y.Error("Delta is not a number in Clean()."), n;
    if (n.length === 0 || n.length == 1 && n[0].length === 0 || e < 0) return n;
    r3 || (n = [n]);
    for (var i = n.length, o, a, s3, l, u3, c, p, h = [], f = 0; f < i; f++) if (a = n[f], o = a.length, o !== 0) {
      if (o < 3) {
        s3 = a, h.push(s3);
        continue;
      }
      for (s3 = a, l = e * e, u3 = a[0], c = 1, p = 1; p < o; p++) (a[p].X - u3.X) * (a[p].X - u3.X) + (a[p].Y - u3.Y) * (a[p].Y - u3.Y) <= l || (s3[c] = a[p], u3 = a[p], c++);
      u3 = a[c - 1], (a[0].X - u3.X) * (a[0].X - u3.X) + (a[0].Y - u3.Y) * (a[0].Y - u3.Y) <= l && c--, c < o && s3.splice(c, o - c), s3.length && h.push(s3);
    }
    return !r3 && h.length ? h = h[0] : !r3 && h.length === 0 ? h = [] : r3 && h.length === 0 && (h = [[]]), h;
  };
  y.JS.Clone = function(t63) {
    if (!(t63 instanceof Array)) return [];
    if (t63.length === 0) return [];
    if (t63.length == 1 && t63[0].length === 0) return [[]];
    var e = t63[0] instanceof Array;
    e || (t63 = [t63]);
    var r3 = t63.length, n, i, o, a, s3 = new Array(r3);
    for (i = 0; i < r3; i++) {
      for (n = t63[i].length, a = new Array(n), o = 0; o < n; o++) a[o] = { X: t63[i][o].X, Y: t63[i][o].Y };
      s3[i] = a;
    }
    return e || (s3 = s3[0]), s3;
  };
  y.JS.Lighten = function(t63, e) {
    if (!(t63 instanceof Array)) return [];
    if (typeof e != "number" || e === null) return y.Error("Tolerance is not a number in Lighten()."), y.JS.Clone(t63);
    if (t63.length === 0 || t63.length == 1 && t63[0].length === 0 || e < 0) return y.JS.Clone(t63);
    t63[0] instanceof Array || (t63 = [t63]);
    var r3, n, i, o, a, s3, l, u3, c, p, h, f, d, g, x, b, v3, P = t63.length, w3 = e * e, T = [];
    for (r3 = 0; r3 < P; r3++) if (i = t63[r3], s3 = i.length, s3 != 0) {
      for (o = 0; o < 1e6; o++) {
        for (a = [], s3 = i.length, i[s3 - 1].X != i[0].X || i[s3 - 1].Y != i[0].Y ? (f = 1, i.push({ X: i[0].X, Y: i[0].Y }), s3 = i.length) : f = 0, h = [], n = 0; n < s3 - 2; n++) l = i[n], c = i[n + 1], u3 = i[n + 2], b = l.X, v3 = l.Y, d = u3.X - b, g = u3.Y - v3, (d !== 0 || g !== 0) && (x = ((c.X - b) * d + (c.Y - v3) * g) / (d * d + g * g), x > 1 ? (b = u3.X, v3 = u3.Y) : x > 0 && (b += d * x, v3 += g * x)), d = c.X - b, g = c.Y - v3, p = d * d + g * g, p <= w3 && (h[n + 1] = 1, n++);
        for (a.push({ X: i[0].X, Y: i[0].Y }), n = 1; n < s3 - 1; n++) h[n] || a.push({ X: i[n].X, Y: i[n].Y });
        if (a.push({ X: i[s3 - 1].X, Y: i[s3 - 1].Y }), f && i.pop(), h.length) i = a;
        else break;
      }
      s3 = a.length, a[s3 - 1].X == a[0].X && a[s3 - 1].Y == a[0].Y && a.pop(), a.length > 2 && T.push(a);
    }
    return !t63[0] instanceof Array && (T = T[0]), typeof T > "u" && (T = [[]]), T;
  };
  y.JS.PerimeterOfPath = function(t63, e, r3) {
    if (typeof t63 > "u") return 0;
    var n = Math.sqrt, i = 0, o, a, s3 = 0, l = 0, u3 = 0, c = 0, p = t63.length;
    if (p < 2) return 0;
    for (e && (t63[p] = t63[0], p++); --p; ) o = t63[p], s3 = o.X, l = o.Y, a = t63[p - 1], u3 = a.X, c = a.Y, i += n((s3 - u3) * (s3 - u3) + (l - c) * (l - c));
    return e && t63.pop(), i / r3;
  };
  y.JS.PerimeterOfPaths = function(t63, e, r3) {
    r3 || (r3 = 1);
    for (var n = 0, i = 0; i < t63.length; i++) n += y.JS.PerimeterOfPath(t63[i], e, r3);
    return n;
  };
  y.JS.ScaleDownPath = function(t63, e) {
    var r3, n;
    for (e || (e = 1), r3 = t63.length; r3--; ) n = t63[r3], n.X = n.X / e, n.Y = n.Y / e;
  };
  y.JS.ScaleDownPaths = function(t63, e) {
    var r3, n, i, o = Math.round;
    for (e || (e = 1), r3 = t63.length; r3--; ) for (n = t63[r3].length; n--; ) i = t63[r3][n], i.X = i.X / e, i.Y = i.Y / e;
  };
  y.JS.ScaleUpPath = function(t63, e) {
    var r3, n, i = Math.round;
    for (e || (e = 1), r3 = t63.length; r3--; ) n = t63[r3], n.X = i(n.X * e), n.Y = i(n.Y * e);
  };
  y.JS.ScaleUpPaths = function(t63, e) {
    var r3, n, i, o = Math.round;
    for (e || (e = 1), r3 = t63.length; r3--; ) for (n = t63[r3].length; n--; ) i = t63[r3][n], i.X = o(i.X * e), i.Y = o(i.Y * e);
  };
  y.ExPolygons = function() {
    return [];
  };
  y.ExPolygon = function() {
    this.outer = null, this.holes = null;
  };
  y.JS.AddOuterPolyNodeToExPolygons = function(t63, e) {
    var r3 = new y.ExPolygon();
    r3.outer = t63.Contour();
    var n = t63.Childs(), i = n.length;
    r3.holes = new Array(i);
    var o, a, s3, l, u3, c;
    for (s3 = 0; s3 < i; s3++) for (o = n[s3], r3.holes[s3] = o.Contour(), l = 0, u3 = o.Childs(), c = u3.length; l < c; l++) a = u3[l], y.JS.AddOuterPolyNodeToExPolygons(a, e);
    e.push(r3);
  };
  y.JS.ExPolygonsToPaths = function(t63) {
    var e, r3, n, i, o = new y.Paths();
    for (e = 0, n = t63.length; e < n; e++) for (o.push(t63[e].outer), r3 = 0, i = t63[e].holes.length; r3 < i; r3++) o.push(t63[e].holes[r3]);
    return o;
  };
  y.JS.PolyTreeToExPolygons = function(t63) {
    var e = new y.ExPolygons(), r3, n, i, o;
    for (n = 0, i = t63.Childs(), o = i.length; n < o; n++) r3 = i[n], y.JS.AddOuterPolyNodeToExPolygons(r3, e);
    return e;
  };
  Fu.exports = y;
});
$i();
var ju = "[MappedinJS]";
var NM = ((i) => (i[i.LOG = 0] = "LOG", i[i.WARN = 1] = "WARN", i[i.ERROR = 2] = "ERROR", i[i.SILENT = 3] = "SILENT", i))(NM || {});
function GM(t63 = "", { prefix: e = ju } = {}) {
  let r3 = `${e}${t63 ? `-${t63}` : ""}`, n = (i, o) => {
    if (typeof window < "u" && window.rnDebug) {
      let a = o.map((s3) => s3 instanceof Error && s3.stack ? `${s3.message}
${s3.stack}` : s3);
      window.rnDebug(`${t63} ${i}: ${a.join(" ")}`);
    }
  };
  return { logState: yc.env.NODE_ENV === "test" ? 3 : 0, log(...i) {
    this.logState <= 0 && (console.log(r3, ...i), n("log", i));
  }, warn(...i) {
    this.logState <= 1 && (console.warn(r3, ...i), n("warn", i));
  }, error(...i) {
    this.logState <= 2 && (console.error(r3, ...i), n("error", i));
  }, assert(...i) {
    console.assert(...i);
  }, time(i) {
    console.time(i);
  }, timeEnd(i) {
    console.timeEnd(i);
  }, setLevel(i) {
    0 <= i && i <= 3 && (this.logState = i);
  } };
}
var Mx = GM();
function u5(t63) {
  0 <= t63 && t63 <= 3 && (Mx.logState = t63);
}
var Pt = Mx;
$i();
$i();
var Bi = class extends Error {
};
Bi.prototype.name = "InvalidTokenError";
function jM(t63) {
  return decodeURIComponent(atob(t63).replace(/(.)/g, (e, r3) => {
    let n = r3.charCodeAt(0).toString(16).toUpperCase();
    return n.length < 2 && (n = "0" + n), "%" + n;
  }));
}
function HM(t63) {
  let e = t63.replace(/-/g, "+").replace(/_/g, "/");
  switch (e.length % 4) {
    case 0:
      break;
    case 2:
      e += "==";
      break;
    case 3:
      e += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return jM(e);
  } catch {
    return atob(e);
  }
}
function Ix(t63, e) {
  if (typeof t63 != "string") throw new Bi("Invalid token specified: must be a string");
  e || (e = {});
  let r3 = e.header === true ? 0 : 1, n = t63.split(".")[r3];
  if (typeof n != "string") throw new Bi(`Invalid token specified: missing part #${r3 + 1}`);
  let i;
  try {
    i = HM(n);
  } catch (o) {
    throw new Bi(`Invalid token specified: invalid base64 for part #${r3 + 1} (${o.message})`);
  }
  try {
    return JSON.parse(i);
  } catch (o) {
    throw new Bi(`Invalid token specified: invalid json for part #${r3 + 1} (${o.message})`);
  }
}
$i();
var Zn = 63710088e-1;
$i();
function XM(t63, e, r3, n) {
  return (t63 < e || t63 > r3) && Pt.warn(n), Math.min(r3, Math.max(e, t63));
}
$i();
function ZM(t63, e) {
  if (t63 == null || e == null) return t63 === e;
  if (t63.length !== e.length) return false;
  for (let r3 = 0; r3 < t63.length; r3++) if (t63[r3] !== e[r3]) return false;
  return true;
}
function T5(t63) {
  let e = Ix(t63);
  if (e.sub == null) throw new Error("Access token is missing sub claim.");
  return { sub: e.sub, aud: typeof e.aud == "string" ? [e.aud] : e.aud ?? [], capabilities: e.capabilities ?? {} };
}
function Hu(t63) {
  return t63 * (Math.PI / 180);
}
function S5(t63, e) {
  let r3 = Math.pow(10, e);
  return Math.sign(t63) * Math.round(Math.abs(t63) * r3) / r3;
}
function Ax(t63, e) {
  return (t63 % e + e) % e;
}
function C5(t63, e) {
  let r3 = Ax(t63, Math.PI * 2), n = Ax(e, Math.PI * 2), i = n - r3, o = n + (i > Math.PI ? -Math.PI * 2 : i < -Math.PI ? Math.PI * 2 : 0);
  return { start: r3, end: o };
}
function qM(t63) {
  return t63 instanceof Al ? Number.isFinite(t63.min.x) && Number.isFinite(t63.min.y) && Number.isFinite(t63.max.x) && Number.isFinite(t63.max.y) : Number.isFinite(t63.min.x) && Number.isFinite(t63.min.y) && Number.isFinite(t63.max.x) && Number.isFinite(t63.max.y) && Number.isFinite(t63.min.z) && Number.isFinite(t63.max.z);
}
function M5() {
  return typeof window < "u" && window !== null;
}
function I5(t63, e) {
  let [r3, n] = t63, [i, o] = e, a = Hu(i - r3), s3 = Hu(o - n);
  return Math.sqrt(a * a + s3 * s3) * Zn;
}
function A5(t63, e) {
  let [r3, n] = t63.map((c) => Hu(c)), [i, o] = e.map((c) => Hu(c)), a = o - n, l = (i - r3) * Math.cos((n + o) / 2), u3 = a;
  return Math.sqrt(l * l + u3 * u3) * Zn;
}
$i();
function k5(t63, e, r3 = false) {
  let n = null, i = 0;
  return function(...o) {
    i++, i === 1 && r3 === true && t63(...o);
    let a = () => {
      (!r3 || i > 1) && t63(...o), n = null, i = 0;
    };
    clearTimeout(n), n = setTimeout(a, e);
  };
}
$i();
$i();
function YM(t63, e) {
  return `${e} ${t63}`;
}
var $a = class extends Error {
  constructor(e, r3 = ju) {
    super(YM(e, r3)), this.name = "MappedinError";
  }
};
var Ex = class extends $a {
  constructor(e, r3 = ju) {
    super(e, r3), this.name = "MappedinRenderError";
  }
};
$i();
var Lm = class t2 extends Error {
  constructor(r3) {
    super(r3);
    t(this, "name", "AssertionError");
    Error.captureStackTrace && Error.captureStackTrace(this, t2);
  }
};
function Lx(t63, e) {
  if (t63 == null) {
    let r3;
    e?.customMessage ? r3 = e.customMessage : r3 = `Expected ${e?.valueName ? `'${e.valueName}'` : "value"} to be defined, but received ${t63}`;
    let n = e?.errorClass || Lm, i = new n(r3);
    throw e?.captureStackTrace !== false && Error.captureStackTrace && Error.captureStackTrace(i, Lx), i;
  }
}
function U5(t63, e, r3) {
  if (Lx(t63), t63?.type !== e) {
    let n = `Expected type ${e} but got ${t63?.type}`;
    throw new Error(r3 ?? n);
  }
}
$i();
var Dm = [0, 4, 6, 8, 10];
var Vt = () => {
  let t63 = new Array(16).fill(0), e = Math.random() * 4294967296;
  for (let n = 0; n < t63.length; n++) n > 0 && (n & 3) === 0 && (e = Math.random() * 4294967296), t63[n] = e >>> ((n & 3) << 3) & 255;
  let r3 = t63.map((n) => n.toString(16).padStart(2, "0"));
  return r3[6] = "4" + r3[6][1], r3[8] = ["8", "9", "a", "b"].includes(r3[7][0]) ? r3[7] : "a" + r3[7][1], Dm.map((n, i) => r3.slice(n, i === Dm.length - 1 ? void 0 : Dm[i + 1]).join("")).join("-");
};
function H5(t63, e = 0) {
  let r3 = 3735928559 ^ e, n = 1103547991 ^ e;
  for (let i = 0, o; i < t63.length; i++) o = t63.charCodeAt(i), r3 = Math.imul(r3 ^ o, 2654435761), n = Math.imul(n ^ o, 1597334677);
  return r3 = Math.imul(r3 ^ r3 >>> 16, 2246822507) ^ Math.imul(n ^ n >>> 13, 3266489909), n = Math.imul(n ^ n >>> 16, 2246822507) ^ Math.imul(r3 ^ r3 >>> 13, 3266489909), 4294967296 * (2097151 & n) + (r3 >>> 0);
}
$i();
var Ka = class {
  constructor() {
    t(this, "_subscribers", {});
    t(this, "_destroyed", false);
  }
  publish(e, r3) {
    !this._subscribers || !this._subscribers[e] || this._destroyed || this._subscribers[e].forEach(function(n) {
      typeof n == "function" && n(r3);
    });
  }
  on(e, r3) {
    (!this._subscribers || this._destroyed) && (this._subscribers = {}), this._subscribers[e] = this._subscribers[e] || [], this._subscribers[e].push(r3);
  }
  off(e, r3) {
    if (!this._subscribers || this._subscribers[e] == null || this._destroyed) return;
    let n = this._subscribers[e].indexOf(r3);
    n !== -1 && this._subscribers[e].splice(n, 1);
  }
  destroy() {
    this._destroyed = true, this._subscribers = {};
  }
};
$i();
var Dx = "mi-session-data";
var Rx = "mi-local-data";
var Ja = "id";
var Qa = "deviceId";
var zi;
var Gr;
var jr;
var Xu = class Xu2 {
  constructor() {
    v(this, Gr);
    v(this, jr);
    try {
      let e = sessionStorage.getItem(Dx);
      e ? w(this, Gr, JSON.parse(e)) : w(this, Gr, { [Ja]: Vt() });
    } catch {
      w(this, Gr, { [Ja]: Vt() });
    }
    try {
      let e = localStorage.getItem(Rx);
      e ? w(this, jr, JSON.parse(e)) : w(this, jr, { [Qa]: Vt() });
    } catch {
      w(this, jr, { [Qa]: Vt() });
    }
    u(this, Gr)[Ja] || (u(this, Gr)[Ja] = Vt()), u(this, jr)[Qa] || (u(this, jr)[Qa] = Vt());
  }
  static getInstance() {
    return u(this, zi) || w(this, zi, new Xu2()), u(this, zi);
  }
  static ___clearInstance() {
    w(this, zi, void 0);
  }
  saveSessionData(e, r3) {
    u(this, Gr)[e] = r3;
    try {
      return sessionStorage.setItem(Dx, JSON.stringify(u(this, Gr))), true;
    } catch {
      return false;
    }
  }
  loadSessionData(e) {
    let r3 = u(this, Gr)[e];
    if (r3 != null) return r3;
  }
  saveLocalData(e, r3) {
    u(this, jr)[e] = r3;
    try {
      return localStorage.setItem(Rx, JSON.stringify(u(this, jr))), true;
    } catch {
      return false;
    }
  }
  loadLocalData(e) {
    let r3 = u(this, jr)[e];
    if (r3 != null) return r3;
  }
};
zi = /* @__PURE__ */ new WeakMap(), Gr = /* @__PURE__ */ new WeakMap(), jr = /* @__PURE__ */ new WeakMap(), v(Xu, zi);
var Rm = Xu;
$i();
var WM = new Set(Object.keys(Nt.NAMES));
var km;
function kx() {
  return km == null && (km = new Nt()), km;
}
var $M = (t63) => WM.has(t63.toLowerCase());
var KM = (t63) => {
  if (!t63.startsWith("#")) return false;
  let e = t63.slice(1);
  if (e.length !== 3 && e.length !== 6) return false;
  for (let r3 = 0; r3 < e.length; r3++) if (!(e[r3] >= "0" && e[r3] <= "9" || e[r3] >= "A" && e[r3] <= "F" || e[r3] >= "a" && e[r3] <= "f")) return false;
  return true;
};
var JM = (t63) => {
  if (!t63.startsWith("rgb(") && !t63.startsWith("rgba(")) return false;
  let e = t63.indexOf("("), r3 = t63.lastIndexOf(")");
  if (e === -1 || r3 === -1 || r3 <= e || r3 !== t63.length - 1) return false;
  let n = t63.slice(e + 1, r3).split(",");
  if (n.length !== 3 && n.length !== 4) return false;
  for (let i = 0; i < n.length; i++) {
    let o = n[i].trim();
    if (i < 3) if (o.endsWith("%")) {
      let a = parseFloat(o.slice(0, -1));
      if (isNaN(a) || a < 0 || a > 100) return false;
    } else {
      let a = parseInt(o, 10);
      if (isNaN(a) || a < 0 || a > 255) return false;
    }
    else {
      let a = parseFloat(o);
      if (isNaN(a) || a < 0 || a > 1) return false;
    }
  }
  return true;
};
var QM = (t63) => {
  if (!t63.startsWith("hsl(") && !t63.startsWith("hsla(")) return false;
  let e = t63.indexOf("("), r3 = t63.lastIndexOf(")");
  if (e === -1 || r3 === -1 || r3 <= e || r3 !== t63.length - 1) return false;
  let n = t63.slice(e + 1, r3).split(",");
  if (n.length !== 3 && n.length !== 4) return false;
  for (let i = 0; i < n.length; i++) {
    let o = n[i].trim();
    if (i === 0) {
      let a = parseFloat(o);
      if (isNaN(a)) return false;
    } else if (i < 3) {
      if (!o.endsWith("%")) return false;
      let a = parseFloat(o.slice(0, -1));
      if (isNaN(a) || a < 0 || a > 100) return false;
    } else {
      let a = parseFloat(o);
      if (isNaN(a) || a < 0 || a > 1) return false;
    }
  }
  return true;
};
var Zu = (t63) => t63 == null || typeof t63 != "string" ? false : !!(KM(t63) || JM(t63) || QM(t63) || $M(t63));
var tN = (t63) => {
  let e = kx();
  return e.set(t63), [e.r, e.g, e.b];
};
var rN = (t63) => {
  let e = kx();
  return e.set(t63[0], t63[1], t63[2]), "#" + e.getHexString();
};
$i();
var Fx = ["ease-in", "ease-out", "ease-in-out", "linear"];
var Ox = (t63) => t63;
var eI = (t63) => t63 * t63;
var tI = (t63) => 1 - Math.cos(t63 * Math.PI / 2);
var rI = (t63) => 1 - (1 - t63) * (1 - t63);
var Bx = { linear: Ox, "ease-in": eI, "ease-out": rI, "ease-in-out": tI };
function aN(t63, e, r3, n, i, o = Ox) {
  if (e === r3) return i;
  t63 = Math.max(e, Math.min(t63, r3));
  let a = (t63 - Math.min(e, r3)) / Math.abs(r3 - e), s3 = typeof o == "function" ? o(a) : Bx[o](a);
  return n + s3 * (i - n);
}
function nI(t63, e) {
  let r3 = 0;
  if (e.length < 2) return r3;
  let i = e[0] < e[1] ? (o, a) => o > a : (o, a) => o < a;
  for (; r3 < e.length - 1 && i(t63, e[r3 + 1]); ) r3++;
  return r3 > e.length - 2 ? Math.max(0, e.length - 2) : r3;
}
function sN(t63, e, r3, n = "ease-in") {
  if (e.length !== r3.length) throw new $a("Input and output ranges must have the same number of values.");
  t63 = Math.max(e[0], Math.min(t63, e[e.length - 1]));
  let i = nI(t63, e), o = (t63 - e[i]) / (e[i + 1] - e[i]), a = typeof n == "function" ? n(o) : Bx[n](o);
  return r3[i] + a * (r3[i + 1] - r3[i]);
}
$i();
function qu(t63) {
  return (t63 % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
}
$i();
$i();
var Yu = { name: "@packages/internal", private: true, version: "6.0.1-beta.51", dependencies: { "@turf/boolean-point-in-polygon": "6.5.0", "@turf/destination": "6.5.0", "@turf/distance": "6.5.0" }, files: ["./common/", "./outdoor-context-4/", "./geojson-navigator/", "./quad-tree/", "./shave-text", "./clipper-lib"] };
$i();
$i();
var Lb = s(fe(), 1);
var Db = s(Nx(), 1);
$i();
$i();
var Fm;
function Wu() {
  return Fm == null && (Fm = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), Fm;
}
var $u;
function Om() {
  if ($u == null && ($u = false, Wu())) {
    let r3 = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: true });
    if (r3) {
      for (let i = 0; i < 5 * 5; i++) {
        let o = i * 4;
        r3.fillStyle = `rgb(${o},${o + 1},${o + 2})`, r3.fillRect(i % 5, Math.floor(i / 5), 1, 1);
      }
      let n = r3.getImageData(0, 0, 5, 5).data;
      for (let i = 0; i < 5 * 5 * 4; i++) if (i % 4 !== 3 && n[i] !== i) {
        $u = true;
        break;
      }
    }
  }
  return $u || false;
}
$i();
$i();
var ue = 1e-6;
var Ae = typeof Float32Array < "u" ? Float32Array : Array;
var qt = Math.random;
var kN = Math.PI / 180;
Math.hypot || (Math.hypot = function() {
  for (var t63 = 0, e = arguments.length; e--; ) t63 += arguments[e] * arguments[e];
  return Math.sqrt(t63);
});
var qn = {};
r(qn, { LDU: () => vI, add: () => PI, adjoint: () => fI, clone: () => aI, copy: () => sI, create: () => oI, determinant: () => mI, equals: () => TI, exactEquals: () => wI, frob: () => _I, fromRotation: () => gI, fromScaling: () => xI, fromValues: () => uI, identity: () => lI, invert: () => hI, mul: () => MI, multiply: () => Gx, multiplyScalar: () => SI, multiplyScalarAndAdd: () => CI, rotate: () => dI, scale: () => yI, set: () => cI, str: () => bI, sub: () => II, subtract: () => jx, transpose: () => pI });
$i();
function oI() {
  var t63 = new Ae(4);
  return Ae != Float32Array && (t63[1] = 0, t63[2] = 0), t63[0] = 1, t63[3] = 1, t63;
}
function aI(t63) {
  var e = new Ae(4);
  return e[0] = t63[0], e[1] = t63[1], e[2] = t63[2], e[3] = t63[3], e;
}
function sI(t63, e) {
  return t63[0] = e[0], t63[1] = e[1], t63[2] = e[2], t63[3] = e[3], t63;
}
function lI(t63) {
  return t63[0] = 1, t63[1] = 0, t63[2] = 0, t63[3] = 1, t63;
}
function uI(t63, e, r3, n) {
  var i = new Ae(4);
  return i[0] = t63, i[1] = e, i[2] = r3, i[3] = n, i;
}
function cI(t63, e, r3, n, i) {
  return t63[0] = e, t63[1] = r3, t63[2] = n, t63[3] = i, t63;
}
function pI(t63, e) {
  if (t63 === e) {
    var r3 = e[1];
    t63[1] = e[2], t63[2] = r3;
  } else t63[0] = e[0], t63[1] = e[2], t63[2] = e[1], t63[3] = e[3];
  return t63;
}
function hI(t63, e) {
  var r3 = e[0], n = e[1], i = e[2], o = e[3], a = r3 * o - i * n;
  return a ? (a = 1 / a, t63[0] = o * a, t63[1] = -n * a, t63[2] = -i * a, t63[3] = r3 * a, t63) : null;
}
function fI(t63, e) {
  var r3 = e[0];
  return t63[0] = e[3], t63[1] = -e[1], t63[2] = -e[2], t63[3] = r3, t63;
}
function mI(t63) {
  return t63[0] * t63[3] - t63[2] * t63[1];
}
function Gx(t63, e, r3) {
  var n = e[0], i = e[1], o = e[2], a = e[3], s3 = r3[0], l = r3[1], u3 = r3[2], c = r3[3];
  return t63[0] = n * s3 + o * l, t63[1] = i * s3 + a * l, t63[2] = n * u3 + o * c, t63[3] = i * u3 + a * c, t63;
}
function dI(t63, e, r3) {
  var n = e[0], i = e[1], o = e[2], a = e[3], s3 = Math.sin(r3), l = Math.cos(r3);
  return t63[0] = n * l + o * s3, t63[1] = i * l + a * s3, t63[2] = n * -s3 + o * l, t63[3] = i * -s3 + a * l, t63;
}
function yI(t63, e, r3) {
  var n = e[0], i = e[1], o = e[2], a = e[3], s3 = r3[0], l = r3[1];
  return t63[0] = n * s3, t63[1] = i * s3, t63[2] = o * l, t63[3] = a * l, t63;
}
function gI(t63, e) {
  var r3 = Math.sin(e), n = Math.cos(e);
  return t63[0] = n, t63[1] = r3, t63[2] = -r3, t63[3] = n, t63;
}
function xI(t63, e) {
  return t63[0] = e[0], t63[1] = 0, t63[2] = 0, t63[3] = e[1], t63;
}
function bI(t63) {
  return "mat2(" + t63[0] + ", " + t63[1] + ", " + t63[2] + ", " + t63[3] + ")";
}
function _I(t63) {
  return Math.hypot(t63[0], t63[1], t63[2], t63[3]);
}
function vI(t63, e, r3, n) {
  return t63[2] = n[2] / n[0], r3[0] = n[0], r3[1] = n[1], r3[3] = n[3] - t63[2] * r3[1], [t63, e, r3];
}
function PI(t63, e, r3) {
  return t63[0] = e[0] + r3[0], t63[1] = e[1] + r3[1], t63[2] = e[2] + r3[2], t63[3] = e[3] + r3[3], t63;
}
function jx(t63, e, r3) {
  return t63[0] = e[0] - r3[0], t63[1] = e[1] - r3[1], t63[2] = e[2] - r3[2], t63[3] = e[3] - r3[3], t63;
}
function wI(t63, e) {
  return t63[0] === e[0] && t63[1] === e[1] && t63[2] === e[2] && t63[3] === e[3];
}
function TI(t63, e) {
  var r3 = t63[0], n = t63[1], i = t63[2], o = t63[3], a = e[0], s3 = e[1], l = e[2], u3 = e[3];
  return Math.abs(r3 - a) <= ue * Math.max(1, Math.abs(r3), Math.abs(a)) && Math.abs(n - s3) <= ue * Math.max(1, Math.abs(n), Math.abs(s3)) && Math.abs(i - l) <= ue * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(o - u3) <= ue * Math.max(1, Math.abs(o), Math.abs(u3));
}
function SI(t63, e, r3) {
  return t63[0] = e[0] * r3, t63[1] = e[1] * r3, t63[2] = e[2] * r3, t63[3] = e[3] * r3, t63;
}
function CI(t63, e, r3, n) {
  return t63[0] = e[0] + r3[0] * n, t63[1] = e[1] + r3[1] * n, t63[2] = e[2] + r3[2] * n, t63[3] = e[3] + r3[3] * n, t63;
}
var MI = Gx;
var II = jx;
var vn = {};
r(vn, { add: () => KI, adjoint: () => BI, clone: () => EI, copy: () => LI, create: () => Bm, determinant: () => zI, equals: () => t22, exactEquals: () => e2, frob: () => $I, fromMat2d: () => XI, fromMat4: () => AI, fromQuat: () => ZI, fromRotation: () => jI, fromScaling: () => HI, fromTranslation: () => GI, fromValues: () => DI, identity: () => kI, invert: () => OI, mul: () => r2, multiply: () => Hx, multiplyScalar: () => JI, multiplyScalarAndAdd: () => QI, normalFromMat4: () => qI, projection: () => YI, rotate: () => UI, scale: () => NI, set: () => RI, str: () => WI, sub: () => n2, subtract: () => Xx, translate: () => VI, transpose: () => FI });
$i();
function Bm() {
  var t63 = new Ae(9);
  return Ae != Float32Array && (t63[1] = 0, t63[2] = 0, t63[3] = 0, t63[5] = 0, t63[6] = 0, t63[7] = 0), t63[0] = 1, t63[4] = 1, t63[8] = 1, t63;
}
function AI(t63, e) {
  return t63[0] = e[0], t63[1] = e[1], t63[2] = e[2], t63[3] = e[4], t63[4] = e[5], t63[5] = e[6], t63[6] = e[8], t63[7] = e[9], t63[8] = e[10], t63;
}
function EI(t63) {
  var e = new Ae(9);
  return e[0] = t63[0], e[1] = t63[1], e[2] = t63[2], e[3] = t63[3], e[4] = t63[4], e[5] = t63[5], e[6] = t63[6], e[7] = t63[7], e[8] = t63[8], e;
}
function LI(t63, e) {
  return t63[0] = e[0], t63[1] = e[1], t63[2] = e[2], t63[3] = e[3], t63[4] = e[4], t63[5] = e[5], t63[6] = e[6], t63[7] = e[7], t63[8] = e[8], t63;
}
function DI(t63, e, r3, n, i, o, a, s3, l) {
  var u3 = new Ae(9);
  return u3[0] = t63, u3[1] = e, u3[2] = r3, u3[3] = n, u3[4] = i, u3[5] = o, u3[6] = a, u3[7] = s3, u3[8] = l, u3;
}
function RI(t63, e, r3, n, i, o, a, s3, l, u3) {
  return t63[0] = e, t63[1] = r3, t63[2] = n, t63[3] = i, t63[4] = o, t63[5] = a, t63[6] = s3, t63[7] = l, t63[8] = u3, t63;
}
function kI(t63) {
  return t63[0] = 1, t63[1] = 0, t63[2] = 0, t63[3] = 0, t63[4] = 1, t63[5] = 0, t63[6] = 0, t63[7] = 0, t63[8] = 1, t63;
}
function FI(t63, e) {
  if (t63 === e) {
    var r3 = e[1], n = e[2], i = e[5];
    t63[1] = e[3], t63[2] = e[6], t63[3] = r3, t63[5] = e[7], t63[6] = n, t63[7] = i;
  } else t63[0] = e[0], t63[1] = e[3], t63[2] = e[6], t63[3] = e[1], t63[4] = e[4], t63[5] = e[7], t63[6] = e[2], t63[7] = e[5], t63[8] = e[8];
  return t63;
}
function OI(t63, e) {
  var r3 = e[0], n = e[1], i = e[2], o = e[3], a = e[4], s3 = e[5], l = e[6], u3 = e[7], c = e[8], p = c * a - s3 * u3, h = -c * o + s3 * l, f = u3 * o - a * l, d = r3 * p + n * h + i * f;
  return d ? (d = 1 / d, t63[0] = p * d, t63[1] = (-c * n + i * u3) * d, t63[2] = (s3 * n - i * a) * d, t63[3] = h * d, t63[4] = (c * r3 - i * l) * d, t63[5] = (-s3 * r3 + i * o) * d, t63[6] = f * d, t63[7] = (-u3 * r3 + n * l) * d, t63[8] = (a * r3 - n * o) * d, t63) : null;
}
function BI(t63, e) {
  var r3 = e[0], n = e[1], i = e[2], o = e[3], a = e[4], s3 = e[5], l = e[6], u3 = e[7], c = e[8];
  return t63[0] = a * c - s3 * u3, t63[1] = i * u3 - n * c, t63[2] = n * s3 - i * a, t63[3] = s3 * l - o * c, t63[4] = r3 * c - i * l, t63[5] = i * o - r3 * s3, t63[6] = o * u3 - a * l, t63[7] = n * l - r3 * u3, t63[8] = r3 * a - n * o, t63;
}
function zI(t63) {
  var e = t63[0], r3 = t63[1], n = t63[2], i = t63[3], o = t63[4], a = t63[5], s3 = t63[6], l = t63[7], u3 = t63[8];
  return e * (u3 * o - a * l) + r3 * (-u3 * i + a * s3) + n * (l * i - o * s3);
}
function Hx(t63, e, r3) {
  var n = e[0], i = e[1], o = e[2], a = e[3], s3 = e[4], l = e[5], u3 = e[6], c = e[7], p = e[8], h = r3[0], f = r3[1], d = r3[2], g = r3[3], x = r3[4], b = r3[5], v3 = r3[6], P = r3[7], w3 = r3[8];
  return t63[0] = h * n + f * a + d * u3, t63[1] = h * i + f * s3 + d * c, t63[2] = h * o + f * l + d * p, t63[3] = g * n + x * a + b * u3, t63[4] = g * i + x * s3 + b * c, t63[5] = g * o + x * l + b * p, t63[6] = v3 * n + P * a + w3 * u3, t63[7] = v3 * i + P * s3 + w3 * c, t63[8] = v3 * o + P * l + w3 * p, t63;
}
function VI(t63, e, r3) {
  var n = e[0], i = e[1], o = e[2], a = e[3], s3 = e[4], l = e[5], u3 = e[6], c = e[7], p = e[8], h = r3[0], f = r3[1];
  return t63[0] = n, t63[1] = i, t63[2] = o, t63[3] = a, t63[4] = s3, t63[5] = l, t63[6] = h * n + f * a + u3, t63[7] = h * i + f * s3 + c, t63[8] = h * o + f * l + p, t63;
}
function UI(t63, e, r3) {
  var n = e[0], i = e[1], o = e[2], a = e[3], s3 = e[4], l = e[5], u3 = e[6], c = e[7], p = e[8], h = Math.sin(r3), f = Math.cos(r3);
  return t63[0] = f * n + h * a, t63[1] = f * i + h * s3, t63[2] = f * o + h * l, t63[3] = f * a - h * n, t63[4] = f * s3 - h * i, t63[5] = f * l - h * o, t63[6] = u3, t63[7] = c, t63[8] = p, t63;
}
function NI(t63, e, r3) {
  var n = r3[0], i = r3[1];
  return t63[0] = n * e[0], t63[1] = n * e[1], t63[2] = n * e[2], t63[3] = i * e[3], t63[4] = i * e[4], t63[5] = i * e[5], t63[6] = e[6], t63[7] = e[7], t63[8] = e[8], t63;
}
function GI(t63, e) {
  return t63[0] = 1, t63[1] = 0, t63[2] = 0, t63[3] = 0, t63[4] = 1, t63[5] = 0, t63[6] = e[0], t63[7] = e[1], t63[8] = 1, t63;
}
function jI(t63, e) {
  var r3 = Math.sin(e), n = Math.cos(e);
  return t63[0] = n, t63[1] = r3, t63[2] = 0, t63[3] = -r3, t63[4] = n, t63[5] = 0, t63[6] = 0, t63[7] = 0, t63[8] = 1, t63;
}
function HI(t63, e) {
  return t63[0] = e[0], t63[1] = 0, t63[2] = 0, t63[3] = 0, t63[4] = e[1], t63[5] = 0, t63[6] = 0, t63[7] = 0, t63[8] = 1, t63;
}
function XI(t63, e) {
  return t63[0] = e[0], t63[1] = e[1], t63[2] = 0, t63[3] = e[2], t63[4] = e[3], t63[5] = 0, t63[6] = e[4], t63[7] = e[5], t63[8] = 1, t63;
}
function ZI(t63, e) {
  var r3 = e[0], n = e[1], i = e[2], o = e[3], a = r3 + r3, s3 = n + n, l = i + i, u3 = r3 * a, c = n * a, p = n * s3, h = i * a, f = i * s3, d = i * l, g = o * a, x = o * s3, b = o * l;
  return t63[0] = 1 - p - d, t63[3] = c - b, t63[6] = h + x, t63[1] = c + b, t63[4] = 1 - u3 - d, t63[7] = f - g, t63[2] = h - x, t63[5] = f + g, t63[8] = 1 - u3 - p, t63;
}
function qI(t63, e) {
  var r3 = e[0], n = e[1], i = e[2], o = e[3], a = e[4], s3 = e[5], l = e[6], u3 = e[7], c = e[8], p = e[9], h = e[10], f = e[11], d = e[12], g = e[13], x = e[14], b = e[15], v3 = r3 * s3 - n * a, P = r3 * l - i * a, w3 = r3 * u3 - o * a, T = n * l - i * s3, S = n * u3 - o * s3, C3 = i * u3 - o * l, A = c * g - p * d, E = c * x - h * d, L = c * b - f * d, F = p * x - h * g, O = p * b - f * g, z = h * b - f * x, I = v3 * z - P * O + w3 * F + T * L - S * E + C3 * A;
  return I ? (I = 1 / I, t63[0] = (s3 * z - l * O + u3 * F) * I, t63[1] = (l * L - a * z - u3 * E) * I, t63[2] = (a * O - s3 * L + u3 * A) * I, t63[3] = (i * O - n * z - o * F) * I, t63[4] = (r3 * z - i * L + o * E) * I, t63[5] = (n * L - r3 * O - o * A) * I, t63[6] = (g * C3 - x * S + b * T) * I, t63[7] = (x * w3 - d * C3 - b * P) * I, t63[8] = (d * S - g * w3 + b * v3) * I, t63) : null;
}
function YI(t63, e, r3) {
  return t63[0] = 2 / e, t63[1] = 0, t63[2] = 0, t63[3] = 0, t63[4] = -2 / r3, t63[5] = 0, t63[6] = -1, t63[7] = 1, t63[8] = 1, t63;
}
function WI(t63) {
  return "mat3(" + t63[0] + ", " + t63[1] + ", " + t63[2] + ", " + t63[3] + ", " + t63[4] + ", " + t63[5] + ", " + t63[6] + ", " + t63[7] + ", " + t63[8] + ")";
}
function $I(t63) {
  return Math.hypot(t63[0], t63[1], t63[2], t63[3], t63[4], t63[5], t63[6], t63[7], t63[8]);
}
function KI(t63, e, r3) {
  return t63[0] = e[0] + r3[0], t63[1] = e[1] + r3[1], t63[2] = e[2] + r3[2], t63[3] = e[3] + r3[3], t63[4] = e[4] + r3[4], t63[5] = e[5] + r3[5], t63[6] = e[6] + r3[6], t63[7] = e[7] + r3[7], t63[8] = e[8] + r3[8], t63;
}
function Xx(t63, e, r3) {
  return t63[0] = e[0] - r3[0], t63[1] = e[1] - r3[1], t63[2] = e[2] - r3[2], t63[3] = e[3] - r3[3], t63[4] = e[4] - r3[4], t63[5] = e[5] - r3[5], t63[6] = e[6] - r3[6], t63[7] = e[7] - r3[7], t63[8] = e[8] - r3[8], t63;
}
function JI(t63, e, r3) {
  return t63[0] = e[0] * r3, t63[1] = e[1] * r3, t63[2] = e[2] * r3, t63[3] = e[3] * r3, t63[4] = e[4] * r3, t63[5] = e[5] * r3, t63[6] = e[6] * r3, t63[7] = e[7] * r3, t63[8] = e[8] * r3, t63;
}
function QI(t63, e, r3, n) {
  return t63[0] = e[0] + r3[0] * n, t63[1] = e[1] + r3[1] * n, t63[2] = e[2] + r3[2] * n, t63[3] = e[3] + r3[3] * n, t63[4] = e[4] + r3[4] * n, t63[5] = e[5] + r3[5] * n, t63[6] = e[6] + r3[6] * n, t63[7] = e[7] + r3[7] * n, t63[8] = e[8] + r3[8] * n, t63;
}
function e2(t63, e) {
  return t63[0] === e[0] && t63[1] === e[1] && t63[2] === e[2] && t63[3] === e[3] && t63[4] === e[4] && t63[5] === e[5] && t63[6] === e[6] && t63[7] === e[7] && t63[8] === e[8];
}
function t22(t63, e) {
  var r3 = t63[0], n = t63[1], i = t63[2], o = t63[3], a = t63[4], s3 = t63[5], l = t63[6], u3 = t63[7], c = t63[8], p = e[0], h = e[1], f = e[2], d = e[3], g = e[4], x = e[5], b = e[6], v3 = e[7], P = e[8];
  return Math.abs(r3 - p) <= ue * Math.max(1, Math.abs(r3), Math.abs(p)) && Math.abs(n - h) <= ue * Math.max(1, Math.abs(n), Math.abs(h)) && Math.abs(i - f) <= ue * Math.max(1, Math.abs(i), Math.abs(f)) && Math.abs(o - d) <= ue * Math.max(1, Math.abs(o), Math.abs(d)) && Math.abs(a - g) <= ue * Math.max(1, Math.abs(a), Math.abs(g)) && Math.abs(s3 - x) <= ue * Math.max(1, Math.abs(s3), Math.abs(x)) && Math.abs(l - b) <= ue * Math.max(1, Math.abs(l), Math.abs(b)) && Math.abs(u3 - v3) <= ue * Math.max(1, Math.abs(u3), Math.abs(v3)) && Math.abs(c - P) <= ue * Math.max(1, Math.abs(c), Math.abs(P));
}
var r2 = Hx;
var n2 = Xx;
var B = {};
r(B, { add: () => N2, adjoint: () => p2, clone: () => o2, copy: () => a2, create: () => i2, determinant: () => h2, equals: () => X2, exactEquals: () => H2, frob: () => U2, fromQuat: () => E2, fromQuat2: () => S2, fromRotation: () => v2, fromRotationTranslation: () => Yx, fromRotationTranslationScale: () => I2, fromRotationTranslationScaleOrigin: () => A2, fromScaling: () => _2, fromTranslation: () => b2, fromValues: () => s2, fromXRotation: () => P2, fromYRotation: () => w2, fromZRotation: () => T2, frustum: () => L2, getRotation: () => M2, getScaling: () => Wx, getTranslation: () => C2, identity: () => Zx, invert: () => c2, lookAt: () => B2, mul: () => Z2, multiply: () => qx, multiplyScalar: () => G2, multiplyScalarAndAdd: () => j2, ortho: () => F2, orthoNO: () => Kx, orthoZO: () => O2, perspective: () => D2, perspectiveFromFieldOfView: () => k2, perspectiveNO: () => $x, perspectiveZO: () => R2, rotate: () => d2, rotateX: () => y2, rotateY: () => g2, rotateZ: () => x2, scale: () => m2, set: () => l2, str: () => V2, sub: () => q2, subtract: () => Jx, targetTo: () => z2, translate: () => f2, transpose: () => u2 });
$i();
function i2() {
  var t63 = new Ae(16);
  return Ae != Float32Array && (t63[1] = 0, t63[2] = 0, t63[3] = 0, t63[4] = 0, t63[6] = 0, t63[7] = 0, t63[8] = 0, t63[9] = 0, t63[11] = 0, t63[12] = 0, t63[13] = 0, t63[14] = 0), t63[0] = 1, t63[5] = 1, t63[10] = 1, t63[15] = 1, t63;
}
function o2(t63) {
  var e = new Ae(16);
  return e[0] = t63[0], e[1] = t63[1], e[2] = t63[2], e[3] = t63[3], e[4] = t63[4], e[5] = t63[5], e[6] = t63[6], e[7] = t63[7], e[8] = t63[8], e[9] = t63[9], e[10] = t63[10], e[11] = t63[11], e[12] = t63[12], e[13] = t63[13], e[14] = t63[14], e[15] = t63[15], e;
}
function a2(t63, e) {
  return t63[0] = e[0], t63[1] = e[1], t63[2] = e[2], t63[3] = e[3], t63[4] = e[4], t63[5] = e[5], t63[6] = e[6], t63[7] = e[7], t63[8] = e[8], t63[9] = e[9], t63[10] = e[10], t63[11] = e[11], t63[12] = e[12], t63[13] = e[13], t63[14] = e[14], t63[15] = e[15], t63;
}
function s2(t63, e, r3, n, i, o, a, s3, l, u3, c, p, h, f, d, g) {
  var x = new Ae(16);
  return x[0] = t63, x[1] = e, x[2] = r3, x[3] = n, x[4] = i, x[5] = o, x[6] = a, x[7] = s3, x[8] = l, x[9] = u3, x[10] = c, x[11] = p, x[12] = h, x[13] = f, x[14] = d, x[15] = g, x;
}
function l2(t63, e, r3, n, i, o, a, s3, l, u3, c, p, h, f, d, g, x) {
  return t63[0] = e, t63[1] = r3, t63[2] = n, t63[3] = i, t63[4] = o, t63[5] = a, t63[6] = s3, t63[7] = l, t63[8] = u3, t63[9] = c, t63[10] = p, t63[11] = h, t63[12] = f, t63[13] = d, t63[14] = g, t63[15] = x, t63;
}
function Zx(t63) {
  return t63[0] = 1, t63[1] = 0, t63[2] = 0, t63[3] = 0, t63[4] = 0, t63[5] = 1, t63[6] = 0, t63[7] = 0, t63[8] = 0, t63[9] = 0, t63[10] = 1, t63[11] = 0, t63[12] = 0, t63[13] = 0, t63[14] = 0, t63[15] = 1, t63;
}
function u2(t63, e) {
  if (t63 === e) {
    var r3 = e[1], n = e[2], i = e[3], o = e[6], a = e[7], s3 = e[11];
    t63[1] = e[4], t63[2] = e[8], t63[3] = e[12], t63[4] = r3, t63[6] = e[9], t63[7] = e[13], t63[8] = n, t63[9] = o, t63[11] = e[14], t63[12] = i, t63[13] = a, t63[14] = s3;
  } else t63[0] = e[0], t63[1] = e[4], t63[2] = e[8], t63[3] = e[12], t63[4] = e[1], t63[5] = e[5], t63[6] = e[9], t63[7] = e[13], t63[8] = e[2], t63[9] = e[6], t63[10] = e[10], t63[11] = e[14], t63[12] = e[3], t63[13] = e[7], t63[14] = e[11], t63[15] = e[15];
  return t63;
}
function c2(t63, e) {
  var r3 = e[0], n = e[1], i = e[2], o = e[3], a = e[4], s3 = e[5], l = e[6], u3 = e[7], c = e[8], p = e[9], h = e[10], f = e[11], d = e[12], g = e[13], x = e[14], b = e[15], v3 = r3 * s3 - n * a, P = r3 * l - i * a, w3 = r3 * u3 - o * a, T = n * l - i * s3, S = n * u3 - o * s3, C3 = i * u3 - o * l, A = c * g - p * d, E = c * x - h * d, L = c * b - f * d, F = p * x - h * g, O = p * b - f * g, z = h * b - f * x, I = v3 * z - P * O + w3 * F + T * L - S * E + C3 * A;
  return I ? (I = 1 / I, t63[0] = (s3 * z - l * O + u3 * F) * I, t63[1] = (i * O - n * z - o * F) * I, t63[2] = (g * C3 - x * S + b * T) * I, t63[3] = (h * S - p * C3 - f * T) * I, t63[4] = (l * L - a * z - u3 * E) * I, t63[5] = (r3 * z - i * L + o * E) * I, t63[6] = (x * w3 - d * C3 - b * P) * I, t63[7] = (c * C3 - h * w3 + f * P) * I, t63[8] = (a * O - s3 * L + u3 * A) * I, t63[9] = (n * L - r3 * O - o * A) * I, t63[10] = (d * S - g * w3 + b * v3) * I, t63[11] = (p * w3 - c * S - f * v3) * I, t63[12] = (s3 * E - a * F - l * A) * I, t63[13] = (r3 * F - n * E + i * A) * I, t63[14] = (g * P - d * T - x * v3) * I, t63[15] = (c * T - p * P + h * v3) * I, t63) : null;
}
function p2(t63, e) {
  var r3 = e[0], n = e[1], i = e[2], o = e[3], a = e[4], s3 = e[5], l = e[6], u3 = e[7], c = e[8], p = e[9], h = e[10], f = e[11], d = e[12], g = e[13], x = e[14], b = e[15];
  return t63[0] = s3 * (h * b - f * x) - p * (l * b - u3 * x) + g * (l * f - u3 * h), t63[1] = -(n * (h * b - f * x) - p * (i * b - o * x) + g * (i * f - o * h)), t63[2] = n * (l * b - u3 * x) - s3 * (i * b - o * x) + g * (i * u3 - o * l), t63[3] = -(n * (l * f - u3 * h) - s3 * (i * f - o * h) + p * (i * u3 - o * l)), t63[4] = -(a * (h * b - f * x) - c * (l * b - u3 * x) + d * (l * f - u3 * h)), t63[5] = r3 * (h * b - f * x) - c * (i * b - o * x) + d * (i * f - o * h), t63[6] = -(r3 * (l * b - u3 * x) - a * (i * b - o * x) + d * (i * u3 - o * l)), t63[7] = r3 * (l * f - u3 * h) - a * (i * f - o * h) + c * (i * u3 - o * l), t63[8] = a * (p * b - f * g) - c * (s3 * b - u3 * g) + d * (s3 * f - u3 * p), t63[9] = -(r3 * (p * b - f * g) - c * (n * b - o * g) + d * (n * f - o * p)), t63[10] = r3 * (s3 * b - u3 * g) - a * (n * b - o * g) + d * (n * u3 - o * s3), t63[11] = -(r3 * (s3 * f - u3 * p) - a * (n * f - o * p) + c * (n * u3 - o * s3)), t63[12] = -(a * (p * x - h * g) - c * (s3 * x - l * g) + d * (s3 * h - l * p)), t63[13] = r3 * (p * x - h * g) - c * (n * x - i * g) + d * (n * h - i * p), t63[14] = -(r3 * (s3 * x - l * g) - a * (n * x - i * g) + d * (n * l - i * s3)), t63[15] = r3 * (s3 * h - l * p) - a * (n * h - i * p) + c * (n * l - i * s3), t63;
}
function h2(t63) {
  var e = t63[0], r3 = t63[1], n = t63[2], i = t63[3], o = t63[4], a = t63[5], s3 = t63[6], l = t63[7], u3 = t63[8], c = t63[9], p = t63[10], h = t63[11], f = t63[12], d = t63[13], g = t63[14], x = t63[15], b = e * a - r3 * o, v3 = e * s3 - n * o, P = e * l - i * o, w3 = r3 * s3 - n * a, T = r3 * l - i * a, S = n * l - i * s3, C3 = u3 * d - c * f, A = u3 * g - p * f, E = u3 * x - h * f, L = c * g - p * d, F = c * x - h * d, O = p * x - h * g;
  return b * O - v3 * F + P * L + w3 * E - T * A + S * C3;
}
function qx(t63, e, r3) {
  var n = e[0], i = e[1], o = e[2], a = e[3], s3 = e[4], l = e[5], u3 = e[6], c = e[7], p = e[8], h = e[9], f = e[10], d = e[11], g = e[12], x = e[13], b = e[14], v3 = e[15], P = r3[0], w3 = r3[1], T = r3[2], S = r3[3];
  return t63[0] = P * n + w3 * s3 + T * p + S * g, t63[1] = P * i + w3 * l + T * h + S * x, t63[2] = P * o + w3 * u3 + T * f + S * b, t63[3] = P * a + w3 * c + T * d + S * v3, P = r3[4], w3 = r3[5], T = r3[6], S = r3[7], t63[4] = P * n + w3 * s3 + T * p + S * g, t63[5] = P * i + w3 * l + T * h + S * x, t63[6] = P * o + w3 * u3 + T * f + S * b, t63[7] = P * a + w3 * c + T * d + S * v3, P = r3[8], w3 = r3[9], T = r3[10], S = r3[11], t63[8] = P * n + w3 * s3 + T * p + S * g, t63[9] = P * i + w3 * l + T * h + S * x, t63[10] = P * o + w3 * u3 + T * f + S * b, t63[11] = P * a + w3 * c + T * d + S * v3, P = r3[12], w3 = r3[13], T = r3[14], S = r3[15], t63[12] = P * n + w3 * s3 + T * p + S * g, t63[13] = P * i + w3 * l + T * h + S * x, t63[14] = P * o + w3 * u3 + T * f + S * b, t63[15] = P * a + w3 * c + T * d + S * v3, t63;
}
function f2(t63, e, r3) {
  var n = r3[0], i = r3[1], o = r3[2], a, s3, l, u3, c, p, h, f, d, g, x, b;
  return e === t63 ? (t63[12] = e[0] * n + e[4] * i + e[8] * o + e[12], t63[13] = e[1] * n + e[5] * i + e[9] * o + e[13], t63[14] = e[2] * n + e[6] * i + e[10] * o + e[14], t63[15] = e[3] * n + e[7] * i + e[11] * o + e[15]) : (a = e[0], s3 = e[1], l = e[2], u3 = e[3], c = e[4], p = e[5], h = e[6], f = e[7], d = e[8], g = e[9], x = e[10], b = e[11], t63[0] = a, t63[1] = s3, t63[2] = l, t63[3] = u3, t63[4] = c, t63[5] = p, t63[6] = h, t63[7] = f, t63[8] = d, t63[9] = g, t63[10] = x, t63[11] = b, t63[12] = a * n + c * i + d * o + e[12], t63[13] = s3 * n + p * i + g * o + e[13], t63[14] = l * n + h * i + x * o + e[14], t63[15] = u3 * n + f * i + b * o + e[15]), t63;
}
function m2(t63, e, r3) {
  var n = r3[0], i = r3[1], o = r3[2];
  return t63[0] = e[0] * n, t63[1] = e[1] * n, t63[2] = e[2] * n, t63[3] = e[3] * n, t63[4] = e[4] * i, t63[5] = e[5] * i, t63[6] = e[6] * i, t63[7] = e[7] * i, t63[8] = e[8] * o, t63[9] = e[9] * o, t63[10] = e[10] * o, t63[11] = e[11] * o, t63[12] = e[12], t63[13] = e[13], t63[14] = e[14], t63[15] = e[15], t63;
}
function d2(t63, e, r3, n) {
  var i = n[0], o = n[1], a = n[2], s3 = Math.hypot(i, o, a), l, u3, c, p, h, f, d, g, x, b, v3, P, w3, T, S, C3, A, E, L, F, O, z, I, R;
  return s3 < ue ? null : (s3 = 1 / s3, i *= s3, o *= s3, a *= s3, l = Math.sin(r3), u3 = Math.cos(r3), c = 1 - u3, p = e[0], h = e[1], f = e[2], d = e[3], g = e[4], x = e[5], b = e[6], v3 = e[7], P = e[8], w3 = e[9], T = e[10], S = e[11], C3 = i * i * c + u3, A = o * i * c + a * l, E = a * i * c - o * l, L = i * o * c - a * l, F = o * o * c + u3, O = a * o * c + i * l, z = i * a * c + o * l, I = o * a * c - i * l, R = a * a * c + u3, t63[0] = p * C3 + g * A + P * E, t63[1] = h * C3 + x * A + w3 * E, t63[2] = f * C3 + b * A + T * E, t63[3] = d * C3 + v3 * A + S * E, t63[4] = p * L + g * F + P * O, t63[5] = h * L + x * F + w3 * O, t63[6] = f * L + b * F + T * O, t63[7] = d * L + v3 * F + S * O, t63[8] = p * z + g * I + P * R, t63[9] = h * z + x * I + w3 * R, t63[10] = f * z + b * I + T * R, t63[11] = d * z + v3 * I + S * R, e !== t63 && (t63[12] = e[12], t63[13] = e[13], t63[14] = e[14], t63[15] = e[15]), t63);
}
function y2(t63, e, r3) {
  var n = Math.sin(r3), i = Math.cos(r3), o = e[4], a = e[5], s3 = e[6], l = e[7], u3 = e[8], c = e[9], p = e[10], h = e[11];
  return e !== t63 && (t63[0] = e[0], t63[1] = e[1], t63[2] = e[2], t63[3] = e[3], t63[12] = e[12], t63[13] = e[13], t63[14] = e[14], t63[15] = e[15]), t63[4] = o * i + u3 * n, t63[5] = a * i + c * n, t63[6] = s3 * i + p * n, t63[7] = l * i + h * n, t63[8] = u3 * i - o * n, t63[9] = c * i - a * n, t63[10] = p * i - s3 * n, t63[11] = h * i - l * n, t63;
}
function g2(t63, e, r3) {
  var n = Math.sin(r3), i = Math.cos(r3), o = e[0], a = e[1], s3 = e[2], l = e[3], u3 = e[8], c = e[9], p = e[10], h = e[11];
  return e !== t63 && (t63[4] = e[4], t63[5] = e[5], t63[6] = e[6], t63[7] = e[7], t63[12] = e[12], t63[13] = e[13], t63[14] = e[14], t63[15] = e[15]), t63[0] = o * i - u3 * n, t63[1] = a * i - c * n, t63[2] = s3 * i - p * n, t63[3] = l * i - h * n, t63[8] = o * n + u3 * i, t63[9] = a * n + c * i, t63[10] = s3 * n + p * i, t63[11] = l * n + h * i, t63;
}
function x2(t63, e, r3) {
  var n = Math.sin(r3), i = Math.cos(r3), o = e[0], a = e[1], s3 = e[2], l = e[3], u3 = e[4], c = e[5], p = e[6], h = e[7];
  return e !== t63 && (t63[8] = e[8], t63[9] = e[9], t63[10] = e[10], t63[11] = e[11], t63[12] = e[12], t63[13] = e[13], t63[14] = e[14], t63[15] = e[15]), t63[0] = o * i + u3 * n, t63[1] = a * i + c * n, t63[2] = s3 * i + p * n, t63[3] = l * i + h * n, t63[4] = u3 * i - o * n, t63[5] = c * i - a * n, t63[6] = p * i - s3 * n, t63[7] = h * i - l * n, t63;
}
function b2(t63, e) {
  return t63[0] = 1, t63[1] = 0, t63[2] = 0, t63[3] = 0, t63[4] = 0, t63[5] = 1, t63[6] = 0, t63[7] = 0, t63[8] = 0, t63[9] = 0, t63[10] = 1, t63[11] = 0, t63[12] = e[0], t63[13] = e[1], t63[14] = e[2], t63[15] = 1, t63;
}
function _2(t63, e) {
  return t63[0] = e[0], t63[1] = 0, t63[2] = 0, t63[3] = 0, t63[4] = 0, t63[5] = e[1], t63[6] = 0, t63[7] = 0, t63[8] = 0, t63[9] = 0, t63[10] = e[2], t63[11] = 0, t63[12] = 0, t63[13] = 0, t63[14] = 0, t63[15] = 1, t63;
}
function v2(t63, e, r3) {
  var n = r3[0], i = r3[1], o = r3[2], a = Math.hypot(n, i, o), s3, l, u3;
  return a < ue ? null : (a = 1 / a, n *= a, i *= a, o *= a, s3 = Math.sin(e), l = Math.cos(e), u3 = 1 - l, t63[0] = n * n * u3 + l, t63[1] = i * n * u3 + o * s3, t63[2] = o * n * u3 - i * s3, t63[3] = 0, t63[4] = n * i * u3 - o * s3, t63[5] = i * i * u3 + l, t63[6] = o * i * u3 + n * s3, t63[7] = 0, t63[8] = n * o * u3 + i * s3, t63[9] = i * o * u3 - n * s3, t63[10] = o * o * u3 + l, t63[11] = 0, t63[12] = 0, t63[13] = 0, t63[14] = 0, t63[15] = 1, t63);
}
function P2(t63, e) {
  var r3 = Math.sin(e), n = Math.cos(e);
  return t63[0] = 1, t63[1] = 0, t63[2] = 0, t63[3] = 0, t63[4] = 0, t63[5] = n, t63[6] = r3, t63[7] = 0, t63[8] = 0, t63[9] = -r3, t63[10] = n, t63[11] = 0, t63[12] = 0, t63[13] = 0, t63[14] = 0, t63[15] = 1, t63;
}
function w2(t63, e) {
  var r3 = Math.sin(e), n = Math.cos(e);
  return t63[0] = n, t63[1] = 0, t63[2] = -r3, t63[3] = 0, t63[4] = 0, t63[5] = 1, t63[6] = 0, t63[7] = 0, t63[8] = r3, t63[9] = 0, t63[10] = n, t63[11] = 0, t63[12] = 0, t63[13] = 0, t63[14] = 0, t63[15] = 1, t63;
}
function T2(t63, e) {
  var r3 = Math.sin(e), n = Math.cos(e);
  return t63[0] = n, t63[1] = r3, t63[2] = 0, t63[3] = 0, t63[4] = -r3, t63[5] = n, t63[6] = 0, t63[7] = 0, t63[8] = 0, t63[9] = 0, t63[10] = 1, t63[11] = 0, t63[12] = 0, t63[13] = 0, t63[14] = 0, t63[15] = 1, t63;
}
function Yx(t63, e, r3) {
  var n = e[0], i = e[1], o = e[2], a = e[3], s3 = n + n, l = i + i, u3 = o + o, c = n * s3, p = n * l, h = n * u3, f = i * l, d = i * u3, g = o * u3, x = a * s3, b = a * l, v3 = a * u3;
  return t63[0] = 1 - (f + g), t63[1] = p + v3, t63[2] = h - b, t63[3] = 0, t63[4] = p - v3, t63[5] = 1 - (c + g), t63[6] = d + x, t63[7] = 0, t63[8] = h + b, t63[9] = d - x, t63[10] = 1 - (c + f), t63[11] = 0, t63[12] = r3[0], t63[13] = r3[1], t63[14] = r3[2], t63[15] = 1, t63;
}
function S2(t63, e) {
  var r3 = new Ae(3), n = -e[0], i = -e[1], o = -e[2], a = e[3], s3 = e[4], l = e[5], u3 = e[6], c = e[7], p = n * n + i * i + o * o + a * a;
  return p > 0 ? (r3[0] = (s3 * a + c * n + l * o - u3 * i) * 2 / p, r3[1] = (l * a + c * i + u3 * n - s3 * o) * 2 / p, r3[2] = (u3 * a + c * o + s3 * i - l * n) * 2 / p) : (r3[0] = (s3 * a + c * n + l * o - u3 * i) * 2, r3[1] = (l * a + c * i + u3 * n - s3 * o) * 2, r3[2] = (u3 * a + c * o + s3 * i - l * n) * 2), Yx(t63, e, r3), t63;
}
function C2(t63, e) {
  return t63[0] = e[12], t63[1] = e[13], t63[2] = e[14], t63;
}
function Wx(t63, e) {
  var r3 = e[0], n = e[1], i = e[2], o = e[4], a = e[5], s3 = e[6], l = e[8], u3 = e[9], c = e[10];
  return t63[0] = Math.hypot(r3, n, i), t63[1] = Math.hypot(o, a, s3), t63[2] = Math.hypot(l, u3, c), t63;
}
function M2(t63, e) {
  var r3 = new Ae(3);
  Wx(r3, e);
  var n = 1 / r3[0], i = 1 / r3[1], o = 1 / r3[2], a = e[0] * n, s3 = e[1] * i, l = e[2] * o, u3 = e[4] * n, c = e[5] * i, p = e[6] * o, h = e[8] * n, f = e[9] * i, d = e[10] * o, g = a + c + d, x = 0;
  return g > 0 ? (x = Math.sqrt(g + 1) * 2, t63[3] = 0.25 * x, t63[0] = (p - f) / x, t63[1] = (h - l) / x, t63[2] = (s3 - u3) / x) : a > c && a > d ? (x = Math.sqrt(1 + a - c - d) * 2, t63[3] = (p - f) / x, t63[0] = 0.25 * x, t63[1] = (s3 + u3) / x, t63[2] = (h + l) / x) : c > d ? (x = Math.sqrt(1 + c - a - d) * 2, t63[3] = (h - l) / x, t63[0] = (s3 + u3) / x, t63[1] = 0.25 * x, t63[2] = (p + f) / x) : (x = Math.sqrt(1 + d - a - c) * 2, t63[3] = (s3 - u3) / x, t63[0] = (h + l) / x, t63[1] = (p + f) / x, t63[2] = 0.25 * x), t63;
}
function I2(t63, e, r3, n) {
  var i = e[0], o = e[1], a = e[2], s3 = e[3], l = i + i, u3 = o + o, c = a + a, p = i * l, h = i * u3, f = i * c, d = o * u3, g = o * c, x = a * c, b = s3 * l, v3 = s3 * u3, P = s3 * c, w3 = n[0], T = n[1], S = n[2];
  return t63[0] = (1 - (d + x)) * w3, t63[1] = (h + P) * w3, t63[2] = (f - v3) * w3, t63[3] = 0, t63[4] = (h - P) * T, t63[5] = (1 - (p + x)) * T, t63[6] = (g + b) * T, t63[7] = 0, t63[8] = (f + v3) * S, t63[9] = (g - b) * S, t63[10] = (1 - (p + d)) * S, t63[11] = 0, t63[12] = r3[0], t63[13] = r3[1], t63[14] = r3[2], t63[15] = 1, t63;
}
function A2(t63, e, r3, n, i) {
  var o = e[0], a = e[1], s3 = e[2], l = e[3], u3 = o + o, c = a + a, p = s3 + s3, h = o * u3, f = o * c, d = o * p, g = a * c, x = a * p, b = s3 * p, v3 = l * u3, P = l * c, w3 = l * p, T = n[0], S = n[1], C3 = n[2], A = i[0], E = i[1], L = i[2], F = (1 - (g + b)) * T, O = (f + w3) * T, z = (d - P) * T, I = (f - w3) * S, R = (1 - (h + b)) * S, H = (x + v3) * S, W = (d + P) * C3, $ = (x - v3) * C3, he = (1 - (h + g)) * C3;
  return t63[0] = F, t63[1] = O, t63[2] = z, t63[3] = 0, t63[4] = I, t63[5] = R, t63[6] = H, t63[7] = 0, t63[8] = W, t63[9] = $, t63[10] = he, t63[11] = 0, t63[12] = r3[0] + A - (F * A + I * E + W * L), t63[13] = r3[1] + E - (O * A + R * E + $ * L), t63[14] = r3[2] + L - (z * A + H * E + he * L), t63[15] = 1, t63;
}
function E2(t63, e) {
  var r3 = e[0], n = e[1], i = e[2], o = e[3], a = r3 + r3, s3 = n + n, l = i + i, u3 = r3 * a, c = n * a, p = n * s3, h = i * a, f = i * s3, d = i * l, g = o * a, x = o * s3, b = o * l;
  return t63[0] = 1 - p - d, t63[1] = c + b, t63[2] = h - x, t63[3] = 0, t63[4] = c - b, t63[5] = 1 - u3 - d, t63[6] = f + g, t63[7] = 0, t63[8] = h + x, t63[9] = f - g, t63[10] = 1 - u3 - p, t63[11] = 0, t63[12] = 0, t63[13] = 0, t63[14] = 0, t63[15] = 1, t63;
}
function L2(t63, e, r3, n, i, o, a) {
  var s3 = 1 / (r3 - e), l = 1 / (i - n), u3 = 1 / (o - a);
  return t63[0] = o * 2 * s3, t63[1] = 0, t63[2] = 0, t63[3] = 0, t63[4] = 0, t63[5] = o * 2 * l, t63[6] = 0, t63[7] = 0, t63[8] = (r3 + e) * s3, t63[9] = (i + n) * l, t63[10] = (a + o) * u3, t63[11] = -1, t63[12] = 0, t63[13] = 0, t63[14] = a * o * 2 * u3, t63[15] = 0, t63;
}
function $x(t63, e, r3, n, i) {
  var o = 1 / Math.tan(e / 2), a;
  return t63[0] = o / r3, t63[1] = 0, t63[2] = 0, t63[3] = 0, t63[4] = 0, t63[5] = o, t63[6] = 0, t63[7] = 0, t63[8] = 0, t63[9] = 0, t63[11] = -1, t63[12] = 0, t63[13] = 0, t63[15] = 0, i != null && i !== 1 / 0 ? (a = 1 / (n - i), t63[10] = (i + n) * a, t63[14] = 2 * i * n * a) : (t63[10] = -1, t63[14] = -2 * n), t63;
}
var D2 = $x;
function R2(t63, e, r3, n, i) {
  var o = 1 / Math.tan(e / 2), a;
  return t63[0] = o / r3, t63[1] = 0, t63[2] = 0, t63[3] = 0, t63[4] = 0, t63[5] = o, t63[6] = 0, t63[7] = 0, t63[8] = 0, t63[9] = 0, t63[11] = -1, t63[12] = 0, t63[13] = 0, t63[15] = 0, i != null && i !== 1 / 0 ? (a = 1 / (n - i), t63[10] = i * a, t63[14] = i * n * a) : (t63[10] = -1, t63[14] = -n), t63;
}
function k2(t63, e, r3, n) {
  var i = Math.tan(e.upDegrees * Math.PI / 180), o = Math.tan(e.downDegrees * Math.PI / 180), a = Math.tan(e.leftDegrees * Math.PI / 180), s3 = Math.tan(e.rightDegrees * Math.PI / 180), l = 2 / (a + s3), u3 = 2 / (i + o);
  return t63[0] = l, t63[1] = 0, t63[2] = 0, t63[3] = 0, t63[4] = 0, t63[5] = u3, t63[6] = 0, t63[7] = 0, t63[8] = -((a - s3) * l * 0.5), t63[9] = (i - o) * u3 * 0.5, t63[10] = n / (r3 - n), t63[11] = -1, t63[12] = 0, t63[13] = 0, t63[14] = n * r3 / (r3 - n), t63[15] = 0, t63;
}
function Kx(t63, e, r3, n, i, o, a) {
  var s3 = 1 / (e - r3), l = 1 / (n - i), u3 = 1 / (o - a);
  return t63[0] = -2 * s3, t63[1] = 0, t63[2] = 0, t63[3] = 0, t63[4] = 0, t63[5] = -2 * l, t63[6] = 0, t63[7] = 0, t63[8] = 0, t63[9] = 0, t63[10] = 2 * u3, t63[11] = 0, t63[12] = (e + r3) * s3, t63[13] = (i + n) * l, t63[14] = (a + o) * u3, t63[15] = 1, t63;
}
var F2 = Kx;
function O2(t63, e, r3, n, i, o, a) {
  var s3 = 1 / (e - r3), l = 1 / (n - i), u3 = 1 / (o - a);
  return t63[0] = -2 * s3, t63[1] = 0, t63[2] = 0, t63[3] = 0, t63[4] = 0, t63[5] = -2 * l, t63[6] = 0, t63[7] = 0, t63[8] = 0, t63[9] = 0, t63[10] = u3, t63[11] = 0, t63[12] = (e + r3) * s3, t63[13] = (i + n) * l, t63[14] = o * u3, t63[15] = 1, t63;
}
function B2(t63, e, r3, n) {
  var i, o, a, s3, l, u3, c, p, h, f, d = e[0], g = e[1], x = e[2], b = n[0], v3 = n[1], P = n[2], w3 = r3[0], T = r3[1], S = r3[2];
  return Math.abs(d - w3) < ue && Math.abs(g - T) < ue && Math.abs(x - S) < ue ? Zx(t63) : (c = d - w3, p = g - T, h = x - S, f = 1 / Math.hypot(c, p, h), c *= f, p *= f, h *= f, i = v3 * h - P * p, o = P * c - b * h, a = b * p - v3 * c, f = Math.hypot(i, o, a), f ? (f = 1 / f, i *= f, o *= f, a *= f) : (i = 0, o = 0, a = 0), s3 = p * a - h * o, l = h * i - c * a, u3 = c * o - p * i, f = Math.hypot(s3, l, u3), f ? (f = 1 / f, s3 *= f, l *= f, u3 *= f) : (s3 = 0, l = 0, u3 = 0), t63[0] = i, t63[1] = s3, t63[2] = c, t63[3] = 0, t63[4] = o, t63[5] = l, t63[6] = p, t63[7] = 0, t63[8] = a, t63[9] = u3, t63[10] = h, t63[11] = 0, t63[12] = -(i * d + o * g + a * x), t63[13] = -(s3 * d + l * g + u3 * x), t63[14] = -(c * d + p * g + h * x), t63[15] = 1, t63);
}
function z2(t63, e, r3, n) {
  var i = e[0], o = e[1], a = e[2], s3 = n[0], l = n[1], u3 = n[2], c = i - r3[0], p = o - r3[1], h = a - r3[2], f = c * c + p * p + h * h;
  f > 0 && (f = 1 / Math.sqrt(f), c *= f, p *= f, h *= f);
  var d = l * h - u3 * p, g = u3 * c - s3 * h, x = s3 * p - l * c;
  return f = d * d + g * g + x * x, f > 0 && (f = 1 / Math.sqrt(f), d *= f, g *= f, x *= f), t63[0] = d, t63[1] = g, t63[2] = x, t63[3] = 0, t63[4] = p * x - h * g, t63[5] = h * d - c * x, t63[6] = c * g - p * d, t63[7] = 0, t63[8] = c, t63[9] = p, t63[10] = h, t63[11] = 0, t63[12] = i, t63[13] = o, t63[14] = a, t63[15] = 1, t63;
}
function V2(t63) {
  return "mat4(" + t63[0] + ", " + t63[1] + ", " + t63[2] + ", " + t63[3] + ", " + t63[4] + ", " + t63[5] + ", " + t63[6] + ", " + t63[7] + ", " + t63[8] + ", " + t63[9] + ", " + t63[10] + ", " + t63[11] + ", " + t63[12] + ", " + t63[13] + ", " + t63[14] + ", " + t63[15] + ")";
}
function U2(t63) {
  return Math.hypot(t63[0], t63[1], t63[2], t63[3], t63[4], t63[5], t63[6], t63[7], t63[8], t63[9], t63[10], t63[11], t63[12], t63[13], t63[14], t63[15]);
}
function N2(t63, e, r3) {
  return t63[0] = e[0] + r3[0], t63[1] = e[1] + r3[1], t63[2] = e[2] + r3[2], t63[3] = e[3] + r3[3], t63[4] = e[4] + r3[4], t63[5] = e[5] + r3[5], t63[6] = e[6] + r3[6], t63[7] = e[7] + r3[7], t63[8] = e[8] + r3[8], t63[9] = e[9] + r3[9], t63[10] = e[10] + r3[10], t63[11] = e[11] + r3[11], t63[12] = e[12] + r3[12], t63[13] = e[13] + r3[13], t63[14] = e[14] + r3[14], t63[15] = e[15] + r3[15], t63;
}
function Jx(t63, e, r3) {
  return t63[0] = e[0] - r3[0], t63[1] = e[1] - r3[1], t63[2] = e[2] - r3[2], t63[3] = e[3] - r3[3], t63[4] = e[4] - r3[4], t63[5] = e[5] - r3[5], t63[6] = e[6] - r3[6], t63[7] = e[7] - r3[7], t63[8] = e[8] - r3[8], t63[9] = e[9] - r3[9], t63[10] = e[10] - r3[10], t63[11] = e[11] - r3[11], t63[12] = e[12] - r3[12], t63[13] = e[13] - r3[13], t63[14] = e[14] - r3[14], t63[15] = e[15] - r3[15], t63;
}
function G2(t63, e, r3) {
  return t63[0] = e[0] * r3, t63[1] = e[1] * r3, t63[2] = e[2] * r3, t63[3] = e[3] * r3, t63[4] = e[4] * r3, t63[5] = e[5] * r3, t63[6] = e[6] * r3, t63[7] = e[7] * r3, t63[8] = e[8] * r3, t63[9] = e[9] * r3, t63[10] = e[10] * r3, t63[11] = e[11] * r3, t63[12] = e[12] * r3, t63[13] = e[13] * r3, t63[14] = e[14] * r3, t63[15] = e[15] * r3, t63;
}
function j2(t63, e, r3, n) {
  return t63[0] = e[0] + r3[0] * n, t63[1] = e[1] + r3[1] * n, t63[2] = e[2] + r3[2] * n, t63[3] = e[3] + r3[3] * n, t63[4] = e[4] + r3[4] * n, t63[5] = e[5] + r3[5] * n, t63[6] = e[6] + r3[6] * n, t63[7] = e[7] + r3[7] * n, t63[8] = e[8] + r3[8] * n, t63[9] = e[9] + r3[9] * n, t63[10] = e[10] + r3[10] * n, t63[11] = e[11] + r3[11] * n, t63[12] = e[12] + r3[12] * n, t63[13] = e[13] + r3[13] * n, t63[14] = e[14] + r3[14] * n, t63[15] = e[15] + r3[15] * n, t63;
}
function H2(t63, e) {
  return t63[0] === e[0] && t63[1] === e[1] && t63[2] === e[2] && t63[3] === e[3] && t63[4] === e[4] && t63[5] === e[5] && t63[6] === e[6] && t63[7] === e[7] && t63[8] === e[8] && t63[9] === e[9] && t63[10] === e[10] && t63[11] === e[11] && t63[12] === e[12] && t63[13] === e[13] && t63[14] === e[14] && t63[15] === e[15];
}
function X2(t63, e) {
  var r3 = t63[0], n = t63[1], i = t63[2], o = t63[3], a = t63[4], s3 = t63[5], l = t63[6], u3 = t63[7], c = t63[8], p = t63[9], h = t63[10], f = t63[11], d = t63[12], g = t63[13], x = t63[14], b = t63[15], v3 = e[0], P = e[1], w3 = e[2], T = e[3], S = e[4], C3 = e[5], A = e[6], E = e[7], L = e[8], F = e[9], O = e[10], z = e[11], I = e[12], R = e[13], H = e[14], W = e[15];
  return Math.abs(r3 - v3) <= ue * Math.max(1, Math.abs(r3), Math.abs(v3)) && Math.abs(n - P) <= ue * Math.max(1, Math.abs(n), Math.abs(P)) && Math.abs(i - w3) <= ue * Math.max(1, Math.abs(i), Math.abs(w3)) && Math.abs(o - T) <= ue * Math.max(1, Math.abs(o), Math.abs(T)) && Math.abs(a - S) <= ue * Math.max(1, Math.abs(a), Math.abs(S)) && Math.abs(s3 - C3) <= ue * Math.max(1, Math.abs(s3), Math.abs(C3)) && Math.abs(l - A) <= ue * Math.max(1, Math.abs(l), Math.abs(A)) && Math.abs(u3 - E) <= ue * Math.max(1, Math.abs(u3), Math.abs(E)) && Math.abs(c - L) <= ue * Math.max(1, Math.abs(c), Math.abs(L)) && Math.abs(p - F) <= ue * Math.max(1, Math.abs(p), Math.abs(F)) && Math.abs(h - O) <= ue * Math.max(1, Math.abs(h), Math.abs(O)) && Math.abs(f - z) <= ue * Math.max(1, Math.abs(f), Math.abs(z)) && Math.abs(d - I) <= ue * Math.max(1, Math.abs(d), Math.abs(I)) && Math.abs(g - R) <= ue * Math.max(1, Math.abs(g), Math.abs(R)) && Math.abs(x - H) <= ue * Math.max(1, Math.abs(x), Math.abs(H)) && Math.abs(b - W) <= ue * Math.max(1, Math.abs(b), Math.abs(W));
}
var Z2 = qx;
var q2 = Jx;
var Yn = {};
r(Yn, { add: () => mE, calculateW: () => nE, clone: () => cE, conjugate: () => sE, copy: () => hE, create: () => Km, dot: () => xb, equals: () => _E, exactEquals: () => bE, exp: () => mb, fromEuler: () => lE, fromMat3: () => yb, fromValues: () => pE, getAngle: () => QA, getAxisAngle: () => JA, identity: () => KA, invert: () => aE, len: () => gE, length: () => bb, lerp: () => yE, ln: () => db, mul: () => dE, multiply: () => fb, normalize: () => Jm, pow: () => iE, random: () => oE, rotateX: () => eE, rotateY: () => tE, rotateZ: () => rE, rotationTo: () => vE, scale: () => gb, set: () => fE, setAxes: () => wE, setAxisAngle: () => hb, slerp: () => rc, sqlerp: () => PE, sqrLen: () => xE, squaredLength: () => _b, str: () => uE });
$i();
var V = {};
r(V, { add: () => K2, angle: () => gA, bezier: () => uA, ceil: () => J2, clone: () => Y2, copy: () => W2, create: () => Ku, cross: () => es, dist: () => SA, distance: () => nb, div: () => TA, divide: () => rb, dot: () => Qu, equals: () => vA, exactEquals: () => _A, floor: () => Q2, forEach: () => IA, fromValues: () => Ju, hermite: () => lA, inverse: () => aA, len: () => Vm, length: () => Qx, lerp: () => sA, max: () => tA, min: () => eA, mul: () => wA, multiply: () => tb, negate: () => oA, normalize: () => zm, random: () => cA, rotateX: () => mA, rotateY: () => dA, rotateZ: () => yA, round: () => rA, scale: () => nA, scaleAndAdd: () => iA, set: () => $2, sqrDist: () => CA, sqrLen: () => MA, squaredDistance: () => ib, squaredLength: () => ob, str: () => bA, sub: () => PA, subtract: () => eb, transformMat3: () => hA, transformMat4: () => pA, transformQuat: () => fA, zero: () => xA });
$i();
function Ku() {
  var t63 = new Ae(3);
  return Ae != Float32Array && (t63[0] = 0, t63[1] = 0, t63[2] = 0), t63;
}
function Y2(t63) {
  var e = new Ae(3);
  return e[0] = t63[0], e[1] = t63[1], e[2] = t63[2], e;
}
function Qx(t63) {
  var e = t63[0], r3 = t63[1], n = t63[2];
  return Math.hypot(e, r3, n);
}
function Ju(t63, e, r3) {
  var n = new Ae(3);
  return n[0] = t63, n[1] = e, n[2] = r3, n;
}
function W2(t63, e) {
  return t63[0] = e[0], t63[1] = e[1], t63[2] = e[2], t63;
}
function $2(t63, e, r3, n) {
  return t63[0] = e, t63[1] = r3, t63[2] = n, t63;
}
function K2(t63, e, r3) {
  return t63[0] = e[0] + r3[0], t63[1] = e[1] + r3[1], t63[2] = e[2] + r3[2], t63;
}
function eb(t63, e, r3) {
  return t63[0] = e[0] - r3[0], t63[1] = e[1] - r3[1], t63[2] = e[2] - r3[2], t63;
}
function tb(t63, e, r3) {
  return t63[0] = e[0] * r3[0], t63[1] = e[1] * r3[1], t63[2] = e[2] * r3[2], t63;
}
function rb(t63, e, r3) {
  return t63[0] = e[0] / r3[0], t63[1] = e[1] / r3[1], t63[2] = e[2] / r3[2], t63;
}
function J2(t63, e) {
  return t63[0] = Math.ceil(e[0]), t63[1] = Math.ceil(e[1]), t63[2] = Math.ceil(e[2]), t63;
}
function Q2(t63, e) {
  return t63[0] = Math.floor(e[0]), t63[1] = Math.floor(e[1]), t63[2] = Math.floor(e[2]), t63;
}
function eA(t63, e, r3) {
  return t63[0] = Math.min(e[0], r3[0]), t63[1] = Math.min(e[1], r3[1]), t63[2] = Math.min(e[2], r3[2]), t63;
}
function tA(t63, e, r3) {
  return t63[0] = Math.max(e[0], r3[0]), t63[1] = Math.max(e[1], r3[1]), t63[2] = Math.max(e[2], r3[2]), t63;
}
function rA(t63, e) {
  return t63[0] = Math.round(e[0]), t63[1] = Math.round(e[1]), t63[2] = Math.round(e[2]), t63;
}
function nA(t63, e, r3) {
  return t63[0] = e[0] * r3, t63[1] = e[1] * r3, t63[2] = e[2] * r3, t63;
}
function iA(t63, e, r3, n) {
  return t63[0] = e[0] + r3[0] * n, t63[1] = e[1] + r3[1] * n, t63[2] = e[2] + r3[2] * n, t63;
}
function nb(t63, e) {
  var r3 = e[0] - t63[0], n = e[1] - t63[1], i = e[2] - t63[2];
  return Math.hypot(r3, n, i);
}
function ib(t63, e) {
  var r3 = e[0] - t63[0], n = e[1] - t63[1], i = e[2] - t63[2];
  return r3 * r3 + n * n + i * i;
}
function ob(t63) {
  var e = t63[0], r3 = t63[1], n = t63[2];
  return e * e + r3 * r3 + n * n;
}
function oA(t63, e) {
  return t63[0] = -e[0], t63[1] = -e[1], t63[2] = -e[2], t63;
}
function aA(t63, e) {
  return t63[0] = 1 / e[0], t63[1] = 1 / e[1], t63[2] = 1 / e[2], t63;
}
function zm(t63, e) {
  var r3 = e[0], n = e[1], i = e[2], o = r3 * r3 + n * n + i * i;
  return o > 0 && (o = 1 / Math.sqrt(o)), t63[0] = e[0] * o, t63[1] = e[1] * o, t63[2] = e[2] * o, t63;
}
function Qu(t63, e) {
  return t63[0] * e[0] + t63[1] * e[1] + t63[2] * e[2];
}
function es(t63, e, r3) {
  var n = e[0], i = e[1], o = e[2], a = r3[0], s3 = r3[1], l = r3[2];
  return t63[0] = i * l - o * s3, t63[1] = o * a - n * l, t63[2] = n * s3 - i * a, t63;
}
function sA(t63, e, r3, n) {
  var i = e[0], o = e[1], a = e[2];
  return t63[0] = i + n * (r3[0] - i), t63[1] = o + n * (r3[1] - o), t63[2] = a + n * (r3[2] - a), t63;
}
function lA(t63, e, r3, n, i, o) {
  var a = o * o, s3 = a * (2 * o - 3) + 1, l = a * (o - 2) + o, u3 = a * (o - 1), c = a * (3 - 2 * o);
  return t63[0] = e[0] * s3 + r3[0] * l + n[0] * u3 + i[0] * c, t63[1] = e[1] * s3 + r3[1] * l + n[1] * u3 + i[1] * c, t63[2] = e[2] * s3 + r3[2] * l + n[2] * u3 + i[2] * c, t63;
}
function uA(t63, e, r3, n, i, o) {
  var a = 1 - o, s3 = a * a, l = o * o, u3 = s3 * a, c = 3 * o * s3, p = 3 * l * a, h = l * o;
  return t63[0] = e[0] * u3 + r3[0] * c + n[0] * p + i[0] * h, t63[1] = e[1] * u3 + r3[1] * c + n[1] * p + i[1] * h, t63[2] = e[2] * u3 + r3[2] * c + n[2] * p + i[2] * h, t63;
}
function cA(t63, e) {
  e = e || 1;
  var r3 = qt() * 2 * Math.PI, n = qt() * 2 - 1, i = Math.sqrt(1 - n * n) * e;
  return t63[0] = Math.cos(r3) * i, t63[1] = Math.sin(r3) * i, t63[2] = n * e, t63;
}
function pA(t63, e, r3) {
  var n = e[0], i = e[1], o = e[2], a = r3[3] * n + r3[7] * i + r3[11] * o + r3[15];
  return a = a || 1, t63[0] = (r3[0] * n + r3[4] * i + r3[8] * o + r3[12]) / a, t63[1] = (r3[1] * n + r3[5] * i + r3[9] * o + r3[13]) / a, t63[2] = (r3[2] * n + r3[6] * i + r3[10] * o + r3[14]) / a, t63;
}
function hA(t63, e, r3) {
  var n = e[0], i = e[1], o = e[2];
  return t63[0] = n * r3[0] + i * r3[3] + o * r3[6], t63[1] = n * r3[1] + i * r3[4] + o * r3[7], t63[2] = n * r3[2] + i * r3[5] + o * r3[8], t63;
}
function fA(t63, e, r3) {
  var n = r3[0], i = r3[1], o = r3[2], a = r3[3], s3 = e[0], l = e[1], u3 = e[2], c = i * u3 - o * l, p = o * s3 - n * u3, h = n * l - i * s3, f = i * h - o * p, d = o * c - n * h, g = n * p - i * c, x = a * 2;
  return c *= x, p *= x, h *= x, f *= 2, d *= 2, g *= 2, t63[0] = s3 + c + f, t63[1] = l + p + d, t63[2] = u3 + h + g, t63;
}
function mA(t63, e, r3, n) {
  var i = [], o = [];
  return i[0] = e[0] - r3[0], i[1] = e[1] - r3[1], i[2] = e[2] - r3[2], o[0] = i[0], o[1] = i[1] * Math.cos(n) - i[2] * Math.sin(n), o[2] = i[1] * Math.sin(n) + i[2] * Math.cos(n), t63[0] = o[0] + r3[0], t63[1] = o[1] + r3[1], t63[2] = o[2] + r3[2], t63;
}
function dA(t63, e, r3, n) {
  var i = [], o = [];
  return i[0] = e[0] - r3[0], i[1] = e[1] - r3[1], i[2] = e[2] - r3[2], o[0] = i[2] * Math.sin(n) + i[0] * Math.cos(n), o[1] = i[1], o[2] = i[2] * Math.cos(n) - i[0] * Math.sin(n), t63[0] = o[0] + r3[0], t63[1] = o[1] + r3[1], t63[2] = o[2] + r3[2], t63;
}
function yA(t63, e, r3, n) {
  var i = [], o = [];
  return i[0] = e[0] - r3[0], i[1] = e[1] - r3[1], i[2] = e[2] - r3[2], o[0] = i[0] * Math.cos(n) - i[1] * Math.sin(n), o[1] = i[0] * Math.sin(n) + i[1] * Math.cos(n), o[2] = i[2], t63[0] = o[0] + r3[0], t63[1] = o[1] + r3[1], t63[2] = o[2] + r3[2], t63;
}
function gA(t63, e) {
  var r3 = t63[0], n = t63[1], i = t63[2], o = e[0], a = e[1], s3 = e[2], l = Math.sqrt(r3 * r3 + n * n + i * i), u3 = Math.sqrt(o * o + a * a + s3 * s3), c = l * u3, p = c && Qu(t63, e) / c;
  return Math.acos(Math.min(Math.max(p, -1), 1));
}
function xA(t63) {
  return t63[0] = 0, t63[1] = 0, t63[2] = 0, t63;
}
function bA(t63) {
  return "vec3(" + t63[0] + ", " + t63[1] + ", " + t63[2] + ")";
}
function _A(t63, e) {
  return t63[0] === e[0] && t63[1] === e[1] && t63[2] === e[2];
}
function vA(t63, e) {
  var r3 = t63[0], n = t63[1], i = t63[2], o = e[0], a = e[1], s3 = e[2];
  return Math.abs(r3 - o) <= ue * Math.max(1, Math.abs(r3), Math.abs(o)) && Math.abs(n - a) <= ue * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(i - s3) <= ue * Math.max(1, Math.abs(i), Math.abs(s3));
}
var PA = eb;
var wA = tb;
var TA = rb;
var SA = nb;
var CA = ib;
var Vm = Qx;
var MA = ob;
var IA = (function() {
  var t63 = Ku();
  return function(e, r3, n, i, o, a) {
    var s3, l;
    for (r3 || (r3 = 3), n || (n = 0), i ? l = Math.min(i * r3 + n, e.length) : l = e.length, s3 = n; s3 < l; s3 += r3) t63[0] = e[s3], t63[1] = e[s3 + 1], t63[2] = e[s3 + 2], o(t63, t63, a), e[s3] = t63[0], e[s3 + 1] = t63[1], e[s3 + 2] = t63[2];
    return e;
  };
})();
var Ne = {};
r(Ne, { add: () => Hm, ceil: () => AA, clone: () => Um, copy: () => Gm, create: () => ab, cross: () => BA, dist: () => ZA, distance: () => cb, div: () => XA, divide: () => ub, dot: () => qm, equals: () => $m, exactEquals: () => Wm, floor: () => EA, forEach: () => $A, fromValues: () => Nm, inverse: () => OA, len: () => YA, length: () => ec, lerp: () => Ym, max: () => DA, min: () => LA, mul: () => HA, multiply: () => lb, negate: () => FA, normalize: () => Zm, random: () => zA, round: () => RA, scale: () => Xm, scaleAndAdd: () => kA, set: () => jm, sqrDist: () => qA, sqrLen: () => WA, squaredDistance: () => pb, squaredLength: () => tc, str: () => GA, sub: () => jA, subtract: () => sb, transformMat4: () => VA, transformQuat: () => UA, zero: () => NA });
$i();
function ab() {
  var t63 = new Ae(4);
  return Ae != Float32Array && (t63[0] = 0, t63[1] = 0, t63[2] = 0, t63[3] = 0), t63;
}
function Um(t63) {
  var e = new Ae(4);
  return e[0] = t63[0], e[1] = t63[1], e[2] = t63[2], e[3] = t63[3], e;
}
function Nm(t63, e, r3, n) {
  var i = new Ae(4);
  return i[0] = t63, i[1] = e, i[2] = r3, i[3] = n, i;
}
function Gm(t63, e) {
  return t63[0] = e[0], t63[1] = e[1], t63[2] = e[2], t63[3] = e[3], t63;
}
function jm(t63, e, r3, n, i) {
  return t63[0] = e, t63[1] = r3, t63[2] = n, t63[3] = i, t63;
}
function Hm(t63, e, r3) {
  return t63[0] = e[0] + r3[0], t63[1] = e[1] + r3[1], t63[2] = e[2] + r3[2], t63[3] = e[3] + r3[3], t63;
}
function sb(t63, e, r3) {
  return t63[0] = e[0] - r3[0], t63[1] = e[1] - r3[1], t63[2] = e[2] - r3[2], t63[3] = e[3] - r3[3], t63;
}
function lb(t63, e, r3) {
  return t63[0] = e[0] * r3[0], t63[1] = e[1] * r3[1], t63[2] = e[2] * r3[2], t63[3] = e[3] * r3[3], t63;
}
function ub(t63, e, r3) {
  return t63[0] = e[0] / r3[0], t63[1] = e[1] / r3[1], t63[2] = e[2] / r3[2], t63[3] = e[3] / r3[3], t63;
}
function AA(t63, e) {
  return t63[0] = Math.ceil(e[0]), t63[1] = Math.ceil(e[1]), t63[2] = Math.ceil(e[2]), t63[3] = Math.ceil(e[3]), t63;
}
function EA(t63, e) {
  return t63[0] = Math.floor(e[0]), t63[1] = Math.floor(e[1]), t63[2] = Math.floor(e[2]), t63[3] = Math.floor(e[3]), t63;
}
function LA(t63, e, r3) {
  return t63[0] = Math.min(e[0], r3[0]), t63[1] = Math.min(e[1], r3[1]), t63[2] = Math.min(e[2], r3[2]), t63[3] = Math.min(e[3], r3[3]), t63;
}
function DA(t63, e, r3) {
  return t63[0] = Math.max(e[0], r3[0]), t63[1] = Math.max(e[1], r3[1]), t63[2] = Math.max(e[2], r3[2]), t63[3] = Math.max(e[3], r3[3]), t63;
}
function RA(t63, e) {
  return t63[0] = Math.round(e[0]), t63[1] = Math.round(e[1]), t63[2] = Math.round(e[2]), t63[3] = Math.round(e[3]), t63;
}
function Xm(t63, e, r3) {
  return t63[0] = e[0] * r3, t63[1] = e[1] * r3, t63[2] = e[2] * r3, t63[3] = e[3] * r3, t63;
}
function kA(t63, e, r3, n) {
  return t63[0] = e[0] + r3[0] * n, t63[1] = e[1] + r3[1] * n, t63[2] = e[2] + r3[2] * n, t63[3] = e[3] + r3[3] * n, t63;
}
function cb(t63, e) {
  var r3 = e[0] - t63[0], n = e[1] - t63[1], i = e[2] - t63[2], o = e[3] - t63[3];
  return Math.hypot(r3, n, i, o);
}
function pb(t63, e) {
  var r3 = e[0] - t63[0], n = e[1] - t63[1], i = e[2] - t63[2], o = e[3] - t63[3];
  return r3 * r3 + n * n + i * i + o * o;
}
function ec(t63) {
  var e = t63[0], r3 = t63[1], n = t63[2], i = t63[3];
  return Math.hypot(e, r3, n, i);
}
function tc(t63) {
  var e = t63[0], r3 = t63[1], n = t63[2], i = t63[3];
  return e * e + r3 * r3 + n * n + i * i;
}
function FA(t63, e) {
  return t63[0] = -e[0], t63[1] = -e[1], t63[2] = -e[2], t63[3] = -e[3], t63;
}
function OA(t63, e) {
  return t63[0] = 1 / e[0], t63[1] = 1 / e[1], t63[2] = 1 / e[2], t63[3] = 1 / e[3], t63;
}
function Zm(t63, e) {
  var r3 = e[0], n = e[1], i = e[2], o = e[3], a = r3 * r3 + n * n + i * i + o * o;
  return a > 0 && (a = 1 / Math.sqrt(a)), t63[0] = r3 * a, t63[1] = n * a, t63[2] = i * a, t63[3] = o * a, t63;
}
function qm(t63, e) {
  return t63[0] * e[0] + t63[1] * e[1] + t63[2] * e[2] + t63[3] * e[3];
}
function BA(t63, e, r3, n) {
  var i = r3[0] * n[1] - r3[1] * n[0], o = r3[0] * n[2] - r3[2] * n[0], a = r3[0] * n[3] - r3[3] * n[0], s3 = r3[1] * n[2] - r3[2] * n[1], l = r3[1] * n[3] - r3[3] * n[1], u3 = r3[2] * n[3] - r3[3] * n[2], c = e[0], p = e[1], h = e[2], f = e[3];
  return t63[0] = p * u3 - h * l + f * s3, t63[1] = -(c * u3) + h * a - f * o, t63[2] = c * l - p * a + f * i, t63[3] = -(c * s3) + p * o - h * i, t63;
}
function Ym(t63, e, r3, n) {
  var i = e[0], o = e[1], a = e[2], s3 = e[3];
  return t63[0] = i + n * (r3[0] - i), t63[1] = o + n * (r3[1] - o), t63[2] = a + n * (r3[2] - a), t63[3] = s3 + n * (r3[3] - s3), t63;
}
function zA(t63, e) {
  e = e || 1;
  var r3, n, i, o, a, s3;
  do
    r3 = qt() * 2 - 1, n = qt() * 2 - 1, a = r3 * r3 + n * n;
  while (a >= 1);
  do
    i = qt() * 2 - 1, o = qt() * 2 - 1, s3 = i * i + o * o;
  while (s3 >= 1);
  var l = Math.sqrt((1 - a) / s3);
  return t63[0] = e * r3, t63[1] = e * n, t63[2] = e * i * l, t63[3] = e * o * l, t63;
}
function VA(t63, e, r3) {
  var n = e[0], i = e[1], o = e[2], a = e[3];
  return t63[0] = r3[0] * n + r3[4] * i + r3[8] * o + r3[12] * a, t63[1] = r3[1] * n + r3[5] * i + r3[9] * o + r3[13] * a, t63[2] = r3[2] * n + r3[6] * i + r3[10] * o + r3[14] * a, t63[3] = r3[3] * n + r3[7] * i + r3[11] * o + r3[15] * a, t63;
}
function UA(t63, e, r3) {
  var n = e[0], i = e[1], o = e[2], a = r3[0], s3 = r3[1], l = r3[2], u3 = r3[3], c = u3 * n + s3 * o - l * i, p = u3 * i + l * n - a * o, h = u3 * o + a * i - s3 * n, f = -a * n - s3 * i - l * o;
  return t63[0] = c * u3 + f * -a + p * -l - h * -s3, t63[1] = p * u3 + f * -s3 + h * -a - c * -l, t63[2] = h * u3 + f * -l + c * -s3 - p * -a, t63[3] = e[3], t63;
}
function NA(t63) {
  return t63[0] = 0, t63[1] = 0, t63[2] = 0, t63[3] = 0, t63;
}
function GA(t63) {
  return "vec4(" + t63[0] + ", " + t63[1] + ", " + t63[2] + ", " + t63[3] + ")";
}
function Wm(t63, e) {
  return t63[0] === e[0] && t63[1] === e[1] && t63[2] === e[2] && t63[3] === e[3];
}
function $m(t63, e) {
  var r3 = t63[0], n = t63[1], i = t63[2], o = t63[3], a = e[0], s3 = e[1], l = e[2], u3 = e[3];
  return Math.abs(r3 - a) <= ue * Math.max(1, Math.abs(r3), Math.abs(a)) && Math.abs(n - s3) <= ue * Math.max(1, Math.abs(n), Math.abs(s3)) && Math.abs(i - l) <= ue * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(o - u3) <= ue * Math.max(1, Math.abs(o), Math.abs(u3));
}
var jA = sb;
var HA = lb;
var XA = ub;
var ZA = cb;
var qA = pb;
var YA = ec;
var WA = tc;
var $A = (function() {
  var t63 = ab();
  return function(e, r3, n, i, o, a) {
    var s3, l;
    for (r3 || (r3 = 4), n || (n = 0), i ? l = Math.min(i * r3 + n, e.length) : l = e.length, s3 = n; s3 < l; s3 += r3) t63[0] = e[s3], t63[1] = e[s3 + 1], t63[2] = e[s3 + 2], t63[3] = e[s3 + 3], o(t63, t63, a), e[s3] = t63[0], e[s3 + 1] = t63[1], e[s3 + 2] = t63[2], e[s3 + 3] = t63[3];
    return e;
  };
})();
function Km() {
  var t63 = new Ae(4);
  return Ae != Float32Array && (t63[0] = 0, t63[1] = 0, t63[2] = 0), t63[3] = 1, t63;
}
function KA(t63) {
  return t63[0] = 0, t63[1] = 0, t63[2] = 0, t63[3] = 1, t63;
}
function hb(t63, e, r3) {
  r3 = r3 * 0.5;
  var n = Math.sin(r3);
  return t63[0] = n * e[0], t63[1] = n * e[1], t63[2] = n * e[2], t63[3] = Math.cos(r3), t63;
}
function JA(t63, e) {
  var r3 = Math.acos(e[3]) * 2, n = Math.sin(r3 / 2);
  return n > ue ? (t63[0] = e[0] / n, t63[1] = e[1] / n, t63[2] = e[2] / n) : (t63[0] = 1, t63[1] = 0, t63[2] = 0), r3;
}
function QA(t63, e) {
  var r3 = xb(t63, e);
  return Math.acos(2 * r3 * r3 - 1);
}
function fb(t63, e, r3) {
  var n = e[0], i = e[1], o = e[2], a = e[3], s3 = r3[0], l = r3[1], u3 = r3[2], c = r3[3];
  return t63[0] = n * c + a * s3 + i * u3 - o * l, t63[1] = i * c + a * l + o * s3 - n * u3, t63[2] = o * c + a * u3 + n * l - i * s3, t63[3] = a * c - n * s3 - i * l - o * u3, t63;
}
function eE(t63, e, r3) {
  r3 *= 0.5;
  var n = e[0], i = e[1], o = e[2], a = e[3], s3 = Math.sin(r3), l = Math.cos(r3);
  return t63[0] = n * l + a * s3, t63[1] = i * l + o * s3, t63[2] = o * l - i * s3, t63[3] = a * l - n * s3, t63;
}
function tE(t63, e, r3) {
  r3 *= 0.5;
  var n = e[0], i = e[1], o = e[2], a = e[3], s3 = Math.sin(r3), l = Math.cos(r3);
  return t63[0] = n * l - o * s3, t63[1] = i * l + a * s3, t63[2] = o * l + n * s3, t63[3] = a * l - i * s3, t63;
}
function rE(t63, e, r3) {
  r3 *= 0.5;
  var n = e[0], i = e[1], o = e[2], a = e[3], s3 = Math.sin(r3), l = Math.cos(r3);
  return t63[0] = n * l + i * s3, t63[1] = i * l - n * s3, t63[2] = o * l + a * s3, t63[3] = a * l - o * s3, t63;
}
function nE(t63, e) {
  var r3 = e[0], n = e[1], i = e[2];
  return t63[0] = r3, t63[1] = n, t63[2] = i, t63[3] = Math.sqrt(Math.abs(1 - r3 * r3 - n * n - i * i)), t63;
}
function mb(t63, e) {
  var r3 = e[0], n = e[1], i = e[2], o = e[3], a = Math.sqrt(r3 * r3 + n * n + i * i), s3 = Math.exp(o), l = a > 0 ? s3 * Math.sin(a) / a : 0;
  return t63[0] = r3 * l, t63[1] = n * l, t63[2] = i * l, t63[3] = s3 * Math.cos(a), t63;
}
function db(t63, e) {
  var r3 = e[0], n = e[1], i = e[2], o = e[3], a = Math.sqrt(r3 * r3 + n * n + i * i), s3 = a > 0 ? Math.atan2(a, o) / a : 0;
  return t63[0] = r3 * s3, t63[1] = n * s3, t63[2] = i * s3, t63[3] = 0.5 * Math.log(r3 * r3 + n * n + i * i + o * o), t63;
}
function iE(t63, e, r3) {
  return db(t63, e), gb(t63, t63, r3), mb(t63, t63), t63;
}
function rc(t63, e, r3, n) {
  var i = e[0], o = e[1], a = e[2], s3 = e[3], l = r3[0], u3 = r3[1], c = r3[2], p = r3[3], h, f, d, g, x;
  return f = i * l + o * u3 + a * c + s3 * p, f < 0 && (f = -f, l = -l, u3 = -u3, c = -c, p = -p), 1 - f > ue ? (h = Math.acos(f), d = Math.sin(h), g = Math.sin((1 - n) * h) / d, x = Math.sin(n * h) / d) : (g = 1 - n, x = n), t63[0] = g * i + x * l, t63[1] = g * o + x * u3, t63[2] = g * a + x * c, t63[3] = g * s3 + x * p, t63;
}
function oE(t63) {
  var e = qt(), r3 = qt(), n = qt(), i = Math.sqrt(1 - e), o = Math.sqrt(e);
  return t63[0] = i * Math.sin(2 * Math.PI * r3), t63[1] = i * Math.cos(2 * Math.PI * r3), t63[2] = o * Math.sin(2 * Math.PI * n), t63[3] = o * Math.cos(2 * Math.PI * n), t63;
}
function aE(t63, e) {
  var r3 = e[0], n = e[1], i = e[2], o = e[3], a = r3 * r3 + n * n + i * i + o * o, s3 = a ? 1 / a : 0;
  return t63[0] = -r3 * s3, t63[1] = -n * s3, t63[2] = -i * s3, t63[3] = o * s3, t63;
}
function sE(t63, e) {
  return t63[0] = -e[0], t63[1] = -e[1], t63[2] = -e[2], t63[3] = e[3], t63;
}
function yb(t63, e) {
  var r3 = e[0] + e[4] + e[8], n;
  if (r3 > 0) n = Math.sqrt(r3 + 1), t63[3] = 0.5 * n, n = 0.5 / n, t63[0] = (e[5] - e[7]) * n, t63[1] = (e[6] - e[2]) * n, t63[2] = (e[1] - e[3]) * n;
  else {
    var i = 0;
    e[4] > e[0] && (i = 1), e[8] > e[i * 3 + i] && (i = 2);
    var o = (i + 1) % 3, a = (i + 2) % 3;
    n = Math.sqrt(e[i * 3 + i] - e[o * 3 + o] - e[a * 3 + a] + 1), t63[i] = 0.5 * n, n = 0.5 / n, t63[3] = (e[o * 3 + a] - e[a * 3 + o]) * n, t63[o] = (e[o * 3 + i] + e[i * 3 + o]) * n, t63[a] = (e[a * 3 + i] + e[i * 3 + a]) * n;
  }
  return t63;
}
function lE(t63, e, r3, n) {
  var i = 0.5 * Math.PI / 180;
  e *= i, r3 *= i, n *= i;
  var o = Math.sin(e), a = Math.cos(e), s3 = Math.sin(r3), l = Math.cos(r3), u3 = Math.sin(n), c = Math.cos(n);
  return t63[0] = o * l * c - a * s3 * u3, t63[1] = a * s3 * c + o * l * u3, t63[2] = a * l * u3 - o * s3 * c, t63[3] = a * l * c + o * s3 * u3, t63;
}
function uE(t63) {
  return "quat(" + t63[0] + ", " + t63[1] + ", " + t63[2] + ", " + t63[3] + ")";
}
var cE = Um;
var pE = Nm;
var hE = Gm;
var fE = jm;
var mE = Hm;
var dE = fb;
var gb = Xm;
var xb = qm;
var yE = Ym;
var bb = ec;
var gE = bb;
var _b = tc;
var xE = _b;
var Jm = Zm;
var bE = Wm;
var _E = $m;
var vE = (function() {
  var t63 = Ku(), e = Ju(1, 0, 0), r3 = Ju(0, 1, 0);
  return function(n, i, o) {
    var a = Qu(i, o);
    return a < -0.999999 ? (es(t63, e, i), Vm(t63) < 1e-6 && es(t63, r3, i), zm(t63, t63), hb(n, t63, Math.PI), n) : a > 0.999999 ? (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n) : (es(t63, i, o), n[0] = t63[0], n[1] = t63[1], n[2] = t63[2], n[3] = 1 + a, Jm(n, n));
  };
})();
var PE = (function() {
  var t63 = Km(), e = Km();
  return function(r3, n, i, o, a, s3) {
    return rc(t63, n, a, s3), rc(e, i, o, s3), rc(r3, t63, e, 2 * s3 * (1 - s3)), r3;
  };
})();
var wE = (function() {
  var t63 = Bm();
  return function(e, r3, n, i) {
    return t63[0] = n[0], t63[3] = n[1], t63[6] = n[2], t63[1] = i[0], t63[4] = i[1], t63[7] = i[2], t63[2] = -r3[0], t63[5] = -r3[1], t63[8] = -r3[2], Jm(e, yb(e, t63));
  };
})();
var wt = {};
r(wt, { add: () => IE, angle: () => YE, ceil: () => AE, clone: () => TE, copy: () => CE, create: () => vb, cross: () => UE, dist: () => nL, distance: () => Sb, div: () => rL, divide: () => Tb, dot: () => VE, equals: () => JE, exactEquals: () => KE, floor: () => EE, forEach: () => aL, fromValues: () => SE, inverse: () => BE, len: () => QE, length: () => Mb, lerp: () => NE, max: () => DE, min: () => LE, mul: () => tL, multiply: () => wb, negate: () => OE, normalize: () => zE, random: () => GE, rotate: () => qE, round: () => RE, scale: () => kE, scaleAndAdd: () => FE, set: () => ME, sqrDist: () => iL, sqrLen: () => oL, squaredDistance: () => Cb, squaredLength: () => Ib, str: () => $E, sub: () => eL, subtract: () => Pb, transformMat2: () => jE, transformMat2d: () => HE, transformMat3: () => XE, transformMat4: () => ZE, zero: () => WE });
$i();
function vb() {
  var t63 = new Ae(2);
  return Ae != Float32Array && (t63[0] = 0, t63[1] = 0), t63;
}
function TE(t63) {
  var e = new Ae(2);
  return e[0] = t63[0], e[1] = t63[1], e;
}
function SE(t63, e) {
  var r3 = new Ae(2);
  return r3[0] = t63, r3[1] = e, r3;
}
function CE(t63, e) {
  return t63[0] = e[0], t63[1] = e[1], t63;
}
function ME(t63, e, r3) {
  return t63[0] = e, t63[1] = r3, t63;
}
function IE(t63, e, r3) {
  return t63[0] = e[0] + r3[0], t63[1] = e[1] + r3[1], t63;
}
function Pb(t63, e, r3) {
  return t63[0] = e[0] - r3[0], t63[1] = e[1] - r3[1], t63;
}
function wb(t63, e, r3) {
  return t63[0] = e[0] * r3[0], t63[1] = e[1] * r3[1], t63;
}
function Tb(t63, e, r3) {
  return t63[0] = e[0] / r3[0], t63[1] = e[1] / r3[1], t63;
}
function AE(t63, e) {
  return t63[0] = Math.ceil(e[0]), t63[1] = Math.ceil(e[1]), t63;
}
function EE(t63, e) {
  return t63[0] = Math.floor(e[0]), t63[1] = Math.floor(e[1]), t63;
}
function LE(t63, e, r3) {
  return t63[0] = Math.min(e[0], r3[0]), t63[1] = Math.min(e[1], r3[1]), t63;
}
function DE(t63, e, r3) {
  return t63[0] = Math.max(e[0], r3[0]), t63[1] = Math.max(e[1], r3[1]), t63;
}
function RE(t63, e) {
  return t63[0] = Math.round(e[0]), t63[1] = Math.round(e[1]), t63;
}
function kE(t63, e, r3) {
  return t63[0] = e[0] * r3, t63[1] = e[1] * r3, t63;
}
function FE(t63, e, r3, n) {
  return t63[0] = e[0] + r3[0] * n, t63[1] = e[1] + r3[1] * n, t63;
}
function Sb(t63, e) {
  var r3 = e[0] - t63[0], n = e[1] - t63[1];
  return Math.hypot(r3, n);
}
function Cb(t63, e) {
  var r3 = e[0] - t63[0], n = e[1] - t63[1];
  return r3 * r3 + n * n;
}
function Mb(t63) {
  var e = t63[0], r3 = t63[1];
  return Math.hypot(e, r3);
}
function Ib(t63) {
  var e = t63[0], r3 = t63[1];
  return e * e + r3 * r3;
}
function OE(t63, e) {
  return t63[0] = -e[0], t63[1] = -e[1], t63;
}
function BE(t63, e) {
  return t63[0] = 1 / e[0], t63[1] = 1 / e[1], t63;
}
function zE(t63, e) {
  var r3 = e[0], n = e[1], i = r3 * r3 + n * n;
  return i > 0 && (i = 1 / Math.sqrt(i)), t63[0] = e[0] * i, t63[1] = e[1] * i, t63;
}
function VE(t63, e) {
  return t63[0] * e[0] + t63[1] * e[1];
}
function UE(t63, e, r3) {
  var n = e[0] * r3[1] - e[1] * r3[0];
  return t63[0] = t63[1] = 0, t63[2] = n, t63;
}
function NE(t63, e, r3, n) {
  var i = e[0], o = e[1];
  return t63[0] = i + n * (r3[0] - i), t63[1] = o + n * (r3[1] - o), t63;
}
function GE(t63, e) {
  e = e || 1;
  var r3 = qt() * 2 * Math.PI;
  return t63[0] = Math.cos(r3) * e, t63[1] = Math.sin(r3) * e, t63;
}
function jE(t63, e, r3) {
  var n = e[0], i = e[1];
  return t63[0] = r3[0] * n + r3[2] * i, t63[1] = r3[1] * n + r3[3] * i, t63;
}
function HE(t63, e, r3) {
  var n = e[0], i = e[1];
  return t63[0] = r3[0] * n + r3[2] * i + r3[4], t63[1] = r3[1] * n + r3[3] * i + r3[5], t63;
}
function XE(t63, e, r3) {
  var n = e[0], i = e[1];
  return t63[0] = r3[0] * n + r3[3] * i + r3[6], t63[1] = r3[1] * n + r3[4] * i + r3[7], t63;
}
function ZE(t63, e, r3) {
  var n = e[0], i = e[1];
  return t63[0] = r3[0] * n + r3[4] * i + r3[12], t63[1] = r3[1] * n + r3[5] * i + r3[13], t63;
}
function qE(t63, e, r3, n) {
  var i = e[0] - r3[0], o = e[1] - r3[1], a = Math.sin(n), s3 = Math.cos(n);
  return t63[0] = i * s3 - o * a + r3[0], t63[1] = i * a + o * s3 + r3[1], t63;
}
function YE(t63, e) {
  var r3 = t63[0], n = t63[1], i = e[0], o = e[1], a = Math.sqrt(r3 * r3 + n * n) * Math.sqrt(i * i + o * o), s3 = a && (r3 * i + n * o) / a;
  return Math.acos(Math.min(Math.max(s3, -1), 1));
}
function WE(t63) {
  return t63[0] = 0, t63[1] = 0, t63;
}
function $E(t63) {
  return "vec2(" + t63[0] + ", " + t63[1] + ")";
}
function KE(t63, e) {
  return t63[0] === e[0] && t63[1] === e[1];
}
function JE(t63, e) {
  var r3 = t63[0], n = t63[1], i = e[0], o = e[1];
  return Math.abs(r3 - i) <= ue * Math.max(1, Math.abs(r3), Math.abs(i)) && Math.abs(n - o) <= ue * Math.max(1, Math.abs(n), Math.abs(o));
}
var QE = Mb;
var eL = Pb;
var tL = wb;
var rL = Tb;
var nL = Sb;
var iL = Cb;
var oL = Ib;
var aL = (function() {
  var t63 = vb();
  return function(e, r3, n, i, o, a) {
    var s3, l;
    for (r3 || (r3 = 2), n || (n = 0), i ? l = Math.min(i * r3 + n, e.length) : l = e.length, s3 = n; s3 < l; s3 += r3) t63[0] = e[s3], t63[1] = e[s3 + 1], o(t63, t63, a), e[s3] = t63[0], e[s3 + 1] = t63[1];
    return e;
  };
})();
$i();
$i();
function yt(t63, e, r3) {
  return e * (8192 / (t63.tileSize * Math.pow(2, r3 - t63.tileID.overscaledZ)));
}
function Fo() {
  return new Float64Array(4);
}
function tt() {
  return new Float64Array(3);
}
function Hr() {
  return new Float64Array(16);
}
function Wn() {
  let t63 = new Float64Array(16);
  return B.identity(t63), t63;
}
function nc() {
  let t63 = new Float32Array(16);
  return B.identity(t63), t63;
}
function Yt(t63, e, r3, n, i = false) {
  if (!r3[0] && !r3[1]) return [0, 0];
  let o = i ? n === "map" ? -t63.bearingInRadians : 0 : n === "viewport" ? t63.bearingInRadians : 0;
  if (o) {
    let a = Math.sin(o), s3 = Math.cos(o);
    r3 = [r3[0] * s3 - r3[1] * a, r3[0] * a + r3[1] * s3];
  }
  return [i ? r3[0] : yt(e, r3[0], t63.zoom), i ? r3[1] : yt(e, r3[1], t63.zoom)];
}
function ts(t63, e) {
  return t63[0] * e[0] + t63[1] * e[1] + t63[2] * e[2] + t63[3];
}
function mr(t63, e, r3) {
  let n = vn.determinant([t63[0], t63[1], t63[2], e[0], e[1], e[2], r3[0], r3[1], r3[2]]);
  if (n === 0) return null;
  let i = V.cross([], [e[0], e[1], e[2]], [r3[0], r3[1], r3[2]]), o = V.cross([], [r3[0], r3[1], r3[2]], [t63[0], t63[1], t63[2]]), a = V.cross([], [t63[0], t63[1], t63[2]], [e[0], e[1], e[2]]), s3 = V.scale([], i, -t63[3]);
  return V.add(s3, s3, V.scale([], o, -e[3])), V.add(s3, s3, V.scale([], a, -r3[3])), V.scale(s3, s3, 1 / n), s3;
}
function Rb(t63, e, r3) {
  let n = t63[0] * r3[0] + t63[1] * r3[1] + t63[2] * r3[2], i = e[0] * r3[0] + e[1] * r3[1] + e[2] * r3[2];
  return i === 0 ? null : (-n - r3[3]) / i;
}
function rs(t63, e, r3, n) {
  let i = Math.sqrt(t63 * t63 + e * e), o = Math.sqrt(r3 * r3 + n * n);
  t63 /= i, e /= i, r3 /= o, n /= o;
  let a = t63 * r3 + e * n, s3 = Math.acos(a);
  return -e * r3 + t63 * n > 0 ? s3 : -s3;
}
function Ut(t63, e) {
  let r3 = Ni(t63, 360), n = Ni(e, 360), i = n - r3, o = n > r3 ? i - 360 : i + 360;
  return Math.abs(i) < Math.abs(o) ? i : o;
}
function ns(t63, e) {
  let r3 = Ni(t63, Math.PI * 2), n = Ni(e, Math.PI * 2);
  return Math.min(Math.abs(r3 - n), Math.abs(r3 - n + Math.PI * 2), Math.abs(r3 - n - Math.PI * 2));
}
function Ni(t63, e) {
  return (t63 % e + e) % e;
}
function Oo(t63, e, r3, n, i) {
  let o = ce((t63 - e) / (r3 - e), 0, 1);
  return Pn(n, i, o);
}
function Pn(t63, e, r3) {
  return t63 * (1 - r3) + e * r3;
}
function kb(t63) {
  let e = 1 / 0, r3 = 1 / 0, n = -1 / 0, i = -1 / 0;
  for (let o of t63) e = Math.min(e, o.x), r3 = Math.min(r3, o.y), n = Math.max(n, o.x), i = Math.max(i, o.y);
  return [e, r3, n, i];
}
function ic(t63) {
  if (t63 <= 0) return 0;
  if (t63 >= 1) return 1;
  let e = t63 * t63, r3 = e * t63;
  return 4 * (t63 < 0.5 ? r3 : 3 * (t63 - e) + r3 - 0.75);
}
function is(t63, e, r3, n) {
  let i = new Db.default(t63, e, r3, n);
  return (o) => i.solve(o);
}
var os = is(0.25, 0.1, 0.25, 1);
function ce(t63, e, r3) {
  return Math.min(r3, Math.max(e, t63));
}
function Rr(t63, e, r3) {
  let n = r3 - e, i = ((t63 - e) % n + n) % n + e;
  return i === e ? r3 : i;
}
function Fb(t63, e) {
  let r3 = [];
  for (let n in t63) n in e || r3.push(n);
  return r3;
}
function Z(t63, ...e) {
  for (let r3 of e) for (let n in r3) t63[n] = r3[n];
  return t63;
}
function nn(t63, e) {
  let r3 = {};
  for (let n = 0; n < e.length; n++) {
    let i = e[n];
    i in t63 && (r3[i] = t63[i]);
  }
  return r3;
}
var sL = 1;
function oc() {
  return sL++;
}
function Ob(t63) {
  return Math.log(t63) / Math.LN2 % 1 === 0;
}
function Bb(t63) {
  return t63 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t63) / Math.LN2));
}
function lt(t63) {
  return Math.pow(2, t63);
}
function rt(t63) {
  return Math.log(t63) / Math.LN2;
}
function as(t63, e, r3) {
  let n = {};
  for (let i in t63) n[i] = e.call(r3 || this, t63[i], i, t63);
  return n;
}
function ac(t63, e, r3) {
  let n = {};
  for (let i in t63) e.call(r3 || this, t63[i], i, t63) && (n[i] = t63[i]);
  return n;
}
function Dr(t63, e) {
  if (Array.isArray(t63)) {
    if (!Array.isArray(e) || t63.length !== e.length) return false;
    for (let r3 = 0; r3 < t63.length; r3++) if (!Dr(t63[r3], e[r3])) return false;
    return true;
  }
  if (typeof t63 == "object" && t63 !== null && e !== null) {
    if (typeof e != "object" || Object.keys(t63).length !== Object.keys(e).length) return false;
    for (let n in t63) if (!Dr(t63[n], e[n])) return false;
    return true;
  }
  return t63 === e;
}
function kt2(t63) {
  return Array.isArray(t63) ? t63.map(kt2) : typeof t63 == "object" && t63 ? as(t63, kt2) : t63;
}
var Ab = {};
function ve2(t63) {
  Ab[t63] || (typeof console < "u" && console.warn(t63), Ab[t63] = true);
}
function wn(t63, e, r3) {
  return (r3.y - t63.y) * (e.x - t63.x) > (e.y - t63.y) * (r3.x - t63.x);
}
function zb(t63, e, r3, n) {
  let i = e.y - t63.y, o = e.x - t63.x, a = n.y - r3.y, s3 = n.x - r3.x, l = a * o - s3 * i;
  if (l === 0) return null;
  let u3 = t63.y - r3.y, c = t63.x - r3.x, p = (s3 * u3 - a * c) / l;
  return new Lb.default(t63.x + p * o, t63.y + p * i);
}
function Vb([t63, e, r3]) {
  return e += 90, e *= Math.PI / 180, r3 *= Math.PI / 180, { x: t63 * Math.cos(e) * Math.sin(r3), y: t63 * Math.sin(e) * Math.sin(r3), z: t63 * Math.cos(r3) };
}
function Tn(t63) {
  return typeof WorkerGlobalScope < "u" && typeof t63 < "u" && t63 instanceof WorkerGlobalScope;
}
function Ub(t63) {
  let e = /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, r3 = {};
  if (t63.replace(e, (n, i, o, a) => {
    let s3 = o || a;
    return r3[i] = s3 ? s3.toLowerCase() : true, "";
  }), r3["max-age"]) {
    let n = parseInt(r3["max-age"], 10);
    isNaN(n) ? delete r3["max-age"] : r3["max-age"] = n;
  }
  return r3;
}
var Qm = null;
function Nb(t63) {
  if (Qm == null) {
    let e = t63.navigator ? t63.navigator.userAgent : null;
    Qm = !!t63.safari || !!(e && (/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
  }
  return Qm;
}
function Wt(t63) {
  return typeof ImageBitmap < "u" && t63 instanceof ImageBitmap;
}
var Gb = async (t63) => {
  if (t63.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
  let e = new Blob([new Uint8Array(t63)], { type: "image/png" });
  try {
    return createImageBitmap(e);
  } catch (r3) {
    throw new Error(`Could not load image because of ${r3.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
  }
};
var Eb = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
var jb = (t63) => new Promise((e, r3) => {
  let n = new Image();
  n.onload = () => {
    e(n), URL.revokeObjectURL(n.src), n.onload = null, window.requestAnimationFrame(() => {
      n.src = Eb;
    });
  }, n.onerror = () => r3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
  let i = new Blob([new Uint8Array(t63)], { type: "image/png" });
  n.src = t63.byteLength ? URL.createObjectURL(i) : Eb;
});
function lL(t63, e, r3, n, i) {
  let o = Math.max(-e, 0) * 4, l = (Math.max(0, r3) - r3) * n * 4 + o, u3 = n * 4, c = Math.max(0, e), p = Math.max(0, r3), h = Math.min(t63.width, e + n), f = Math.min(t63.height, r3 + i);
  return { rect: { x: c, y: p, width: h - c, height: f - p }, layout: [{ offset: l, stride: u3 }] };
}
async function Hb(t63, e, r3, n, i) {
  if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
  let o = new VideoFrame(t63, { timestamp: 0 });
  try {
    let a = o?.format;
    if (!a || !(a.startsWith("BGR") || a.startsWith("RGB"))) throw new Error(`Unrecognized format ${a}`);
    let s3 = a.startsWith("BGR"), l = new Uint8ClampedArray(n * i * 4);
    if (await o.copyTo(l, lL(t63, e, r3, n, i)), s3) for (let u3 = 0; u3 < l.length; u3 += 4) {
      let c = l[u3];
      l[u3] = l[u3 + 2], l[u3 + 2] = c;
    }
    return l;
  } finally {
    o.close();
  }
}
function ss(t63, e, r3, n) {
  return t63.addEventListener(e, r3, n), { unsubscribe: () => {
    t63.removeEventListener(e, r3, n);
  } };
}
function Ve(t63) {
  return t63 * Math.PI / 180;
}
function Ui(t63) {
  return t63 / Math.PI * 180;
}
function sc(t63, e) {
  return t63.roll == e.roll && t63.pitch == e.pitch && t63.bearing == e.bearing;
}
function Xb(t63) {
  let e = new Float64Array(9);
  vn.fromQuat(e, t63);
  let r3 = Ui(-Math.asin(ce(e[2], -1, 1))), n, i;
  return Math.hypot(e[5], e[8]) < 1e-3 ? (n = 0, i = -Ui(Math.atan2(e[3], e[4]))) : (n = Ui(e[5] === 0 && e[8] === 0 ? 0 : Math.atan2(e[5], e[8])), i = Ui(e[1] === 0 && e[0] === 0 ? 0 : Math.atan2(e[1], e[0]))), { roll: n, pitch: r3 + 90, bearing: i };
}
function ed(t63, e, r3) {
  let n = wt.fromValues(e.x - r3.x, e.y - r3.y), i = wt.fromValues(t63.x - r3.x, t63.y - r3.y), o = n[0] * i[1] - n[1] * i[0], a = Math.atan2(o, wt.dot(n, i));
  return Ui(a);
}
function td(t63, e, r3) {
  let n = new Float64Array(4);
  return Yn.fromEuler(n, t63, e - 90, r3), n;
}
var Gi = 25;
var ls = 0;
var Nt2 = 85.051129;
var Zb = { touchstart: true, touchmove: true, touchmoveWindow: true, touchend: true, touchcancel: true };
var qb = { dblclick: true, click: true, mouseover: true, mouseout: true, mousedown: true, mousemove: true, mousemoveWindow: true, mouseup: true, mouseupWindow: true, contextmenu: true, wheel: true };
function Yb(t63, e) {
  return Zb[e] && "touches" in t63;
}
function Wb(t63, e) {
  return qb[e] && (t63 instanceof MouseEvent || t63 instanceof WheelEvent);
}
function $b(t63) {
  return Zb[t63] || qb[t63];
}
$i();
$i();
var Kb = "AbortError";
function Jb(t63) {
  return t63.message === Kb;
}
function ji() {
  return new Error(Kb);
}
var uL = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date);
var lc;
var rd;
var ae = { now: uL, frame(t63, e, r3) {
  let n = requestAnimationFrame((o) => {
    i(), e(o);
  }), { unsubscribe: i } = ss(t63.signal, "abort", () => {
    i(), cancelAnimationFrame(n), r3(ji());
  }, false);
}, frameAsync(t63) {
  return new Promise((e, r3) => {
    this.frame(t63, e, r3);
  });
}, getImageData(t63, e = 0) {
  return this.getImageCanvasContext(t63).getImageData(-e, -e, t63.width + 2 * e, t63.height + 2 * e);
}, getImageCanvasContext(t63) {
  let e = window.document.createElement("canvas"), r3 = e.getContext("2d", { willReadFrequently: true });
  if (!r3) throw new Error("failed to create canvas 2d context");
  return e.width = t63.width, e.height = t63.height, r3.drawImage(t63, 0, 0, t63.width, t63.height), r3;
}, resolveURL(t63) {
  return lc || (lc = document.createElement("a")), lc.href = t63, lc.href;
}, hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
  return matchMedia ? (rd == null && (rd = matchMedia("(prefers-reduced-motion: reduce)")), rd.matches) : false;
} };
$i();
var Qb = s(fe(), 1);
var Be = class Be2 {
  static testProp(e) {
    if (!Be2.docStyle) return e[0];
    for (let r3 = 0; r3 < e.length; r3++) if (e[r3] in Be2.docStyle) return e[r3];
    return e[0];
  }
  static create(e, r3, n) {
    let i = window.document.createElement(e);
    return r3 !== void 0 && (i.className = r3), n && n.appendChild(i), i;
  }
  static createNS(e, r3) {
    return window.document.createElementNS(e, r3);
  }
  static disableDrag() {
    Be2.docStyle && Be2.selectProp && (Be2.userSelect = Be2.docStyle[Be2.selectProp], Be2.docStyle[Be2.selectProp] = "none");
  }
  static enableDrag() {
    Be2.docStyle && Be2.selectProp && (Be2.docStyle[Be2.selectProp] = Be2.userSelect);
  }
  static setTransform(e, r3) {
    e.style[Be2.transformProp] = r3;
  }
  static addEventListener(e, r3, n, i = {}) {
    "passive" in i ? e.addEventListener(r3, n, i) : e.addEventListener(r3, n, i.capture);
  }
  static removeEventListener(e, r3, n, i = {}) {
    "passive" in i ? e.removeEventListener(r3, n, i) : e.removeEventListener(r3, n, i.capture);
  }
  static suppressClickInternal(e) {
    e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", Be2.suppressClickInternal, true);
  }
  static suppressClick() {
    window.addEventListener("click", Be2.suppressClickInternal, true), window.setTimeout(() => {
      window.removeEventListener("click", Be2.suppressClickInternal, true);
    }, 0);
  }
  static getScale(e) {
    let r3 = e.getBoundingClientRect();
    return { x: r3.width / e.offsetWidth || 1, y: r3.height / e.offsetHeight || 1, boundingClientRect: r3 };
  }
  static getPoint(e, r3, n) {
    let i = r3.boundingClientRect;
    return new Qb.default((n.clientX - i.left) / r3.x - e.clientLeft, (n.clientY - i.top) / r3.y - e.clientTop);
  }
  static mousePos(e, r3) {
    let n = Be2.getScale(e);
    return Be2.getPoint(e, n, r3);
  }
  static touchPos(e, r3) {
    let n = [], i = Be2.getScale(e);
    for (let o = 0; o < r3.length; o++) n.push(Be2.getPoint(e, i, r3[o]));
    return n;
  }
  static mouseButton(e) {
    return e.button;
  }
  static remove(e) {
    e.parentNode && e.parentNode.removeChild(e);
  }
  static sanitize(e) {
    let i = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"), o = i.querySelectorAll("script");
    for (let a of o) a.remove();
    return Be2.clean(i), i.innerHTML;
  }
  static isPossiblyDangerous(e, r3) {
    let n = r3.replace(/\s+/g, "").toLowerCase();
    if (["src", "href", "xlink:href"].includes(e) && (n.includes("javascript:") || n.includes("data:")) || e.startsWith("on")) return true;
  }
  static clean(e) {
    let r3 = e.children;
    for (let n of r3) Be2.removeAttributes(n), Be2.clean(n);
  }
  static removeAttributes(e) {
    for (let { name: r3, value: n } of e.attributes) Be2.isPossiblyDangerous(r3, n) && e.removeAttribute(r3);
  }
};
Be.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, Be.selectProp = Be.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), Be.transformProp = Be.testProp(["transform", "WebkitTransform"]);
var ie = Be;
$i();
$i();
$i();
var $t = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
function uc(t63) {
  return $t.REGISTERED_PROTOCOLS[t63.substring(0, t63.indexOf("://"))];
}
$i();
var cc = "global-dispatcher";
var $n = class extends Error {
  constructor(e, r3, n, i) {
    super(`AJAXError: ${r3} (${e}): ${n}`), this.status = e, this.statusText = r3, this.url = n, this.body = i;
  }
};
var pc = () => Tn(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href;
var cL = (t63) => /^file:/.test(t63) || /^file:/.test(pc()) && !/^\w+:/.test(t63);
async function pL(t63, e) {
  let r3 = new Request(t63.url, { method: t63.method || "GET", body: t63.body, credentials: t63.credentials, headers: t63.headers, cache: t63.cache, referrer: pc(), signal: e.signal });
  t63.type === "json" && !r3.headers.has("Accept") && r3.headers.set("Accept", "application/json");
  let n;
  try {
    n = await fetch(r3);
  } catch (a) {
    throw new $n(0, a.message, t63.url, new Blob());
  }
  if (!n.ok) {
    let a = await n.blob();
    throw new $n(n.status, n.statusText, t63.url, a);
  }
  let i;
  t63.type === "arrayBuffer" || t63.type === "image" ? i = n.arrayBuffer() : t63.type === "json" ? i = n.json() : i = n.text();
  let o = await i;
  if (e.signal.aborted) throw ji();
  return { data: o, cacheControl: n.headers.get("Cache-Control"), expires: n.headers.get("Expires") };
}
function hL(t63, e) {
  return new Promise((r3, n) => {
    let i = new XMLHttpRequest();
    i.open(t63.method || "GET", t63.url, true), (t63.type === "arrayBuffer" || t63.type === "image") && (i.responseType = "arraybuffer");
    for (let o in t63.headers) i.setRequestHeader(o, t63.headers[o]);
    t63.type === "json" && (i.responseType = "text", t63.headers?.Accept || i.setRequestHeader("Accept", "application/json")), i.withCredentials = t63.credentials === "include", i.onerror = () => {
      n(new Error(i.statusText));
    }, i.onload = () => {
      if (!e.signal.aborted) if ((i.status >= 200 && i.status < 300 || i.status === 0) && i.response !== null) {
        let o = i.response;
        if (t63.type === "json") try {
          o = JSON.parse(i.response);
        } catch (a) {
          n(a);
          return;
        }
        r3({ data: o, cacheControl: i.getResponseHeader("Cache-Control"), expires: i.getResponseHeader("Expires") });
      } else {
        let o = new Blob([i.response], { type: i.getResponseHeader("Content-Type") });
        n(new $n(i.status, i.statusText, t63.url, o));
      }
    }, e.signal.addEventListener("abort", () => {
      i.abort(), n(ji());
    }), i.send(t63.body);
  });
}
var Bo = function(t63, e) {
  if (/:\/\//.test(t63.url) && !/^https?:|^file:/.test(t63.url)) {
    let r3 = uc(t63.url);
    if (r3) return r3(t63, e);
    if (Tn(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: t63, targetMapId: cc }, e);
  }
  if (!cL(t63.url)) {
    if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return pL(t63, e);
    if (Tn(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: t63, mustQueue: true, targetMapId: cc }, e);
  }
  return hL(t63, e);
};
var Kn = (t63, e) => Bo(Z(t63, { type: "json" }), e);
var e_ = (t63, e) => Bo(Z(t63, { type: "arrayBuffer" }), e);
function nd(t63) {
  if (!t63 || t63.indexOf("://") <= 0 || t63.indexOf("data:image/") === 0 || t63.indexOf("blob:") === 0) return true;
  let e = new URL(t63), r3 = window.location;
  return e.protocol === r3.protocol && e.host === r3.host;
}
var t_ = (t63) => {
  let e = window.document.createElement("video");
  return e.muted = true, new Promise((r3) => {
    e.onloadstart = () => {
      r3(e);
    };
    for (let n of t63) {
      let i = window.document.createElement("source");
      nd(n) || (e.crossOrigin = "Anonymous"), i.src = n, e.appendChild(i);
    }
  });
};
$i();
$i();
var cs = { supported: false, testSupport: fL };
var us;
var id = false;
var zo;
var r_ = false;
typeof document < "u" && (zo = document.createElement("img"), zo.onload = () => {
  us && n_(us), us = null, r_ = true;
}, zo.onerror = () => {
  id = true, us = null;
}, zo.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
function fL(t63) {
  id || !zo || (r_ ? n_(t63) : us = t63);
}
function n_(t63) {
  let e = t63.createTexture();
  t63.bindTexture(t63.TEXTURE_2D, e);
  try {
    if (t63.texImage2D(t63.TEXTURE_2D, 0, t63.RGBA, t63.RGBA, t63.UNSIGNED_BYTE, zo), t63.isContextLost()) return;
    cs.supported = true;
  } catch {
  }
  t63.deleteTexture(e), id = true;
}
var Gt;
((f) => {
  let t63, e, r3, n;
  f.resetRequestQueue = () => {
    t63 = [], e = 0, r3 = 0, n = {};
  }, f.addThrottleControl = (d) => {
    let g = r3++;
    return n[g] = d, g;
  }, f.removeThrottleControl = (d) => {
    delete n[d], p();
  };
  let s3 = () => {
    for (let d of Object.keys(n)) if (n[d]()) return true;
    return false;
  };
  f.getImage = (d, g, x = true) => new Promise((b, v3) => {
    cs.supported && (d.headers || (d.headers = {}), d.headers.accept = "image/webp,*/*"), Z(d, { type: "image" });
    let P = { abortController: g, requestParameters: d, supportImageRefresh: x, state: "queued", onError: (w3) => {
      v3(w3);
    }, onSuccess: (w3) => {
      b(w3);
    } };
    t63.push(P), p();
  });
  let u3 = (d) => typeof createImageBitmap == "function" ? Gb(d) : jb(d), c = async (d) => {
    d.state = "running";
    let { requestParameters: g, supportImageRefresh: x, onError: b, onSuccess: v3, abortController: P } = d, w3 = x === false && !Tn(self) && !uc(g.url) && (!g.headers || Object.keys(g.headers).reduce((S, C3) => S && C3 === "accept", true));
    e++;
    let T = w3 ? h(g, P) : Bo(g, P);
    try {
      let S = await T;
      if (delete d.abortController, d.state = "completed", S.data instanceof HTMLImageElement || Wt(S.data)) v3(S);
      else if (S.data) {
        let C3 = await u3(S.data);
        v3({ data: C3, cacheControl: S.cacheControl, expires: S.expires });
      }
    } catch (S) {
      delete d.abortController, b(S);
    } finally {
      e--, p();
    }
  }, p = () => {
    let d = s3() ? $t.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : $t.MAX_PARALLEL_IMAGE_REQUESTS;
    for (let g = e; g < d && t63.length > 0; g++) {
      let x = t63.shift();
      if (x.abortController.signal.aborted) {
        g--;
        continue;
      }
      c(x);
    }
  }, h = (d, g) => new Promise((x, b) => {
    let v3 = new Image(), P = d.url, w3 = d.credentials;
    w3 && w3 === "include" ? v3.crossOrigin = "use-credentials" : (w3 && w3 === "same-origin" || !nd(P)) && (v3.crossOrigin = "anonymous"), g.signal.addEventListener("abort", () => {
      v3.src = "", b(ji());
    }), v3.fetchPriority = "high", v3.onload = () => {
      v3.onerror = v3.onload = null, x({ data: v3 });
    }, v3.onerror = () => {
      v3.onerror = v3.onload = null, !g.signal.aborted && b(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
    }, v3.src = P;
  });
})(Gt || (Gt = {}));
Gt.resetRequestQueue();
$i();
var hc = class {
  constructor(e) {
    this._transformRequestFn = e;
  }
  transformRequest(e, r3) {
    return this._transformRequestFn ? this._transformRequestFn(e, r3) || { url: e } : { url: e };
  }
  setTransformRequest(e) {
    this._transformRequestFn = e;
  }
};
$i();
$i();
function i_(t63, e, r3) {
  r3[t63] && r3[t63].indexOf(e) !== -1 || (r3[t63] = r3[t63] || [], r3[t63].push(e));
}
function od(t63, e, r3) {
  if (r3 && r3[t63]) {
    let n = r3[t63].indexOf(e);
    n !== -1 && r3[t63].splice(n, 1);
  }
}
var U = class {
  constructor(e, r3 = {}) {
    Z(this, r3), this.type = e;
  }
};
var Q = class extends U {
  constructor(e, r3 = {}) {
    super("error", Z({ error: e }, r3));
  }
};
var Ee = class {
  on(e, r3) {
    return this._listeners = this._listeners || {}, i_(e, r3, this._listeners), { unsubscribe: () => {
      this.off(e, r3);
    } };
  }
  off(e, r3) {
    return od(e, r3, this._listeners), od(e, r3, this._oneTimeListeners), this;
  }
  once(e, r3) {
    return r3 ? (this._oneTimeListeners = this._oneTimeListeners || {}, i_(e, r3, this._oneTimeListeners), this) : new Promise((n) => this.once(e, n));
  }
  fire(e, r3) {
    typeof e == "string" && (e = new U(e, r3 || {}));
    let n = e.type;
    if (this.listens(n)) {
      e.target = this;
      let i = this._listeners && this._listeners[n] ? this._listeners[n].slice() : [];
      for (let s3 of i) s3.call(this, e);
      let o = this._oneTimeListeners && this._oneTimeListeners[n] ? this._oneTimeListeners[n].slice() : [];
      for (let s3 of o) od(n, s3, this._oneTimeListeners), s3.call(this, e);
      let a = this._eventedParent;
      a && (Z(e, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), a.fire(e));
    } else e instanceof Q && console.error(e.error);
    return this;
  }
  listens(e) {
    return this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e);
  }
  setEventedParent(e, r3) {
    return this._eventedParent = e, this._eventedParentData = r3, this;
  }
};
$i();
$i();
$i();
$i();
var mL = 8;
var dL = { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } };
var yL = { "*": { type: "source" } };
var gL = ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"];
var xL = { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } };
var bL = { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } };
var _L = { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } };
var vL = { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } };
var PL = { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } };
var wL = { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } };
var TL = { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } };
var SL = ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"];
var CL = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var ML = { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var IL = { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var AL = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var EL = { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var LL = { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var DL = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var RL = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var kL = { type: "array", value: "*" };
var FL = { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } };
var OL = { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } };
var BL = { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 };
var zL = { type: "array", value: "*", minimum: 1 };
var VL = { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } };
var UL = { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } };
var NL = { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } };
var GL = { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: false, expression: { interpolated: true, parameters: ["zoom"] } } };
var jL = ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"];
var HL = { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } };
var XL = { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } };
var ZL = { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } };
var qL = { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } };
var YL = { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } };
var WL = { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } };
var $L = { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } };
var KL = { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } };
var JL = { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } };
var QL = { "*": { type: "string" } };
var D = { $version: mL, $root: dL, sources: yL, source: gL, source_vector: xL, source_raster: bL, source_raster_dem: _L, source_geojson: vL, source_video: PL, source_image: wL, layer: TL, layout: SL, layout_background: CL, layout_fill: ML, layout_circle: IL, layout_heatmap: AL, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: EL, layout_symbol: LL, layout_raster: DL, layout_hillshade: RL, "layout_color-relief": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: kL, filter_operator: FL, geometry_type: OL, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: BL, expression: zL, light: VL, sky: UL, terrain: NL, projection: GL, paint: jL, paint_fill: HL, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: XL, paint_circle: ZL, paint_heatmap: qL, paint_symbol: YL, paint_raster: WL, paint_hillshade: $L, "paint_color-relief": { "color-relief-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "color-relief-color": { type: "color", transition: false, expression: { interpolated: true, parameters: ["elevation"] }, "property-type": "color-ramp" } }, paint_background: KL, transition: JL, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: QL };
var eD = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
function tD(t63, e) {
  let r3 = {};
  for (let n in t63) n !== "ref" && (r3[n] = t63[n]);
  return eD.forEach((n) => {
    n in e && (r3[n] = e[n]);
  }), r3;
}
function Dd(t63) {
  t63 = t63.slice();
  let e = /* @__PURE__ */ Object.create(null);
  for (let r3 = 0; r3 < t63.length; r3++) e[t63[r3].id] = t63[r3];
  for (let r3 = 0; r3 < t63.length; r3++) "ref" in t63[r3] && (t63[r3] = tD(t63[r3], e[t63[r3].ref]));
  return t63;
}
function Ge(t63, e) {
  if (Array.isArray(t63)) {
    if (!Array.isArray(e) || t63.length !== e.length) return false;
    for (let r3 = 0; r3 < t63.length; r3++) if (!Ge(t63[r3], e[r3])) return false;
    return true;
  }
  if (typeof t63 == "object" && t63 !== null && e !== null) {
    if (typeof e != "object" || Object.keys(t63).length !== Object.keys(e).length) return false;
    for (let n in t63) if (!Ge(t63[n], e[n])) return false;
    return true;
  }
  return t63 === e;
}
function kr(t63, e) {
  t63.push(e);
}
function M_(t63, e, r3) {
  kr(r3, { command: "addSource", args: [t63, e[t63]] });
}
function I_(t63, e, r3) {
  kr(e, { command: "removeSource", args: [t63] }), r3[t63] = true;
}
function rD(t63, e, r3, n) {
  I_(t63, r3, n), M_(t63, e, r3);
}
function nD(t63, e, r3) {
  let n;
  for (n in t63[r3]) if (Object.prototype.hasOwnProperty.call(t63[r3], n) && n !== "data" && !Ge(t63[r3][n], e[r3][n])) return false;
  for (n in e[r3]) if (Object.prototype.hasOwnProperty.call(e[r3], n) && n !== "data" && !Ge(t63[r3][n], e[r3][n])) return false;
  return true;
}
function iD(t63, e, r3, n) {
  t63 = t63 || {}, e = e || {};
  let i;
  for (i in t63) Object.prototype.hasOwnProperty.call(t63, i) && (Object.prototype.hasOwnProperty.call(e, i) || I_(i, r3, n));
  for (i in e) Object.prototype.hasOwnProperty.call(e, i) && (Object.prototype.hasOwnProperty.call(t63, i) ? Ge(t63[i], e[i]) || (t63[i].type === "geojson" && e[i].type === "geojson" && nD(t63, e, i) ? kr(r3, { command: "setGeoJSONSourceData", args: [i, e[i].data] }) : rD(i, e, r3, n)) : M_(i, e, r3));
}
function fc(t63, e, r3, n, i, o) {
  t63 = t63 || {}, e = e || {};
  for (let a in t63) Object.prototype.hasOwnProperty.call(t63, a) && (Ge(t63[a], e[a]) || r3.push({ command: o, args: [n, a, e[a], i] }));
  for (let a in e) !Object.prototype.hasOwnProperty.call(e, a) || Object.prototype.hasOwnProperty.call(t63, a) || Ge(t63[a], e[a]) || r3.push({ command: o, args: [n, a, e[a], i] });
}
function o_(t63) {
  return t63.id;
}
function a_(t63, e) {
  return t63[e.id] = e, t63;
}
function oD(t63, e, r3) {
  t63 = t63 || [], e = e || [];
  let n = t63.map(o_), i = e.map(o_), o = t63.reduce(a_, {}), a = e.reduce(a_, {}), s3 = n.slice(), l = /* @__PURE__ */ Object.create(null), u3, c, p, h, f;
  for (let d = 0, g = 0; d < n.length; d++) u3 = n[d], Object.prototype.hasOwnProperty.call(a, u3) ? g++ : (kr(r3, { command: "removeLayer", args: [u3] }), s3.splice(s3.indexOf(u3, g), 1));
  for (let d = 0, g = 0; d < i.length; d++) u3 = i[i.length - 1 - d], s3[s3.length - 1 - d] !== u3 && (Object.prototype.hasOwnProperty.call(o, u3) ? (kr(r3, { command: "removeLayer", args: [u3] }), s3.splice(s3.lastIndexOf(u3, s3.length - g), 1)) : g++, h = s3[s3.length - d], kr(r3, { command: "addLayer", args: [a[u3], h] }), s3.splice(s3.length - d, 0, u3), l[u3] = true);
  for (let d = 0; d < i.length; d++) if (u3 = i[d], c = o[u3], p = a[u3], !(l[u3] || Ge(c, p))) {
    if (!Ge(c.source, p.source) || !Ge(c["source-layer"], p["source-layer"]) || !Ge(c.type, p.type)) {
      kr(r3, { command: "removeLayer", args: [u3] }), h = s3[s3.lastIndexOf(u3) + 1], kr(r3, { command: "addLayer", args: [p, h] });
      continue;
    }
    fc(c.layout, p.layout, r3, u3, null, "setLayoutProperty"), fc(c.paint, p.paint, r3, u3, null, "setPaintProperty"), Ge(c.filter, p.filter) || kr(r3, { command: "setFilter", args: [u3, p.filter] }), (!Ge(c.minzoom, p.minzoom) || !Ge(c.maxzoom, p.maxzoom)) && kr(r3, { command: "setLayerZoomRange", args: [u3, p.minzoom, p.maxzoom] });
    for (f in c) Object.prototype.hasOwnProperty.call(c, f) && (f === "layout" || f === "paint" || f === "filter" || f === "metadata" || f === "minzoom" || f === "maxzoom" || (f.indexOf("paint.") === 0 ? fc(c[f], p[f], r3, u3, f.slice(6), "setPaintProperty") : Ge(c[f], p[f]) || kr(r3, { command: "setLayerProperty", args: [u3, f, p[f]] })));
    for (f in p) !Object.prototype.hasOwnProperty.call(p, f) || Object.prototype.hasOwnProperty.call(c, f) || f === "layout" || f === "paint" || f === "filter" || f === "metadata" || f === "minzoom" || f === "maxzoom" || (f.indexOf("paint.") === 0 ? fc(c[f], p[f], r3, u3, f.slice(6), "setPaintProperty") : Ge(c[f], p[f]) || kr(r3, { command: "setLayerProperty", args: [u3, f, p[f]] }));
  }
}
function A_(t63, e) {
  if (!t63) return [{ command: "setStyle", args: [e] }];
  let r3 = [];
  try {
    if (!Ge(t63.version, e.version)) return [{ command: "setStyle", args: [e] }];
    Ge(t63.center, e.center) || r3.push({ command: "setCenter", args: [e.center] }), Ge(t63.state, e.state) || r3.push({ command: "setGlobalState", args: [e.state] }), Ge(t63.centerAltitude, e.centerAltitude) || r3.push({ command: "setCenterAltitude", args: [e.centerAltitude] }), Ge(t63.zoom, e.zoom) || r3.push({ command: "setZoom", args: [e.zoom] }), Ge(t63.bearing, e.bearing) || r3.push({ command: "setBearing", args: [e.bearing] }), Ge(t63.pitch, e.pitch) || r3.push({ command: "setPitch", args: [e.pitch] }), Ge(t63.roll, e.roll) || r3.push({ command: "setRoll", args: [e.roll] }), Ge(t63.sprite, e.sprite) || r3.push({ command: "setSprite", args: [e.sprite] }), Ge(t63.glyphs, e.glyphs) || r3.push({ command: "setGlyphs", args: [e.glyphs] }), Ge(t63.transition, e.transition) || r3.push({ command: "setTransition", args: [e.transition] }), Ge(t63.light, e.light) || r3.push({ command: "setLight", args: [e.light] }), Ge(t63.terrain, e.terrain) || r3.push({ command: "setTerrain", args: [e.terrain] }), Ge(t63.sky, e.sky) || r3.push({ command: "setSky", args: [e.sky] }), Ge(t63.projection, e.projection) || r3.push({ command: "setProjection", args: [e.projection] });
    let n = {}, i = [];
    iD(t63.sources, e.sources, i, n);
    let o = [];
    t63.layers && t63.layers.forEach((a) => {
      "source" in a && n[a.source] ? r3.push({ command: "removeLayer", args: [a.id] }) : o.push(a);
    }), r3 = r3.concat(i), oD(o, e.layers, r3);
  } catch (n) {
    console.warn("Unable to compute style diff:", n), r3 = [{ command: "setStyle", args: [e] }];
  }
  return r3;
}
var G = class {
  constructor(e, r3, n, i) {
    this.message = (e ? `${e}: ` : "") + n, i && (this.identifier = i), r3 != null && r3.__line__ && (this.line = r3.__line__);
  }
};
function Go(t63, ...e) {
  for (let r3 of e) for (let n in r3) t63[n] = r3[n];
  return t63;
}
var Fr = class extends Error {
  constructor(e, r3) {
    super(r3), this.message = r3, this.key = e;
  }
};
var dd = class t3 {
  constructor(e, r3 = []) {
    this.parent = e, this.bindings = {};
    for (let [n, i] of r3) this.bindings[n] = i;
  }
  concat(e) {
    return new t3(this, e);
  }
  get(e) {
    if (this.bindings[e]) return this.bindings[e];
    if (this.parent) return this.parent.get(e);
    throw new Error(`${e} not found in scope.`);
  }
  has(e) {
    return this.bindings[e] ? true : this.parent ? this.parent.has(e) : false;
  }
};
var Zo = { kind: "null" };
var Y = { kind: "number" };
var Pe2 = { kind: "string" };
var ge = { kind: "boolean" };
var Br = { kind: "color" };
var Dc = { kind: "projectionDefinition" };
var qi = { kind: "object" };
var me = { kind: "value" };
var aD = { kind: "error" };
var Rc = { kind: "collator" };
var qo = { kind: "formatted" };
var kc = { kind: "padding" };
var ms = { kind: "colorArray" };
var Fc = { kind: "numberArray" };
var Is = { kind: "resolvedImage" };
var Oc = { kind: "variableAnchorOffsetCollection" };
function dr(t63, e) {
  return { kind: "array", itemType: t63, N: e };
}
function nt(t63) {
  if (t63.kind === "array") {
    let e = nt(t63.itemType);
    return typeof t63.N == "number" ? `array<${e}, ${t63.N}>` : t63.itemType.kind === "value" ? "array" : `array<${e}>`;
  } else return t63.kind;
}
var sD = [Zo, Y, Pe2, ge, Br, Dc, qo, qi, dr(me), kc, Fc, ms, Is, Oc];
function ds(t63, e) {
  if (e.kind === "error") return null;
  if (t63.kind === "array") {
    if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !ds(t63.itemType, e.itemType)) && (typeof t63.N != "number" || t63.N === e.N)) return null;
  } else {
    if (t63.kind === e.kind) return null;
    if (t63.kind === "value") {
      for (let r3 of sD) if (!ds(r3, e)) return null;
    }
  }
  return `Expected ${nt(t63)} but found ${nt(e)} instead.`;
}
function Rd(t63, e) {
  return e.some((r3) => r3.kind === t63.kind);
}
function Yi(t63, e) {
  return e.some((r3) => r3 === "null" ? t63 === null : r3 === "array" ? Array.isArray(t63) : r3 === "object" ? t63 && !Array.isArray(t63) && typeof t63 == "object" : r3 === typeof t63);
}
function Jn(t63, e) {
  return t63.kind === "array" && e.kind === "array" ? t63.itemType.kind === e.itemType.kind && typeof t63.N == "number" : t63.kind === e.kind;
}
var E_ = 0.96422;
var L_ = 1;
var D_ = 0.82521;
var R_ = 4 / 29;
var No = 6 / 29;
var k_ = 3 * No * No;
var lD = No * No * No;
var uD = Math.PI / 180;
var cD = 180 / Math.PI;
function F_(t63) {
  return t63 = t63 % 360, t63 < 0 && (t63 += 360), t63;
}
function O_([t63, e, r3, n]) {
  t63 = ad(t63), e = ad(e), r3 = ad(r3);
  let i, o, a = sd((0.2225045 * t63 + 0.7168786 * e + 0.0606169 * r3) / L_);
  t63 === e && e === r3 ? i = o = a : (i = sd((0.4360747 * t63 + 0.3850649 * e + 0.1430804 * r3) / E_), o = sd((0.0139322 * t63 + 0.0971045 * e + 0.7141733 * r3) / D_));
  let s3 = 116 * a - 16;
  return [s3 < 0 ? 0 : s3, 500 * (i - a), 200 * (a - o), n];
}
function ad(t63) {
  return t63 <= 0.04045 ? t63 / 12.92 : Math.pow((t63 + 0.055) / 1.055, 2.4);
}
function sd(t63) {
  return t63 > lD ? Math.pow(t63, 1 / 3) : t63 / k_ + R_;
}
function B_([t63, e, r3, n]) {
  let i = (t63 + 16) / 116, o = isNaN(e) ? i : i + e / 500, a = isNaN(r3) ? i : i - r3 / 200;
  return i = L_ * ud(i), o = E_ * ud(o), a = D_ * ud(a), [ld(3.1338561 * o - 1.6168667 * i - 0.4906146 * a), ld(-0.9787684 * o + 1.9161415 * i + 0.033454 * a), ld(0.0719453 * o - 0.2289914 * i + 1.4052427 * a), n];
}
function ld(t63) {
  return t63 = t63 <= 304e-5 ? 12.92 * t63 : 1.055 * Math.pow(t63, 1 / 2.4) - 0.055, t63 < 0 ? 0 : t63 > 1 ? 1 : t63;
}
function ud(t63) {
  return t63 > No ? t63 * t63 * t63 : k_ * (t63 - R_);
}
function pD(t63) {
  let [e, r3, n, i] = O_(t63), o = Math.sqrt(r3 * r3 + n * n);
  return [Math.round(o * 1e4) ? F_(Math.atan2(n, r3) * cD) : NaN, o, e, i];
}
function hD([t63, e, r3, n]) {
  return t63 = isNaN(t63) ? 0 : t63 * uD, B_([r3, Math.cos(t63) * e, Math.sin(t63) * e, n]);
}
function fD([t63, e, r3, n]) {
  t63 = F_(t63), e /= 100, r3 /= 100;
  function i(o) {
    let a = (o + t63 / 30) % 12, s3 = e * Math.min(r3, 1 - r3);
    return r3 - s3 * Math.max(-1, Math.min(a - 3, 9 - a, 1));
  }
  return [i(0), i(8), i(4), n];
}
var mD = Object.hasOwn || function(e, r3) {
  return Object.prototype.hasOwnProperty.call(e, r3);
};
function hs(t63, e) {
  return mD(t63, e) ? t63[e] : void 0;
}
function dD(t63) {
  if (t63 = t63.toLowerCase().trim(), t63 === "transparent") return [0, 0, 0, 0];
  let e = hs(yD, t63);
  if (e) {
    let [i, o, a] = e;
    return [i / 255, o / 255, a / 255, 1];
  }
  if (t63.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t63)) {
    let o = t63.length < 6 ? 1 : 2, a = 1;
    return [mc(t63.slice(a, a += o)), mc(t63.slice(a, a += o)), mc(t63.slice(a, a += o)), mc(t63.slice(a, a + o) || "ff")];
  }
  if (t63.startsWith("rgb")) {
    let i = /^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, o = t63.match(i);
    if (o) {
      let [a, s3, l, u3, c, p, h, f, d, g, x, b] = o, v3 = [u3 || " ", h || " ", g].join("");
      if (v3 === "  " || v3 === "  /" || v3 === ",," || v3 === ",,,") {
        let P = [l, p, d].join(""), w3 = P === "%%%" ? 100 : P === "" ? 255 : 0;
        if (w3) {
          let T = [Vo(+s3 / w3, 0, 1), Vo(+c / w3, 0, 1), Vo(+f / w3, 0, 1), x ? s_(+x, b) : 1];
          if (l_(T)) return T;
        }
      }
      return;
    }
  }
  let r3 = /^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, n = t63.match(r3);
  if (n) {
    let [i, o, a, s3, l, u3, c, p, h] = n, f = [a || " ", l || " ", c].join("");
    if (f === "  " || f === "  /" || f === ",," || f === ",,,") {
      let d = [+o, Vo(+s3, 0, 100), Vo(+u3, 0, 100), p ? s_(+p, h) : 1];
      if (l_(d)) return fD(d);
    }
  }
}
function mc(t63) {
  return parseInt(t63.padEnd(2, t63), 16) / 255;
}
function s_(t63, e) {
  return Vo(e ? t63 / 100 : t63, 0, 1);
}
function Vo(t63, e, r3) {
  return Math.min(Math.max(e, t63), r3);
}
function l_(t63) {
  return !t63.some(Number.isNaN);
}
var yD = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
function ei(t63, e, r3) {
  return t63 + r3 * (e - t63);
}
function jo(t63, e, r3) {
  return t63.map((n, i) => ei(n, e[i], r3));
}
function gD(t63) {
  return t63 === "rgb" || t63 === "hcl" || t63 === "lab";
}
var K = class t4 {
  constructor(e, r3, n, i = 1, o = true) {
    this.r = e, this.g = r3, this.b = n, this.a = i, o || (this.r *= i, this.g *= i, this.b *= i, i || this.overwriteGetter("rgb", [e, r3, n, i]));
  }
  static parse(e) {
    if (e instanceof t4) return e;
    if (typeof e != "string") return;
    let r3 = dD(e);
    if (r3) return new t4(...r3, false);
  }
  get rgb() {
    let { r: e, g: r3, b: n, a: i } = this, o = i || 1 / 0;
    return this.overwriteGetter("rgb", [e / o, r3 / o, n / o, i]);
  }
  get hcl() {
    return this.overwriteGetter("hcl", pD(this.rgb));
  }
  get lab() {
    return this.overwriteGetter("lab", O_(this.rgb));
  }
  overwriteGetter(e, r3) {
    return Object.defineProperty(this, e, { value: r3 }), r3;
  }
  toString() {
    let [e, r3, n, i] = this.rgb;
    return `rgba(${[e, r3, n].map((o) => Math.round(o * 255)).join(",")},${i})`;
  }
  static interpolate(e, r3, n, i = "rgb") {
    switch (i) {
      case "rgb": {
        let [o, a, s3, l] = jo(e.rgb, r3.rgb, n);
        return new t4(o, a, s3, l, false);
      }
      case "hcl": {
        let [o, a, s3, l] = e.hcl, [u3, c, p, h] = r3.hcl, f, d;
        if (!isNaN(o) && !isNaN(u3)) {
          let P = u3 - o;
          u3 > o && P > 180 ? P -= 360 : u3 < o && o - u3 > 180 && (P += 360), f = o + n * P;
        } else isNaN(o) ? isNaN(u3) ? f = NaN : (f = u3, (s3 === 1 || s3 === 0) && (d = c)) : (f = o, (p === 1 || p === 0) && (d = a));
        let [g, x, b, v3] = hD([f, d ?? ei(a, c, n), ei(s3, p, n), ei(l, h, n)]);
        return new t4(g, x, b, v3, false);
      }
      case "lab": {
        let [o, a, s3, l] = B_(jo(e.lab, r3.lab, n));
        return new t4(o, a, s3, l, false);
      }
    }
  }
};
K.black = new K(0, 0, 0, 1);
K.white = new K(1, 1, 1, 1);
K.transparent = new K(0, 0, 0, 0);
K.red = new K(1, 0, 0, 1);
var ys = class {
  constructor(e, r3, n) {
    e ? this.sensitivity = r3 ? "variant" : "case" : this.sensitivity = r3 ? "accent" : "base", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
  }
  compare(e, r3) {
    return this.collator.compare(e, r3);
  }
  resolvedLocale() {
    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
  }
};
var xD = ["bottom", "center", "top"];
var gs = class {
  constructor(e, r3, n, i, o, a) {
    this.text = e, this.image = r3, this.scale = n, this.fontStack = i, this.textColor = o, this.verticalAlign = a;
  }
};
var yr = class t5 {
  constructor(e) {
    this.sections = e;
  }
  static fromString(e) {
    return new t5([new gs(e, null, null, null, null, null)]);
  }
  isEmpty() {
    return this.sections.length === 0 ? true : !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0);
  }
  static factory(e) {
    return e instanceof t5 ? e : t5.fromString(e);
  }
  toString() {
    return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
  }
};
var zr = class t6 {
  constructor(e) {
    this.values = e.slice();
  }
  static parse(e) {
    if (e instanceof t6) return e;
    if (typeof e == "number") return new t6([e, e, e, e]);
    if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
      for (let r3 of e) if (typeof r3 != "number") return;
      switch (e.length) {
        case 1:
          e = [e[0], e[0], e[0], e[0]];
          break;
        case 2:
          e = [e[0], e[1], e[0], e[1]];
          break;
        case 3:
          e = [e[0], e[1], e[2], e[1]];
          break;
      }
      return new t6(e);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(e, r3, n) {
    return new t6(jo(e.values, r3.values, n));
  }
};
var Vr = class t7 {
  constructor(e) {
    this.values = e.slice();
  }
  static parse(e) {
    if (e instanceof t7) return e;
    if (typeof e == "number") return new t7([e]);
    if (Array.isArray(e)) {
      for (let r3 of e) if (typeof r3 != "number") return;
      return new t7(e);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(e, r3, n) {
    return new t7(jo(e.values, r3.values, n));
  }
};
var Kt = class t8 {
  constructor(e) {
    this.values = e.slice();
  }
  static parse(e) {
    if (e instanceof t8) return e;
    if (typeof e == "string") {
      let n = K.parse(e);
      return n ? new t8([n]) : void 0;
    }
    if (!Array.isArray(e)) return;
    let r3 = [];
    for (let n of e) {
      if (typeof n != "string") return;
      let i = K.parse(n);
      if (!i) return;
      r3.push(i);
    }
    return new t8(r3);
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(e, r3, n, i = "rgb") {
    let o = [];
    if (e.values.length != r3.values.length) throw new Error(`colorArray: Arrays have mismatched length (${e.values.length} vs. ${r3.values.length}), cannot interpolate.`);
    for (let a = 0; a < e.values.length; a++) o.push(K.interpolate(e.values[a], r3.values[a], n, i));
    return new t8(o);
  }
};
var Ke = class extends Error {
  constructor(e) {
    super(e), this.name = "RuntimeError";
  }
  toJSON() {
    return this.message;
  }
};
var bD = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
var an = class t9 {
  constructor(e) {
    this.values = e.slice();
  }
  static parse(e) {
    if (e instanceof t9) return e;
    if (!(!Array.isArray(e) || e.length < 1 || e.length % 2 !== 0)) {
      for (let r3 = 0; r3 < e.length; r3 += 2) {
        let n = e[r3], i = e[r3 + 1];
        if (typeof n != "string" || !bD.has(n) || !Array.isArray(i) || i.length !== 2 || typeof i[0] != "number" || typeof i[1] != "number") return;
      }
      return new t9(e);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(e, r3, n) {
    let i = e.values, o = r3.values;
    if (i.length !== o.length) throw new Ke(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${r3.toString()}`);
    let a = [];
    for (let s3 = 0; s3 < i.length; s3 += 2) {
      if (i[s3] !== o[s3]) throw new Ke(`Cannot interpolate values containing mismatched anchors. from[${s3}]: ${i[s3]}, to[${s3}]: ${o[s3]}`);
      a.push(i[s3]);
      let [l, u3] = i[s3 + 1], [c, p] = o[s3 + 1];
      a.push([ei(l, c, n), ei(u3, p, n)]);
    }
    return new t9(a);
  }
};
var Jt = class t10 {
  constructor(e) {
    this.name = e.name, this.available = e.available;
  }
  toString() {
    return this.name;
  }
  static fromString(e) {
    return e ? new t10({ name: e, available: false }) : null;
  }
};
var sn = class t11 {
  constructor(e, r3, n) {
    this.from = e, this.to = r3, this.transition = n;
  }
  static interpolate(e, r3, n) {
    return new t11(e, r3, n);
  }
  static parse(e) {
    if (e instanceof t11) return e;
    if (Array.isArray(e) && e.length === 3 && typeof e[0] == "string" && typeof e[1] == "string" && typeof e[2] == "number") return new t11(e[0], e[1], e[2]);
    if (typeof e == "object" && typeof e.from == "string" && typeof e.to == "string" && typeof e.transition == "number") return new t11(e.from, e.to, e.transition);
    if (typeof e == "string") return new t11(e, e, 1);
  }
};
function z_(t63, e, r3, n) {
  return typeof t63 == "number" && t63 >= 0 && t63 <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof r3 == "number" && r3 >= 0 && r3 <= 255 ? typeof n > "u" || typeof n == "number" && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[t63, e, r3, n].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n == "number" ? [t63, e, r3, n] : [t63, e, r3]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
}
function xs(t63) {
  if (t63 === null || typeof t63 == "string" || typeof t63 == "boolean" || typeof t63 == "number" || t63 instanceof sn || t63 instanceof K || t63 instanceof ys || t63 instanceof yr || t63 instanceof zr || t63 instanceof Vr || t63 instanceof Kt || t63 instanceof an || t63 instanceof Jt) return true;
  if (Array.isArray(t63)) {
    for (let e of t63) if (!xs(e)) return false;
    return true;
  } else if (typeof t63 == "object") {
    for (let e in t63) if (!xs(t63[e])) return false;
    return true;
  } else return false;
}
function ct(t63) {
  if (t63 === null) return Zo;
  if (typeof t63 == "string") return Pe2;
  if (typeof t63 == "boolean") return ge;
  if (typeof t63 == "number") return Y;
  if (t63 instanceof K) return Br;
  if (t63 instanceof sn) return Dc;
  if (t63 instanceof ys) return Rc;
  if (t63 instanceof yr) return qo;
  if (t63 instanceof zr) return kc;
  if (t63 instanceof Vr) return Fc;
  if (t63 instanceof Kt) return ms;
  if (t63 instanceof an) return Oc;
  if (t63 instanceof Jt) return Is;
  if (Array.isArray(t63)) {
    let e = t63.length, r3;
    for (let n of t63) {
      let i = ct(n);
      if (!r3) r3 = i;
      else {
        if (r3 === i) continue;
        r3 = me;
        break;
      }
    }
    return dr(r3 || me, e);
  } else return qi;
}
function fs(t63) {
  let e = typeof t63;
  return t63 === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(t63) : t63 instanceof K || t63 instanceof sn || t63 instanceof yr || t63 instanceof zr || t63 instanceof Vr || t63 instanceof Kt || t63 instanceof an || t63 instanceof Jt ? t63.toString() : JSON.stringify(t63);
}
var ti = class t12 {
  constructor(e, r3) {
    this.type = e, this.value = r3;
  }
  static parse(e, r3) {
    if (e.length !== 2) return r3.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
    if (!xs(e[1])) return r3.error("invalid value");
    let n = e[1], i = ct(n), o = r3.expectedType;
    return i.kind === "array" && i.N === 0 && o && o.kind === "array" && (typeof o.N != "number" || o.N === 0) && (i = o), new t12(i, n);
  }
  evaluate() {
    return this.value;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
var dc = { string: Pe2, number: Y, boolean: ge, object: qi };
var Xr = class t13 {
  constructor(e, r3) {
    this.type = e, this.args = r3;
  }
  static parse(e, r3) {
    if (e.length < 2) return r3.error("Expected at least one argument.");
    let n = 1, i, o = e[0];
    if (o === "array") {
      let s3;
      if (e.length > 2) {
        let u3 = e[1];
        if (typeof u3 != "string" || !(u3 in dc) || u3 === "object") return r3.error('The item type argument of "array" must be one of string, number, boolean', 1);
        s3 = dc[u3], n++;
      } else s3 = me;
      let l;
      if (e.length > 3) {
        if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return r3.error('The length argument to "array" must be a positive integer literal', 2);
        l = e[2], n++;
      }
      i = dr(s3, l);
    } else {
      if (!dc[o]) throw new Error(`Types doesn't contain name = ${o}`);
      i = dc[o];
    }
    let a = [];
    for (; n < e.length; n++) {
      let s3 = r3.parse(e[n], n, me);
      if (!s3) return null;
      a.push(s3);
    }
    return new t13(i, a);
  }
  evaluate(e) {
    for (let r3 = 0; r3 < this.args.length; r3++) {
      let n = this.args[r3].evaluate(e);
      if (ds(this.type, ct(n))) {
        if (r3 === this.args.length - 1) throw new Ke(`Expected value to be of type ${nt(this.type)}, but found ${nt(ct(n))} instead.`);
      } else return n;
    }
    throw new Error();
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
};
var u_ = { "to-boolean": ge, "to-color": Br, "to-number": Y, "to-string": Pe2 };
var Qn = class t14 {
  constructor(e, r3) {
    this.type = e, this.args = r3;
  }
  static parse(e, r3) {
    if (e.length < 2) return r3.error("Expected at least one argument.");
    let n = e[0];
    if (!u_[n]) throw new Error(`Can't parse ${n} as it is not part of the known types`);
    if ((n === "to-boolean" || n === "to-string") && e.length !== 2) return r3.error("Expected one argument.");
    let i = u_[n], o = [];
    for (let a = 1; a < e.length; a++) {
      let s3 = r3.parse(e[a], a, me);
      if (!s3) return null;
      o.push(s3);
    }
    return new t14(i, o);
  }
  evaluate(e) {
    switch (this.type.kind) {
      case "boolean":
        return !!this.args[0].evaluate(e);
      case "color": {
        let r3, n;
        for (let i of this.args) {
          if (r3 = i.evaluate(e), n = null, r3 instanceof K) return r3;
          if (typeof r3 == "string") {
            let o = e.parseColor(r3);
            if (o) return o;
          } else if (Array.isArray(r3) && (r3.length < 3 || r3.length > 4 ? n = `Invalid rgba value ${JSON.stringify(r3)}: expected an array containing either three or four numeric values.` : n = z_(r3[0], r3[1], r3[2], r3[3]), !n)) return new K(r3[0] / 255, r3[1] / 255, r3[2] / 255, r3[3]);
        }
        throw new Ke(n || `Could not parse color from value '${typeof r3 == "string" ? r3 : JSON.stringify(r3)}'`);
      }
      case "padding": {
        let r3;
        for (let n of this.args) {
          r3 = n.evaluate(e);
          let i = zr.parse(r3);
          if (i) return i;
        }
        throw new Ke(`Could not parse padding from value '${typeof r3 == "string" ? r3 : JSON.stringify(r3)}'`);
      }
      case "numberArray": {
        let r3;
        for (let n of this.args) {
          r3 = n.evaluate(e);
          let i = Vr.parse(r3);
          if (i) return i;
        }
        throw new Ke(`Could not parse numberArray from value '${typeof r3 == "string" ? r3 : JSON.stringify(r3)}'`);
      }
      case "colorArray": {
        let r3;
        for (let n of this.args) {
          r3 = n.evaluate(e);
          let i = Kt.parse(r3);
          if (i) return i;
        }
        throw new Ke(`Could not parse colorArray from value '${typeof r3 == "string" ? r3 : JSON.stringify(r3)}'`);
      }
      case "variableAnchorOffsetCollection": {
        let r3;
        for (let n of this.args) {
          r3 = n.evaluate(e);
          let i = an.parse(r3);
          if (i) return i;
        }
        throw new Ke(`Could not parse variableAnchorOffsetCollection from value '${typeof r3 == "string" ? r3 : JSON.stringify(r3)}'`);
      }
      case "number": {
        let r3 = null;
        for (let n of this.args) {
          if (r3 = n.evaluate(e), r3 === null) return 0;
          let i = Number(r3);
          if (!isNaN(i)) return i;
        }
        throw new Ke(`Could not convert ${JSON.stringify(r3)} to number.`);
      }
      case "formatted":
        return yr.fromString(fs(this.args[0].evaluate(e)));
      case "resolvedImage":
        return Jt.fromString(fs(this.args[0].evaluate(e)));
      case "projectionDefinition":
        return this.args[0].evaluate(e);
      default:
        return fs(this.args[0].evaluate(e));
    }
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
};
var _D = ["Unknown", "Point", "LineString", "Polygon"];
var bc = class {
  constructor() {
    this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
  }
  id() {
    return this.feature && "id" in this.feature ? this.feature.id : null;
  }
  geometryType() {
    return this.feature ? typeof this.feature.type == "number" ? _D[this.feature.type] : this.feature.type : null;
  }
  geometry() {
    return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
  }
  canonicalID() {
    return this.canonical;
  }
  properties() {
    return this.feature && this.feature.properties || {};
  }
  parseColor(e) {
    let r3 = this._parseColorCache.get(e);
    return r3 || (r3 = K.parse(e), this._parseColorCache.set(e, r3)), r3;
  }
};
var _c = class t15 {
  constructor(e, r3, n = [], i, o = new dd(), a = []) {
    this.registry = e, this.path = n, this.key = n.map((s3) => `[${s3}]`).join(""), this.scope = o, this.errors = a, this.expectedType = i, this._isConstant = r3;
  }
  parse(e, r3, n, i, o = {}) {
    return r3 ? this.concat(r3, n, i)._parse(e, o) : this._parse(e, o);
  }
  _parse(e, r3) {
    (e === null || typeof e == "string" || typeof e == "boolean" || typeof e == "number") && (e = ["literal", e]);
    function n(i, o, a) {
      return a === "assert" ? new Xr(o, [i]) : a === "coerce" ? new Qn(o, [i]) : i;
    }
    if (Array.isArray(e)) {
      if (e.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
      let i = e[0];
      if (typeof i != "string") return this.error(`Expression name must be a string, but found ${typeof i} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
      let o = this.registry[i];
      if (o) {
        let a = o.parse(e, this);
        if (!a) return null;
        if (this.expectedType) {
          let s3 = this.expectedType, l = a.type;
          if ((s3.kind === "string" || s3.kind === "number" || s3.kind === "boolean" || s3.kind === "object" || s3.kind === "array") && l.kind === "value") a = n(a, s3, r3.typeAnnotation || "assert");
          else if (s3.kind === "projectionDefinition" && ["string", "array"].includes(l.kind) || ["color", "formatted", "resolvedImage"].includes(s3.kind) && ["value", "string"].includes(l.kind) || ["padding", "numberArray"].includes(s3.kind) && ["value", "number", "array"].includes(l.kind) || s3.kind === "colorArray" && ["value", "string", "array"].includes(l.kind) || s3.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(l.kind)) a = n(a, s3, r3.typeAnnotation || "coerce");
          else if (this.checkSubtype(s3, l)) return null;
        }
        if (!(a instanceof ti) && a.type.kind !== "resolvedImage" && this._isConstant(a)) {
          let s3 = new bc();
          try {
            a = new ti(a.type, a.evaluate(s3));
          } catch (l) {
            return this.error(l.message), null;
          }
        }
        return a;
      }
      return this.error(`Unknown expression "${i}". If you wanted a literal array, use ["literal", [...]].`, 0);
    } else return typeof e > "u" ? this.error("'undefined' value invalid. Use null instead.") : typeof e == "object" ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error(`Expected an array, but found ${typeof e} instead.`);
  }
  concat(e, r3, n) {
    let i = typeof e == "number" ? this.path.concat(e) : this.path, o = n ? this.scope.concat(n) : this.scope;
    return new t15(this.registry, this._isConstant, i, r3 || null, o, this.errors);
  }
  error(e, ...r3) {
    let n = `${this.key}${r3.map((i) => `[${i}]`).join("")}`;
    this.errors.push(new Fr(n, e));
  }
  checkSubtype(e, r3) {
    let n = ds(e, r3);
    return n && this.error(n), n;
  }
};
var vc = class t16 {
  constructor(e, r3) {
    this.type = r3.type, this.bindings = [].concat(e), this.result = r3;
  }
  evaluate(e) {
    return this.result.evaluate(e);
  }
  eachChild(e) {
    for (let r3 of this.bindings) e(r3[1]);
    e(this.result);
  }
  static parse(e, r3) {
    if (e.length < 4) return r3.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
    let n = [];
    for (let o = 1; o < e.length - 1; o += 2) {
      let a = e[o];
      if (typeof a != "string") return r3.error(`Expected string, but found ${typeof a} instead.`, o);
      if (/[^a-zA-Z0-9_]/.test(a)) return r3.error("Variable names must contain only alphanumeric characters or '_'.", o);
      let s3 = r3.parse(e[o + 1], o + 1);
      if (!s3) return null;
      n.push([a, s3]);
    }
    let i = r3.parse(e[e.length - 1], e.length - 1, r3.expectedType, n);
    return i ? new t16(n, i) : null;
  }
  outputDefined() {
    return this.result.outputDefined();
  }
};
var Pc = class t17 {
  constructor(e, r3) {
    this.type = r3.type, this.name = e, this.boundExpression = r3;
  }
  static parse(e, r3) {
    if (e.length !== 2 || typeof e[1] != "string") return r3.error("'var' expression requires exactly one string literal argument.");
    let n = e[1];
    return r3.scope.has(n) ? new t17(n, r3.scope.get(n)) : r3.error(`Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`, 1);
  }
  evaluate(e) {
    return this.boundExpression.evaluate(e);
  }
  eachChild() {
  }
  outputDefined() {
    return false;
  }
};
var yd = class t18 {
  constructor(e, r3, n) {
    this.type = e, this.index = r3, this.input = n;
  }
  static parse(e, r3) {
    if (e.length !== 3) return r3.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
    let n = r3.parse(e[1], 1, Y), i = r3.parse(e[2], 2, dr(r3.expectedType || me));
    if (!n || !i) return null;
    let o = i.type;
    return new t18(o.itemType, n, i);
  }
  evaluate(e) {
    let r3 = this.index.evaluate(e), n = this.input.evaluate(e);
    if (r3 < 0) throw new Ke(`Array index out of bounds: ${r3} < 0.`);
    if (r3 >= n.length) throw new Ke(`Array index out of bounds: ${r3} > ${n.length - 1}.`);
    if (r3 !== Math.floor(r3)) throw new Ke(`Array index must be an integer, but found ${r3} instead.`);
    return n[r3];
  }
  eachChild(e) {
    e(this.index), e(this.input);
  }
  outputDefined() {
    return false;
  }
};
var gd = class t19 {
  constructor(e, r3) {
    this.type = ge, this.needle = e, this.haystack = r3;
  }
  static parse(e, r3) {
    if (e.length !== 3) return r3.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
    let n = r3.parse(e[1], 1, me), i = r3.parse(e[2], 2, me);
    return !n || !i ? null : Rd(n.type, [ge, Pe2, Y, Zo, me]) ? new t19(n, i) : r3.error(`Expected first argument to be of type boolean, string, number or null, but found ${nt(n.type)} instead`);
  }
  evaluate(e) {
    let r3 = this.needle.evaluate(e), n = this.haystack.evaluate(e);
    if (!n) return false;
    if (!Yi(r3, ["boolean", "string", "number", "null"])) throw new Ke(`Expected first argument to be of type boolean, string, number or null, but found ${nt(ct(r3))} instead.`);
    if (!Yi(n, ["string", "array"])) throw new Ke(`Expected second argument to be of type array or string, but found ${nt(ct(n))} instead.`);
    return n.indexOf(r3) >= 0;
  }
  eachChild(e) {
    e(this.needle), e(this.haystack);
  }
  outputDefined() {
    return true;
  }
};
var xd = class t20 {
  constructor(e, r3, n) {
    this.type = Y, this.needle = e, this.haystack = r3, this.fromIndex = n;
  }
  static parse(e, r3) {
    if (e.length <= 2 || e.length >= 5) return r3.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
    let n = r3.parse(e[1], 1, me), i = r3.parse(e[2], 2, me);
    if (!n || !i) return null;
    if (!Rd(n.type, [ge, Pe2, Y, Zo, me])) return r3.error(`Expected first argument to be of type boolean, string, number or null, but found ${nt(n.type)} instead`);
    if (e.length === 4) {
      let o = r3.parse(e[3], 3, Y);
      return o ? new t20(n, i, o) : null;
    } else return new t20(n, i);
  }
  evaluate(e) {
    let r3 = this.needle.evaluate(e), n = this.haystack.evaluate(e);
    if (!Yi(r3, ["boolean", "string", "number", "null"])) throw new Ke(`Expected first argument to be of type boolean, string, number or null, but found ${nt(ct(r3))} instead.`);
    let i;
    if (this.fromIndex && (i = this.fromIndex.evaluate(e)), Yi(n, ["string"])) {
      let o = n.indexOf(r3, i);
      return o === -1 ? -1 : [...n.slice(0, o)].length;
    } else {
      if (Yi(n, ["array"])) return n.indexOf(r3, i);
      throw new Ke(`Expected second argument to be of type array or string, but found ${nt(ct(n))} instead.`);
    }
  }
  eachChild(e) {
    e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
  }
  outputDefined() {
    return false;
  }
};
var bd = class t21 {
  constructor(e, r3, n, i, o, a) {
    this.inputType = e, this.type = r3, this.input = n, this.cases = i, this.outputs = o, this.otherwise = a;
  }
  static parse(e, r3) {
    if (e.length < 5) return r3.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
    if (e.length % 2 !== 1) return r3.error("Expected an even number of arguments.");
    let n, i;
    r3.expectedType && r3.expectedType.kind !== "value" && (i = r3.expectedType);
    let o = {}, a = [];
    for (let u3 = 2; u3 < e.length - 1; u3 += 2) {
      let c = e[u3], p = e[u3 + 1];
      Array.isArray(c) || (c = [c]);
      let h = r3.concat(u3);
      if (c.length === 0) return h.error("Expected at least one branch label.");
      for (let d of c) {
        if (typeof d != "number" && typeof d != "string") return h.error("Branch labels must be numbers or strings.");
        if (typeof d == "number" && Math.abs(d) > Number.MAX_SAFE_INTEGER) return h.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
        if (typeof d == "number" && Math.floor(d) !== d) return h.error("Numeric branch labels must be integer values.");
        if (!n) n = ct(d);
        else if (h.checkSubtype(n, ct(d))) return null;
        if (typeof o[String(d)] < "u") return h.error("Branch labels must be unique.");
        o[String(d)] = a.length;
      }
      let f = r3.parse(p, u3, i);
      if (!f) return null;
      i = i || f.type, a.push(f);
    }
    let s3 = r3.parse(e[1], 1, me);
    if (!s3) return null;
    let l = r3.parse(e[e.length - 1], e.length - 1, i);
    return !l || s3.type.kind !== "value" && r3.concat(1).checkSubtype(n, s3.type) ? null : new t21(n, i, s3, o, a, l);
  }
  evaluate(e) {
    let r3 = this.input.evaluate(e);
    return (ct(r3) === this.inputType && this.outputs[this.cases[r3]] || this.otherwise).evaluate(e);
  }
  eachChild(e) {
    e(this.input), this.outputs.forEach(e), e(this.otherwise);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
  }
};
var _d = class t23 {
  constructor(e, r3, n) {
    this.type = e, this.branches = r3, this.otherwise = n;
  }
  static parse(e, r3) {
    if (e.length < 4) return r3.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
    if (e.length % 2 !== 0) return r3.error("Expected an odd number of arguments.");
    let n;
    r3.expectedType && r3.expectedType.kind !== "value" && (n = r3.expectedType);
    let i = [];
    for (let a = 1; a < e.length - 1; a += 2) {
      let s3 = r3.parse(e[a], a, ge);
      if (!s3) return null;
      let l = r3.parse(e[a + 1], a + 1, n);
      if (!l) return null;
      i.push([s3, l]), n = n || l.type;
    }
    let o = r3.parse(e[e.length - 1], e.length - 1, n);
    if (!o) return null;
    if (!n) throw new Error("Can't infer output type");
    return new t23(n, i, o);
  }
  evaluate(e) {
    for (let [r3, n] of this.branches) if (r3.evaluate(e)) return n.evaluate(e);
    return this.otherwise.evaluate(e);
  }
  eachChild(e) {
    for (let [r3, n] of this.branches) e(r3), e(n);
    e(this.otherwise);
  }
  outputDefined() {
    return this.branches.every(([e, r3]) => r3.outputDefined()) && this.otherwise.outputDefined();
  }
};
var vd = class t24 {
  constructor(e, r3, n, i) {
    this.type = e, this.input = r3, this.beginIndex = n, this.endIndex = i;
  }
  static parse(e, r3) {
    if (e.length <= 2 || e.length >= 5) return r3.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
    let n = r3.parse(e[1], 1, me), i = r3.parse(e[2], 2, Y);
    if (!n || !i) return null;
    if (!Rd(n.type, [dr(me), Pe2, me])) return r3.error(`Expected first argument to be of type array or string, but found ${nt(n.type)} instead`);
    if (e.length === 4) {
      let o = r3.parse(e[3], 3, Y);
      return o ? new t24(n.type, n, i, o) : null;
    } else return new t24(n.type, n, i);
  }
  evaluate(e) {
    let r3 = this.input.evaluate(e), n = this.beginIndex.evaluate(e), i;
    if (this.endIndex && (i = this.endIndex.evaluate(e)), Yi(r3, ["string"])) return [...r3].slice(n, i).join("");
    if (Yi(r3, ["array"])) return r3.slice(n, i);
    throw new Ke(`Expected first argument to be of type array or string, but found ${nt(ct(r3))} instead.`);
  }
  eachChild(e) {
    e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
  }
  outputDefined() {
    return false;
  }
};
function Bc(t63, e) {
  let r3 = t63.length - 1, n = 0, i = r3, o = 0, a, s3;
  for (; n <= i; ) if (o = Math.floor((n + i) / 2), a = t63[o], s3 = t63[o + 1], a <= e) {
    if (o === r3 || e < s3) return o;
    n = o + 1;
  } else if (a > e) i = o - 1;
  else throw new Ke("Input is not a number.");
  return 0;
}
var Ho = class t25 {
  constructor(e, r3, n) {
    this.type = e, this.input = r3, this.labels = [], this.outputs = [];
    for (let [i, o] of n) this.labels.push(i), this.outputs.push(o);
  }
  static parse(e, r3) {
    if (e.length - 1 < 4) return r3.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
    if ((e.length - 1) % 2 !== 0) return r3.error("Expected an even number of arguments.");
    let n = r3.parse(e[1], 1, Y);
    if (!n) return null;
    let i = [], o = null;
    r3.expectedType && r3.expectedType.kind !== "value" && (o = r3.expectedType);
    for (let a = 1; a < e.length; a += 2) {
      let s3 = a === 1 ? -1 / 0 : e[a], l = e[a + 1], u3 = a, c = a + 1;
      if (typeof s3 != "number") return r3.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', u3);
      if (i.length && i[i.length - 1][0] >= s3) return r3.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', u3);
      let p = r3.parse(l, c, o);
      if (!p) return null;
      o = o || p.type, i.push([s3, p]);
    }
    return new t25(o, n, i);
  }
  evaluate(e) {
    let r3 = this.labels, n = this.outputs;
    if (r3.length === 1) return n[0].evaluate(e);
    let i = this.input.evaluate(e);
    if (i <= r3[0]) return n[0].evaluate(e);
    let o = r3.length;
    if (i >= r3[o - 1]) return n[o - 1].evaluate(e);
    let a = Bc(r3, i);
    return n[a].evaluate(e);
  }
  eachChild(e) {
    e(this.input);
    for (let r3 of this.outputs) e(r3);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined());
  }
};
function vD(t63) {
  return t63 && t63.__esModule && Object.prototype.hasOwnProperty.call(t63, "default") ? t63.default : t63;
}
var cd;
var c_;
function PD() {
  if (c_) return cd;
  c_ = 1, cd = t63;
  function t63(e, r3, n, i) {
    this.cx = 3 * e, this.bx = 3 * (n - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r3, this.by = 3 * (i - r3) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = r3, this.p2x = n, this.p2y = i;
  }
  return t63.prototype = { sampleCurveX: function(e) {
    return ((this.ax * e + this.bx) * e + this.cx) * e;
  }, sampleCurveY: function(e) {
    return ((this.ay * e + this.by) * e + this.cy) * e;
  }, sampleCurveDerivativeX: function(e) {
    return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
  }, solveCurveX: function(e, r3) {
    if (r3 === void 0 && (r3 = 1e-6), e < 0) return 0;
    if (e > 1) return 1;
    for (var n = e, i = 0; i < 8; i++) {
      var o = this.sampleCurveX(n) - e;
      if (Math.abs(o) < r3) return n;
      var a = this.sampleCurveDerivativeX(n);
      if (Math.abs(a) < 1e-6) break;
      n = n - o / a;
    }
    var s3 = 0, l = 1;
    for (n = e, i = 0; i < 20 && (o = this.sampleCurveX(n), !(Math.abs(o - e) < r3)); i++) e > o ? s3 = n : l = n, n = (l - s3) * 0.5 + s3;
    return n;
  }, solve: function(e, r3) {
    return this.sampleCurveY(this.solveCurveX(e, r3));
  } }, cd;
}
var wD = PD();
var TD = vD(wD);
var jt = class t26 {
  constructor(e, r3, n, i, o) {
    this.type = e, this.operator = r3, this.interpolation = n, this.input = i, this.labels = [], this.outputs = [];
    for (let [a, s3] of o) this.labels.push(a), this.outputs.push(s3);
  }
  static interpolationFactor(e, r3, n, i) {
    let o = 0;
    if (e.name === "exponential") o = pd(r3, e.base, n, i);
    else if (e.name === "linear") o = pd(r3, 1, n, i);
    else if (e.name === "cubic-bezier") {
      let a = e.controlPoints;
      o = new TD(a[0], a[1], a[2], a[3]).solve(pd(r3, 1, n, i));
    }
    return o;
  }
  static parse(e, r3) {
    let [n, i, o, ...a] = e;
    if (!Array.isArray(i) || i.length === 0) return r3.error("Expected an interpolation type expression.", 1);
    if (i[0] === "linear") i = { name: "linear" };
    else if (i[0] === "exponential") {
      let u3 = i[1];
      if (typeof u3 != "number") return r3.error("Exponential interpolation requires a numeric base.", 1, 1);
      i = { name: "exponential", base: u3 };
    } else if (i[0] === "cubic-bezier") {
      let u3 = i.slice(1);
      if (u3.length !== 4 || u3.some((c) => typeof c != "number" || c < 0 || c > 1)) return r3.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
      i = { name: "cubic-bezier", controlPoints: u3 };
    } else return r3.error(`Unknown interpolation type ${String(i[0])}`, 1, 0);
    if (e.length - 1 < 4) return r3.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
    if ((e.length - 1) % 2 !== 0) return r3.error("Expected an even number of arguments.");
    if (o = r3.parse(o, 2, Y), !o) return null;
    let s3 = [], l = null;
    (n === "interpolate-hcl" || n === "interpolate-lab") && r3.expectedType != ms ? l = Br : r3.expectedType && r3.expectedType.kind !== "value" && (l = r3.expectedType);
    for (let u3 = 0; u3 < a.length; u3 += 2) {
      let c = a[u3], p = a[u3 + 1], h = u3 + 3, f = u3 + 4;
      if (typeof c != "number") return r3.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', h);
      if (s3.length && s3[s3.length - 1][0] >= c) return r3.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', h);
      let d = r3.parse(p, f, l);
      if (!d) return null;
      l = l || d.type, s3.push([c, d]);
    }
    return !Jn(l, Y) && !Jn(l, Dc) && !Jn(l, Br) && !Jn(l, kc) && !Jn(l, Fc) && !Jn(l, ms) && !Jn(l, Oc) && !Jn(l, dr(Y)) ? r3.error(`Type ${nt(l)} is not interpolatable.`) : new t26(l, n, i, o, s3);
  }
  evaluate(e) {
    let r3 = this.labels, n = this.outputs;
    if (r3.length === 1) return n[0].evaluate(e);
    let i = this.input.evaluate(e);
    if (i <= r3[0]) return n[0].evaluate(e);
    let o = r3.length;
    if (i >= r3[o - 1]) return n[o - 1].evaluate(e);
    let a = Bc(r3, i), s3 = r3[a], l = r3[a + 1], u3 = t26.interpolationFactor(this.interpolation, i, s3, l), c = n[a].evaluate(e), p = n[a + 1].evaluate(e);
    switch (this.operator) {
      case "interpolate":
        switch (this.type.kind) {
          case "number":
            return ei(c, p, u3);
          case "color":
            return K.interpolate(c, p, u3);
          case "padding":
            return zr.interpolate(c, p, u3);
          case "colorArray":
            return Kt.interpolate(c, p, u3);
          case "numberArray":
            return Vr.interpolate(c, p, u3);
          case "variableAnchorOffsetCollection":
            return an.interpolate(c, p, u3);
          case "array":
            return jo(c, p, u3);
          case "projectionDefinition":
            return sn.interpolate(c, p, u3);
        }
      case "interpolate-hcl":
        switch (this.type.kind) {
          case "color":
            return K.interpolate(c, p, u3, "hcl");
          case "colorArray":
            return Kt.interpolate(c, p, u3, "hcl");
        }
      case "interpolate-lab":
        switch (this.type.kind) {
          case "color":
            return K.interpolate(c, p, u3, "lab");
          case "colorArray":
            return Kt.interpolate(c, p, u3, "lab");
        }
    }
  }
  eachChild(e) {
    e(this.input);
    for (let r3 of this.outputs) e(r3);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined());
  }
};
function pd(t63, e, r3, n) {
  let i = n - r3, o = t63 - r3;
  return i === 0 ? 0 : e === 1 ? o / i : (Math.pow(e, o) - 1) / (Math.pow(e, i) - 1);
}
var Fe = { color: K.interpolate, number: ei, padding: zr.interpolate, numberArray: Vr.interpolate, colorArray: Kt.interpolate, variableAnchorOffsetCollection: an.interpolate, array: jo };
var wc = class t27 {
  constructor(e, r3) {
    this.type = e, this.args = r3;
  }
  static parse(e, r3) {
    if (e.length < 2) return r3.error("Expected at least one argument.");
    let n = null, i = r3.expectedType;
    i && i.kind !== "value" && (n = i);
    let o = [];
    for (let s3 of e.slice(1)) {
      let l = r3.parse(s3, 1 + o.length, n, void 0, { typeAnnotation: "omit" });
      if (!l) return null;
      n = n || l.type, o.push(l);
    }
    if (!n) throw new Error("No output type");
    return i && o.some((s3) => ds(i, s3.type)) ? new t27(me, o) : new t27(n, o);
  }
  evaluate(e) {
    let r3 = null, n = 0, i;
    for (let o of this.args) if (n++, r3 = o.evaluate(e), r3 && r3 instanceof Jt && !r3.available && (i || (i = r3.name), r3 = null, n === this.args.length && (r3 = i)), r3 !== null) break;
    return r3;
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
};
function p_(t63, e) {
  return t63 === "==" || t63 === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
}
function SD(t63, e, r3) {
  return e === r3;
}
function CD(t63, e, r3) {
  return e !== r3;
}
function MD(t63, e, r3) {
  return e < r3;
}
function ID(t63, e, r3) {
  return e > r3;
}
function AD(t63, e, r3) {
  return e <= r3;
}
function ED(t63, e, r3) {
  return e >= r3;
}
function V_(t63, e, r3, n) {
  return n.compare(e, r3) === 0;
}
function LD(t63, e, r3, n) {
  return !V_(t63, e, r3, n);
}
function DD(t63, e, r3, n) {
  return n.compare(e, r3) < 0;
}
function RD(t63, e, r3, n) {
  return n.compare(e, r3) > 0;
}
function kD(t63, e, r3, n) {
  return n.compare(e, r3) <= 0;
}
function FD(t63, e, r3, n) {
  return n.compare(e, r3) >= 0;
}
function Yo(t63, e, r3) {
  let n = t63 !== "==" && t63 !== "!=";
  return class U_ {
    constructor(o, a, s3) {
      this.type = ge, this.lhs = o, this.rhs = a, this.collator = s3, this.hasUntypedArgument = o.type.kind === "value" || a.type.kind === "value";
    }
    static parse(o, a) {
      if (o.length !== 3 && o.length !== 4) return a.error("Expected two or three arguments.");
      let s3 = o[0], l = a.parse(o[1], 1, me);
      if (!l) return null;
      if (!p_(s3, l.type)) return a.concat(1).error(`"${s3}" comparisons are not supported for type '${nt(l.type)}'.`);
      let u3 = a.parse(o[2], 2, me);
      if (!u3) return null;
      if (!p_(s3, u3.type)) return a.concat(2).error(`"${s3}" comparisons are not supported for type '${nt(u3.type)}'.`);
      if (l.type.kind !== u3.type.kind && l.type.kind !== "value" && u3.type.kind !== "value") return a.error(`Cannot compare types '${nt(l.type)}' and '${nt(u3.type)}'.`);
      n && (l.type.kind === "value" && u3.type.kind !== "value" ? l = new Xr(u3.type, [l]) : l.type.kind !== "value" && u3.type.kind === "value" && (u3 = new Xr(l.type, [u3])));
      let c = null;
      if (o.length === 4) {
        if (l.type.kind !== "string" && u3.type.kind !== "string" && l.type.kind !== "value" && u3.type.kind !== "value") return a.error("Cannot use collator to compare non-string types.");
        if (c = a.parse(o[3], 3, Rc), !c) return null;
      }
      return new U_(l, u3, c);
    }
    evaluate(o) {
      let a = this.lhs.evaluate(o), s3 = this.rhs.evaluate(o);
      if (n && this.hasUntypedArgument) {
        let l = ct(a), u3 = ct(s3);
        if (l.kind !== u3.kind || !(l.kind === "string" || l.kind === "number")) throw new Ke(`Expected arguments for "${t63}" to be (string, string) or (number, number), but found (${l.kind}, ${u3.kind}) instead.`);
      }
      if (this.collator && !n && this.hasUntypedArgument) {
        let l = ct(a), u3 = ct(s3);
        if (l.kind !== "string" || u3.kind !== "string") return e(o, a, s3);
      }
      return this.collator ? r3(o, a, s3, this.collator.evaluate(o)) : e(o, a, s3);
    }
    eachChild(o) {
      o(this.lhs), o(this.rhs), this.collator && o(this.collator);
    }
    outputDefined() {
      return true;
    }
  };
}
var OD = Yo("==", SD, V_);
var BD = Yo("!=", CD, LD);
var zD = Yo("<", MD, DD);
var VD = Yo(">", ID, RD);
var UD = Yo("<=", AD, kD);
var ND = Yo(">=", ED, FD);
var Tc = class t28 {
  constructor(e, r3, n) {
    this.type = Rc, this.locale = n, this.caseSensitive = e, this.diacriticSensitive = r3;
  }
  static parse(e, r3) {
    if (e.length !== 2) return r3.error("Expected one argument.");
    let n = e[1];
    if (typeof n != "object" || Array.isArray(n)) return r3.error("Collator options argument must be an object.");
    let i = r3.parse(n["case-sensitive"] === void 0 ? false : n["case-sensitive"], 1, ge);
    if (!i) return null;
    let o = r3.parse(n["diacritic-sensitive"] === void 0 ? false : n["diacritic-sensitive"], 1, ge);
    if (!o) return null;
    let a = null;
    return n.locale && (a = r3.parse(n.locale, 1, Pe2), !a) ? null : new t28(i, o, a);
  }
  evaluate(e) {
    return new ys(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
  }
  eachChild(e) {
    e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
  }
  outputDefined() {
    return false;
  }
};
var Pd = class t29 {
  constructor(e, r3, n, i, o) {
    this.type = Pe2, this.number = e, this.locale = r3, this.currency = n, this.minFractionDigits = i, this.maxFractionDigits = o;
  }
  static parse(e, r3) {
    if (e.length !== 3) return r3.error("Expected two arguments.");
    let n = r3.parse(e[1], 1, Y);
    if (!n) return null;
    let i = e[2];
    if (typeof i != "object" || Array.isArray(i)) return r3.error("NumberFormat options argument must be an object.");
    let o = null;
    if (i.locale && (o = r3.parse(i.locale, 1, Pe2), !o)) return null;
    let a = null;
    if (i.currency && (a = r3.parse(i.currency, 1, Pe2), !a)) return null;
    let s3 = null;
    if (i["min-fraction-digits"] && (s3 = r3.parse(i["min-fraction-digits"], 1, Y), !s3)) return null;
    let l = null;
    return i["max-fraction-digits"] && (l = r3.parse(i["max-fraction-digits"], 1, Y), !l) ? null : new t29(n, o, a, s3, l);
  }
  evaluate(e) {
    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(e) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0 }).format(this.number.evaluate(e));
  }
  eachChild(e) {
    e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
  }
  outputDefined() {
    return false;
  }
};
var bs = class t30 {
  constructor(e) {
    this.type = qo, this.sections = e;
  }
  static parse(e, r3) {
    if (e.length < 2) return r3.error("Expected at least one argument.");
    let n = e[1];
    if (!Array.isArray(n) && typeof n == "object") return r3.error("First argument must be an image or text section.");
    let i = [], o = false;
    for (let a = 1; a <= e.length - 1; ++a) {
      let s3 = e[a];
      if (o && typeof s3 == "object" && !Array.isArray(s3)) {
        o = false;
        let l = null;
        if (s3["font-scale"] && (l = r3.parse(s3["font-scale"], 1, Y), !l)) return null;
        let u3 = null;
        if (s3["text-font"] && (u3 = r3.parse(s3["text-font"], 1, dr(Pe2)), !u3)) return null;
        let c = null;
        if (s3["text-color"] && (c = r3.parse(s3["text-color"], 1, Br), !c)) return null;
        let p = null;
        if (s3["vertical-align"]) {
          if (typeof s3["vertical-align"] == "string" && !xD.includes(s3["vertical-align"])) return r3.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s3["vertical-align"]}' instead.`);
          if (p = r3.parse(s3["vertical-align"], 1, Pe2), !p) return null;
        }
        let h = i[i.length - 1];
        h.scale = l, h.font = u3, h.textColor = c, h.verticalAlign = p;
      } else {
        let l = r3.parse(e[a], 1, me);
        if (!l) return null;
        let u3 = l.type.kind;
        if (u3 !== "string" && u3 !== "value" && u3 !== "null" && u3 !== "resolvedImage") return r3.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
        o = true, i.push({ content: l, scale: null, font: null, textColor: null, verticalAlign: null });
      }
    }
    return new t30(i);
  }
  evaluate(e) {
    let r3 = (n) => {
      let i = n.content.evaluate(e);
      return ct(i) === Is ? new gs("", i, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(e) : null) : new gs(fs(i), null, n.scale ? n.scale.evaluate(e) : null, n.font ? n.font.evaluate(e).join(",") : null, n.textColor ? n.textColor.evaluate(e) : null, n.verticalAlign ? n.verticalAlign.evaluate(e) : null);
    };
    return new yr(this.sections.map(r3));
  }
  eachChild(e) {
    for (let r3 of this.sections) e(r3.content), r3.scale && e(r3.scale), r3.font && e(r3.font), r3.textColor && e(r3.textColor), r3.verticalAlign && e(r3.verticalAlign);
  }
  outputDefined() {
    return false;
  }
};
var wd = class t31 {
  constructor(e) {
    this.type = Is, this.input = e;
  }
  static parse(e, r3) {
    if (e.length !== 2) return r3.error("Expected two arguments.");
    let n = r3.parse(e[1], 1, Pe2);
    return n ? new t31(n) : r3.error("No image name provided.");
  }
  evaluate(e) {
    let r3 = this.input.evaluate(e), n = Jt.fromString(r3);
    return n && e.availableImages && (n.available = e.availableImages.indexOf(r3) > -1), n;
  }
  eachChild(e) {
    e(this.input);
  }
  outputDefined() {
    return false;
  }
};
var Td = class t32 {
  constructor(e) {
    this.type = Y, this.input = e;
  }
  static parse(e, r3) {
    if (e.length !== 2) return r3.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
    let n = r3.parse(e[1], 1);
    return n ? n.type.kind !== "array" && n.type.kind !== "string" && n.type.kind !== "value" ? r3.error(`Expected argument of type string or array, but found ${nt(n.type)} instead.`) : new t32(n) : null;
  }
  evaluate(e) {
    let r3 = this.input.evaluate(e);
    if (typeof r3 == "string") return [...r3].length;
    if (Array.isArray(r3)) return r3.length;
    throw new Ke(`Expected value to be of type string or array, but found ${nt(ct(r3))} instead.`);
  }
  eachChild(e) {
    e(this.input);
  }
  outputDefined() {
    return false;
  }
};
var on = 8192;
function GD(t63, e) {
  let r3 = jD(t63[0]), n = XD(t63[1]), i = Math.pow(2, e.z);
  return [Math.round(r3 * i * on), Math.round(n * i * on)];
}
function kd(t63, e) {
  let r3 = Math.pow(2, e.z), n = (t63[0] / on + e.x) / r3, i = (t63[1] / on + e.y) / r3;
  return [HD(n), ZD(i)];
}
function jD(t63) {
  return (180 + t63) / 360;
}
function HD(t63) {
  return t63 * 360 - 180;
}
function XD(t63) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t63 * Math.PI / 360))) / 360;
}
function ZD(t63) {
  return 360 / Math.PI * Math.atan(Math.exp((180 - t63 * 360) * Math.PI / 180)) - 90;
}
function As(t63, e) {
  t63[0] = Math.min(t63[0], e[0]), t63[1] = Math.min(t63[1], e[1]), t63[2] = Math.max(t63[2], e[0]), t63[3] = Math.max(t63[3], e[1]);
}
function _s(t63, e) {
  return !(t63[0] <= e[0] || t63[2] >= e[2] || t63[1] <= e[1] || t63[3] >= e[3]);
}
function qD(t63, e, r3) {
  return e[1] > t63[1] != r3[1] > t63[1] && t63[0] < (r3[0] - e[0]) * (t63[1] - e[1]) / (r3[1] - e[1]) + e[0];
}
function YD(t63, e, r3) {
  let n = t63[0] - e[0], i = t63[1] - e[1], o = t63[0] - r3[0], a = t63[1] - r3[1];
  return n * a - o * i === 0 && n * o <= 0 && i * a <= 0;
}
function zc(t63, e, r3, n) {
  let i = [e[0] - t63[0], e[1] - t63[1]], o = [n[0] - r3[0], n[1] - r3[1]];
  return JD(o, i) === 0 ? false : !!(h_(t63, e, r3, n) && h_(r3, n, t63, e));
}
function WD(t63, e, r3) {
  for (let n of r3) for (let i = 0; i < n.length - 1; ++i) if (zc(t63, e, n[i], n[i + 1])) return true;
  return false;
}
function Wo(t63, e, r3 = false) {
  let n = false;
  for (let i of e) for (let o = 0; o < i.length - 1; o++) {
    if (YD(t63, i[o], i[o + 1])) return r3;
    qD(t63, i[o], i[o + 1]) && (n = !n);
  }
  return n;
}
function $D(t63, e) {
  for (let r3 of e) if (Wo(t63, r3)) return true;
  return false;
}
function N_(t63, e) {
  for (let r3 of t63) if (!Wo(r3, e)) return false;
  for (let r3 = 0; r3 < t63.length - 1; ++r3) if (WD(t63[r3], t63[r3 + 1], e)) return false;
  return true;
}
function KD(t63, e) {
  for (let r3 of e) if (N_(t63, r3)) return true;
  return false;
}
function JD(t63, e) {
  return t63[0] * e[1] - t63[1] * e[0];
}
function h_(t63, e, r3, n) {
  let i = t63[0] - r3[0], o = t63[1] - r3[1], a = e[0] - r3[0], s3 = e[1] - r3[1], l = n[0] - r3[0], u3 = n[1] - r3[1], c = i * u3 - l * o, p = a * u3 - l * s3;
  return c > 0 && p < 0 || c < 0 && p > 0;
}
function Fd(t63, e, r3) {
  let n = [];
  for (let i = 0; i < t63.length; i++) {
    let o = [];
    for (let a = 0; a < t63[i].length; a++) {
      let s3 = GD(t63[i][a], r3);
      As(e, s3), o.push(s3);
    }
    n.push(o);
  }
  return n;
}
function G_(t63, e, r3) {
  let n = [];
  for (let i = 0; i < t63.length; i++) {
    let o = Fd(t63[i], e, r3);
    n.push(o);
  }
  return n;
}
function j_(t63, e, r3, n) {
  if (t63[0] < r3[0] || t63[0] > r3[2]) {
    let i = n * 0.5, o = t63[0] - r3[0] > i ? -n : r3[0] - t63[0] > i ? n : 0;
    o === 0 && (o = t63[0] - r3[2] > i ? -n : r3[2] - t63[0] > i ? n : 0), t63[0] += o;
  }
  As(e, t63);
}
function QD(t63) {
  t63[0] = t63[1] = 1 / 0, t63[2] = t63[3] = -1 / 0;
}
function f_(t63, e, r3, n) {
  let i = Math.pow(2, n.z) * on, o = [n.x * on, n.y * on], a = [];
  for (let s3 of t63) for (let l of s3) {
    let u3 = [l.x + o[0], l.y + o[1]];
    j_(u3, e, r3, i), a.push(u3);
  }
  return a;
}
function m_(t63, e, r3, n) {
  let i = Math.pow(2, n.z) * on, o = [n.x * on, n.y * on], a = [];
  for (let s3 of t63) {
    let l = [];
    for (let u3 of s3) {
      let c = [u3.x + o[0], u3.y + o[1]];
      As(e, c), l.push(c);
    }
    a.push(l);
  }
  if (e[2] - e[0] <= i / 2) {
    QD(e);
    for (let s3 of a) for (let l of s3) j_(l, e, r3, i);
  }
  return a;
}
function eR(t63, e) {
  let r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i = t63.canonicalID();
  if (e.type === "Polygon") {
    let o = Fd(e.coordinates, n, i), a = f_(t63.geometry(), r3, n, i);
    if (!_s(r3, n)) return false;
    for (let s3 of a) if (!Wo(s3, o)) return false;
  }
  if (e.type === "MultiPolygon") {
    let o = G_(e.coordinates, n, i), a = f_(t63.geometry(), r3, n, i);
    if (!_s(r3, n)) return false;
    for (let s3 of a) if (!$D(s3, o)) return false;
  }
  return true;
}
function tR(t63, e) {
  let r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i = t63.canonicalID();
  if (e.type === "Polygon") {
    let o = Fd(e.coordinates, n, i), a = m_(t63.geometry(), r3, n, i);
    if (!_s(r3, n)) return false;
    for (let s3 of a) if (!N_(s3, o)) return false;
  }
  if (e.type === "MultiPolygon") {
    let o = G_(e.coordinates, n, i), a = m_(t63.geometry(), r3, n, i);
    if (!_s(r3, n)) return false;
    for (let s3 of a) if (!KD(s3, o)) return false;
  }
  return true;
}
var vs = class t33 {
  constructor(e, r3) {
    this.type = ge, this.geojson = e, this.geometries = r3;
  }
  static parse(e, r3) {
    if (e.length !== 2) return r3.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
    if (xs(e[1])) {
      let n = e[1];
      if (n.type === "FeatureCollection") {
        let i = [];
        for (let o of n.features) {
          let { type: a, coordinates: s3 } = o.geometry;
          a === "Polygon" && i.push(s3), a === "MultiPolygon" && i.push(...s3);
        }
        if (i.length) {
          let o = { type: "MultiPolygon", coordinates: i };
          return new t33(n, o);
        }
      } else if (n.type === "Feature") {
        let i = n.geometry.type;
        if (i === "Polygon" || i === "MultiPolygon") return new t33(n, n.geometry);
      } else if (n.type === "Polygon" || n.type === "MultiPolygon") return new t33(n, n);
    }
    return r3.error("'within' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(e) {
    if (e.geometry() != null && e.canonicalID() != null) {
      if (e.geometryType() === "Point") return eR(e, this.geometries);
      if (e.geometryType() === "LineString") return tR(e, this.geometries);
    }
    return false;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
var Sc = class {
  constructor(e = [], r3 = (n, i) => n < i ? -1 : n > i ? 1 : 0) {
    if (this.data = e, this.length = this.data.length, this.compare = r3, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
  }
  push(e) {
    this.data.push(e), this._up(this.length++);
  }
  pop() {
    if (this.length === 0) return;
    let e = this.data[0], r3 = this.data.pop();
    return --this.length > 0 && (this.data[0] = r3, this._down(0)), e;
  }
  peek() {
    return this.data[0];
  }
  _up(e) {
    let { data: r3, compare: n } = this, i = r3[e];
    for (; e > 0; ) {
      let o = e - 1 >> 1, a = r3[o];
      if (n(i, a) >= 0) break;
      r3[e] = a, e = o;
    }
    r3[e] = i;
  }
  _down(e) {
    let { data: r3, compare: n } = this, i = this.length >> 1, o = r3[e];
    for (; e < i; ) {
      let a = (e << 1) + 1, s3 = a + 1;
      if (s3 < this.length && n(r3[s3], r3[a]) < 0 && (a = s3), n(r3[a], o) >= 0) break;
      r3[e] = r3[a], e = a;
    }
    r3[e] = o;
  }
};
function H_(t63, e, r3 = 0, n = t63.length - 1, i = rR) {
  for (; n > r3; ) {
    if (n - r3 > 600) {
      let l = n - r3 + 1, u3 = e - r3 + 1, c = Math.log(l), p = 0.5 * Math.exp(2 * c / 3), h = 0.5 * Math.sqrt(c * p * (l - p) / l) * (u3 - l / 2 < 0 ? -1 : 1), f = Math.max(r3, Math.floor(e - u3 * p / l + h)), d = Math.min(n, Math.floor(e + (l - u3) * p / l + h));
      H_(t63, e, f, d, i);
    }
    let o = t63[e], a = r3, s3 = n;
    for (ps2(t63, r3, e), i(t63[n], o) > 0 && ps2(t63, r3, n); a < s3; ) {
      for (ps2(t63, a, s3), a++, s3--; i(t63[a], o) < 0; ) a++;
      for (; i(t63[s3], o) > 0; ) s3--;
    }
    i(t63[r3], o) === 0 ? ps2(t63, r3, s3) : (s3++, ps2(t63, s3, n)), s3 <= e && (r3 = s3 + 1), e <= s3 && (n = s3 - 1);
  }
}
function ps2(t63, e, r3) {
  let n = t63[e];
  t63[e] = t63[r3], t63[r3] = n;
}
function rR(t63, e) {
  return t63 < e ? -1 : t63 > e ? 1 : 0;
}
function Es(t63, e) {
  if (t63.length <= 1) return [t63];
  let n = [], i, o;
  for (let a of t63) {
    let s3 = iR(a);
    s3 !== 0 && (a.area = Math.abs(s3), o === void 0 && (o = s3 < 0), o === s3 < 0 ? (i && n.push(i), i = [a]) : i.push(a));
  }
  if (i && n.push(i), e > 1) for (let a = 0; a < n.length; a++) n[a].length <= e || (H_(n[a], e, 1, n[a].length - 1, nR), n[a] = n[a].slice(0, e));
  return n;
}
function nR(t63, e) {
  return e.area - t63.area;
}
function iR(t63) {
  let e = 0;
  for (let r3 = 0, n = t63.length, i = n - 1, o, a; r3 < n; i = r3++) o = t63[r3], a = t63[i], e += (a.x - o.x) * (o.y + a.y);
  return e;
}
var oR = 6378.137;
var d_ = 1 / 298.257223563;
var y_ = d_ * (2 - d_);
var g_ = Math.PI / 180;
var Ps = class {
  constructor(e) {
    let r3 = g_ * oR * 1e3, n = Math.cos(e * g_), i = 1 / (1 - y_ * (1 - n * n)), o = Math.sqrt(i);
    this.kx = r3 * o * n, this.ky = r3 * o * i * (1 - y_);
  }
  distance(e, r3) {
    let n = this.wrap(e[0] - r3[0]) * this.kx, i = (e[1] - r3[1]) * this.ky;
    return Math.sqrt(n * n + i * i);
  }
  pointOnLine(e, r3) {
    let n = 1 / 0, i, o, a, s3;
    for (let l = 0; l < e.length - 1; l++) {
      let u3 = e[l][0], c = e[l][1], p = this.wrap(e[l + 1][0] - u3) * this.kx, h = (e[l + 1][1] - c) * this.ky, f = 0;
      (p !== 0 || h !== 0) && (f = (this.wrap(r3[0] - u3) * this.kx * p + (r3[1] - c) * this.ky * h) / (p * p + h * h), f > 1 ? (u3 = e[l + 1][0], c = e[l + 1][1]) : f > 0 && (u3 += p / this.kx * f, c += h / this.ky * f)), p = this.wrap(r3[0] - u3) * this.kx, h = (r3[1] - c) * this.ky;
      let d = p * p + h * h;
      d < n && (n = d, i = u3, o = c, a = l, s3 = f);
    }
    return { point: [i, o], index: a, t: Math.max(0, Math.min(1, s3)) };
  }
  wrap(e) {
    for (; e < -180; ) e += 360;
    for (; e > 180; ) e -= 360;
    return e;
  }
};
var Sd = 100;
var Cd = 50;
function X_(t63, e) {
  return e[0] - t63[0];
}
function Cc(t63) {
  return t63[1] - t63[0] + 1;
}
function Sn(t63, e) {
  return t63[1] >= t63[0] && t63[1] < e;
}
function Md(t63, e) {
  if (t63[0] > t63[1]) return [null, null];
  let r3 = Cc(t63);
  if (e) {
    if (r3 === 2) return [t63, null];
    let i = Math.floor(r3 / 2);
    return [[t63[0], t63[0] + i], [t63[0] + i, t63[1]]];
  }
  if (r3 === 1) return [t63, null];
  let n = Math.floor(r3 / 2) - 1;
  return [[t63[0], t63[0] + n], [t63[0] + n + 1, t63[1]]];
}
function Id(t63, e) {
  if (!Sn(e, t63.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  let r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  for (let n = e[0]; n <= e[1]; ++n) As(r3, t63[n]);
  return r3;
}
function Ad(t63) {
  let e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  for (let r3 of t63) for (let n of r3) As(e, n);
  return e;
}
function x_(t63) {
  return t63[0] !== -1 / 0 && t63[1] !== -1 / 0 && t63[2] !== 1 / 0 && t63[3] !== 1 / 0;
}
function Od(t63, e, r3) {
  if (!x_(t63) || !x_(e)) return NaN;
  let n = 0, i = 0;
  return t63[2] < e[0] && (n = e[0] - t63[2]), t63[0] > e[2] && (n = t63[0] - e[2]), t63[1] > e[3] && (i = t63[1] - e[3]), t63[3] < e[1] && (i = e[1] - t63[3]), r3.distance([0, 0], [n, i]);
}
function Zi(t63, e, r3) {
  let n = r3.pointOnLine(e, t63);
  return r3.distance(t63, n.point);
}
function Bd(t63, e, r3, n, i) {
  let o = Math.min(Zi(t63, [r3, n], i), Zi(e, [r3, n], i)), a = Math.min(Zi(r3, [t63, e], i), Zi(n, [t63, e], i));
  return Math.min(o, a);
}
function aR(t63, e, r3, n, i) {
  if (!(Sn(e, t63.length) && Sn(n, r3.length))) return 1 / 0;
  let a = 1 / 0;
  for (let s3 = e[0]; s3 < e[1]; ++s3) {
    let l = t63[s3], u3 = t63[s3 + 1];
    for (let c = n[0]; c < n[1]; ++c) {
      let p = r3[c], h = r3[c + 1];
      if (zc(l, u3, p, h)) return 0;
      a = Math.min(a, Bd(l, u3, p, h, i));
    }
  }
  return a;
}
function sR(t63, e, r3, n, i) {
  if (!(Sn(e, t63.length) && Sn(n, r3.length))) return NaN;
  let a = 1 / 0;
  for (let s3 = e[0]; s3 <= e[1]; ++s3) for (let l = n[0]; l <= n[1]; ++l) if (a = Math.min(a, i.distance(t63[s3], r3[l])), a === 0) return a;
  return a;
}
function lR(t63, e, r3) {
  if (Wo(t63, e, true)) return 0;
  let n = 1 / 0;
  for (let i of e) {
    let o = i[0], a = i[i.length - 1];
    if (o !== a && (n = Math.min(n, Zi(t63, [a, o], r3)), n === 0)) return n;
    let s3 = r3.pointOnLine(i, t63);
    if (n = Math.min(n, r3.distance(t63, s3.point)), n === 0) return n;
  }
  return n;
}
function uR(t63, e, r3, n) {
  if (!Sn(e, t63.length)) return NaN;
  for (let o = e[0]; o <= e[1]; ++o) if (Wo(t63[o], r3, true)) return 0;
  let i = 1 / 0;
  for (let o = e[0]; o < e[1]; ++o) {
    let a = t63[o], s3 = t63[o + 1];
    for (let l of r3) for (let u3 = 0, c = l.length, p = c - 1; u3 < c; p = u3++) {
      let h = l[p], f = l[u3];
      if (zc(a, s3, h, f)) return 0;
      i = Math.min(i, Bd(a, s3, h, f, n));
    }
  }
  return i;
}
function b_(t63, e) {
  for (let r3 of t63) for (let n of r3) if (Wo(n, e, true)) return true;
  return false;
}
function cR(t63, e, r3, n = 1 / 0) {
  let i = Ad(t63), o = Ad(e);
  if (n !== 1 / 0 && Od(i, o, r3) >= n) return n;
  if (_s(i, o)) {
    if (b_(t63, e)) return 0;
  } else if (b_(e, t63)) return 0;
  let a = 1 / 0;
  for (let s3 of t63) for (let l = 0, u3 = s3.length, c = u3 - 1; l < u3; c = l++) {
    let p = s3[c], h = s3[l];
    for (let f of e) for (let d = 0, g = f.length, x = g - 1; d < g; x = d++) {
      let b = f[x], v3 = f[d];
      if (zc(p, h, b, v3)) return 0;
      a = Math.min(a, Bd(p, h, b, v3, r3));
    }
  }
  return a;
}
function __(t63, e, r3, n, i, o) {
  if (!o) return;
  let a = Od(Id(n, o), i, r3);
  a < e && t63.push([a, o, [0, 0]]);
}
function yc2(t63, e, r3, n, i, o, a) {
  if (!o || !a) return;
  let s3 = Od(Id(n, o), Id(i, a), r3);
  s3 < e && t63.push([s3, o, a]);
}
function Mc(t63, e, r3, n, i = 1 / 0) {
  let o = Math.min(n.distance(t63[0], r3[0][0]), i);
  if (o === 0) return o;
  let a = new Sc([[0, [0, t63.length - 1], [0, 0]]], X_), s3 = Ad(r3);
  for (; a.length > 0; ) {
    let l = a.pop();
    if (l[0] >= o) continue;
    let u3 = l[1], c = e ? Cd : Sd;
    if (Cc(u3) <= c) {
      if (!Sn(u3, t63.length)) return NaN;
      if (e) {
        let p = uR(t63, u3, r3, n);
        if (isNaN(p) || p === 0) return p;
        o = Math.min(o, p);
      } else for (let p = u3[0]; p <= u3[1]; ++p) {
        let h = lR(t63[p], r3, n);
        if (o = Math.min(o, h), o === 0) return 0;
      }
    } else {
      let p = Md(u3, e);
      __(a, o, n, t63, s3, p[0]), __(a, o, n, t63, s3, p[1]);
    }
  }
  return o;
}
function Ic(t63, e, r3, n, i, o = 1 / 0) {
  let a = Math.min(o, i.distance(t63[0], r3[0]));
  if (a === 0) return a;
  let s3 = new Sc([[0, [0, t63.length - 1], [0, r3.length - 1]]], X_);
  for (; s3.length > 0; ) {
    let l = s3.pop();
    if (l[0] >= a) continue;
    let u3 = l[1], c = l[2], p = e ? Cd : Sd, h = n ? Cd : Sd;
    if (Cc(u3) <= p && Cc(c) <= h) {
      if (!Sn(u3, t63.length) && Sn(c, r3.length)) return NaN;
      let f;
      if (e && n) f = aR(t63, u3, r3, c, i), a = Math.min(a, f);
      else if (e && !n) {
        let d = t63.slice(u3[0], u3[1] + 1);
        for (let g = c[0]; g <= c[1]; ++g) if (f = Zi(r3[g], d, i), a = Math.min(a, f), a === 0) return a;
      } else if (!e && n) {
        let d = r3.slice(c[0], c[1] + 1);
        for (let g = u3[0]; g <= u3[1]; ++g) if (f = Zi(t63[g], d, i), a = Math.min(a, f), a === 0) return a;
      } else f = sR(t63, u3, r3, c, i), a = Math.min(a, f);
    } else {
      let f = Md(u3, e), d = Md(c, n);
      yc2(s3, a, i, t63, r3, f[0], d[0]), yc2(s3, a, i, t63, r3, f[0], d[1]), yc2(s3, a, i, t63, r3, f[1], d[0]), yc2(s3, a, i, t63, r3, f[1], d[1]);
    }
  }
  return a;
}
function pR(t63, e) {
  let r3 = t63.geometry(), n = r3.flat().map((a) => kd([a.x, a.y], t63.canonical));
  if (r3.length === 0) return NaN;
  let i = new Ps(n[0][1]), o = 1 / 0;
  for (let a of e) {
    switch (a.type) {
      case "Point":
        o = Math.min(o, Ic(n, false, [a.coordinates], false, i, o));
        break;
      case "LineString":
        o = Math.min(o, Ic(n, false, a.coordinates, true, i, o));
        break;
      case "Polygon":
        o = Math.min(o, Mc(n, false, a.coordinates, i, o));
        break;
    }
    if (o === 0) return o;
  }
  return o;
}
function hR(t63, e) {
  let r3 = t63.geometry(), n = r3.flat().map((a) => kd([a.x, a.y], t63.canonical));
  if (r3.length === 0) return NaN;
  let i = new Ps(n[0][1]), o = 1 / 0;
  for (let a of e) {
    switch (a.type) {
      case "Point":
        o = Math.min(o, Ic(n, true, [a.coordinates], false, i, o));
        break;
      case "LineString":
        o = Math.min(o, Ic(n, true, a.coordinates, true, i, o));
        break;
      case "Polygon":
        o = Math.min(o, Mc(n, true, a.coordinates, i, o));
        break;
    }
    if (o === 0) return o;
  }
  return o;
}
function fR(t63, e) {
  let r3 = t63.geometry();
  if (r3.length === 0 || r3[0].length === 0) return NaN;
  let n = Es(r3, 0).map((a) => a.map((s3) => s3.map((l) => kd([l.x, l.y], t63.canonical)))), i = new Ps(n[0][0][0][1]), o = 1 / 0;
  for (let a of e) for (let s3 of n) {
    switch (a.type) {
      case "Point":
        o = Math.min(o, Mc([a.coordinates], false, s3, i, o));
        break;
      case "LineString":
        o = Math.min(o, Mc(a.coordinates, true, s3, i, o));
        break;
      case "Polygon":
        o = Math.min(o, cR(s3, a.coordinates, i, o));
        break;
    }
    if (o === 0) return o;
  }
  return o;
}
function hd(t63) {
  return t63.type === "MultiPolygon" ? t63.coordinates.map((e) => ({ type: "Polygon", coordinates: e })) : t63.type === "MultiLineString" ? t63.coordinates.map((e) => ({ type: "LineString", coordinates: e })) : t63.type === "MultiPoint" ? t63.coordinates.map((e) => ({ type: "Point", coordinates: e })) : [t63];
}
var ws = class t34 {
  constructor(e, r3) {
    this.type = Y, this.geojson = e, this.geometries = r3;
  }
  static parse(e, r3) {
    if (e.length !== 2) return r3.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);
    if (xs(e[1])) {
      let n = e[1];
      if (n.type === "FeatureCollection") return new t34(n, n.features.map((i) => hd(i.geometry)).flat());
      if (n.type === "Feature") return new t34(n, hd(n.geometry));
      if ("type" in n && "coordinates" in n) return new t34(n, hd(n));
    }
    return r3.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(e) {
    if (e.geometry() != null && e.canonicalID() != null) {
      if (e.geometryType() === "Point") return pR(e, this.geometries);
      if (e.geometryType() === "LineString") return hR(e, this.geometries);
      if (e.geometryType() === "Polygon") return fR(e, this.geometries);
    }
    return NaN;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
var Ts = class t35 {
  constructor(e) {
    this.type = me, this.key = e;
  }
  static parse(e, r3) {
    if (e.length !== 2) return r3.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
    let n = e[1];
    return n == null ? r3.error("Global state property must be defined.") : typeof n != "string" ? r3.error(`Global state property must be string, but found ${typeof e[1]} instead.`) : new t35(n);
  }
  evaluate(e) {
    var r3;
    let n = (r3 = e.globals) === null || r3 === void 0 ? void 0 : r3.globalState;
    return !n || Object.keys(n).length === 0 ? null : hs(n, this.key);
  }
  eachChild() {
  }
  outputDefined() {
    return false;
  }
};
var Ji = { "==": OD, "!=": BD, ">": VD, "<": zD, ">=": ND, "<=": UD, array: Xr, at: yd, boolean: Xr, case: _d, coalesce: wc, collator: Tc, format: bs, image: wd, in: gd, "index-of": xd, interpolate: jt, "interpolate-hcl": jt, "interpolate-lab": jt, length: Td, let: vc, literal: ti, match: bd, number: Xr, "number-format": Pd, object: Xr, slice: vd, step: Ho, string: Xr, "to-boolean": Qn, "to-color": Qn, "to-number": Qn, "to-string": Qn, var: Pc, within: vs, distance: ws, "global-state": Ts };
var ln2 = class t36 {
  constructor(e, r3, n, i) {
    this.name = e, this.type = r3, this._evaluate = n, this.args = i;
  }
  evaluate(e) {
    return this._evaluate(e, this.args);
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return false;
  }
  static parse(e, r3) {
    let n = e[0], i = t36.definitions[n];
    if (!i) return r3.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
    let o = Array.isArray(i) ? i[0] : i.type, a = Array.isArray(i) ? [[i[1], i[2]]] : i.overloads, s3 = a.filter(([u3]) => !Array.isArray(u3) || u3.length === e.length - 1), l = null;
    for (let [u3, c] of s3) {
      l = new _c(r3.registry, Ac, r3.path, null, r3.scope);
      let p = [], h = false;
      for (let f = 1; f < e.length; f++) {
        let d = e[f], g = Array.isArray(u3) ? u3[f - 1] : u3.type, x = l.parse(d, 1 + p.length, g);
        if (!x) {
          h = true;
          break;
        }
        p.push(x);
      }
      if (!h) {
        if (Array.isArray(u3) && u3.length !== p.length) {
          l.error(`Expected ${u3.length} arguments, but found ${p.length} instead.`);
          continue;
        }
        for (let f = 0; f < p.length; f++) {
          let d = Array.isArray(u3) ? u3[f] : u3.type, g = p[f];
          l.concat(f + 1).checkSubtype(d, g.type);
        }
        if (l.errors.length === 0) return new t36(n, o, c, p);
      }
    }
    if (s3.length === 1) r3.errors.push(...l.errors);
    else {
      let c = (s3.length ? s3 : a).map(([h]) => dR(h)).join(" | "), p = [];
      for (let h = 1; h < e.length; h++) {
        let f = r3.parse(e[h], 1 + p.length);
        if (!f) return null;
        p.push(nt(f.type));
      }
      r3.error(`Expected arguments of type ${c}, but found (${p.join(", ")}) instead.`);
    }
    return null;
  }
  static register(e, r3) {
    t36.definitions = r3;
    for (let n in r3) e[n] = t36;
  }
};
function v_(t63, [e, r3, n, i]) {
  e = e.evaluate(t63), r3 = r3.evaluate(t63), n = n.evaluate(t63);
  let o = i ? i.evaluate(t63) : 1, a = z_(e, r3, n, o);
  if (a) throw new Ke(a);
  return new K(e / 255, r3 / 255, n / 255, o, false);
}
function P_(t63, e) {
  return t63 in e;
}
function fd(t63, e) {
  let r3 = e[t63];
  return typeof r3 > "u" ? null : r3;
}
function mR(t63, e, r3, n) {
  for (; r3 <= n; ) {
    let i = r3 + n >> 1;
    if (e[i] === t63) return true;
    e[i] > t63 ? n = i - 1 : r3 = i + 1;
  }
  return false;
}
function Xi(t63) {
  return { type: t63 };
}
ln2.register(Ji, { error: [aD, [Pe2], (t63, [e]) => {
  throw new Ke(e.evaluate(t63));
}], typeof: [Pe2, [me], (t63, [e]) => nt(ct(e.evaluate(t63)))], "to-rgba": [dr(Y, 4), [Br], (t63, [e]) => {
  let [r3, n, i, o] = e.evaluate(t63).rgb;
  return [r3 * 255, n * 255, i * 255, o];
}], rgb: [Br, [Y, Y, Y], v_], rgba: [Br, [Y, Y, Y, Y], v_], has: { type: ge, overloads: [[[Pe2], (t63, [e]) => P_(e.evaluate(t63), t63.properties())], [[Pe2, qi], (t63, [e, r3]) => P_(e.evaluate(t63), r3.evaluate(t63))]] }, get: { type: me, overloads: [[[Pe2], (t63, [e]) => fd(e.evaluate(t63), t63.properties())], [[Pe2, qi], (t63, [e, r3]) => fd(e.evaluate(t63), r3.evaluate(t63))]] }, "feature-state": [me, [Pe2], (t63, [e]) => fd(e.evaluate(t63), t63.featureState || {})], properties: [qi, [], (t63) => t63.properties()], "geometry-type": [Pe2, [], (t63) => t63.geometryType()], id: [me, [], (t63) => t63.id()], zoom: [Y, [], (t63) => t63.globals.zoom], "heatmap-density": [Y, [], (t63) => t63.globals.heatmapDensity || 0], elevation: [Y, [], (t63) => t63.globals.elevation || 0], "line-progress": [Y, [], (t63) => t63.globals.lineProgress || 0], accumulated: [me, [], (t63) => t63.globals.accumulated === void 0 ? null : t63.globals.accumulated], "+": [Y, Xi(Y), (t63, e) => {
  let r3 = 0;
  for (let n of e) r3 += n.evaluate(t63);
  return r3;
}], "*": [Y, Xi(Y), (t63, e) => {
  let r3 = 1;
  for (let n of e) r3 *= n.evaluate(t63);
  return r3;
}], "-": { type: Y, overloads: [[[Y, Y], (t63, [e, r3]) => e.evaluate(t63) - r3.evaluate(t63)], [[Y], (t63, [e]) => -e.evaluate(t63)]] }, "/": [Y, [Y, Y], (t63, [e, r3]) => e.evaluate(t63) / r3.evaluate(t63)], "%": [Y, [Y, Y], (t63, [e, r3]) => e.evaluate(t63) % r3.evaluate(t63)], ln2: [Y, [], () => Math.LN2], pi: [Y, [], () => Math.PI], e: [Y, [], () => Math.E], "^": [Y, [Y, Y], (t63, [e, r3]) => Math.pow(e.evaluate(t63), r3.evaluate(t63))], sqrt: [Y, [Y], (t63, [e]) => Math.sqrt(e.evaluate(t63))], log10: [Y, [Y], (t63, [e]) => Math.log(e.evaluate(t63)) / Math.LN10], ln: [Y, [Y], (t63, [e]) => Math.log(e.evaluate(t63))], log2: [Y, [Y], (t63, [e]) => Math.log(e.evaluate(t63)) / Math.LN2], sin: [Y, [Y], (t63, [e]) => Math.sin(e.evaluate(t63))], cos: [Y, [Y], (t63, [e]) => Math.cos(e.evaluate(t63))], tan: [Y, [Y], (t63, [e]) => Math.tan(e.evaluate(t63))], asin: [Y, [Y], (t63, [e]) => Math.asin(e.evaluate(t63))], acos: [Y, [Y], (t63, [e]) => Math.acos(e.evaluate(t63))], atan: [Y, [Y], (t63, [e]) => Math.atan(e.evaluate(t63))], min: [Y, Xi(Y), (t63, e) => Math.min(...e.map((r3) => r3.evaluate(t63)))], max: [Y, Xi(Y), (t63, e) => Math.max(...e.map((r3) => r3.evaluate(t63)))], abs: [Y, [Y], (t63, [e]) => Math.abs(e.evaluate(t63))], round: [Y, [Y], (t63, [e]) => {
  let r3 = e.evaluate(t63);
  return r3 < 0 ? -Math.round(-r3) : Math.round(r3);
}], floor: [Y, [Y], (t63, [e]) => Math.floor(e.evaluate(t63))], ceil: [Y, [Y], (t63, [e]) => Math.ceil(e.evaluate(t63))], "filter-==": [ge, [Pe2, me], (t63, [e, r3]) => t63.properties()[e.value] === r3.value], "filter-id-==": [ge, [me], (t63, [e]) => t63.id() === e.value], "filter-type-==": [ge, [Pe2], (t63, [e]) => t63.geometryType() === e.value], "filter-<": [ge, [Pe2, me], (t63, [e, r3]) => {
  let n = t63.properties()[e.value], i = r3.value;
  return typeof n == typeof i && n < i;
}], "filter-id-<": [ge, [me], (t63, [e]) => {
  let r3 = t63.id(), n = e.value;
  return typeof r3 == typeof n && r3 < n;
}], "filter->": [ge, [Pe2, me], (t63, [e, r3]) => {
  let n = t63.properties()[e.value], i = r3.value;
  return typeof n == typeof i && n > i;
}], "filter-id->": [ge, [me], (t63, [e]) => {
  let r3 = t63.id(), n = e.value;
  return typeof r3 == typeof n && r3 > n;
}], "filter-<=": [ge, [Pe2, me], (t63, [e, r3]) => {
  let n = t63.properties()[e.value], i = r3.value;
  return typeof n == typeof i && n <= i;
}], "filter-id-<=": [ge, [me], (t63, [e]) => {
  let r3 = t63.id(), n = e.value;
  return typeof r3 == typeof n && r3 <= n;
}], "filter->=": [ge, [Pe2, me], (t63, [e, r3]) => {
  let n = t63.properties()[e.value], i = r3.value;
  return typeof n == typeof i && n >= i;
}], "filter-id->=": [ge, [me], (t63, [e]) => {
  let r3 = t63.id(), n = e.value;
  return typeof r3 == typeof n && r3 >= n;
}], "filter-has": [ge, [me], (t63, [e]) => e.value in t63.properties()], "filter-has-id": [ge, [], (t63) => t63.id() !== null && t63.id() !== void 0], "filter-type-in": [ge, [dr(Pe2)], (t63, [e]) => e.value.indexOf(t63.geometryType()) >= 0], "filter-id-in": [ge, [dr(me)], (t63, [e]) => e.value.indexOf(t63.id()) >= 0], "filter-in-small": [ge, [Pe2, dr(me)], (t63, [e, r3]) => r3.value.indexOf(t63.properties()[e.value]) >= 0], "filter-in-large": [ge, [Pe2, dr(me)], (t63, [e, r3]) => mR(t63.properties()[e.value], r3.value, 0, r3.value.length - 1)], all: { type: ge, overloads: [[[ge, ge], (t63, [e, r3]) => e.evaluate(t63) && r3.evaluate(t63)], [Xi(ge), (t63, e) => {
  for (let r3 of e) if (!r3.evaluate(t63)) return false;
  return true;
}]] }, any: { type: ge, overloads: [[[ge, ge], (t63, [e, r3]) => e.evaluate(t63) || r3.evaluate(t63)], [Xi(ge), (t63, e) => {
  for (let r3 of e) if (r3.evaluate(t63)) return true;
  return false;
}]] }, "!": [ge, [ge], (t63, [e]) => !e.evaluate(t63)], "is-supported-script": [ge, [Pe2], (t63, [e]) => {
  let r3 = t63.globals && t63.globals.isSupportedScript;
  return r3 ? r3(e.evaluate(t63)) : true;
}], upcase: [Pe2, [Pe2], (t63, [e]) => e.evaluate(t63).toUpperCase()], downcase: [Pe2, [Pe2], (t63, [e]) => e.evaluate(t63).toLowerCase()], concat: [Pe2, Xi(me), (t63, e) => e.map((r3) => fs(r3.evaluate(t63))).join("")], "resolved-locale": [Pe2, [Rc], (t63, [e]) => e.evaluate(t63).resolvedLocale()] });
function dR(t63) {
  return Array.isArray(t63) ? `(${t63.map(nt).join(", ")})` : `(${nt(t63.type)}...)`;
}
function Ac(t63) {
  if (t63 instanceof Pc) return Ac(t63.boundExpression);
  if (t63 instanceof ln2 && t63.name === "error") return false;
  if (t63 instanceof Tc) return false;
  if (t63 instanceof vs) return false;
  if (t63 instanceof ws) return false;
  if (t63 instanceof Ts) return false;
  let e = t63 instanceof Qn || t63 instanceof Xr, r3 = true;
  return t63.eachChild((n) => {
    e ? r3 = r3 && Ac(n) : r3 = r3 && n instanceof ti;
  }), r3 ? Vc(t63) && Uc(t63, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]) : false;
}
function Vc(t63) {
  if (t63 instanceof ln2) {
    if (t63.name === "get" && t63.args.length === 1) return false;
    if (t63.name === "feature-state") return false;
    if (t63.name === "has" && t63.args.length === 1) return false;
    if (t63.name === "properties" || t63.name === "geometry-type" || t63.name === "id") return false;
    if (/^filter-/.test(t63.name)) return false;
  }
  if (t63 instanceof vs || t63 instanceof ws) return false;
  let e = true;
  return t63.eachChild((r3) => {
    e && !Vc(r3) && (e = false);
  }), e;
}
function Ss(t63) {
  if (t63 instanceof ln2 && t63.name === "feature-state") return false;
  let e = true;
  return t63.eachChild((r3) => {
    e && !Ss(r3) && (e = false);
  }), e;
}
function Uc(t63, e) {
  if (t63 instanceof ln2 && e.indexOf(t63.name) >= 0) return false;
  let r3 = true;
  return t63.eachChild((n) => {
    r3 && !Uc(n, e) && (r3 = false);
  }), r3;
}
function Ed(t63) {
  return { result: "success", value: t63 };
}
function Uo(t63) {
  return { result: "error", value: t63 };
}
function ri(t63) {
  return t63["property-type"] === "data-driven" || t63["property-type"] === "cross-faded-data-driven";
}
function Z_(t63) {
  return !!t63.expression && t63.expression.parameters.indexOf("zoom") > -1;
}
function zd(t63) {
  return !!t63.expression && t63.expression.interpolated;
}
function we(t63) {
  return t63 instanceof Number ? "number" : t63 instanceof String ? "string" : t63 instanceof Boolean ? "boolean" : Array.isArray(t63) ? "array" : t63 === null ? "null" : typeof t63;
}
function Nc(t63) {
  return typeof t63 == "object" && t63 !== null && !Array.isArray(t63) && ct(t63) === qi;
}
function yR(t63) {
  return t63;
}
function gR(t63) {
  switch (t63.type) {
    case "color":
      return K.parse;
    case "padding":
      return zr.parse;
    case "numberArray":
      return Vr.parse;
    case "colorArray":
      return Kt.parse;
    default:
      return null;
  }
}
function xR(t63) {
  switch (t63) {
    case "exponential":
      return Y_;
    case "interval":
      return _R;
    case "categorical":
      return bR;
    case "identity":
      return vR;
    default:
      throw new Error(`Unknown function type "${t63}"`);
  }
}
function q_(t63, e) {
  let r3 = t63.stops && typeof t63.stops[0][0] == "object", n = r3 || t63.property !== void 0, i = r3 || !n, o = t63.type || (zd(e) ? "exponential" : "interval"), a = gR(e);
  if (a && (t63 = Go({}, t63), t63.stops && (t63.stops = t63.stops.map((c) => [c[0], a(c[1])])), t63.default ? t63.default = a(t63.default) : t63.default = a(e.default)), t63.colorSpace && !gD(t63.colorSpace)) throw new Error(`Unknown color space: "${t63.colorSpace}"`);
  let s3 = xR(o), l, u3;
  if (o === "categorical") {
    l = /* @__PURE__ */ Object.create(null);
    for (let c of t63.stops) l[c[0]] = c[1];
    u3 = typeof t63.stops[0][0];
  }
  if (r3) {
    let c = {}, p = [];
    for (let d = 0; d < t63.stops.length; d++) {
      let g = t63.stops[d], x = g[0].zoom;
      c[x] === void 0 && (c[x] = { zoom: x, type: t63.type, property: t63.property, default: t63.default, stops: [] }, p.push(x)), c[x].stops.push([g[0].value, g[1]]);
    }
    let h = [];
    for (let d of p) h.push([c[d].zoom, q_(c[d], e)]);
    let f = { name: "linear" };
    return { kind: "composite", interpolationType: f, interpolationFactor: jt.interpolationFactor.bind(void 0, f), zoomStops: h.map((d) => d[0]), evaluate({ zoom: d }, g) {
      return Y_({ stops: h, base: t63.base }, e, d).evaluate(d, g);
    } };
  } else if (i) {
    let c = o === "exponential" ? { name: "exponential", base: t63.base !== void 0 ? t63.base : 1 } : null;
    return { kind: "camera", interpolationType: c, interpolationFactor: jt.interpolationFactor.bind(void 0, c), zoomStops: t63.stops.map((p) => p[0]), evaluate: ({ zoom: p }) => s3(t63, e, p, l, u3) };
  } else return { kind: "source", evaluate(c, p) {
    let h = p && p.properties ? p.properties[t63.property] : void 0;
    return h === void 0 ? Ls2(t63.default, e.default) : s3(t63, e, h, l, u3);
  } };
}
function Ls2(t63, e, r3) {
  if (t63 !== void 0) return t63;
  if (e !== void 0) return e;
  if (r3 !== void 0) return r3;
}
function bR(t63, e, r3, n, i) {
  let o = typeof r3 === i ? n[r3] : void 0;
  return Ls2(o, t63.default, e.default);
}
function _R(t63, e, r3) {
  if (we(r3) !== "number") return Ls2(t63.default, e.default);
  let n = t63.stops.length;
  if (n === 1 || r3 <= t63.stops[0][0]) return t63.stops[0][1];
  if (r3 >= t63.stops[n - 1][0]) return t63.stops[n - 1][1];
  let i = Bc(t63.stops.map((o) => o[0]), r3);
  return t63.stops[i][1];
}
function Y_(t63, e, r3) {
  let n = t63.base !== void 0 ? t63.base : 1;
  if (we(r3) !== "number") return Ls2(t63.default, e.default);
  let i = t63.stops.length;
  if (i === 1 || r3 <= t63.stops[0][0]) return t63.stops[0][1];
  if (r3 >= t63.stops[i - 1][0]) return t63.stops[i - 1][1];
  let o = Bc(t63.stops.map((c) => c[0]), r3), a = PR(r3, n, t63.stops[o][0], t63.stops[o + 1][0]), s3 = t63.stops[o][1], l = t63.stops[o + 1][1], u3 = Fe[e.type] || yR;
  return typeof s3.evaluate == "function" ? { evaluate(...c) {
    let p = s3.evaluate.apply(void 0, c), h = l.evaluate.apply(void 0, c);
    if (!(p === void 0 || h === void 0)) return u3(p, h, a, t63.colorSpace);
  } } : u3(s3, l, a, t63.colorSpace);
}
function vR(t63, e, r3) {
  switch (e.type) {
    case "color":
      r3 = K.parse(r3);
      break;
    case "formatted":
      r3 = yr.fromString(r3.toString());
      break;
    case "resolvedImage":
      r3 = Jt.fromString(r3.toString());
      break;
    case "padding":
      r3 = zr.parse(r3);
      break;
    case "colorArray":
      r3 = Kt.parse(r3);
      break;
    case "numberArray":
      r3 = Vr.parse(r3);
      break;
    default:
      we(r3) !== e.type && (e.type !== "enum" || !e.values[r3]) && (r3 = void 0);
  }
  return Ls2(r3, t63.default, e.default);
}
function PR(t63, e, r3, n) {
  let i = n - r3, o = t63 - r3;
  return i === 0 ? 0 : e === 1 ? o / i : (Math.pow(e, o) - 1) / (Math.pow(e, i) - 1);
}
var Wi = class {
  constructor(e, r3) {
    this.expression = e, this._warningHistory = {}, this._evaluator = new bc(), this._defaultValue = r3 ? TR(r3) : null, this._enumValues = r3 && r3.type === "enum" ? r3.values : null;
  }
  evaluateWithoutErrorHandling(e, r3, n, i, o, a) {
    return this._evaluator.globals = e, this._evaluator.feature = r3, this._evaluator.featureState = n, this._evaluator.canonical = i, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = a, this.expression.evaluate(this._evaluator);
  }
  evaluate(e, r3, n, i, o, a) {
    this._evaluator.globals = e, this._evaluator.feature = r3 || null, this._evaluator.featureState = n || null, this._evaluator.canonical = i, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = a || null;
    try {
      let s3 = this.expression.evaluate(this._evaluator);
      if (s3 == null || typeof s3 == "number" && s3 !== s3) return this._defaultValue;
      if (this._enumValues && !(s3 in this._enumValues)) throw new Ke(`Expected value to be one of ${Object.keys(this._enumValues).map((l) => JSON.stringify(l)).join(", ")}, but found ${JSON.stringify(s3)} instead.`);
      return s3;
    } catch (s3) {
      return this._warningHistory[s3.message] || (this._warningHistory[s3.message] = true, typeof console < "u" && console.warn(s3.message)), this._defaultValue;
    }
  }
};
function Ds(t63) {
  return Array.isArray(t63) && t63.length > 0 && typeof t63[0] == "string" && t63[0] in Ji;
}
function Vd(t63, e) {
  let r3 = new _c(Ji, Ac, [], e ? wR(e) : void 0), n = r3.parse(t63, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
  return n ? Ed(new Wi(n, e)) : Uo(r3.errors);
}
var un = class {
  constructor(e, r3) {
    this.kind = e, this._styleExpression = r3, this.isStateDependent = e !== "constant" && !Ss(r3.expression), this.globalStateRefs = Gc(r3.expression);
  }
  evaluateWithoutErrorHandling(e, r3, n, i, o, a) {
    return this._styleExpression.evaluateWithoutErrorHandling(e, r3, n, i, o, a);
  }
  evaluate(e, r3, n, i, o, a) {
    return this._styleExpression.evaluate(e, r3, n, i, o, a);
  }
};
var ni2 = class {
  constructor(e, r3, n, i) {
    this.kind = e, this.zoomStops = n, this._styleExpression = r3, this.isStateDependent = e !== "camera" && !Ss(r3.expression), this.globalStateRefs = Gc(r3.expression), this.interpolationType = i;
  }
  evaluateWithoutErrorHandling(e, r3, n, i, o, a) {
    return this._styleExpression.evaluateWithoutErrorHandling(e, r3, n, i, o, a);
  }
  evaluate(e, r3, n, i, o, a) {
    return this._styleExpression.evaluate(e, r3, n, i, o, a);
  }
  interpolationFactor(e, r3, n) {
    return this.interpolationType ? jt.interpolationFactor(this.interpolationType, e, r3, n) : 0;
  }
};
function W_(t63) {
  return t63._styleExpression !== void 0;
}
function $_(t63, e) {
  let r3 = Vd(t63, e);
  if (r3.result === "error") return r3;
  let n = r3.value.expression, i = Vc(n);
  if (!i && !ri(e)) return Uo([new Fr("", "data expressions not supported")]);
  let o = Uc(n, ["zoom"]);
  if (!o && !Z_(e)) return Uo([new Fr("", "zoom expressions not supported")]);
  let a = xc(n);
  if (!a && !o) return Uo([new Fr("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
  if (a instanceof Fr) return Uo([a]);
  if (a instanceof jt && !zd(e)) return Uo([new Fr("", '"interpolate" expressions cannot be used with this property')]);
  if (!a) return Ed(i ? new un("constant", r3.value) : new un("source", r3.value));
  let s3 = a instanceof jt ? a.interpolation : void 0;
  return Ed(i ? new ni2("camera", r3.value, a.labels, s3) : new ni2("composite", r3.value, a.labels, s3));
}
var Cs2 = class t37 {
  constructor(e, r3) {
    this._parameters = e, this._specification = r3, Go(this, q_(this._parameters, this._specification));
  }
  static deserialize(e) {
    return new t37(e._parameters, e._specification);
  }
  static serialize(e) {
    return { _parameters: e._parameters, _specification: e._specification };
  }
};
function K_(t63, e) {
  if (Nc(t63)) return new Cs2(t63, e);
  if (Ds(t63)) {
    let r3 = $_(t63, e);
    if (r3.result === "error") throw new Error(r3.value.map((n) => `${n.key}: ${n.message}`).join(", "));
    return r3.value;
  } else {
    let r3 = t63;
    return e.type === "color" && typeof t63 == "string" ? r3 = K.parse(t63) : e.type === "padding" && (typeof t63 == "number" || Array.isArray(t63)) ? r3 = zr.parse(t63) : e.type === "numberArray" && (typeof t63 == "number" || Array.isArray(t63)) ? r3 = Vr.parse(t63) : e.type === "colorArray" && (typeof t63 == "string" || Array.isArray(t63)) ? r3 = Kt.parse(t63) : e.type === "variableAnchorOffsetCollection" && Array.isArray(t63) ? r3 = an.parse(t63) : e.type === "projectionDefinition" && typeof t63 == "string" && (r3 = sn.parse(t63)), { globalStateRefs: /* @__PURE__ */ new Set(), kind: "constant", evaluate: () => r3 };
  }
}
function xc(t63) {
  let e = null;
  if (t63 instanceof vc) e = xc(t63.result);
  else if (t63 instanceof wc) {
    for (let r3 of t63.args) if (e = xc(r3), e) break;
  } else (t63 instanceof Ho || t63 instanceof jt) && t63.input instanceof ln2 && t63.input.name === "zoom" && (e = t63);
  return e instanceof Fr || t63.eachChild((r3) => {
    let n = xc(r3);
    n instanceof Fr ? e = n : !e && n ? e = new Fr("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && n && e !== n && (e = new Fr("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
  }), e;
}
function Gc(t63, e = /* @__PURE__ */ new Set()) {
  return t63 instanceof Ts && e.add(t63.key), t63.eachChild((r3) => {
    Gc(r3, e);
  }), e;
}
function wR(t63) {
  let e = { color: Br, string: Pe2, number: Y, enum: Pe2, boolean: ge, formatted: qo, padding: kc, numberArray: Fc, colorArray: ms, projectionDefinition: Dc, resolvedImage: Is, variableAnchorOffsetCollection: Oc };
  return t63.type === "array" ? dr(e[t63.value] || me, t63.length) : e[t63.type];
}
function TR(t63) {
  if (t63.type === "color" && Nc(t63.default)) return new K(0, 0, 0, 0);
  switch (t63.type) {
    case "color":
      return K.parse(t63.default) || null;
    case "padding":
      return zr.parse(t63.default) || null;
    case "numberArray":
      return Vr.parse(t63.default) || null;
    case "colorArray":
      return Kt.parse(t63.default) || null;
    case "variableAnchorOffsetCollection":
      return an.parse(t63.default) || null;
    case "projectionDefinition":
      return sn.parse(t63.default) || null;
    default:
      return t63.default === void 0 ? null : t63.default;
  }
}
function Ud(t63) {
  if (t63 === true || t63 === false) return true;
  if (!Array.isArray(t63) || t63.length === 0) return false;
  switch (t63[0]) {
    case "has":
      return t63.length >= 2 && t63[1] !== "$id" && t63[1] !== "$type";
    case "in":
      return t63.length >= 3 && (typeof t63[1] != "string" || Array.isArray(t63[2]));
    case "!in":
    case "!has":
    case "none":
      return false;
    case "==":
    case "!=":
    case ">":
    case ">=":
    case "<":
    case "<=":
      return t63.length !== 3 || Array.isArray(t63[1]) || Array.isArray(t63[2]);
    case "any":
    case "all":
      for (let e of t63.slice(1)) if (!Ud(e) && typeof e != "boolean") return false;
      return true;
    default:
      return true;
  }
}
var SR = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
function ii(t63) {
  if (t63 == null) return { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
  Ud(t63) || (t63 = Ec(t63));
  let e = Vd(t63, SR);
  if (e.result === "error") throw new Error(e.value.map((r3) => `${r3.key}: ${r3.message}`).join(", "));
  {
    let r3 = J_(t63);
    return { filter: (n, i, o) => e.value.evaluate(n, i, {}, o), needGeometry: r3, getGlobalStateRefs: () => Gc(e.value.expression) };
  }
}
function CR(t63, e) {
  return t63 < e ? -1 : t63 > e ? 1 : 0;
}
function J_(t63) {
  if (!Array.isArray(t63)) return false;
  if (t63[0] === "within" || t63[0] === "distance") return true;
  for (let e = 1; e < t63.length; e++) if (J_(t63[e])) return true;
  return false;
}
function Ec(t63) {
  if (!t63) return true;
  let e = t63[0];
  return t63.length <= 1 ? e !== "any" : e === "==" ? md(t63[1], t63[2], "==") : e === "!=" ? gc(md(t63[1], t63[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? md(t63[1], t63[2], e) : e === "any" ? MR(t63.slice(1)) : e === "all" ? ["all"].concat(t63.slice(1).map(Ec)) : e === "none" ? ["all"].concat(t63.slice(1).map(Ec).map(gc)) : e === "in" ? w_(t63[1], t63.slice(2)) : e === "!in" ? gc(w_(t63[1], t63.slice(2))) : e === "has" ? T_(t63[1]) : e === "!has" ? gc(T_(t63[1])) : true;
}
function md(t63, e, r3) {
  switch (t63) {
    case "$type":
      return [`filter-type-${r3}`, e];
    case "$id":
      return [`filter-id-${r3}`, e];
    default:
      return [`filter-${r3}`, t63, e];
  }
}
function MR(t63) {
  return ["any"].concat(t63.map(Ec));
}
function w_(t63, e) {
  if (e.length === 0) return false;
  switch (t63) {
    case "$type":
      return ["filter-type-in", ["literal", e]];
    case "$id":
      return ["filter-id-in", ["literal", e]];
    default:
      return e.length > 200 && !e.some((r3) => typeof r3 != typeof e[0]) ? ["filter-in-large", t63, ["literal", e.sort(CR)]] : ["filter-in-small", t63, ["literal", e]];
  }
}
function T_(t63) {
  switch (t63) {
    case "$type":
      return true;
    case "$id":
      return ["filter-has-id"];
    default:
      return ["filter-has", t63];
  }
}
function gc(t63) {
  return ["!", t63];
}
function Q_() {
  let t63 = {}, e = D.$version;
  for (let r3 in D.$root) {
    let n = D.$root[r3];
    if (n.required) {
      let i = null;
      r3 === "version" ? i = e : n.type === "array" ? i = [] : i = {}, i != null && (t63[r3] = i);
    }
  }
  return t63;
}
function ev(t63) {
  let e = t63.key, r3 = t63.value;
  return r3 ? [new G(e, r3, "constants have been deprecated as of v8")] : [];
}
function ut(t63) {
  return t63 instanceof Number || t63 instanceof String || t63 instanceof Boolean ? t63.valueOf() : t63;
}
function $i2(t63) {
  if (Array.isArray(t63)) return t63.map($i2);
  if (t63 instanceof Object && !(t63 instanceof Number || t63 instanceof String || t63 instanceof Boolean)) {
    let e = {};
    for (let r3 in t63) e[r3] = $i2(t63[r3]);
    return e;
  }
  return ut(t63);
}
function Or(t63) {
  let e = t63.key, r3 = t63.value, n = t63.valueSpec || {}, i = t63.objectElementValidators || {}, o = t63.style, a = t63.styleSpec, s3 = t63.validateSpec, l = [], u3 = we(r3);
  if (u3 !== "object") return [new G(e, r3, `object expected, ${u3} found`)];
  for (let c in r3) {
    let p = c.split(".")[0], h = hs(n, p) || n["*"], f;
    if (hs(i, p)) f = i[p];
    else if (hs(n, p)) f = s3;
    else if (i["*"]) f = i["*"];
    else if (n["*"]) f = s3;
    else {
      l.push(new G(e, r3[c], `unknown property "${c}"`));
      continue;
    }
    l = l.concat(f({ key: (e && `${e}.`) + c, value: r3[c], valueSpec: h, style: o, styleSpec: a, object: r3, objectKey: c, validateSpec: s3 }, r3));
  }
  for (let c in n) i[c] || n[c].required && n[c].default === void 0 && r3[c] === void 0 && l.push(new G(e, r3, `missing required property "${c}"`));
  return l;
}
function Nd(t63) {
  let e = t63.value, r3 = t63.valueSpec, n = t63.validateSpec, i = t63.style, o = t63.styleSpec, a = t63.key, s3 = t63.arrayElementValidator || n;
  if (we(e) !== "array") return [new G(a, e, `array expected, ${we(e)} found`)];
  if (r3.length && e.length !== r3.length) return [new G(a, e, `array length ${r3.length} expected, length ${e.length} found`)];
  if (r3["min-length"] && e.length < r3["min-length"]) return [new G(a, e, `array length at least ${r3["min-length"]} expected, length ${e.length} found`)];
  let l = { type: r3.value, values: r3.values };
  o.$version < 7 && (l.function = r3.function), we(r3.value) === "object" && (l = r3.value);
  let u3 = [];
  for (let c = 0; c < e.length; c++) u3 = u3.concat(s3({ array: e, arrayIndex: c, value: e[c], valueSpec: l, validateSpec: t63.validateSpec, style: i, styleSpec: o, key: `${a}[${c}]` }));
  return u3;
}
function jc(t63) {
  let e = t63.key, r3 = t63.value, n = t63.valueSpec, i = we(r3);
  return i === "number" && r3 !== r3 && (i = "NaN"), i !== "number" ? [new G(e, r3, `number expected, ${i} found`)] : "minimum" in n && r3 < n.minimum ? [new G(e, r3, `${r3} is less than the minimum value ${n.minimum}`)] : "maximum" in n && r3 > n.maximum ? [new G(e, r3, `${r3} is greater than the maximum value ${n.maximum}`)] : [];
}
function tv(t63) {
  let e = t63.valueSpec, r3 = ut(t63.value.type), n, i = {}, o, a, s3 = r3 !== "categorical" && t63.value.property === void 0, l = !s3, u3 = we(t63.value.stops) === "array" && we(t63.value.stops[0]) === "array" && we(t63.value.stops[0][0]) === "object", c = Or({ key: t63.key, value: t63.value, valueSpec: t63.styleSpec.function, validateSpec: t63.validateSpec, style: t63.style, styleSpec: t63.styleSpec, objectElementValidators: { stops: p, default: d } });
  return r3 === "identity" && s3 && c.push(new G(t63.key, t63.value, 'missing required property "property"')), r3 !== "identity" && !t63.value.stops && c.push(new G(t63.key, t63.value, 'missing required property "stops"')), r3 === "exponential" && t63.valueSpec.expression && !zd(t63.valueSpec) && c.push(new G(t63.key, t63.value, "exponential functions not supported")), t63.styleSpec.$version >= 8 && (l && !ri(t63.valueSpec) ? c.push(new G(t63.key, t63.value, "property functions not supported")) : s3 && !Z_(t63.valueSpec) && c.push(new G(t63.key, t63.value, "zoom functions not supported"))), (r3 === "categorical" || u3) && t63.value.property === void 0 && c.push(new G(t63.key, t63.value, '"property" property is required')), c;
  function p(g) {
    if (r3 === "identity") return [new G(g.key, g.value, 'identity function may not have a "stops" property')];
    let x = [], b = g.value;
    return x = x.concat(Nd({ key: g.key, value: b, valueSpec: g.valueSpec, validateSpec: g.validateSpec, style: g.style, styleSpec: g.styleSpec, arrayElementValidator: h })), we(b) === "array" && b.length === 0 && x.push(new G(g.key, b, "array must have at least one stop")), x;
  }
  function h(g) {
    let x = [], b = g.value, v3 = g.key;
    if (we(b) !== "array") return [new G(v3, b, `array expected, ${we(b)} found`)];
    if (b.length !== 2) return [new G(v3, b, `array length 2 expected, length ${b.length} found`)];
    if (u3) {
      if (we(b[0]) !== "object") return [new G(v3, b, `object expected, ${we(b[0])} found`)];
      if (b[0].zoom === void 0) return [new G(v3, b, "object stop key must have zoom")];
      if (b[0].value === void 0) return [new G(v3, b, "object stop key must have value")];
      if (a && a > ut(b[0].zoom)) return [new G(v3, b[0].zoom, "stop zoom values must appear in ascending order")];
      ut(b[0].zoom) !== a && (a = ut(b[0].zoom), o = void 0, i = {}), x = x.concat(Or({ key: `${v3}[0]`, value: b[0], valueSpec: { zoom: {} }, validateSpec: g.validateSpec, style: g.style, styleSpec: g.styleSpec, objectElementValidators: { zoom: jc, value: f } }));
    } else x = x.concat(f({ key: `${v3}[0]`, value: b[0], validateSpec: g.validateSpec, style: g.style, styleSpec: g.styleSpec }, b));
    return Ds($i2(b[1])) ? x.concat([new G(`${v3}[1]`, b[1], "expressions are not allowed in function stops.")]) : x.concat(g.validateSpec({ key: `${v3}[1]`, value: b[1], valueSpec: e, validateSpec: g.validateSpec, style: g.style, styleSpec: g.styleSpec }));
  }
  function f(g, x) {
    let b = we(g.value), v3 = ut(g.value), P = g.value !== null ? g.value : x;
    if (!n) n = b;
    else if (b !== n) return [new G(g.key, P, `${b} stop domain type must match previous stop domain type ${n}`)];
    if (b !== "number" && b !== "string" && b !== "boolean") return [new G(g.key, P, "stop domain value must be a number, string, or boolean")];
    if (b !== "number" && r3 !== "categorical") {
      let w3 = `number expected, ${b} found`;
      return ri(e) && r3 === void 0 && (w3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new G(g.key, P, w3)];
    }
    return r3 === "categorical" && b === "number" && (!isFinite(v3) || Math.floor(v3) !== v3) ? [new G(g.key, P, `integer expected, found ${v3}`)] : r3 !== "categorical" && b === "number" && o !== void 0 && v3 < o ? [new G(g.key, P, "stop domain values must appear in ascending order")] : (o = v3, r3 === "categorical" && v3 in i ? [new G(g.key, P, "stop domain values must be unique")] : (i[v3] = true, []));
  }
  function d(g) {
    return g.validateSpec({ key: g.key, value: g.value, valueSpec: e, validateSpec: g.validateSpec, style: g.style, styleSpec: g.styleSpec });
  }
}
function Xo(t63) {
  let e = (t63.expressionContext === "property" ? $_ : Vd)($i2(t63.value), t63.valueSpec);
  if (e.result === "error") return e.value.map((n) => new G(`${t63.key}${n.key}`, t63.value, n.message));
  let r3 = e.value.expression || e.value._styleExpression.expression;
  if (t63.expressionContext === "property" && t63.propertyKey === "text-font" && !r3.outputDefined()) return [new G(t63.key, t63.value, `Invalid data expression for "${t63.propertyKey}". Output values must be contained as literals within the expression.`)];
  if (t63.expressionContext === "property" && t63.propertyType === "layout" && !Ss(r3)) return [new G(t63.key, t63.value, '"feature-state" data expressions are not supported with layout properties.')];
  if (t63.expressionContext === "filter" && !Ss(r3)) return [new G(t63.key, t63.value, '"feature-state" data expressions are not supported with filters.')];
  if (t63.expressionContext && t63.expressionContext.indexOf("cluster") === 0) {
    if (!Uc(r3, ["zoom", "feature-state"])) return [new G(t63.key, t63.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
    if (t63.expressionContext === "cluster-initial" && !Vc(r3)) return [new G(t63.key, t63.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
  }
  return [];
}
function IR(t63) {
  let e = t63.value, r3 = t63.key, n = we(e);
  return n !== "boolean" ? [new G(r3, e, `boolean expected, ${n} found`)] : [];
}
function Ld(t63) {
  let e = t63.key, r3 = t63.value, n = we(r3);
  return n !== "string" ? [new G(e, r3, `color expected, ${n} found`)] : K.parse(String(r3)) ? [] : [new G(e, r3, `color expected, "${r3}" found`)];
}
function Ms(t63) {
  let e = t63.key, r3 = t63.value, n = t63.valueSpec, i = [];
  return Array.isArray(n.values) ? n.values.indexOf(ut(r3)) === -1 && i.push(new G(e, r3, `expected one of [${n.values.join(", ")}], ${JSON.stringify(r3)} found`)) : Object.keys(n.values).indexOf(ut(r3)) === -1 && i.push(new G(e, r3, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(r3)} found`)), i;
}
function Gd(t63) {
  return Ud($i2(t63.value)) ? Xo(Go({}, t63, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : rv(t63);
}
function rv(t63) {
  let e = t63.value, r3 = t63.key;
  if (we(e) !== "array") return [new G(r3, e, `array expected, ${we(e)} found`)];
  let n = t63.styleSpec, i, o = [];
  if (e.length < 1) return [new G(r3, e, "filter array must have at least 1 element")];
  switch (o = o.concat(Ms({ key: `${r3}[0]`, value: e[0], valueSpec: n.filter_operator, style: t63.style, styleSpec: t63.styleSpec })), ut(e[0])) {
    case "<":
    case "<=":
    case ">":
    case ">=":
      e.length >= 2 && ut(e[1]) === "$type" && o.push(new G(r3, e, `"$type" cannot be use with operator "${e[0]}"`));
    case "==":
    case "!=":
      e.length !== 3 && o.push(new G(r3, e, `filter array for operator "${e[0]}" must have 3 elements`));
    case "in":
    case "!in":
      e.length >= 2 && (i = we(e[1]), i !== "string" && o.push(new G(`${r3}[1]`, e[1], `string expected, ${i} found`)));
      for (let a = 2; a < e.length; a++) i = we(e[a]), ut(e[1]) === "$type" ? o = o.concat(Ms({ key: `${r3}[${a}]`, value: e[a], valueSpec: n.geometry_type, style: t63.style, styleSpec: t63.styleSpec })) : i !== "string" && i !== "number" && i !== "boolean" && o.push(new G(`${r3}[${a}]`, e[a], `string, number, or boolean expected, ${i} found`));
      break;
    case "any":
    case "all":
    case "none":
      for (let a = 1; a < e.length; a++) o = o.concat(rv({ key: `${r3}[${a}]`, value: e[a], style: t63.style, styleSpec: t63.styleSpec }));
      break;
    case "has":
    case "!has":
      i = we(e[1]), e.length !== 2 ? o.push(new G(r3, e, `filter array for "${e[0]}" operator must have 2 elements`)) : i !== "string" && o.push(new G(`${r3}[1]`, e[1], `string expected, ${i} found`));
      break;
  }
  return o;
}
function nv(t63, e) {
  let r3 = t63.key, n = t63.validateSpec, i = t63.style, o = t63.styleSpec, a = t63.value, s3 = t63.objectKey, l = o[`${e}_${t63.layerType}`];
  if (!l) return [];
  let u3 = s3.match(/^(.*)-transition$/);
  if (e === "paint" && u3 && l[u3[1]] && l[u3[1]].transition) return n({ key: r3, value: a, valueSpec: o.transition, style: i, styleSpec: o });
  let c = t63.valueSpec || l[s3];
  if (!c) return [new G(r3, a, `unknown property "${s3}"`)];
  let p;
  if (we(a) === "string" && ri(c) && !c.tokens && (p = /^{([^}]+)}$/.exec(a))) return [new G(r3, a, `"${s3}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(p[1])} }\`.`)];
  let h = [];
  return t63.layerType === "symbol" && (s3 === "text-field" && i && !i.glyphs && h.push(new G(r3, a, 'use of "text-field" requires a style "glyphs" property')), s3 === "text-font" && Nc($i2(a)) && ut(a.type) === "identity" && h.push(new G(r3, a, '"text-font" does not support identity functions'))), h.concat(n({ key: t63.key, value: a, valueSpec: c, style: i, styleSpec: o, expressionContext: "property", propertyType: e, propertyKey: s3 }));
}
function iv(t63) {
  return nv(t63, "paint");
}
function ov(t63) {
  return nv(t63, "layout");
}
function av(t63) {
  let e = [], r3 = t63.value, n = t63.key, i = t63.style, o = t63.styleSpec;
  if (we(r3) !== "object") return [new G(n, r3, `object expected, ${we(r3)} found`)];
  !r3.type && !r3.ref && e.push(new G(n, r3, 'either "type" or "ref" is required'));
  let a = ut(r3.type), s3 = ut(r3.ref);
  if (r3.id) {
    let l = ut(r3.id);
    for (let u3 = 0; u3 < t63.arrayIndex; u3++) {
      let c = i.layers[u3];
      ut(c.id) === l && e.push(new G(n, r3.id, `duplicate layer id "${r3.id}", previously used at line ${c.id.__line__}`));
    }
  }
  if ("ref" in r3) {
    ["type", "source", "source-layer", "filter", "layout"].forEach((u3) => {
      u3 in r3 && e.push(new G(n, r3[u3], `"${u3}" is prohibited for ref layers`));
    });
    let l;
    i.layers.forEach((u3) => {
      ut(u3.id) === s3 && (l = u3);
    }), l ? l.ref ? e.push(new G(n, r3.ref, "ref cannot reference another ref layer")) : a = ut(l.type) : e.push(new G(n, r3.ref, `ref layer "${s3}" not found`));
  } else if (a !== "background") if (!r3.source) e.push(new G(n, r3, 'missing required property "source"'));
  else {
    let l = i.sources && i.sources[r3.source], u3 = l && ut(l.type);
    l ? u3 === "vector" && a === "raster" ? e.push(new G(n, r3.source, `layer "${r3.id}" requires a raster source`)) : u3 !== "raster-dem" && a === "hillshade" ? e.push(new G(n, r3.source, `layer "${r3.id}" requires a raster-dem source`)) : u3 !== "raster-dem" && a === "color-relief" ? e.push(new G(n, r3.source, `layer "${r3.id}" requires a raster-dem source`)) : u3 === "raster" && a !== "raster" ? e.push(new G(n, r3.source, `layer "${r3.id}" requires a vector source`)) : u3 === "vector" && !r3["source-layer"] ? e.push(new G(n, r3, `layer "${r3.id}" must specify a "source-layer"`)) : u3 === "raster-dem" && a !== "hillshade" && a !== "color-relief" ? e.push(new G(n, r3.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : a === "line" && r3.paint && r3.paint["line-gradient"] && (u3 !== "geojson" || !l.lineMetrics) && e.push(new G(n, r3, `layer "${r3.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new G(n, r3.source, `source "${r3.source}" not found`));
  }
  return e = e.concat(Or({ key: n, value: r3, valueSpec: o.layer, style: t63.style, styleSpec: t63.styleSpec, validateSpec: t63.validateSpec, objectElementValidators: { "*"() {
    return [];
  }, type() {
    return t63.validateSpec({ key: `${n}.type`, value: r3.type, valueSpec: o.layer.type, style: t63.style, styleSpec: t63.styleSpec, validateSpec: t63.validateSpec, object: r3, objectKey: "type" });
  }, filter: Gd, layout(l) {
    return Or({ layer: r3, key: l.key, value: l.value, style: l.style, styleSpec: l.styleSpec, validateSpec: l.validateSpec, objectElementValidators: { "*"(u3) {
      return ov(Go({ layerType: a }, u3));
    } } });
  }, paint(l) {
    return Or({ layer: r3, key: l.key, value: l.value, style: l.style, styleSpec: l.styleSpec, validateSpec: l.validateSpec, objectElementValidators: { "*"(u3) {
      return iv(Go({ layerType: a }, u3));
    } } });
  } } })), e;
}
function Ki(t63) {
  let e = t63.value, r3 = t63.key, n = we(e);
  return n !== "string" ? [new G(r3, e, `string expected, ${n} found`)] : [];
}
function AR(t63) {
  var e;
  let r3 = (e = t63.sourceName) !== null && e !== void 0 ? e : "", n = t63.value, i = t63.styleSpec, o = i.source_raster_dem, a = t63.style, s3 = [], l = we(n);
  if (n === void 0) return s3;
  if (l !== "object") return s3.push(new G("source_raster_dem", n, `object expected, ${l} found`)), s3;
  let c = ut(n.encoding) === "custom", p = ["redFactor", "greenFactor", "blueFactor", "baseShift"], h = t63.value.encoding ? `"${t63.value.encoding}"` : "Default";
  for (let f in n) !c && p.includes(f) ? s3.push(new G(f, n[f], `In "${r3}": "${f}" is only valid when "encoding" is set to "custom". ${h} encoding found`)) : o[f] ? s3 = s3.concat(t63.validateSpec({ key: f, value: n[f], valueSpec: o[f], validateSpec: t63.validateSpec, style: a, styleSpec: i })) : s3.push(new G(f, n[f], `unknown property "${f}"`));
  return s3;
}
var S_ = { promoteId: ER };
function sv(t63) {
  let e = t63.value, r3 = t63.key, n = t63.styleSpec, i = t63.style, o = t63.validateSpec;
  if (!e.type) return [new G(r3, e, '"type" is required')];
  let a = ut(e.type), s3;
  switch (a) {
    case "vector":
    case "raster":
      return s3 = Or({ key: r3, value: e, valueSpec: n[`source_${a.replace("-", "_")}`], style: t63.style, styleSpec: n, objectElementValidators: S_, validateSpec: o }), s3;
    case "raster-dem":
      return s3 = AR({ sourceName: r3, value: e, style: t63.style, styleSpec: n, validateSpec: o }), s3;
    case "geojson":
      if (s3 = Or({ key: r3, value: e, valueSpec: n.source_geojson, style: i, styleSpec: n, validateSpec: o, objectElementValidators: S_ }), e.cluster) for (let l in e.clusterProperties) {
        let [u3, c] = e.clusterProperties[l], p = typeof u3 == "string" ? [u3, ["accumulated"], ["get", l]] : u3;
        s3.push(...Xo({ key: `${r3}.${l}.map`, value: c, expressionContext: "cluster-map" })), s3.push(...Xo({ key: `${r3}.${l}.reduce`, value: p, expressionContext: "cluster-reduce" }));
      }
      return s3;
    case "video":
      return Or({ key: r3, value: e, valueSpec: n.source_video, style: i, validateSpec: o, styleSpec: n });
    case "image":
      return Or({ key: r3, value: e, valueSpec: n.source_image, style: i, validateSpec: o, styleSpec: n });
    case "canvas":
      return [new G(r3, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
    default:
      return Ms({ key: `${r3}.type`, value: e.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
  }
}
function ER({ key: t63, value: e }) {
  if (we(e) === "string") return Ki({ key: t63, value: e });
  {
    let r3 = [];
    for (let n in e) r3.push(...Ki({ key: `${t63}.${n}`, value: e[n] }));
    return r3;
  }
}
function lv(t63) {
  let e = t63.value, r3 = t63.styleSpec, n = r3.light, i = t63.style, o = [], a = we(e);
  if (e === void 0) return o;
  if (a !== "object") return o = o.concat([new G("light", e, `object expected, ${a} found`)]), o;
  for (let s3 in e) {
    let l = s3.match(/^(.*)-transition$/);
    l && n[l[1]] && n[l[1]].transition ? o = o.concat(t63.validateSpec({ key: s3, value: e[s3], valueSpec: r3.transition, validateSpec: t63.validateSpec, style: i, styleSpec: r3 })) : n[s3] ? o = o.concat(t63.validateSpec({ key: s3, value: e[s3], valueSpec: n[s3], validateSpec: t63.validateSpec, style: i, styleSpec: r3 })) : o = o.concat([new G(s3, e[s3], `unknown property "${s3}"`)]);
  }
  return o;
}
function uv(t63) {
  let e = t63.value, r3 = t63.styleSpec, n = r3.sky, i = t63.style, o = we(e);
  if (e === void 0) return [];
  if (o !== "object") return [new G("sky", e, `object expected, ${o} found`)];
  let a = [];
  for (let s3 in e) n[s3] ? a = a.concat(t63.validateSpec({ key: s3, value: e[s3], valueSpec: n[s3], style: i, styleSpec: r3 })) : a = a.concat([new G(s3, e[s3], `unknown property "${s3}"`)]);
  return a;
}
function cv(t63) {
  let e = t63.value, r3 = t63.styleSpec, n = r3.terrain, i = t63.style, o = [], a = we(e);
  if (e === void 0) return o;
  if (a !== "object") return o = o.concat([new G("terrain", e, `object expected, ${a} found`)]), o;
  for (let s3 in e) n[s3] ? o = o.concat(t63.validateSpec({ key: s3, value: e[s3], valueSpec: n[s3], validateSpec: t63.validateSpec, style: i, styleSpec: r3 })) : o = o.concat([new G(s3, e[s3], `unknown property "${s3}"`)]);
  return o;
}
function LR(t63) {
  return Ki(t63).length === 0 ? [] : Xo(t63);
}
function DR(t63) {
  return Ki(t63).length === 0 ? [] : Xo(t63);
}
function RR(t63) {
  let e = t63.key, r3 = t63.value;
  if (we(r3) === "array") {
    if (r3.length < 1 || r3.length > 4) return [new G(e, r3, `padding requires 1 to 4 values; ${r3.length} values found`)];
    let i = { type: "number" }, o = [];
    for (let a = 0; a < r3.length; a++) o = o.concat(t63.validateSpec({ key: `${e}[${a}]`, value: r3[a], validateSpec: t63.validateSpec, valueSpec: i }));
    return o;
  } else return jc({ key: e, value: r3, valueSpec: {} });
}
function kR(t63) {
  let e = t63.key, r3 = t63.value;
  if (we(r3) === "array") {
    let i = { type: "number" };
    if (r3.length < 1) return [new G(e, r3, "array length at least 1 expected, length 0 found")];
    let o = [];
    for (let a = 0; a < r3.length; a++) o = o.concat(t63.validateSpec({ key: `${e}[${a}]`, value: r3[a], validateSpec: t63.validateSpec, valueSpec: i }));
    return o;
  } else return jc({ key: e, value: r3, valueSpec: {} });
}
function FR(t63) {
  let e = t63.key, r3 = t63.value;
  if (we(r3) === "array") {
    if (r3.length < 1) return [new G(e, r3, "array length at least 1 expected, length 0 found")];
    let i = [];
    for (let o = 0; o < r3.length; o++) i = i.concat(Ld({ key: `${e}[${o}]`, value: r3[o] }));
    return i;
  } else return Ld({ key: e, value: r3 });
}
function OR(t63) {
  let e = t63.key, r3 = t63.value, n = we(r3), i = t63.styleSpec;
  if (n !== "array" || r3.length < 1 || r3.length % 2 !== 0) return [new G(e, r3, "variableAnchorOffsetCollection requires a non-empty array of even length")];
  let o = [];
  for (let a = 0; a < r3.length; a += 2) o = o.concat(Ms({ key: `${e}[${a}]`, value: r3[a], valueSpec: i.layout_symbol["text-anchor"] })), o = o.concat(Nd({ key: `${e}[${a + 1}]`, value: r3[a + 1], valueSpec: { length: 2, value: "number" }, validateSpec: t63.validateSpec, style: t63.style, styleSpec: i }));
  return o;
}
function pv(t63) {
  let e = [], r3 = t63.value, n = t63.key;
  if (Array.isArray(r3)) {
    let i = [], o = [];
    for (let a in r3) {
      r3[a].id && i.includes(r3[a].id) && e.push(new G(n, r3, `all the sprites' ids must be unique, but ${r3[a].id} is duplicated`)), i.push(r3[a].id), r3[a].url && o.includes(r3[a].url) && e.push(new G(n, r3, `all the sprites' URLs must be unique, but ${r3[a].url} is duplicated`)), o.push(r3[a].url);
      let s3 = { id: { type: "string", required: true }, url: { type: "string", required: true } };
      e = e.concat(Or({ key: `${n}[${a}]`, value: r3[a], valueSpec: s3, validateSpec: t63.validateSpec }));
    }
    return e;
  } else return Ki({ key: n, value: r3 });
}
function BR(t63) {
  let e = t63.value, r3 = t63.styleSpec, n = r3.projection, i = t63.style, o = we(e);
  if (e === void 0) return [];
  if (o !== "object") return [new G("projection", e, `object expected, ${o} found`)];
  let a = [];
  for (let s3 in e) n[s3] ? a = a.concat(t63.validateSpec({ key: s3, value: e[s3], valueSpec: n[s3], style: i, styleSpec: r3 })) : a = a.concat([new G(s3, e[s3], `unknown property "${s3}"`)]);
  return a;
}
function zR(t63) {
  let e = t63.key, r3 = t63.value;
  r3 = r3 instanceof String ? r3.valueOf() : r3;
  let n = we(r3);
  return n === "array" && !UR(r3) && !VR(r3) ? [new G(e, r3, `projection expected, invalid array ${JSON.stringify(r3)} found`)] : ["array", "string"].includes(n) ? [] : [new G(e, r3, `projection expected, invalid type "${n}" found`)];
}
function VR(t63) {
  return !!["interpolate", "step", "literal"].includes(t63[0]);
}
function UR(t63) {
  return Array.isArray(t63) && t63.length === 3 && typeof t63[0] == "string" && typeof t63[1] == "string" && typeof t63[2] == "number";
}
function NR(t63) {
  return !!t63 && t63.constructor === Object;
}
function hv(t63) {
  return NR(t63.value) ? [] : [new G(t63.key, t63.value, `object expected, ${we(t63.value)} found`)];
}
var C_ = { "*"() {
  return [];
}, array: Nd, boolean: IR, number: jc, color: Ld, constants: ev, enum: Ms, filter: Gd, function: tv, layer: av, object: Or, source: sv, light: lv, sky: uv, terrain: cv, projection: BR, projectionDefinition: zR, string: Ki, formatted: LR, resolvedImage: DR, padding: RR, numberArray: kR, colorArray: FR, variableAnchorOffsetCollection: OR, sprite: pv, state: hv };
function Lc(t63) {
  let e = t63.value, r3 = t63.valueSpec, n = t63.styleSpec;
  return t63.validateSpec = Lc, r3.expression && Nc(ut(e)) ? tv(t63) : r3.expression && Ds($i2(e)) ? Xo(t63) : r3.type && C_[r3.type] ? C_[r3.type](t63) : Or(Go({}, t63, { valueSpec: r3.type ? n[r3.type] : r3 }));
}
function fv(t63) {
  let e = t63.value, r3 = t63.key, n = Ki(t63);
  return n.length || (e.indexOf("{fontstack}") === -1 && n.push(new G(r3, e, '"glyphs" url must include a "{fontstack}" token')), e.indexOf("{range}") === -1 && n.push(new G(r3, e, '"glyphs" url must include a "{range}" token'))), n;
}
function gr(t63, e = D) {
  let r3 = [];
  return r3 = r3.concat(Lc({ key: "", value: t63, valueSpec: e.$root, styleSpec: e, style: t63, validateSpec: Lc, objectElementValidators: { glyphs: fv, "*"() {
    return [];
  } } })), t63.constants && (r3 = r3.concat(ev({ key: "constants", value: t63.constants }))), mv(r3);
}
gr.source = qr(Zr2(sv));
gr.sprite = qr(Zr2(pv));
gr.glyphs = qr(Zr2(fv));
gr.light = qr(Zr2(lv));
gr.sky = qr(Zr2(uv));
gr.terrain = qr(Zr2(cv));
gr.state = qr(Zr2(hv));
gr.layer = qr(Zr2(av));
gr.filter = qr(Zr2(Gd));
gr.paintProperty = qr(Zr2(iv));
gr.layoutProperty = qr(Zr2(ov));
function Zr2(t63) {
  return function(e) {
    return t63({ ...e, validateSpec: Lc });
  };
}
function mv(t63) {
  return [].concat(t63).sort((e, r3) => e.line - r3.line);
}
function qr(t63) {
  return function(...e) {
    return mv(t63.apply(this, e));
  };
}
$i();
var Je = gr;
var N6 = Je.source;
var dv = Je.light;
var yv = Je.sky;
var G6 = Je.terrain;
var j6 = Je.filter;
var gv = Je.paintProperty;
var xv = Je.layoutProperty;
function oi(t63, e) {
  let r3 = false;
  if (e && e.length) for (let n of e) t63.fire(new Q(new Error(n.message))), r3 = true;
  return r3;
}
$i();
$i();
$i();
var Qi = class t38 {
  constructor(e, r3, n) {
    let i = this.cells = [];
    if (e instanceof ArrayBuffer) {
      this.arrayBuffer = e;
      let a = new Int32Array(this.arrayBuffer);
      e = a[0], r3 = a[1], n = a[2], this.d = r3 + 2 * n;
      for (let u3 = 0; u3 < this.d * this.d; u3++) {
        let c = a[3 + u3], p = a[3 + u3 + 1];
        i.push(c === p ? null : a.subarray(c, p));
      }
      let s3 = a[3 + i.length], l = a[3 + i.length + 1];
      this.keys = a.subarray(s3, l), this.bboxes = a.subarray(l), this.insert = this._insertReadonly;
    } else {
      this.d = r3 + 2 * n;
      for (let a = 0; a < this.d * this.d; a++) i.push([]);
      this.keys = [], this.bboxes = [];
    }
    this.n = r3, this.extent = e, this.padding = n, this.scale = r3 / e, this.uid = 0;
    let o = n / r3 * e;
    this.min = -o, this.max = e + o;
  }
  insert(e, r3, n, i, o) {
    this._forEachCell(r3, n, i, o, this._insertCell, this.uid++, void 0, void 0), this.keys.push(e), this.bboxes.push(r3), this.bboxes.push(n), this.bboxes.push(i), this.bboxes.push(o);
  }
  _insertReadonly() {
    throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
  }
  _insertCell(e, r3, n, i, o, a) {
    this.cells[o].push(a);
  }
  query(e, r3, n, i, o) {
    let a = this.min, s3 = this.max;
    if (e <= a && r3 <= a && s3 <= n && s3 <= i && !o) return Array.prototype.slice.call(this.keys);
    {
      let l = [], u3 = {};
      return this._forEachCell(e, r3, n, i, this._queryCell, l, u3, o), l;
    }
  }
  _queryCell(e, r3, n, i, o, a, s3, l) {
    let u3 = this.cells[o];
    if (u3 !== null) {
      let c = this.keys, p = this.bboxes;
      for (let h = 0; h < u3.length; h++) {
        let f = u3[h];
        if (s3[f] === void 0) {
          let d = f * 4;
          (l ? l(p[d + 0], p[d + 1], p[d + 2], p[d + 3]) : e <= p[d + 2] && r3 <= p[d + 3] && n >= p[d + 0] && i >= p[d + 1]) ? (s3[f] = true, a.push(c[f])) : s3[f] = false;
        }
      }
    }
  }
  _forEachCell(e, r3, n, i, o, a, s3, l) {
    let u3 = this._convertToCellCoord(e), c = this._convertToCellCoord(r3), p = this._convertToCellCoord(n), h = this._convertToCellCoord(i);
    for (let f = u3; f <= p; f++) for (let d = c; d <= h; d++) {
      let g = this.d * d + f;
      if (!(l && !l(this._convertFromCellCoord(f), this._convertFromCellCoord(d), this._convertFromCellCoord(f + 1), this._convertFromCellCoord(d + 1))) && o.call(this, e, r3, n, i, g, a, s3, l)) return;
    }
  }
  _convertFromCellCoord(e) {
    return (e - this.padding) / this.scale;
  }
  _convertToCellCoord(e) {
    return Math.max(0, Math.min(this.d - 1, Math.floor(e * this.scale) + this.padding));
  }
  toArrayBuffer() {
    if (this.arrayBuffer) return this.arrayBuffer;
    let e = this.cells, r3 = 3 + this.cells.length + 1 + 1, n = 0;
    for (let a = 0; a < this.cells.length; a++) n += this.cells[a].length;
    let i = new Int32Array(r3 + n + this.keys.length + this.bboxes.length);
    i[0] = this.extent, i[1] = this.n, i[2] = this.padding;
    let o = r3;
    for (let a = 0; a < e.length; a++) {
      let s3 = e[a];
      i[3 + a] = o, i.set(s3, o), o += s3.length;
    }
    return i[3 + e.length] = o, i.set(this.keys, o), o += this.keys.length, i[3 + e.length + 1] = o, i.set(this.bboxes, o), o += this.bboxes.length, i.buffer;
  }
  static serialize(e, r3) {
    let n = e.toArrayBuffer();
    return r3 && r3.push(n), { buffer: n };
  }
  static deserialize(e) {
    return new t38(e.buffer);
  }
};
var Cn = {};
function X(t63, e, r3 = {}) {
  if (Cn[t63]) throw new Error(`${t63} is already registered.`);
  Object.defineProperty(e, "_classRegistryKey", { value: t63, writeable: false }), Cn[t63] = { klass: e, omit: r3.omit || [], shallow: r3.shallow || [] };
}
X("Object", Object);
X("Set", Set);
X("TransferableGridIndex", Qi);
X("Color", K);
X("Error", Error);
X("AJAXError", $n);
X("ResolvedImage", Jt);
X("StylePropertyFunction", Cs2);
X("StyleExpression", Wi, { omit: ["_evaluator"] });
X("ZoomDependentExpression", ni2);
X("ZoomConstantExpression", un);
X("CompoundExpression", ln2, { omit: ["_evaluate"] });
for (let t63 in Ji) Ji[t63]._classRegistryKey || X(`Expression_${t63}`, Ji[t63]);
function bv(t63) {
  return t63 && typeof ArrayBuffer < "u" && (t63 instanceof ArrayBuffer || t63.constructor && t63.constructor.name === "ArrayBuffer");
}
function jd(t63) {
  let e = t63.constructor;
  return t63.$name || e._classRegistryKey;
}
function GR(t63) {
  if (t63 === null || typeof t63 != "object") return false;
  let e = jd(t63);
  return !!(e && e !== "Object");
}
function _v(t63) {
  return !GR(t63) && (t63 == null || typeof t63 == "boolean" || typeof t63 == "number" || typeof t63 == "string" || t63 instanceof Boolean || t63 instanceof Number || t63 instanceof String || t63 instanceof Date || t63 instanceof RegExp || t63 instanceof Blob || t63 instanceof Error || bv(t63) || Wt(t63) || ArrayBuffer.isView(t63) || t63 instanceof ImageData);
}
function $o(t63, e) {
  if (_v(t63)) {
    if ((bv(t63) || Wt(t63)) && e && e.push(t63), ArrayBuffer.isView(t63)) {
      let o = t63;
      e && e.push(o.buffer);
    }
    return t63 instanceof ImageData && e && e.push(t63.data.buffer), t63;
  }
  if (Array.isArray(t63)) {
    let o = [];
    for (let a of t63) o.push($o(a, e));
    return o;
  }
  if (typeof t63 != "object") throw new Error(`can't serialize object of type ${typeof t63}`);
  let r3 = jd(t63);
  if (!r3) throw new Error(`can't serialize object of unregistered class ${t63.constructor.name}`);
  if (!Cn[r3]) throw new Error(`${r3} is not registered.`);
  let { klass: n } = Cn[r3], i = n.serialize ? n.serialize(t63, e) : {};
  if (n.serialize) {
    if (e && i === e[e.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
  } else {
    for (let o in t63) {
      if (!t63.hasOwnProperty(o) || Cn[r3].omit.indexOf(o) >= 0) continue;
      let a = t63[o];
      i[o] = Cn[r3].shallow.indexOf(o) >= 0 ? a : $o(a, e);
    }
    t63 instanceof Error && (i.message = t63.message);
  }
  if (i.$name) throw new Error("$name property is reserved for worker serialization logic.");
  return r3 !== "Object" && (i.$name = r3), i;
}
function Ko(t63) {
  if (_v(t63)) return t63;
  if (Array.isArray(t63)) return t63.map(Ko);
  if (typeof t63 != "object") throw new Error(`can't deserialize object of type ${typeof t63}`);
  let e = jd(t63) || "Object";
  if (!Cn[e]) throw new Error(`can't deserialize unregistered class ${e}`);
  let { klass: r3 } = Cn[e];
  if (!r3) throw new Error(`can't deserialize unregistered class ${e}`);
  if (r3.deserialize) return r3.deserialize(t63);
  let n = Object.create(r3.prototype);
  for (let i of Object.keys(t63)) {
    if (i === "$name") continue;
    let o = t63[i];
    n[i] = Cn[e].shallow.indexOf(i) >= 0 ? o : Ko(o);
  }
  return n;
}
$i();
$i();
var eo = class {
  constructor() {
    this.first = true;
  }
  update(e, r3) {
    let n = Math.floor(e);
    return this.first ? (this.first = false, this.lastIntegerZoom = n, this.lastIntegerZoomTime = 0, this.lastZoom = e, this.lastFloorZoom = n, true) : (this.lastFloorZoom > n ? (this.lastIntegerZoom = n + 1, this.lastIntegerZoomTime = r3) : this.lastFloorZoom < n && (this.lastIntegerZoom = n, this.lastIntegerZoomTime = r3), e !== this.lastZoom ? (this.lastZoom = e, this.lastFloorZoom = n, true) : false);
  }
};
$i();
$i();
var ht = { "Latin-1 Supplement": (t63) => t63 >= 128 && t63 <= 255, "Hangul Jamo": (t63) => t63 >= 4352 && t63 <= 4607, Khmer: (t63) => t63 >= 6016 && t63 <= 6143, "General Punctuation": (t63) => t63 >= 8192 && t63 <= 8303, "Letterlike Symbols": (t63) => t63 >= 8448 && t63 <= 8527, "Number Forms": (t63) => t63 >= 8528 && t63 <= 8591, "Miscellaneous Technical": (t63) => t63 >= 8960 && t63 <= 9215, "Control Pictures": (t63) => t63 >= 9216 && t63 <= 9279, "Optical Character Recognition": (t63) => t63 >= 9280 && t63 <= 9311, "Enclosed Alphanumerics": (t63) => t63 >= 9312 && t63 <= 9471, "Geometric Shapes": (t63) => t63 >= 9632 && t63 <= 9727, "Miscellaneous Symbols": (t63) => t63 >= 9728 && t63 <= 9983, "Miscellaneous Symbols and Arrows": (t63) => t63 >= 11008 && t63 <= 11263, "Ideographic Description Characters": (t63) => t63 >= 12272 && t63 <= 12287, "CJK Symbols and Punctuation": (t63) => t63 >= 12288 && t63 <= 12351, Hiragana: (t63) => t63 >= 12352 && t63 <= 12447, Katakana: (t63) => t63 >= 12448 && t63 <= 12543, Kanbun: (t63) => t63 >= 12688 && t63 <= 12703, "CJK Strokes": (t63) => t63 >= 12736 && t63 <= 12783, "Enclosed CJK Letters and Months": (t63) => t63 >= 12800 && t63 <= 13055, "CJK Compatibility": (t63) => t63 >= 13056 && t63 <= 13311, "Yijing Hexagram Symbols": (t63) => t63 >= 19904 && t63 <= 19967, "CJK Unified Ideographs": (t63) => t63 >= 19968 && t63 <= 40959, "Hangul Syllables": (t63) => t63 >= 44032 && t63 <= 55215, "Private Use Area": (t63) => t63 >= 57344 && t63 <= 63743, "Vertical Forms": (t63) => t63 >= 65040 && t63 <= 65055, "CJK Compatibility Forms": (t63) => t63 >= 65072 && t63 <= 65103, "Small Form Variants": (t63) => t63 >= 65104 && t63 <= 65135, "Halfwidth and Fullwidth Forms": (t63) => t63 >= 65280 && t63 <= 65519 };
function Hd(t63) {
  for (let e of t63) if (vv(e.charCodeAt(0))) return true;
  return false;
}
function Xd(t63) {
  let e = t63.map((r3) => {
    try {
      return new RegExp(`\\p{sc=${r3}}`, "u").source;
    } catch {
      return null;
    }
  }).filter((r3) => r3);
  return new RegExp(e.join("|"), "u");
}
var jR = ["Arab", "Dupl", "Mong", "Ougr", "Syrc"];
var oG = Xd(jR);
var HR = ["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"];
var XR = Xd(HR);
function vv(t63) {
  return t63 === 746 || t63 === 747 ? true : t63 < 4352 ? false : !!(ht["CJK Compatibility Forms"](t63) && !(t63 >= 65097 && t63 <= 65103) || ht["CJK Compatibility"](t63) || ht["CJK Strokes"](t63) || ht["CJK Symbols and Punctuation"](t63) && !(t63 >= 12296 && t63 <= 12305) && !(t63 >= 12308 && t63 <= 12319) && t63 !== 12336 || ht["Enclosed CJK Letters and Months"](t63) || ht["Ideographic Description Characters"](t63) || ht.Kanbun(t63) || ht.Katakana(t63) && t63 !== 12540 || ht["Halfwidth and Fullwidth Forms"](t63) && t63 !== 65288 && t63 !== 65289 && t63 !== 65293 && !(t63 >= 65306 && t63 <= 65310) && t63 !== 65339 && t63 !== 65341 && t63 !== 65343 && !(t63 >= 65371 && t63 <= 65503) && t63 !== 65507 && !(t63 >= 65512 && t63 <= 65519) || ht["Small Form Variants"](t63) && !(t63 >= 65112 && t63 <= 65118) && !(t63 >= 65123 && t63 <= 65126) || ht["Vertical Forms"](t63) || ht["Yijing Hexagram Symbols"](t63) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(t63)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(t63)) || XR.test(String.fromCodePoint(t63)));
}
var ZR = ["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"];
var qR = Xd(ZR);
function Pv(t63) {
  return qR.test(String.fromCodePoint(t63));
}
function YR(t63, e) {
  return !(!e && Pv(t63) || t63 >= 2304 && t63 <= 3583 || t63 >= 3840 && t63 <= 4255 || ht.Khmer(t63));
}
function wv(t63) {
  for (let e of t63) if (Pv(e.charCodeAt(0))) return true;
  return false;
}
function Tv(t63, e) {
  for (let r3 of t63) if (!YR(r3.charCodeAt(0), e)) return false;
  return true;
}
$i();
var Zd = class {
  constructor() {
    this.TIMEOUT = 5e3;
    this.applyArabicShaping = null;
    this.processBidirectionalText = null;
    this.processStyledBidirectionalText = null;
    this.pluginStatus = "unavailable";
    this.pluginURL = null;
    this.loadScriptResolve = () => {
    };
  }
  setState(e) {
    this.pluginStatus = e.pluginStatus, this.pluginURL = e.pluginURL;
  }
  getState() {
    return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
  }
  setMethods(e) {
    if (cn2.isParsed()) throw new Error("RTL text plugin already registered.");
    this.applyArabicShaping = e.applyArabicShaping, this.processBidirectionalText = e.processBidirectionalText, this.processStyledBidirectionalText = e.processStyledBidirectionalText, this.loadScriptResolve();
  }
  isParsed() {
    return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
  }
  getRTLTextPluginStatus() {
    return this.pluginStatus;
  }
  async syncState(e, r3) {
    if (this.isParsed()) return this.getState();
    if (e.pluginStatus !== "loading") return this.setState(e), e;
    let n = e.pluginURL, i = new Promise((s3) => {
      this.loadScriptResolve = s3;
    });
    r3(n);
    let o = new Promise((s3) => setTimeout(() => s3(), this.TIMEOUT));
    if (await Promise.race([i, o]), this.isParsed()) {
      let s3 = { pluginStatus: "loaded", pluginURL: n };
      return this.setState(s3), s3;
    }
    throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${n}`);
  }
};
var cn2 = new Zd();
var Te = class {
  constructor(e, r3) {
    this.zoom = e, r3 ? (this.now = r3.now || 0, this.fadeDuration = r3.fadeDuration || 0, this.zoomHistory = r3.zoomHistory || new eo(), this.transition = r3.transition || {}, this.globalState = r3.globalState || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new eo(), this.transition = {}, this.globalState = {});
  }
  isSupportedScript(e) {
    return Tv(e, cn2.getRTLTextPluginStatus() === "loaded");
  }
  crossFadingFactor() {
    return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
  }
  getCrossfadeParameters() {
    let e = this.zoom, r3 = e - Math.floor(e), n = this.crossFadingFactor();
    return e > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: r3 + (1 - r3) * n } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - n) * r3 };
  }
};
var Jo2 = class {
  constructor(e, r3) {
    this.property = e, this.value = r3, this.expression = K_(r3 === void 0 ? e.specification.default : r3, e.specification);
  }
  isDataDriven() {
    return this.expression.kind === "source" || this.expression.kind === "composite";
  }
  getGlobalStateRefs() {
    return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
  }
  possiblyEvaluate(e, r3, n) {
    return this.property.possiblyEvaluate(this, e, r3, n);
  }
};
var Rs = class {
  constructor(e) {
    this.property = e, this.value = new Jo2(e, void 0);
  }
  transitioned(e, r3) {
    return new Hc(this.property, this.value, r3, Z({}, e.transition, this.transition), e.now);
  }
  untransitioned() {
    return new Hc(this.property, this.value, null, {}, 0);
  }
};
var pn = class {
  constructor(e) {
    this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues);
  }
  getValue(e) {
    return kt2(this._values[e].value.value);
  }
  setValue(e, r3) {
    Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new Rs(this._values[e].property)), this._values[e].value = new Jo2(this._values[e].property, r3 === null ? void 0 : kt2(r3));
  }
  getTransition(e) {
    return kt2(this._values[e].transition);
  }
  setTransition(e, r3) {
    Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new Rs(this._values[e].property)), this._values[e].transition = kt2(r3) || void 0;
  }
  serialize() {
    let e = {};
    for (let r3 of Object.keys(this._values)) {
      let n = this.getValue(r3);
      n !== void 0 && (e[r3] = n);
      let i = this.getTransition(r3);
      i !== void 0 && (e[`${r3}-transition`] = i);
    }
    return e;
  }
  transitioned(e, r3) {
    let n = new Xc(this._properties);
    for (let i of Object.keys(this._values)) n._values[i] = this._values[i].transitioned(e, r3._values[i]);
    return n;
  }
  untransitioned() {
    let e = new Xc(this._properties);
    for (let r3 of Object.keys(this._values)) e._values[r3] = this._values[r3].untransitioned();
    return e;
  }
};
var Hc = class {
  constructor(e, r3, n, i, o) {
    this.property = e, this.value = r3, this.begin = o + i.delay || 0, this.end = this.begin + i.duration || 0, e.specification.transition && (i.delay || i.duration) && (this.prior = n);
  }
  possiblyEvaluate(e, r3, n) {
    let i = e.now || 0, o = this.value.possiblyEvaluate(e, r3, n), a = this.prior;
    if (a) {
      if (i > this.end) return this.prior = null, o;
      if (this.value.isDataDriven()) return this.prior = null, o;
      if (i < this.begin) return a.possiblyEvaluate(e, r3, n);
      {
        let s3 = (i - this.begin) / (this.end - this.begin);
        return this.property.interpolate(a.possiblyEvaluate(e, r3, n), o, ic(s3));
      }
    } else return o;
  }
};
var Xc = class {
  constructor(e) {
    this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues);
  }
  possiblyEvaluate(e, r3, n) {
    let i = new ai(this._properties);
    for (let o of Object.keys(this._values)) i._values[o] = this._values[o].possiblyEvaluate(e, r3, n);
    return i;
  }
  hasTransition() {
    for (let e of Object.keys(this._values)) if (this._values[e].prior) return true;
    return false;
  }
};
var Zc = class {
  constructor(e) {
    this._properties = e, this._values = Object.create(e.defaultPropertyValues);
  }
  hasValue(e) {
    return this._values[e].value !== void 0;
  }
  getValue(e) {
    return kt2(this._values[e].value);
  }
  setValue(e, r3) {
    this._values[e] = new Jo2(this._values[e].property, r3 === null ? void 0 : kt2(r3));
  }
  serialize() {
    let e = {};
    for (let r3 of Object.keys(this._values)) {
      let n = this.getValue(r3);
      n !== void 0 && (e[r3] = n);
    }
    return e;
  }
  possiblyEvaluate(e, r3, n) {
    let i = new ai(this._properties);
    for (let o of Object.keys(this._values)) i._values[o] = this._values[o].possiblyEvaluate(e, r3, n);
    return i;
  }
};
var Ft = class {
  constructor(e, r3, n) {
    this.property = e, this.value = r3, this.parameters = n;
  }
  isConstant() {
    return this.value.kind === "constant";
  }
  constantOr(e) {
    return this.value.kind === "constant" ? this.value.value : e;
  }
  evaluate(e, r3, n, i) {
    return this.property.evaluate(this.value, this.parameters, e, r3, n, i);
  }
};
var ai = class {
  constructor(e) {
    this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues);
  }
  get(e) {
    return this._values[e];
  }
};
var q3 = class {
  constructor(e) {
    this.specification = e;
  }
  possiblyEvaluate(e, r3) {
    if (e.isDataDriven()) throw new Error("Value should not be data driven");
    return e.expression.evaluate(r3);
  }
  interpolate(e, r3, n) {
    let i = this.specification.type, o = Fe[i];
    return o ? o(e, r3, n) : e;
  }
};
var te = class {
  constructor(e, r3) {
    this.specification = e, this.overrides = r3;
  }
  possiblyEvaluate(e, r3, n, i) {
    return e.expression.kind === "constant" || e.expression.kind === "camera" ? new Ft(this, { kind: "constant", value: e.expression.evaluate(r3, null, {}, n, i) }, r3) : new Ft(this, e.expression, r3);
  }
  interpolate(e, r3, n) {
    if (e.value.kind !== "constant" || r3.value.kind !== "constant") return e;
    if (e.value.value === void 0 || r3.value.value === void 0) return new Ft(this, { kind: "constant", value: void 0 }, e.parameters);
    let i = this.specification.type, o = Fe[i];
    if (o) {
      let a = o(e.value.value, r3.value.value, n);
      return new Ft(this, { kind: "constant", value: a }, e.parameters);
    } else return e;
  }
  evaluate(e, r3, n, i, o, a) {
    return e.kind === "constant" ? e.value : e.evaluate(r3, n, i, o, a);
  }
};
var Mn2 = class extends te {
  possiblyEvaluate(e, r3, n, i) {
    if (e.value === void 0) return new Ft(this, { kind: "constant", value: void 0 }, r3);
    if (e.expression.kind === "constant") {
      let o = e.expression.evaluate(r3, null, {}, n, i), s3 = e.property.specification.type === "resolvedImage" && typeof o != "string" ? o.name : o, l = this._calculate(s3, s3, s3, r3);
      return new Ft(this, { kind: "constant", value: l }, r3);
    } else if (e.expression.kind === "camera") {
      let o = this._calculate(e.expression.evaluate({ zoom: r3.zoom - 1 }), e.expression.evaluate({ zoom: r3.zoom }), e.expression.evaluate({ zoom: r3.zoom + 1 }), r3);
      return new Ft(this, { kind: "constant", value: o }, r3);
    } else return new Ft(this, e.expression, r3);
  }
  evaluate(e, r3, n, i, o, a) {
    if (e.kind === "source") {
      let s3 = e.evaluate(r3, n, i, o, a);
      return this._calculate(s3, s3, s3, r3);
    } else return e.kind === "composite" ? this._calculate(e.evaluate({ zoom: Math.floor(r3.zoom) - 1 }, n, i), e.evaluate({ zoom: Math.floor(r3.zoom) }, n, i), e.evaluate({ zoom: Math.floor(r3.zoom) + 1 }, n, i), r3) : e.value;
  }
  _calculate(e, r3, n, i) {
    return i.zoom > i.zoomHistory.lastIntegerZoom ? { from: e, to: r3 } : { from: n, to: r3 };
  }
  interpolate(e) {
    return e;
  }
};
var to = class {
  constructor(e) {
    this.specification = e;
  }
  possiblyEvaluate(e, r3, n, i) {
    if (e.value !== void 0) if (e.expression.kind === "constant") {
      let o = e.expression.evaluate(r3, null, {}, n, i);
      return this._calculate(o, o, o, r3);
    } else return this._calculate(e.expression.evaluate(new Te(Math.floor(r3.zoom - 1), r3)), e.expression.evaluate(new Te(Math.floor(r3.zoom), r3)), e.expression.evaluate(new Te(Math.floor(r3.zoom + 1), r3)), r3);
  }
  _calculate(e, r3, n, i) {
    return i.zoom > i.zoomHistory.lastIntegerZoom ? { from: e, to: r3 } : { from: n, to: r3 };
  }
  interpolate(e) {
    return e;
  }
};
var In = class {
  constructor(e) {
    this.specification = e;
  }
  possiblyEvaluate(e, r3, n, i) {
    return !!e.expression.evaluate(r3, null, {}, n, i);
  }
  interpolate() {
    return false;
  }
};
var Ue = class {
  constructor(e) {
    this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
    for (let r3 in e) {
      let n = e[r3];
      n.specification.overridable && this.overridableProperties.push(r3);
      let i = this.defaultPropertyValues[r3] = new Jo2(n, void 0), o = this.defaultTransitionablePropertyValues[r3] = new Rs(n);
      this.defaultTransitioningPropertyValues[r3] = o.untransitioned(), this.defaultPossiblyEvaluatedValues[r3] = i.possiblyEvaluate({});
    }
  }
};
X("DataDrivenProperty", te);
X("DataConstantProperty", q3);
X("CrossFadedDataDrivenProperty", Mn2);
X("CrossFadedProperty", to);
X("ColorRampProperty", In);
var qc = "-transition";
var it = class extends Ee {
  constructor(e, r3) {
    if (super(), this.id = e.id, this.type = e.type, this._featureFilter = { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() }, e.type !== "custom" && (e = e, this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, e.type !== "background" && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter, this._featureFilter = ii(e.filter)), r3.layout && (this._unevaluatedLayout = new Zc(r3.layout)), r3.paint)) {
      this._transitionablePaint = new pn(r3.paint);
      for (let n in e.paint) this.setPaintProperty(n, e.paint[n], { validate: false });
      for (let n in e.layout) this.setLayoutProperty(n, e.layout[n], { validate: false });
      this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new ai(r3.paint);
    }
  }
  setFilter(e) {
    this.filter = e, this._featureFilter = ii(e);
  }
  getCrossfadeParameters() {
    return this._crossfadeParameters;
  }
  getLayoutProperty(e) {
    return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e);
  }
  getLayoutAffectingGlobalStateRefs() {
    let e = /* @__PURE__ */ new Set();
    if (this._unevaluatedLayout) for (let r3 in this._unevaluatedLayout._values) {
      let n = this._unevaluatedLayout._values[r3];
      for (let i of n.getGlobalStateRefs()) e.add(i);
    }
    for (let r3 of this._featureFilter.getGlobalStateRefs()) e.add(r3);
    return e;
  }
  setLayoutProperty(e, r3, n = {}) {
    if (r3 != null) {
      let i = `layers.${this.id}.layout.${e}`;
      if (this._validate(xv, i, e, r3, n)) return;
    }
    if (e === "visibility") {
      this.visibility = r3;
      return;
    }
    this._unevaluatedLayout.setValue(e, r3);
  }
  getPaintProperty(e) {
    return e.endsWith(qc) ? this._transitionablePaint.getTransition(e.slice(0, -qc.length)) : this._transitionablePaint.getValue(e);
  }
  setPaintProperty(e, r3, n = {}) {
    if (r3 != null) {
      let i = `layers.${this.id}.paint.${e}`;
      if (this._validate(gv, i, e, r3, n)) return false;
    }
    if (e.endsWith(qc)) return this._transitionablePaint.setTransition(e.slice(0, -qc.length), r3 || void 0), false;
    {
      let i = this._transitionablePaint._values[e], o = i.property.specification["property-type"] === "cross-faded-data-driven", a = i.value.isDataDriven(), s3 = i.value;
      this._transitionablePaint.setValue(e, r3), this._handleSpecialPaintPropertyUpdate(e);
      let l = this._transitionablePaint._values[e].value;
      return l.isDataDriven() || a || o || this._handleOverridablePaintPropertyUpdate(e, s3, l);
    }
  }
  _handleSpecialPaintPropertyUpdate(e) {
  }
  _handleOverridablePaintPropertyUpdate(e, r3, n) {
    return false;
  }
  isHidden(e) {
    return this.minzoom && e < this.minzoom || this.maxzoom && e >= this.maxzoom ? true : this.visibility === "none";
  }
  updateTransitions(e) {
    this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint);
  }
  hasTransition() {
    return this._transitioningPaint.hasTransition();
  }
  recalculate(e, r3) {
    e.getCrossfadeParameters && (this._crossfadeParameters = e.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, r3)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, r3);
  }
  serialize() {
    let e = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
    return this.visibility && (e.layout = e.layout || {}, e.layout.visibility = this.visibility), ac(e, (r3, n) => r3 !== void 0 && !(n === "layout" && !Object.keys(r3).length) && !(n === "paint" && !Object.keys(r3).length));
  }
  _validate(e, r3, n, i, o = {}) {
    return o && o.validate === false ? false : oi(this, e.call(Je, { key: r3, layerType: this.type, objectKey: n, value: i, styleSpec: D, style: { glyphs: true, sprite: true } }));
  }
  is3D() {
    return false;
  }
  isTileClipped() {
    return false;
  }
  hasOffscreenPass() {
    return false;
  }
  resize() {
  }
  isStateDependent() {
    for (let e in this.paint._values) {
      let r3 = this.paint.get(e);
      if (!(!(r3 instanceof Ft) || !ri(r3.property.specification)) && (r3.value.kind === "source" || r3.value.kind === "composite") && r3.value.isStateDependent) return true;
    }
    return false;
  }
};
$i();
$i();
$i();
var WR = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
var si = class {
  constructor(e, r3) {
    this._structArray = e, this._pos1 = r3 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
  }
};
var $R = 128;
var KR = 5;
var qe = class {
  constructor() {
    this.isTransferred = false, this.capacity = -1, this.resize(0);
  }
  static serialize(e, r3) {
    return e._trim(), r3 && (e.isTransferred = true, r3.push(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer };
  }
  static deserialize(e) {
    let r3 = Object.create(this.prototype);
    return r3.arrayBuffer = e.arrayBuffer, r3.length = e.length, r3.capacity = e.arrayBuffer.byteLength / r3.bytesPerElement, r3._refreshViews(), r3;
  }
  _trim() {
    this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
  }
  clear() {
    this.length = 0;
  }
  resize(e) {
    this.reserve(e), this.length = e;
  }
  reserve(e) {
    if (e > this.capacity) {
      this.capacity = Math.max(e, Math.floor(this.capacity * KR), $R), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
      let r3 = this.uint8;
      this._refreshViews(), r3 && this.uint8.set(r3);
    }
  }
  _refreshViews() {
    throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
  }
};
function ze(t63, e = 1) {
  let r3 = 0, n = 0, i = t63.map((a) => {
    let s3 = JR(a.type), l = r3 = Sv(r3, Math.max(e, s3)), u3 = a.components || 1;
    return n = Math.max(n, s3), r3 += s3 * u3, { name: a.name, type: a.type, components: u3, offset: l };
  }), o = Sv(r3, Math.max(n, e));
  return { members: i, size: o, alignment: e };
}
function JR(t63) {
  return WR[t63].BYTES_PER_ELEMENT;
}
function Sv(t63, e) {
  return Math.ceil(t63 / e) * e;
}
var Cv = s(fe(), 1);
var ro = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, r3) {
    let n = this.length;
    return this.resize(n + 1), this.emplace(n, e, r3);
  }
  emplace(e, r3, n) {
    let i = e * 2;
    return this.int16[i + 0] = r3, this.int16[i + 1] = n, e;
  }
};
ro.prototype.bytesPerElement = 4;
X("StructArrayLayout2i4", ro);
var Qo = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, r3, n) {
    let i = this.length;
    return this.resize(i + 1), this.emplace(i, e, r3, n);
  }
  emplace(e, r3, n, i) {
    let o = e * 3;
    return this.int16[o + 0] = r3, this.int16[o + 1] = n, this.int16[o + 2] = i, e;
  }
};
Qo.prototype.bytesPerElement = 6;
X("StructArrayLayout3i6", Qo);
var ks = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, r3, n, i) {
    let o = this.length;
    return this.resize(o + 1), this.emplace(o, e, r3, n, i);
  }
  emplace(e, r3, n, i, o) {
    let a = e * 4;
    return this.int16[a + 0] = r3, this.int16[a + 1] = n, this.int16[a + 2] = i, this.int16[a + 3] = o, e;
  }
};
ks.prototype.bytesPerElement = 8;
X("StructArrayLayout4i8", ks);
var Fs = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, r3, n, i, o, a) {
    let s3 = this.length;
    return this.resize(s3 + 1), this.emplace(s3, e, r3, n, i, o, a);
  }
  emplace(e, r3, n, i, o, a, s3) {
    let l = e * 6;
    return this.int16[l + 0] = r3, this.int16[l + 1] = n, this.int16[l + 2] = i, this.int16[l + 3] = o, this.int16[l + 4] = a, this.int16[l + 5] = s3, e;
  }
};
Fs.prototype.bytesPerElement = 12;
X("StructArrayLayout2i4i12", Fs);
var Os = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, r3, n, i, o, a) {
    let s3 = this.length;
    return this.resize(s3 + 1), this.emplace(s3, e, r3, n, i, o, a);
  }
  emplace(e, r3, n, i, o, a, s3) {
    let l = e * 4, u3 = e * 8;
    return this.int16[l + 0] = r3, this.int16[l + 1] = n, this.uint8[u3 + 4] = i, this.uint8[u3 + 5] = o, this.uint8[u3 + 6] = a, this.uint8[u3 + 7] = s3, e;
  }
};
Os.prototype.bytesPerElement = 8;
X("StructArrayLayout2i4ub8", Os);
var li = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, r3) {
    let n = this.length;
    return this.resize(n + 1), this.emplace(n, e, r3);
  }
  emplace(e, r3, n) {
    let i = e * 2;
    return this.float32[i + 0] = r3, this.float32[i + 1] = n, e;
  }
};
li.prototype.bytesPerElement = 8;
X("StructArrayLayout2f8", li);
var Bs = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, r3, n, i, o, a, s3, l, u3, c) {
    let p = this.length;
    return this.resize(p + 1), this.emplace(p, e, r3, n, i, o, a, s3, l, u3, c);
  }
  emplace(e, r3, n, i, o, a, s3, l, u3, c, p) {
    let h = e * 10;
    return this.uint16[h + 0] = r3, this.uint16[h + 1] = n, this.uint16[h + 2] = i, this.uint16[h + 3] = o, this.uint16[h + 4] = a, this.uint16[h + 5] = s3, this.uint16[h + 6] = l, this.uint16[h + 7] = u3, this.uint16[h + 8] = c, this.uint16[h + 9] = p, e;
  }
};
Bs.prototype.bytesPerElement = 20;
X("StructArrayLayout10ui20", Bs);
var zs = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, r3, n, i, o, a, s3, l, u3, c, p, h) {
    let f = this.length;
    return this.resize(f + 1), this.emplace(f, e, r3, n, i, o, a, s3, l, u3, c, p, h);
  }
  emplace(e, r3, n, i, o, a, s3, l, u3, c, p, h, f) {
    let d = e * 12;
    return this.int16[d + 0] = r3, this.int16[d + 1] = n, this.int16[d + 2] = i, this.int16[d + 3] = o, this.uint16[d + 4] = a, this.uint16[d + 5] = s3, this.uint16[d + 6] = l, this.uint16[d + 7] = u3, this.int16[d + 8] = c, this.int16[d + 9] = p, this.int16[d + 10] = h, this.int16[d + 11] = f, e;
  }
};
zs.prototype.bytesPerElement = 24;
X("StructArrayLayout4i4ui4i24", zs);
var Vs = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, r3, n) {
    let i = this.length;
    return this.resize(i + 1), this.emplace(i, e, r3, n);
  }
  emplace(e, r3, n, i) {
    let o = e * 3;
    return this.float32[o + 0] = r3, this.float32[o + 1] = n, this.float32[o + 2] = i, e;
  }
};
Vs.prototype.bytesPerElement = 12;
X("StructArrayLayout3f12", Vs);
var Us = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
  }
  emplaceBack(e) {
    let r3 = this.length;
    return this.resize(r3 + 1), this.emplace(r3, e);
  }
  emplace(e, r3) {
    let n = e * 1;
    return this.uint32[n + 0] = r3, e;
  }
};
Us.prototype.bytesPerElement = 4;
X("StructArrayLayout1ul4", Us);
var Ns = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, r3, n, i, o, a, s3, l, u3) {
    let c = this.length;
    return this.resize(c + 1), this.emplace(c, e, r3, n, i, o, a, s3, l, u3);
  }
  emplace(e, r3, n, i, o, a, s3, l, u3, c) {
    let p = e * 10, h = e * 5;
    return this.int16[p + 0] = r3, this.int16[p + 1] = n, this.int16[p + 2] = i, this.int16[p + 3] = o, this.int16[p + 4] = a, this.int16[p + 5] = s3, this.uint32[h + 3] = l, this.uint16[p + 8] = u3, this.uint16[p + 9] = c, e;
  }
};
Ns.prototype.bytesPerElement = 20;
X("StructArrayLayout6i1ul2ui20", Ns);
var Gs = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, r3, n, i, o, a) {
    let s3 = this.length;
    return this.resize(s3 + 1), this.emplace(s3, e, r3, n, i, o, a);
  }
  emplace(e, r3, n, i, o, a, s3) {
    let l = e * 6;
    return this.int16[l + 0] = r3, this.int16[l + 1] = n, this.int16[l + 2] = i, this.int16[l + 3] = o, this.int16[l + 4] = a, this.int16[l + 5] = s3, e;
  }
};
Gs.prototype.bytesPerElement = 12;
X("StructArrayLayout2i2i2i12", Gs);
var js = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, r3, n, i, o) {
    let a = this.length;
    return this.resize(a + 1), this.emplace(a, e, r3, n, i, o);
  }
  emplace(e, r3, n, i, o, a) {
    let s3 = e * 4, l = e * 8;
    return this.float32[s3 + 0] = r3, this.float32[s3 + 1] = n, this.float32[s3 + 2] = i, this.int16[l + 6] = o, this.int16[l + 7] = a, e;
  }
};
js.prototype.bytesPerElement = 16;
X("StructArrayLayout2f1f2i16", js);
var Hs = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, r3, n, i, o, a) {
    let s3 = this.length;
    return this.resize(s3 + 1), this.emplace(s3, e, r3, n, i, o, a);
  }
  emplace(e, r3, n, i, o, a, s3) {
    let l = e * 16, u3 = e * 4, c = e * 8;
    return this.uint8[l + 0] = r3, this.uint8[l + 1] = n, this.float32[u3 + 1] = i, this.float32[u3 + 2] = o, this.int16[c + 6] = a, this.int16[c + 7] = s3, e;
  }
};
Hs.prototype.bytesPerElement = 16;
X("StructArrayLayout2ub2f2i16", Hs);
var ea = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, r3, n) {
    let i = this.length;
    return this.resize(i + 1), this.emplace(i, e, r3, n);
  }
  emplace(e, r3, n, i) {
    let o = e * 3;
    return this.uint16[o + 0] = r3, this.uint16[o + 1] = n, this.uint16[o + 2] = i, e;
  }
};
ea.prototype.bytesPerElement = 6;
X("StructArrayLayout3ui6", ea);
var Xs = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, r3, n, i, o, a, s3, l, u3, c, p, h, f, d, g, x, b) {
    let v3 = this.length;
    return this.resize(v3 + 1), this.emplace(v3, e, r3, n, i, o, a, s3, l, u3, c, p, h, f, d, g, x, b);
  }
  emplace(e, r3, n, i, o, a, s3, l, u3, c, p, h, f, d, g, x, b, v3) {
    let P = e * 24, w3 = e * 12, T = e * 48;
    return this.int16[P + 0] = r3, this.int16[P + 1] = n, this.uint16[P + 2] = i, this.uint16[P + 3] = o, this.uint32[w3 + 2] = a, this.uint32[w3 + 3] = s3, this.uint32[w3 + 4] = l, this.uint16[P + 10] = u3, this.uint16[P + 11] = c, this.uint16[P + 12] = p, this.float32[w3 + 7] = h, this.float32[w3 + 8] = f, this.uint8[T + 36] = d, this.uint8[T + 37] = g, this.uint8[T + 38] = x, this.uint32[w3 + 10] = b, this.int16[P + 22] = v3, e;
  }
};
Xs.prototype.bytesPerElement = 48;
X("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Xs);
var Zs = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, r3, n, i, o, a, s3, l, u3, c, p, h, f, d, g, x, b, v3, P, w3, T, S, C3, A, E, L, F, O) {
    let z = this.length;
    return this.resize(z + 1), this.emplace(z, e, r3, n, i, o, a, s3, l, u3, c, p, h, f, d, g, x, b, v3, P, w3, T, S, C3, A, E, L, F, O);
  }
  emplace(e, r3, n, i, o, a, s3, l, u3, c, p, h, f, d, g, x, b, v3, P, w3, T, S, C3, A, E, L, F, O, z) {
    let I = e * 32, R = e * 16;
    return this.int16[I + 0] = r3, this.int16[I + 1] = n, this.int16[I + 2] = i, this.int16[I + 3] = o, this.int16[I + 4] = a, this.int16[I + 5] = s3, this.int16[I + 6] = l, this.int16[I + 7] = u3, this.uint16[I + 8] = c, this.uint16[I + 9] = p, this.uint16[I + 10] = h, this.uint16[I + 11] = f, this.uint16[I + 12] = d, this.uint16[I + 13] = g, this.uint16[I + 14] = x, this.uint16[I + 15] = b, this.uint16[I + 16] = v3, this.uint16[I + 17] = P, this.uint16[I + 18] = w3, this.uint16[I + 19] = T, this.uint16[I + 20] = S, this.uint16[I + 21] = C3, this.uint16[I + 22] = A, this.uint32[R + 12] = E, this.float32[R + 13] = L, this.float32[R + 14] = F, this.uint16[I + 30] = O, this.uint16[I + 31] = z, e;
  }
};
Zs.prototype.bytesPerElement = 64;
X("StructArrayLayout8i15ui1ul2f2ui64", Zs);
var no = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e) {
    let r3 = this.length;
    return this.resize(r3 + 1), this.emplace(r3, e);
  }
  emplace(e, r3) {
    let n = e * 1;
    return this.float32[n + 0] = r3, e;
  }
};
no.prototype.bytesPerElement = 4;
X("StructArrayLayout1f4", no);
var qs = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, r3, n) {
    let i = this.length;
    return this.resize(i + 1), this.emplace(i, e, r3, n);
  }
  emplace(e, r3, n, i) {
    let o = e * 6, a = e * 3;
    return this.uint16[o + 0] = r3, this.float32[a + 1] = n, this.float32[a + 2] = i, e;
  }
};
qs.prototype.bytesPerElement = 12;
X("StructArrayLayout1ui2f12", qs);
var Ys = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, r3, n) {
    let i = this.length;
    return this.resize(i + 1), this.emplace(i, e, r3, n);
  }
  emplace(e, r3, n, i) {
    let o = e * 2, a = e * 4;
    return this.uint32[o + 0] = r3, this.uint16[a + 2] = n, this.uint16[a + 3] = i, e;
  }
};
Ys.prototype.bytesPerElement = 8;
X("StructArrayLayout1ul2ui8", Ys);
var Ws = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, r3) {
    let n = this.length;
    return this.resize(n + 1), this.emplace(n, e, r3);
  }
  emplace(e, r3, n) {
    let i = e * 2;
    return this.uint16[i + 0] = r3, this.uint16[i + 1] = n, e;
  }
};
Ws.prototype.bytesPerElement = 4;
X("StructArrayLayout2ui4", Ws);
var $s = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e) {
    let r3 = this.length;
    return this.resize(r3 + 1), this.emplace(r3, e);
  }
  emplace(e, r3) {
    let n = e * 1;
    return this.uint16[n + 0] = r3, e;
  }
};
$s.prototype.bytesPerElement = 2;
X("StructArrayLayout1ui2", $s);
var ta = class extends qe {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, r3, n, i) {
    let o = this.length;
    return this.resize(o + 1), this.emplace(o, e, r3, n, i);
  }
  emplace(e, r3, n, i, o) {
    let a = e * 4;
    return this.float32[a + 0] = r3, this.float32[a + 1] = n, this.float32[a + 2] = i, this.float32[a + 3] = o, e;
  }
};
ta.prototype.bytesPerElement = 16;
X("StructArrayLayout4f16", ta);
var Yc = class extends si {
  get anchorPointX() {
    return this._structArray.int16[this._pos2 + 0];
  }
  get anchorPointY() {
    return this._structArray.int16[this._pos2 + 1];
  }
  get x1() {
    return this._structArray.int16[this._pos2 + 2];
  }
  get y1() {
    return this._structArray.int16[this._pos2 + 3];
  }
  get x2() {
    return this._structArray.int16[this._pos2 + 4];
  }
  get y2() {
    return this._structArray.int16[this._pos2 + 5];
  }
  get featureIndex() {
    return this._structArray.uint32[this._pos4 + 3];
  }
  get sourceLayerIndex() {
    return this._structArray.uint16[this._pos2 + 8];
  }
  get bucketIndex() {
    return this._structArray.uint16[this._pos2 + 9];
  }
  get anchorPoint() {
    return new Cv.default(this.anchorPointX, this.anchorPointY);
  }
};
Yc.prototype.size = 20;
var Ks = class extends Ns {
  get(e) {
    return new Yc(this, e);
  }
};
X("CollisionBoxArray", Ks);
var Wc = class extends si {
  get anchorX() {
    return this._structArray.int16[this._pos2 + 0];
  }
  get anchorY() {
    return this._structArray.int16[this._pos2 + 1];
  }
  get glyphStartIndex() {
    return this._structArray.uint16[this._pos2 + 2];
  }
  get numGlyphs() {
    return this._structArray.uint16[this._pos2 + 3];
  }
  get vertexStartIndex() {
    return this._structArray.uint32[this._pos4 + 2];
  }
  get lineStartIndex() {
    return this._structArray.uint32[this._pos4 + 3];
  }
  get lineLength() {
    return this._structArray.uint32[this._pos4 + 4];
  }
  get segment() {
    return this._structArray.uint16[this._pos2 + 10];
  }
  get lowerSize() {
    return this._structArray.uint16[this._pos2 + 11];
  }
  get upperSize() {
    return this._structArray.uint16[this._pos2 + 12];
  }
  get lineOffsetX() {
    return this._structArray.float32[this._pos4 + 7];
  }
  get lineOffsetY() {
    return this._structArray.float32[this._pos4 + 8];
  }
  get writingMode() {
    return this._structArray.uint8[this._pos1 + 36];
  }
  get placedOrientation() {
    return this._structArray.uint8[this._pos1 + 37];
  }
  set placedOrientation(e) {
    this._structArray.uint8[this._pos1 + 37] = e;
  }
  get hidden() {
    return this._structArray.uint8[this._pos1 + 38];
  }
  set hidden(e) {
    this._structArray.uint8[this._pos1 + 38] = e;
  }
  get crossTileID() {
    return this._structArray.uint32[this._pos4 + 10];
  }
  set crossTileID(e) {
    this._structArray.uint32[this._pos4 + 10] = e;
  }
  get associatedIconIndex() {
    return this._structArray.int16[this._pos2 + 22];
  }
};
Wc.prototype.size = 48;
var Js = class extends Xs {
  get(e) {
    return new Wc(this, e);
  }
};
X("PlacedSymbolArray", Js);
var $c = class extends si {
  get anchorX() {
    return this._structArray.int16[this._pos2 + 0];
  }
  get anchorY() {
    return this._structArray.int16[this._pos2 + 1];
  }
  get rightJustifiedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 2];
  }
  get centerJustifiedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 3];
  }
  get leftJustifiedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 4];
  }
  get verticalPlacedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 5];
  }
  get placedIconSymbolIndex() {
    return this._structArray.int16[this._pos2 + 6];
  }
  get verticalPlacedIconSymbolIndex() {
    return this._structArray.int16[this._pos2 + 7];
  }
  get key() {
    return this._structArray.uint16[this._pos2 + 8];
  }
  get textBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 9];
  }
  get textBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 10];
  }
  get verticalTextBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 11];
  }
  get verticalTextBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 12];
  }
  get iconBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 13];
  }
  get iconBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 14];
  }
  get verticalIconBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 15];
  }
  get verticalIconBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 16];
  }
  get featureIndex() {
    return this._structArray.uint16[this._pos2 + 17];
  }
  get numHorizontalGlyphVertices() {
    return this._structArray.uint16[this._pos2 + 18];
  }
  get numVerticalGlyphVertices() {
    return this._structArray.uint16[this._pos2 + 19];
  }
  get numIconVertices() {
    return this._structArray.uint16[this._pos2 + 20];
  }
  get numVerticalIconVertices() {
    return this._structArray.uint16[this._pos2 + 21];
  }
  get useRuntimeCollisionCircles() {
    return this._structArray.uint16[this._pos2 + 22];
  }
  get crossTileID() {
    return this._structArray.uint32[this._pos4 + 12];
  }
  set crossTileID(e) {
    this._structArray.uint32[this._pos4 + 12] = e;
  }
  get textBoxScale() {
    return this._structArray.float32[this._pos4 + 13];
  }
  get collisionCircleDiameter() {
    return this._structArray.float32[this._pos4 + 14];
  }
  get textAnchorOffsetStartIndex() {
    return this._structArray.uint16[this._pos2 + 30];
  }
  get textAnchorOffsetEndIndex() {
    return this._structArray.uint16[this._pos2 + 31];
  }
};
$c.prototype.size = 64;
var Qs = class extends Zs {
  get(e) {
    return new $c(this, e);
  }
};
X("SymbolInstanceArray", Qs);
var el = class extends no {
  getoffsetX(e) {
    return this.float32[e * 1 + 0];
  }
};
X("GlyphOffsetArray", el);
var tl = class extends Qo {
  getx(e) {
    return this.int16[e * 3 + 0];
  }
  gety(e) {
    return this.int16[e * 3 + 1];
  }
  gettileUnitDistanceFromAnchor(e) {
    return this.int16[e * 3 + 2];
  }
};
X("SymbolLineVertexArray", tl);
var Kc = class extends si {
  get textAnchor() {
    return this._structArray.uint16[this._pos2 + 0];
  }
  get textOffset0() {
    return this._structArray.float32[this._pos4 + 1];
  }
  get textOffset1() {
    return this._structArray.float32[this._pos4 + 2];
  }
};
Kc.prototype.size = 12;
var rl = class extends qs {
  get(e) {
    return new Kc(this, e);
  }
};
X("TextAnchorOffsetArray", rl);
var Jc = class extends si {
  get featureIndex() {
    return this._structArray.uint32[this._pos4 + 0];
  }
  get sourceLayerIndex() {
    return this._structArray.uint16[this._pos2 + 2];
  }
  get bucketIndex() {
    return this._structArray.uint16[this._pos2 + 3];
  }
};
Jc.prototype.size = 8;
var nl = class extends Ys {
  get(e) {
    return new Jc(this, e);
  }
};
X("FeatureIndexArray", nl);
var Et = class extends ro {
};
var Qc = class extends Qo {
};
var ep = class extends ks {
};
var tp = class extends ro {
};
var rp = class extends ro {
};
var np = class extends Fs {
};
var ip = class extends Os {
};
var op = class extends li {
};
var An = class extends Bs {
};
var ap = class extends zs {
};
var sp = class extends Vs {
};
var lp = class extends Us {
};
var il2 = class extends Gs {
};
var up = class extends js {
};
var cp = class extends Hs {
};
var pp = class extends ea {
};
var Qe = class extends ea {
};
var ui = class extends Ws {
};
var ol2 = class extends $s {
};
$i();
var QR = ze([{ name: "a_pos", components: 2, type: "Int16" }], 4);
var { members: Mv, size: FG, alignment: OG } = QR;
$i();
var de2 = class t39 {
  constructor(e = []) {
    this._forceNewSegmentOnNextPrepare = false;
    this.segments = e;
  }
  prepareSegment(e, r3, n, i) {
    let o = this.segments[this.segments.length - 1];
    return e > t39.MAX_VERTEX_ARRAY_LENGTH && ve2(`Max vertices per segment is ${t39.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${t39.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !o || o.vertexLength + e > t39.MAX_VERTEX_ARRAY_LENGTH || o.sortKey !== i ? this.createNewSegment(r3, n, i) : o;
  }
  createNewSegment(e, r3, n) {
    let i = { vertexOffset: e.length, primitiveOffset: r3.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
    return n !== void 0 && (i.sortKey = n), this._forceNewSegmentOnNextPrepare = false, this.segments.push(i), i;
  }
  getOrCreateLatestSegment(e, r3, n) {
    return this.prepareSegment(0, e, r3, n);
  }
  forceNewSegmentOnNextPrepare() {
    this._forceNewSegmentOnNextPrepare = true;
  }
  get() {
    return this.segments;
  }
  destroy() {
    for (let e of this.segments) for (let r3 in e.vaos) e.vaos[r3].destroy();
  }
  static simpleSegment(e, r3, n, i) {
    return new t39([{ vertexOffset: e, primitiveOffset: r3, vertexLength: n, primitiveLength: i, vaos: {}, sortKey: 0 }]);
  }
};
de2.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1;
X("SegmentVector", de2);
$i();
$i();
function qd(t63, e) {
  return t63 = ce(Math.floor(t63), 0, 255), e = ce(Math.floor(e), 0, 255), 256 * t63 + e;
}
$i();
var al = ze([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
$i();
var Dv = s($d(), 1);
var sl = class t40 {
  constructor() {
    this.ids = [], this.positions = [], this.indexed = false;
  }
  add(e, r3, n, i) {
    this.ids.push(Lv(e)), this.positions.push(r3, n, i);
  }
  getPositions(e) {
    if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
    let r3 = Lv(e), n = 0, i = this.ids.length - 1;
    for (; n < i; ) {
      let a = n + i >> 1;
      this.ids[a] >= r3 ? i = a : n = a + 1;
    }
    let o = [];
    for (; this.ids[n] === r3; ) {
      let a = this.positions[3 * n], s3 = this.positions[3 * n + 1], l = this.positions[3 * n + 2];
      o.push({ index: a, start: s3, end: l }), n++;
    }
    return o;
  }
  static serialize(e, r3) {
    let n = new Float64Array(e.ids), i = new Uint32Array(e.positions);
    return Kd(n, i, 0, n.length - 1), r3 && r3.push(n.buffer, i.buffer), { ids: n, positions: i };
  }
  static deserialize(e) {
    let r3 = new t40();
    return r3.ids = e.ids, r3.positions = e.positions, r3.indexed = true, r3;
  }
};
function Lv(t63) {
  let e = +t63;
  return !isNaN(e) && e <= Number.MAX_SAFE_INTEGER ? e : (0, Dv.default)(String(t63));
}
function Kd(t63, e, r3, n) {
  for (; r3 < n; ) {
    let i = t63[r3 + n >> 1], o = r3 - 1, a = n + 1;
    for (; ; ) {
      do
        o++;
      while (t63[o] < i);
      do
        a--;
      while (t63[a] > i);
      if (o >= a) break;
      fp(t63, o, a), fp(e, 3 * o, 3 * a), fp(e, 3 * o + 1, 3 * a + 1), fp(e, 3 * o + 2, 3 * a + 2);
    }
    a - r3 < n - a ? (Kd(t63, e, r3, a), r3 = a + 1) : (Kd(t63, e, a + 1, n), n = a);
  }
}
function fp(t63, e, r3) {
  let n = t63[e];
  t63[e] = t63[r3], t63[r3] = n;
}
X("FeaturePositionMap", sl);
$i();
var Yr = class {
  constructor(e, r3) {
    this.gl = e.gl, this.location = r3;
  }
};
var re = class extends Yr {
  constructor(e, r3) {
    super(e, r3), this.current = 0;
  }
  set(e) {
    this.current !== e && (this.current = e, this.gl.uniform1i(this.location, e));
  }
};
var N = class extends Yr {
  constructor(e, r3) {
    super(e, r3), this.current = 0;
  }
  set(e) {
    this.current !== e && (this.current = e, this.gl.uniform1f(this.location, e));
  }
};
var ee = class extends Yr {
  constructor(e, r3) {
    super(e, r3), this.current = [0, 0];
  }
  set(e) {
    (e[0] !== this.current[0] || e[1] !== this.current[1]) && (this.current = e, this.gl.uniform2f(this.location, e[0], e[1]));
  }
};
var gt = class extends Yr {
  constructor(e, r3) {
    super(e, r3), this.current = [0, 0, 0];
  }
  set(e) {
    (e[0] !== this.current[0] || e[1] !== this.current[1] || e[2] !== this.current[2]) && (this.current = e, this.gl.uniform3f(this.location, e[0], e[1], e[2]));
  }
};
var Ot = class extends Yr {
  constructor(e, r3) {
    super(e, r3), this.current = [0, 0, 0, 0];
  }
  set(e) {
    (e[0] !== this.current[0] || e[1] !== this.current[1] || e[2] !== this.current[2] || e[3] !== this.current[3]) && (this.current = e, this.gl.uniform4f(this.location, e[0], e[1], e[2], e[3]));
  }
};
var Bt = class extends Yr {
  constructor(e, r3) {
    super(e, r3), this.current = K.transparent;
  }
  set(e) {
    (e.r !== this.current.r || e.g !== this.current.g || e.b !== this.current.b || e.a !== this.current.a) && (this.current = e, this.gl.uniform4f(this.location, e.r, e.g, e.b, e.a));
  }
};
var ll = class extends Yr {
  constructor(e, r3) {
    super(e, r3), this.current = new Array();
  }
  set(e) {
    if (e != this.current) {
      this.current = e;
      let r3 = new Float32Array(e.length * 4);
      for (let n = 0; n < e.length; n++) r3[4 * n] = e[n].r, r3[4 * n + 1] = e[n].g, r3[4 * n + 2] = e[n].b, r3[4 * n + 3] = e[n].a;
      this.gl.uniform4fv(this.location, r3);
    }
  }
};
var ul = class extends Yr {
  constructor(e, r3) {
    super(e, r3), this.current = new Array();
  }
  set(e) {
    if (e != this.current) {
      this.current = e;
      let r3 = new Float32Array(e);
      this.gl.uniform1fv(this.location, r3);
    }
  }
};
var nk = new Float32Array(16);
var ft = class extends Yr {
  constructor(e, r3) {
    super(e, r3), this.current = nk;
  }
  set(e) {
    if (e[12] !== this.current[12] || e[0] !== this.current[0]) {
      this.current = e, this.gl.uniformMatrix4fv(this.location, false, e);
      return;
    }
    for (let r3 = 1; r3 < 16; r3++) if (e[r3] !== this.current[r3]) {
      this.current = e, this.gl.uniformMatrix4fv(this.location, false, e);
      break;
    }
  }
};
function Jd(t63) {
  return [qd(255 * t63.r, 255 * t63.g), qd(255 * t63.b, 255 * t63.a)];
}
var io = class {
  constructor(e, r3, n) {
    this.value = e, this.uniformNames = r3.map((i) => `u_${i}`), this.type = n;
  }
  setUniform(e, r3, n) {
    e.set(n.constantOr(this.value));
  }
  getBinding(e, r3, n) {
    return this.type === "color" ? new Bt(e, r3) : new N(e, r3);
  }
};
var ci = class {
  constructor(e, r3) {
    this.uniformNames = r3.map((n) => `u_${n}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
  }
  setConstantPatternPositions(e, r3) {
    this.pixelRatioFrom = r3.pixelRatio, this.pixelRatioTo = e.pixelRatio, this.patternFrom = r3.tlbr, this.patternTo = e.tlbr;
  }
  setUniform(e, r3, n, i) {
    let o = i === "u_pattern_to" ? this.patternTo : i === "u_pattern_from" ? this.patternFrom : i === "u_pixel_ratio_to" ? this.pixelRatioTo : i === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
    o && e.set(o);
  }
  getBinding(e, r3, n) {
    return n.substr(0, 9) === "u_pattern" ? new Ot(e, r3) : new N(e, r3);
  }
};
var Wr = class {
  constructor(e, r3, n, i) {
    this.expression = e, this.type = n, this.maxValue = 0, this.paintVertexAttributes = r3.map((o) => ({ name: `a_${o}`, type: "Float32", components: n === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new i();
  }
  populatePaintArray(e, r3, n, i, o) {
    let a = this.paintVertexArray.length, s3 = this.expression.evaluate(new Te(0), r3, {}, i, [], o);
    this.paintVertexArray.resize(e), this._setPaintValue(a, e, s3);
  }
  updatePaintArray(e, r3, n, i) {
    let o = this.expression.evaluate({ zoom: 0 }, n, i);
    this._setPaintValue(e, r3, o);
  }
  _setPaintValue(e, r3, n) {
    if (this.type === "color") {
      let i = Jd(n);
      for (let o = e; o < r3; o++) this.paintVertexArray.emplace(o, i[0], i[1]);
    } else {
      for (let i = e; i < r3; i++) this.paintVertexArray.emplace(i, n);
      this.maxValue = Math.max(this.maxValue, Math.abs(n));
    }
  }
  upload(e) {
    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
  }
  destroy() {
    this.paintVertexBuffer && this.paintVertexBuffer.destroy();
  }
};
var xr = class {
  constructor(e, r3, n, i, o, a) {
    this.expression = e, this.uniformNames = r3.map((s3) => `u_${s3}_t`), this.type = n, this.useIntegerZoom = i, this.zoom = o, this.maxValue = 0, this.paintVertexAttributes = r3.map((s3) => ({ name: `a_${s3}`, type: "Float32", components: n === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new a();
  }
  populatePaintArray(e, r3, n, i, o) {
    let a = this.expression.evaluate(new Te(this.zoom), r3, {}, i, [], o), s3 = this.expression.evaluate(new Te(this.zoom + 1), r3, {}, i, [], o), l = this.paintVertexArray.length;
    this.paintVertexArray.resize(e), this._setPaintValue(l, e, a, s3);
  }
  updatePaintArray(e, r3, n, i) {
    let o = this.expression.evaluate({ zoom: this.zoom }, n, i), a = this.expression.evaluate({ zoom: this.zoom + 1 }, n, i);
    this._setPaintValue(e, r3, o, a);
  }
  _setPaintValue(e, r3, n, i) {
    if (this.type === "color") {
      let o = Jd(n), a = Jd(i);
      for (let s3 = e; s3 < r3; s3++) this.paintVertexArray.emplace(s3, o[0], o[1], a[0], a[1]);
    } else {
      for (let o = e; o < r3; o++) this.paintVertexArray.emplace(o, n, i);
      this.maxValue = Math.max(this.maxValue, Math.abs(n), Math.abs(i));
    }
  }
  upload(e) {
    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
  }
  destroy() {
    this.paintVertexBuffer && this.paintVertexBuffer.destroy();
  }
  setUniform(e, r3) {
    let n = this.useIntegerZoom ? Math.floor(r3.zoom) : r3.zoom, i = ce(this.expression.interpolationFactor(n, this.zoom, this.zoom + 1), 0, 1);
    e.set(i);
  }
  getBinding(e, r3, n) {
    return new N(e, r3);
  }
};
var hn = class {
  constructor(e, r3, n, i, o, a) {
    this.expression = e, this.type = r3, this.useIntegerZoom = n, this.zoom = i, this.layerId = a, this.zoomInPaintVertexArray = new o(), this.zoomOutPaintVertexArray = new o();
  }
  populatePaintArray(e, r3, n) {
    let i = this.zoomInPaintVertexArray.length;
    this.zoomInPaintVertexArray.resize(e), this.zoomOutPaintVertexArray.resize(e), this._setPaintValues(i, e, r3.patterns && r3.patterns[this.layerId], n);
  }
  updatePaintArray(e, r3, n, i, o) {
    this._setPaintValues(e, r3, n.patterns && n.patterns[this.layerId], o);
  }
  _setPaintValues(e, r3, n, i) {
    if (!i || !n) return;
    let { min: o, mid: a, max: s3 } = n, l = i[o], u3 = i[a], c = i[s3];
    if (!(!l || !u3 || !c)) for (let p = e; p < r3; p++) this.zoomInPaintVertexArray.emplace(p, u3.tl[0], u3.tl[1], u3.br[0], u3.br[1], l.tl[0], l.tl[1], l.br[0], l.br[1], u3.pixelRatio, l.pixelRatio), this.zoomOutPaintVertexArray.emplace(p, u3.tl[0], u3.tl[1], u3.br[0], u3.br[1], c.tl[0], c.tl[1], c.br[0], c.br[1], u3.pixelRatio, c.pixelRatio);
  }
  upload(e) {
    this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = e.createVertexBuffer(this.zoomInPaintVertexArray, al.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = e.createVertexBuffer(this.zoomOutPaintVertexArray, al.members, this.expression.isStateDependent));
  }
  destroy() {
    this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
  }
};
var mp = class {
  constructor(e, r3, n) {
    this.binders = {}, this._buffers = [];
    let i = [];
    for (let o in e.paint._values) {
      if (!n(o)) continue;
      let a = e.paint.get(o);
      if (!(a instanceof Ft) || !ri(a.property.specification)) continue;
      let s3 = ik(o, e.type), l = a.value, u3 = a.property.specification.type, c = a.property.useIntegerZoom, p = a.property.specification["property-type"], h = p === "cross-faded" || p === "cross-faded-data-driven";
      if (l.kind === "constant") this.binders[o] = h ? new ci(l.value, s3) : new io(l.value, s3, u3), i.push(`/u_${o}`);
      else if (l.kind === "source" || h) {
        let f = Rv(o, u3, "source");
        this.binders[o] = h ? new hn(l, u3, c, r3, f, e.id) : new Wr(l, s3, u3, f), i.push(`/a_${o}`);
      } else {
        let f = Rv(o, u3, "composite");
        this.binders[o] = new xr(l, s3, u3, c, r3, f), i.push(`/z_${o}`);
      }
    }
    this.cacheKey = i.sort().join("");
  }
  getMaxValue(e) {
    let r3 = this.binders[e];
    return r3 instanceof Wr || r3 instanceof xr ? r3.maxValue : 0;
  }
  populatePaintArrays(e, r3, n, i, o) {
    for (let a in this.binders) {
      let s3 = this.binders[a];
      (s3 instanceof Wr || s3 instanceof xr || s3 instanceof hn) && s3.populatePaintArray(e, r3, n, i, o);
    }
  }
  setConstantPatternPositions(e, r3) {
    for (let n in this.binders) {
      let i = this.binders[n];
      i instanceof ci && i.setConstantPatternPositions(e, r3);
    }
  }
  updatePaintArrays(e, r3, n, i, o) {
    let a = false;
    for (let s3 in e) {
      let l = r3.getPositions(s3);
      for (let u3 of l) {
        let c = n.feature(u3.index);
        for (let p in this.binders) {
          let h = this.binders[p];
          if ((h instanceof Wr || h instanceof xr || h instanceof hn) && h.expression.isStateDependent === true) {
            let f = i.paint.get(p);
            h.expression = f.value, h.updatePaintArray(u3.start, u3.end, c, e[s3], o), a = true;
          }
        }
      }
    }
    return a;
  }
  defines() {
    let e = [];
    for (let r3 in this.binders) {
      let n = this.binders[r3];
      (n instanceof io || n instanceof ci) && e.push(...n.uniformNames.map((i) => `#define HAS_UNIFORM_${i}`));
    }
    return e;
  }
  getBinderAttributes() {
    let e = [];
    for (let r3 in this.binders) {
      let n = this.binders[r3];
      if (n instanceof Wr || n instanceof xr) for (let i = 0; i < n.paintVertexAttributes.length; i++) e.push(n.paintVertexAttributes[i].name);
      else if (n instanceof hn) for (let i = 0; i < al.members.length; i++) e.push(al.members[i].name);
    }
    return e;
  }
  getBinderUniforms() {
    let e = [];
    for (let r3 in this.binders) {
      let n = this.binders[r3];
      if (n instanceof io || n instanceof ci || n instanceof xr) for (let i of n.uniformNames) e.push(i);
    }
    return e;
  }
  getPaintVertexBuffers() {
    return this._buffers;
  }
  getUniforms(e, r3) {
    let n = [];
    for (let i in this.binders) {
      let o = this.binders[i];
      if (o instanceof io || o instanceof ci || o instanceof xr) {
        for (let a of o.uniformNames) if (r3[a]) {
          let s3 = o.getBinding(e, r3[a], a);
          n.push({ name: a, property: i, binding: s3 });
        }
      }
    }
    return n;
  }
  setUniforms(e, r3, n, i) {
    for (let { name: o, property: a, binding: s3 } of r3) this.binders[a].setUniform(s3, i, n.get(a), o);
  }
  updatePaintBuffers(e) {
    this._buffers = [];
    for (let r3 in this.binders) {
      let n = this.binders[r3];
      if (e && n instanceof hn) {
        let i = e.fromScale === 2 ? n.zoomInPaintVertexBuffer : n.zoomOutPaintVertexBuffer;
        i && this._buffers.push(i);
      } else (n instanceof Wr || n instanceof xr) && n.paintVertexBuffer && this._buffers.push(n.paintVertexBuffer);
    }
  }
  upload(e) {
    for (let r3 in this.binders) {
      let n = this.binders[r3];
      (n instanceof Wr || n instanceof xr || n instanceof hn) && n.upload(e);
    }
    this.updatePaintBuffers();
  }
  destroy() {
    for (let e in this.binders) {
      let r3 = this.binders[e];
      (r3 instanceof Wr || r3 instanceof xr || r3 instanceof hn) && r3.destroy();
    }
  }
};
var Qt = class {
  constructor(e, r3, n = () => true) {
    this.programConfigurations = {};
    for (let i of e) this.programConfigurations[i.id] = new mp(i, r3, n);
    this.needsUpload = false, this._featureMap = new sl(), this._bufferOffset = 0;
  }
  populatePaintArrays(e, r3, n, i, o, a) {
    for (let s3 in this.programConfigurations) this.programConfigurations[s3].populatePaintArrays(e, r3, i, o, a);
    r3.id !== void 0 && this._featureMap.add(r3.id, n, this._bufferOffset, e), this._bufferOffset = e, this.needsUpload = true;
  }
  updatePaintArrays(e, r3, n, i) {
    for (let o of n) this.needsUpload = this.programConfigurations[o.id].updatePaintArrays(e, this._featureMap, r3, o, i) || this.needsUpload;
  }
  get(e) {
    return this.programConfigurations[e];
  }
  upload(e) {
    if (this.needsUpload) {
      for (let r3 in this.programConfigurations) this.programConfigurations[r3].upload(e);
      this.needsUpload = false;
    }
  }
  destroy() {
    for (let e in this.programConfigurations) this.programConfigurations[e].destroy();
  }
};
function ik(t63, e) {
  return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t63] || [t63.replace(`${e}-`, "").replace(/-/g, "_")];
}
function ok(t63) {
  return { "line-pattern": { source: An, composite: An }, "fill-pattern": { source: An, composite: An }, "fill-extrusion-pattern": { source: An, composite: An } }[t63];
}
function Rv(t63, e, r3) {
  let n = { color: { source: li, composite: ta }, number: { source: no, composite: li } }, i = ok(t63);
  return i && i[r3] || n[e][r3];
}
X("ConstantBinder", io);
X("CrossFadedConstantBinder", ci);
X("SourceExpressionBinder", Wr);
X("CrossFadedCompositeBinder", hn);
X("CompositeExpressionBinder", xr);
X("ProgramConfiguration", mp, { omit: ["_buffers"] });
X("ProgramConfigurationSet", Qt);
$i();
$i();
var ak = 15;
var Qd = Math.pow(2, ak - 1) - 1;
var kv = -Qd - 1;
function er(t63) {
  let e = 8192 / t63.extent, r3 = t63.loadGeometry();
  for (let n = 0; n < r3.length; n++) {
    let i = r3[n];
    for (let o = 0; o < i.length; o++) {
      let a = i[o], s3 = Math.round(a.x * e), l = Math.round(a.y * e);
      a.x = ce(s3, kv, Qd), a.y = ce(l, kv, Qd), (s3 < a.x || s3 > a.x + 1 || l < a.y || l > a.y + 1) && ve2("Geometry exceeds allowed extent, reduce your vector tile buffer size");
    }
  }
  return r3;
}
$i();
function tr(t63, e) {
  return { type: t63.type, id: t63.id, properties: t63.properties, geometry: e ? er(t63) : [] };
}
var Fv = -32768;
function sk(t63, e, r3, n, i) {
  t63.emplaceBack(Fv + e * 8 + n, Fv + r3 * 8 + i);
}
var oo = class {
  constructor(e) {
    this.zoom = e.zoom, this.globalState = e.globalState, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((r3) => r3.id), this.index = e.index, this.hasPattern = false, this.layoutVertexArray = new tp(), this.indexArray = new Qe(), this.segments = new de2(), this.programConfigurations = new Qt(e.layers, e.zoom), this.stateDependentLayerIds = this.layers.filter((r3) => r3.isStateDependent()).map((r3) => r3.id);
  }
  populate(e, r3, n) {
    let i = this.layers[0], o = [], a = null, s3 = false, l = i.type === "heatmap";
    if (i.type === "circle") {
      let c = i;
      a = c.layout.get("circle-sort-key"), s3 = !a.isConstant(), l = l || c.paint.get("circle-pitch-alignment") === "map";
    }
    let u3 = l ? r3.subdivisionGranularity.circle : 1;
    for (let { feature: c, id: p, index: h, sourceLayerIndex: f } of e) {
      let d = this.layers[0]._featureFilter.needGeometry, g = tr(c, d);
      if (!this.layers[0]._featureFilter.filter(new Te(this.zoom, { globalState: this.globalState }), g, n)) continue;
      let x = s3 ? a.evaluate(g, {}, n) : void 0, b = { id: p, properties: c.properties, type: c.type, sourceLayerIndex: f, index: h, geometry: d ? g.geometry : er(c), patterns: {}, sortKey: x };
      o.push(b);
    }
    s3 && o.sort((c, p) => c.sortKey - p.sortKey);
    for (let c of o) {
      let { geometry: p, index: h, sourceLayerIndex: f } = c, d = e[h].feature;
      this.addFeature(c, p, h, n, u3), r3.featureIndex.insert(d, p, h, f, this.index);
    }
  }
  update(e, r3, n) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r3, this.stateDependentLayers, n);
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e) {
    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Mv), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
  }
  addFeature(e, r3, n, i, o = 1) {
    let a;
    switch (o) {
      case 1:
        a = [0, 7];
        break;
      case 3:
        a = [0, 2, 5, 7];
        break;
      case 5:
        a = [0, 1, 3, 4, 6, 7];
        break;
      case 7:
        a = [0, 1, 2, 3, 4, 5, 6, 7];
        break;
      default:
        throw new Error(`Invalid circle bucket granularity: ${o}; valid values are 1, 3, 5, 7.`);
    }
    let s3 = a.length;
    for (let l of r3) for (let u3 of l) {
      let c = u3.x, p = u3.y;
      if (c < 0 || c >= 8192 || p < 0 || p >= 8192) continue;
      let h = this.segments.prepareSegment(s3 * s3, this.layoutVertexArray, this.indexArray, e.sortKey), f = h.vertexLength;
      for (let d = 0; d < s3; d++) for (let g = 0; g < s3; g++) sk(this.layoutVertexArray, c, p, a[g], a[d]);
      for (let d = 0; d < s3 - 1; d++) for (let g = 0; g < s3 - 1; g++) {
        let x = f + d * s3 + g, b = f + (d + 1) * s3 + g;
        this.indexArray.emplaceBack(x, b + 1, x + 1), this.indexArray.emplaceBack(x, b, b + 1);
      }
      h.vertexLength += s3 * s3, h.primitiveLength += (s3 - 1) * (s3 - 1) * 2;
    }
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, {}, i);
  }
};
X("CircleBucket", oo, { omit: ["layers"] });
$i();
var cl = s(fe(), 1);
function dp(t63, e) {
  for (let r3 = 0; r3 < t63.length; r3++) if (ra(e, t63[r3])) return true;
  for (let r3 = 0; r3 < e.length; r3++) if (ra(t63, e[r3])) return true;
  return !!ty(t63, e);
}
function Bv(t63, e, r3) {
  return !!(ra(t63, e) || ey(e, t63, r3));
}
function yp(t63, e) {
  if (t63.length === 1) return Ov(e, t63[0]);
  for (let r3 = 0; r3 < e.length; r3++) {
    let n = e[r3];
    for (let i = 0; i < n.length; i++) if (ra(t63, n[i])) return true;
  }
  for (let r3 = 0; r3 < t63.length; r3++) if (Ov(e, t63[r3])) return true;
  for (let r3 = 0; r3 < e.length; r3++) if (ty(t63, e[r3])) return true;
  return false;
}
function zv(t63, e, r3) {
  for (let n = 0; n < e.length; n++) {
    let i = e[n];
    if (t63.length >= 3) {
      for (let o = 0; o < i.length; o++) if (ra(t63, i[o])) return true;
    }
    if (lk(t63, i, r3)) return true;
  }
  return false;
}
function lk(t63, e, r3) {
  if (t63.length > 1) {
    if (ty(t63, e)) return true;
    for (let n = 0; n < e.length; n++) if (ey(e[n], t63, r3)) return true;
  }
  for (let n = 0; n < t63.length; n++) if (ey(t63[n], e, r3)) return true;
  return false;
}
function ty(t63, e) {
  if (t63.length === 0 || e.length === 0) return false;
  for (let r3 = 0; r3 < t63.length - 1; r3++) {
    let n = t63[r3], i = t63[r3 + 1];
    for (let o = 0; o < e.length - 1; o++) {
      let a = e[o], s3 = e[o + 1];
      if (uk(n, i, a, s3)) return true;
    }
  }
  return false;
}
function uk(t63, e, r3, n) {
  return wn(t63, r3, n) !== wn(e, r3, n) && wn(t63, e, r3) !== wn(t63, e, n);
}
function ey(t63, e, r3) {
  let n = r3 * r3;
  if (e.length === 1) return t63.distSqr(e[0]) < n;
  for (let i = 1; i < e.length; i++) {
    let o = e[i - 1], a = e[i];
    if (Vv(t63, o, a) < n) return true;
  }
  return false;
}
function Vv(t63, e, r3) {
  let n = e.distSqr(r3);
  if (n === 0) return t63.distSqr(e);
  let i = ((t63.x - e.x) * (r3.x - e.x) + (t63.y - e.y) * (r3.y - e.y)) / n;
  return i < 0 ? t63.distSqr(e) : i > 1 ? t63.distSqr(r3) : t63.distSqr(r3.sub(e)._mult(i)._add(e));
}
function Ov(t63, e) {
  let r3 = false, n, i, o;
  for (let a = 0; a < t63.length; a++) {
    n = t63[a];
    for (let s3 = 0, l = n.length - 1; s3 < n.length; l = s3++) i = n[s3], o = n[l], i.y > e.y != o.y > e.y && e.x < (o.x - i.x) * (e.y - i.y) / (o.y - i.y) + i.x && (r3 = !r3);
  }
  return r3;
}
function ra(t63, e) {
  let r3 = false;
  for (let n = 0, i = t63.length - 1; n < t63.length; i = n++) {
    let o = t63[n], a = t63[i];
    o.y > e.y != a.y > e.y && e.x < (a.x - o.x) * (e.y - o.y) / (a.y - o.y) + o.x && (r3 = !r3);
  }
  return r3;
}
function Uv(t63, e, r3, n, i) {
  for (let a of t63) if (e <= a.x && r3 <= a.y && n >= a.x && i >= a.y) return true;
  let o = [new cl.default(e, r3), new cl.default(e, i), new cl.default(n, i), new cl.default(n, r3)];
  if (t63.length > 2) {
    for (let a of o) if (ra(t63, a)) return true;
  }
  for (let a = 0; a < t63.length - 1; a++) {
    let s3 = t63[a], l = t63[a + 1];
    if (ck(s3, l, o)) return true;
  }
  return false;
}
function ck(t63, e, r3) {
  let n = r3[0], i = r3[2];
  if (t63.x < n.x && e.x < n.x || t63.x > i.x && e.x > i.x || t63.y < n.y && e.y < n.y || t63.y > i.y && e.y > i.y) return false;
  let o = wn(t63, e, r3[0]);
  return o !== wn(t63, e, r3[1]) || o !== wn(t63, e, r3[2]) || o !== wn(t63, e, r3[3]);
}
$i();
var gp = s(fe(), 1);
function ao(t63, e, r3) {
  let n = e.paint.get(t63).value;
  return n.kind === "constant" ? n.value : r3.programConfigurations.get(e.id).getMaxValue(t63);
}
function pi(t63) {
  return Math.sqrt(t63[0] * t63[0] + t63[1] * t63[1]);
}
function hi(t63, e, r3, n, i) {
  if (!e[0] && !e[1]) return t63;
  let o = gp.default.convert(e)._mult(i);
  r3 === "viewport" && o._rotate(-n);
  let a = [];
  for (let s3 = 0; s3 < t63.length; s3++) {
    let l = t63[s3];
    a.push(l.sub(o));
  }
  return a;
}
function Nv(t63, e) {
  let r3 = [];
  for (let n = 0; n < t63.length; n++) {
    let i = t63[n], o = [];
    for (let a = 0; a < i.length; a++) {
      let s3 = i[a - 1], l = i[a], u3 = i[a + 1], c = a === 0 ? new gp.default(0, 0) : l.sub(s3)._unit()._perp(), p = a === i.length - 1 ? new gp.default(0, 0) : u3.sub(l)._unit()._perp(), h = c._add(p)._unit(), f = h.x * p.x + h.y * p.y;
      f !== 0 && h._mult(1 / f), o.push(h._mult(e)._add(l));
    }
    r3.push(o);
  }
  return r3;
}
$i();
var Gv;
var hk = () => Gv = Gv || new Ue({ "circle-sort-key": new te(D.layout_circle["circle-sort-key"]) });
var jv;
var fk = () => jv = jv || new Ue({ "circle-radius": new te(D.paint_circle["circle-radius"]), "circle-color": new te(D.paint_circle["circle-color"]), "circle-blur": new te(D.paint_circle["circle-blur"]), "circle-opacity": new te(D.paint_circle["circle-opacity"]), "circle-translate": new q3(D.paint_circle["circle-translate"]), "circle-translate-anchor": new q3(D.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new q3(D.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new q3(D.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new te(D.paint_circle["circle-stroke-width"]), "circle-stroke-color": new te(D.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new te(D.paint_circle["circle-stroke-opacity"]) });
var Hv = { get paint() {
  return fk();
}, get layout() {
  return hk();
} };
var Xv = s(fe(), 1);
var Zv = (t63) => t63.type === "circle";
var xp = class extends it {
  constructor(e) {
    super(e, Hv);
  }
  createBucket(e) {
    return new oo(e);
  }
  queryRadius(e) {
    let r3 = e;
    return ao("circle-radius", this, r3) + ao("circle-stroke-width", this, r3) + pi(this.paint.get("circle-translate"));
  }
  queryIntersectsFeature({ queryGeometry: e, feature: r3, featureState: n, geometry: i, transform: o, pixelsToTileUnits: a, unwrappedTileID: s3, getElevation: l }) {
    let u3 = hi(e, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -o.bearingInRadians, a), c = this.paint.get("circle-radius").evaluate(r3, n), p = this.paint.get("circle-stroke-width").evaluate(r3, n), h = c + p, f = this.paint.get("circle-pitch-alignment") === "map", d = f ? u3 : mk(u3, o, s3, l), g = f ? h * a : h;
    for (let x of i) for (let b of x) {
      let v3 = f ? b : qv(b, o, s3, l), P = g, w3 = o.projectTileCoordinates(b.x, b.y, s3, l).signedDistanceFromCamera;
      if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? P *= w3 / o.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (P *= o.cameraToCenterDistance / w3), Bv(d, v3, P)) return true;
    }
    return false;
  }
};
function qv(t63, e, r3, n) {
  let i = e.projectTileCoordinates(t63.x, t63.y, r3, n).point;
  return new Xv.default((i.x * 0.5 + 0.5) * e.width, (-i.y * 0.5 + 0.5) * e.height);
}
function mk(t63, e, r3, n) {
  return t63.map((i) => qv(i, e, r3, n));
}
$i();
$i();
var pl = class extends oo {
};
X("HeatmapBucket", pl, { omit: ["layers"] });
$i();
var Yv;
var dk = () => Yv = Yv || new Ue({ "heatmap-radius": new te(D.paint_heatmap["heatmap-radius"]), "heatmap-weight": new te(D.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new q3(D.paint_heatmap["heatmap-intensity"]), "heatmap-color": new In(D.paint_heatmap["heatmap-color"]), "heatmap-opacity": new q3(D.paint_heatmap["heatmap-opacity"]) });
var Wv = { get paint() {
  return dk();
} };
$i();
$i();
function ry(t63, { width: e, height: r3 }, n, i) {
  if (!i) i = new Uint8Array(e * r3 * n);
  else if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);
  else if (i.length !== e * r3 * n) throw new RangeError(`mismatched image size. expected: ${i.length} but got: ${e * r3 * n}`);
  return t63.width = e, t63.height = r3, t63.data = i, t63;
}
function $v(t63, { width: e, height: r3 }, n) {
  if (e === t63.width && r3 === t63.height) return;
  let i = ry({}, { width: e, height: r3 }, n);
  ny(t63, i, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t63.width, e), height: Math.min(t63.height, r3) }, n), t63.width = e, t63.height = r3, t63.data = i.data;
}
function ny(t63, e, r3, n, i, o) {
  if (i.width === 0 || i.height === 0) return e;
  if (i.width > t63.width || i.height > t63.height || r3.x > t63.width - i.width || r3.y > t63.height - i.height) throw new RangeError("out of range source coordinates for image copy");
  if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError("out of range destination coordinates for image copy");
  let a = t63.data, s3 = e.data;
  if (a === s3) throw new Error("srcData equals dstData, so image is already copied");
  for (let l = 0; l < i.height; l++) {
    let u3 = ((r3.y + l) * t63.width + r3.x) * o, c = ((n.y + l) * e.width + n.x) * o;
    for (let p = 0; p < i.width * o; p++) s3[c + p] = a[u3 + p];
  }
  return e;
}
var so = class t41 {
  constructor(e, r3) {
    ry(this, e, 1, r3);
  }
  resize(e) {
    $v(this, e, 1);
  }
  clone() {
    return new t41({ width: this.width, height: this.height }, new Uint8Array(this.data));
  }
  static copy(e, r3, n, i, o) {
    ny(e, r3, n, i, o, 1);
  }
};
var Le2 = class t42 {
  constructor(e, r3) {
    ry(this, e, 4, r3);
  }
  resize(e) {
    $v(this, e, 4);
  }
  replace(e, r3) {
    r3 ? this.data.set(e) : e instanceof Uint8ClampedArray ? this.data = new Uint8Array(e.buffer) : this.data = e;
  }
  clone() {
    return new t42({ width: this.width, height: this.height }, new Uint8Array(this.data));
  }
  static copy(e, r3, n, i, o) {
    ny(e, r3, n, i, o, 4);
  }
  setPixel(e, r3, n) {
    let i = (e * this.width + r3) * 4;
    this.data[i + 0] = Math.round(n.r * 255 / n.a), this.data[i + 1] = Math.round(n.g * 255 / n.a), this.data[i + 2] = Math.round(n.b * 255 / n.a), this.data[i + 3] = Math.round(n.a * 255);
  }
};
X("AlphaImage", so);
X("RGBAImage", Le2);
function bp(t63) {
  let e = {}, r3 = t63.resolution || 256, n = t63.clips ? t63.clips.length : 1, i = t63.image || new Le2({ width: r3, height: n });
  if (!Ob(r3)) throw new Error(`width is not a power of 2 - ${r3}`);
  let o = (a, s3, l) => {
    e[t63.evaluationKey] = l;
    let u3 = t63.expression.evaluate(e);
    i.setPixel(a / 4 / r3, s3 / 4, u3);
  };
  if (t63.clips) for (let a = 0, s3 = 0; a < n; ++a, s3 += r3 * 4) for (let l = 0, u3 = 0; l < r3; l++, u3 += 4) {
    let c = l / (r3 - 1), { start: p, end: h } = t63.clips[a], f = p * (1 - c) + h * c;
    o(s3, u3, f);
  }
  else for (let a = 0, s3 = 0; a < r3; a++, s3 += 4) {
    let l = a / (r3 - 1);
    o(0, s3, l);
  }
  return i;
}
var na = "big-fb";
var Kv = (t63) => t63.type === "heatmap";
var _p = class extends it {
  createBucket(e) {
    return new pl(e);
  }
  constructor(e) {
    super(e, Wv), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
  }
  _handleSpecialPaintPropertyUpdate(e) {
    e === "heatmap-color" && this._updateColorRamp();
  }
  _updateColorRamp() {
    let e = this._transitionablePaint._values["heatmap-color"].value.expression;
    this.colorRamp = bp({ expression: e, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
  }
  resize() {
    this.heatmapFbos.has(na) && this.heatmapFbos.delete(na);
  }
  queryRadius() {
    return 0;
  }
  queryIntersectsFeature() {
    return false;
  }
  hasOffscreenPass() {
    return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
  }
};
$i();
$i();
var Jv;
var yk = () => Jv = Jv || new Ue({ "hillshade-illumination-direction": new q3(D.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new q3(D.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new q3(D.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new q3(D.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new q3(D.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new q3(D.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new q3(D.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new q3(D.paint_hillshade["hillshade-method"]) });
var Qv = { get paint() {
  return yk();
} };
var e0 = (t63) => t63.type === "hillshade";
var vp = class extends it {
  constructor(e) {
    super(e, Qv), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
  }
  getIlluminationProperties() {
    let e = this.paint.get("hillshade-illumination-direction").values, r3 = this.paint.get("hillshade-illumination-altitude").values, n = this.paint.get("hillshade-highlight-color").values, i = this.paint.get("hillshade-shadow-color").values, o = Math.max(e.length, r3.length, n.length, i.length);
    e = e.concat(Array(o - e.length).fill(e.at(-1))), r3 = r3.concat(Array(o - r3.length).fill(r3.at(-1))), n = n.concat(Array(o - n.length).fill(n.at(-1))), i = i.concat(Array(o - i.length).fill(i.at(-1)));
    let a = r3.map(Ve);
    return { directionRadians: e.map(Ve), altitudeRadians: a, shadowColor: i, highlightColor: n };
  }
  hasOffscreenPass() {
    return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
  }
};
$i();
$i();
var t0;
var gk = () => t0 = t0 || new Ue({ "color-relief-opacity": new q3(D["paint_color-relief"]["color-relief-opacity"]), "color-relief-color": new In(D["paint_color-relief"]["color-relief-color"]) });
var r0 = { get paint() {
  return gk();
} };
$i();
var Se = class {
  constructor(e, r3, n, i) {
    this.context = e, this.format = n, this.texture = e.gl.createTexture(), this.update(r3, i);
  }
  update(e, r3, n) {
    let { width: i, height: o } = e, a = (!this.size || this.size[0] !== i || this.size[1] !== o) && !n, { context: s3 } = this, { gl: l } = s3;
    if (this.useMipmap = !!(r3 && r3.useMipmap), l.bindTexture(l.TEXTURE_2D, this.texture), s3.pixelStoreUnpackFlipY.set(false), s3.pixelStoreUnpack.set(1), s3.pixelStoreUnpackPremultiplyAlpha.set(this.format === l.RGBA && (!r3 || r3.premultiply !== false)), a) this.size = [i, o], e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || Wt(e) ? l.texImage2D(l.TEXTURE_2D, 0, this.format, this.format, l.UNSIGNED_BYTE, e) : l.texImage2D(l.TEXTURE_2D, 0, this.format, i, o, 0, this.format, l.UNSIGNED_BYTE, e.data);
    else {
      let { x: u3, y: c } = n || { x: 0, y: 0 };
      e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || Wt(e) ? l.texSubImage2D(l.TEXTURE_2D, 0, u3, c, l.RGBA, l.UNSIGNED_BYTE, e) : l.texSubImage2D(l.TEXTURE_2D, 0, u3, c, i, o, l.RGBA, l.UNSIGNED_BYTE, e.data);
    }
    this.useMipmap && this.isSizePowerOfTwo() && l.generateMipmap(l.TEXTURE_2D), s3.pixelStoreUnpackFlipY.setDefault(), s3.pixelStoreUnpack.setDefault(), s3.pixelStoreUnpackPremultiplyAlpha.setDefault();
  }
  bind(e, r3, n) {
    let { context: i } = this, { gl: o } = i;
    o.bindTexture(o.TEXTURE_2D, this.texture), n === o.LINEAR_MIPMAP_NEAREST && !this.isSizePowerOfTwo() && (n = o.LINEAR), e !== this.filter && (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, e), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, n || e), this.filter = e), r3 !== this.wrap && (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, r3), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, r3), this.wrap = r3);
  }
  isSizePowerOfTwo() {
    return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 === 0;
  }
  destroy() {
    let { gl: e } = this.context;
    e.deleteTexture(this.texture), this.texture = null;
  }
};
$i();
var iy = class {
  constructor(e, r3, n, i = 1, o = 1, a = 1, s3 = 0) {
    if (this.uid = e, r3.height !== r3.width) throw new RangeError("DEM tiles must be square");
    if (n && !["mapbox", "terrarium", "custom"].includes(n)) {
      ve2(`"${n}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
      return;
    }
    this.stride = r3.height;
    let l = this.dim = r3.height - 2;
    switch (this.data = new Uint32Array(r3.data.buffer), n) {
      case "terrarium":
        this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
        break;
      case "custom":
        this.redFactor = i, this.greenFactor = o, this.blueFactor = a, this.baseShift = s3;
        break;
      case "mapbox":
      default:
        this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
        break;
    }
    for (let u3 = 0; u3 < l; u3++) this.data[this._idx(-1, u3)] = this.data[this._idx(0, u3)], this.data[this._idx(l, u3)] = this.data[this._idx(l - 1, u3)], this.data[this._idx(u3, -1)] = this.data[this._idx(u3, 0)], this.data[this._idx(u3, l)] = this.data[this._idx(u3, l - 1)];
    this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(l, -1)] = this.data[this._idx(l - 1, 0)], this.data[this._idx(-1, l)] = this.data[this._idx(0, l - 1)], this.data[this._idx(l, l)] = this.data[this._idx(l - 1, l - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
    for (let u3 = 0; u3 < l; u3++) for (let c = 0; c < l; c++) {
      let p = this.get(u3, c);
      p > this.max && (this.max = p), p < this.min && (this.min = p);
    }
  }
  get(e, r3) {
    let n = new Uint8Array(this.data.buffer), i = this._idx(e, r3) * 4;
    return this.unpack(n[i], n[i + 1], n[i + 2]);
  }
  getUnpackVector() {
    return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
  }
  _idx(e, r3) {
    if (e < -1 || e >= this.dim + 1 || r3 < -1 || r3 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
    return (r3 + 1) * this.stride + (e + 1);
  }
  unpack(e, r3, n) {
    return e * this.redFactor + r3 * this.greenFactor + n * this.blueFactor - this.baseShift;
  }
  pack(e) {
    return oy(e, this.getUnpackVector());
  }
  getPixels() {
    return new Le2({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
  }
  backfillBorder(e, r3, n) {
    if (this.dim !== e.dim) throw new Error("dem dimension mismatch");
    let i = r3 * this.dim, o = r3 * this.dim + this.dim, a = n * this.dim, s3 = n * this.dim + this.dim;
    switch (r3) {
      case -1:
        i = o - 1;
        break;
      case 1:
        o = i + 1;
        break;
    }
    switch (n) {
      case -1:
        a = s3 - 1;
        break;
      case 1:
        s3 = a + 1;
        break;
    }
    let l = -r3 * this.dim, u3 = -n * this.dim;
    for (let c = a; c < s3; c++) for (let p = i; p < o; p++) this.data[this._idx(p, c)] = e.data[this._idx(p + l, c + u3)];
  }
};
function oy(t63, e) {
  let r3 = e[0], n = e[1], i = e[2], o = e[3], a = Math.min(r3, n, i), s3 = Math.round((t63 + o) / a);
  return { r: Math.floor(s3 * a / r3) % 256, g: Math.floor(s3 * a / n) % 256, b: Math.floor(s3 * a / i) % 256 };
}
X("DEMData", iy);
var n0 = (t63) => t63.type === "color-relief";
var Pp = class extends it {
  constructor(e) {
    super(e, r0);
  }
  _createColorRamp(e) {
    let r3 = { elevationStops: [], colorStops: [] }, n = this._transitionablePaint._values["color-relief-color"].value.expression;
    if (n instanceof un && n._styleExpression.expression instanceof jt) {
      this.colorRampExpression = n;
      let a = n._styleExpression.expression;
      r3.elevationStops = a.labels, r3.colorStops = [];
      for (let s3 of r3.elevationStops) r3.colorStops.push(a.evaluate({ globals: { elevation: s3 } }));
    }
    if (r3.elevationStops.length < 1 && (r3.elevationStops = [0], r3.colorStops = [K.transparent]), r3.elevationStops.length < 2 && (r3.elevationStops.push(r3.elevationStops[0] + 1), r3.colorStops.push(r3.colorStops[0])), r3.elevationStops.length <= e) return r3;
    let i = { elevationStops: [], colorStops: [] }, o = (r3.elevationStops.length - 1) / (e - 1);
    for (let a = 0; a < r3.elevationStops.length - 0.5; a += o) i.elevationStops.push(r3.elevationStops[Math.round(a)]), i.colorStops.push(r3.colorStops[Math.round(a)]);
    return ve2(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`), i;
  }
  _colorRampChanged() {
    return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
  }
  getColorRampTextures(e, r3, n) {
    if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
    let i = this._createColorRamp(r3), o = new Le2({ width: i.colorStops.length, height: 1 }), a = new Le2({ width: i.colorStops.length, height: 1 });
    for (let s3 = 0; s3 < i.elevationStops.length; s3++) {
      let l = oy(i.elevationStops[s3], n);
      a.setPixel(0, s3, new K(l.r / 255, l.g / 255, l.b / 255, 1)), o.setPixel(0, s3, i.colorStops[s3]);
    }
    return this.colorRampTextures = { elevationTexture: new Se(e, a, e.gl.RGBA), colorTexture: new Se(e, o, e.gl.RGBA) }, this.colorRampTextures;
  }
  hasOffscreenPass() {
    return this.visibility !== "none" && !!this.colorRampTextures;
  }
};
$i();
$i();
$i();
var xk = ze([{ name: "a_pos", components: 2, type: "Int16" }], 4);
var { members: i0, size: _H, alignment: vH } = xk;
$i();
function ia(t63, e, r3) {
  let n = r3.patternDependencies, i = false;
  for (let o of e) {
    let a = o.paint.get(`${t63}-pattern`);
    a.isConstant() || (i = true);
    let s3 = a.constantOr(null);
    s3 && (i = true, n[s3.to] = true, n[s3.from] = true);
  }
  return i;
}
function oa(t63, e, r3, n, i) {
  let o = i.patternDependencies;
  for (let a of e) {
    let l = a.paint.get(`${t63}-pattern`).value;
    if (l.kind !== "constant") {
      let u3 = l.evaluate({ zoom: n - 1 }, r3, {}, i.availableImages), c = l.evaluate({ zoom: n }, r3, {}, i.availableImages), p = l.evaluate({ zoom: n + 1 }, r3, {}, i.availableImages);
      u3 = u3 && u3.name ? u3.name : u3, c = c && c.name ? c.name : c, p = p && p.name ? p.name : p, o[u3] = true, o[c] = true, o[p] = true, r3.patterns[a.id] = { min: u3, mid: c, max: p };
    }
  }
  return r3;
}
$i();
var yl = s(fe(), 1);
$i();
function ly(t63, e, r3 = 2) {
  let n = e && e.length, i = n ? e[0] * r3 : t63.length, o = a0(t63, 0, i, r3, true), a = [];
  if (!o || o.next === o.prev) return a;
  let s3, l, u3;
  if (n && (o = wk(t63, e, o, r3)), t63.length > 80 * r3) {
    s3 = 1 / 0, l = 1 / 0;
    let c = -1 / 0, p = -1 / 0;
    for (let h = r3; h < i; h += r3) {
      let f = t63[h], d = t63[h + 1];
      f < s3 && (s3 = f), d < l && (l = d), f > c && (c = f), d > p && (p = d);
    }
    u3 = Math.max(c - s3, p - l), u3 = u3 !== 0 ? 32767 / u3 : 0;
  }
  return fl(o, a, r3, s3, l, u3, 0), a;
}
function a0(t63, e, r3, n, i) {
  let o;
  if (i === kk(t63, e, r3, n) > 0) for (let a = e; a < r3; a += n) o = o0(a / n | 0, t63[a], t63[a + 1], o);
  else for (let a = r3 - n; a >= e; a -= n) o = o0(a / n | 0, t63[a], t63[a + 1], o);
  return o && aa(o, o.next) && (dl(o), o = o.next), o;
}
function lo(t63, e) {
  if (!t63) return t63;
  e || (e = t63);
  let r3 = t63, n;
  do
    if (n = false, !r3.steiner && (aa(r3, r3.next) || at2(r3.prev, r3, r3.next) === 0)) {
      if (dl(r3), r3 = e = r3.prev, r3 === r3.next) break;
      n = true;
    } else r3 = r3.next;
  while (n || r3 !== e);
  return e;
}
function fl(t63, e, r3, n, i, o, a) {
  if (!t63) return;
  !a && o && Ik(t63, n, i, o);
  let s3 = t63;
  for (; t63.prev !== t63.next; ) {
    let l = t63.prev, u3 = t63.next;
    if (o ? _k(t63, n, i, o) : bk(t63)) {
      e.push(l.i, t63.i, u3.i), dl(t63), t63 = u3.next, s3 = u3.next;
      continue;
    }
    if (t63 = u3, t63 === s3) {
      a ? a === 1 ? (t63 = vk(lo(t63), e), fl(t63, e, r3, n, i, o, 2)) : a === 2 && Pk(t63, e, r3, n, i, o) : fl(lo(t63), e, r3, n, i, o, 1);
      break;
    }
  }
}
function bk(t63) {
  let e = t63.prev, r3 = t63, n = t63.next;
  if (at2(e, r3, n) >= 0) return false;
  let i = e.x, o = r3.x, a = n.x, s3 = e.y, l = r3.y, u3 = n.y, c = Math.min(i, o, a), p = Math.min(s3, l, u3), h = Math.max(i, o, a), f = Math.max(s3, l, u3), d = n.next;
  for (; d !== e; ) {
    if (d.x >= c && d.x <= h && d.y >= p && d.y <= f && hl(i, s3, o, l, a, u3, d.x, d.y) && at2(d.prev, d, d.next) >= 0) return false;
    d = d.next;
  }
  return true;
}
function _k(t63, e, r3, n) {
  let i = t63.prev, o = t63, a = t63.next;
  if (at2(i, o, a) >= 0) return false;
  let s3 = i.x, l = o.x, u3 = a.x, c = i.y, p = o.y, h = a.y, f = Math.min(s3, l, u3), d = Math.min(c, p, h), g = Math.max(s3, l, u3), x = Math.max(c, p, h), b = ay(f, d, e, r3, n), v3 = ay(g, x, e, r3, n), P = t63.prevZ, w3 = t63.nextZ;
  for (; P && P.z >= b && w3 && w3.z <= v3; ) {
    if (P.x >= f && P.x <= g && P.y >= d && P.y <= x && P !== i && P !== a && hl(s3, c, l, p, u3, h, P.x, P.y) && at2(P.prev, P, P.next) >= 0 || (P = P.prevZ, w3.x >= f && w3.x <= g && w3.y >= d && w3.y <= x && w3 !== i && w3 !== a && hl(s3, c, l, p, u3, h, w3.x, w3.y) && at2(w3.prev, w3, w3.next) >= 0)) return false;
    w3 = w3.nextZ;
  }
  for (; P && P.z >= b; ) {
    if (P.x >= f && P.x <= g && P.y >= d && P.y <= x && P !== i && P !== a && hl(s3, c, l, p, u3, h, P.x, P.y) && at2(P.prev, P, P.next) >= 0) return false;
    P = P.prevZ;
  }
  for (; w3 && w3.z <= v3; ) {
    if (w3.x >= f && w3.x <= g && w3.y >= d && w3.y <= x && w3 !== i && w3 !== a && hl(s3, c, l, p, u3, h, w3.x, w3.y) && at2(w3.prev, w3, w3.next) >= 0) return false;
    w3 = w3.nextZ;
  }
  return true;
}
function vk(t63, e) {
  let r3 = t63;
  do {
    let n = r3.prev, i = r3.next.next;
    !aa(n, i) && l0(n, r3, r3.next, i) && ml(n, i) && ml(i, n) && (e.push(n.i, r3.i, i.i), dl(r3), dl(r3.next), r3 = t63 = i), r3 = r3.next;
  } while (r3 !== t63);
  return lo(r3);
}
function Pk(t63, e, r3, n, i, o) {
  let a = t63;
  do {
    let s3 = a.next.next;
    for (; s3 !== a.prev; ) {
      if (a.i !== s3.i && Lk(a, s3)) {
        let l = u0(a, s3);
        a = lo(a, a.next), l = lo(l, l.next), fl(a, e, r3, n, i, o, 0), fl(l, e, r3, n, i, o, 0);
        return;
      }
      s3 = s3.next;
    }
    a = a.next;
  } while (a !== t63);
}
function wk(t63, e, r3, n) {
  let i = [];
  for (let o = 0, a = e.length; o < a; o++) {
    let s3 = e[o] * n, l = o < a - 1 ? e[o + 1] * n : t63.length, u3 = a0(t63, s3, l, n, false);
    u3 === u3.next && (u3.steiner = true), i.push(Ek(u3));
  }
  i.sort(Tk);
  for (let o = 0; o < i.length; o++) r3 = Sk(i[o], r3);
  return r3;
}
function Tk(t63, e) {
  let r3 = t63.x - e.x;
  if (r3 === 0 && (r3 = t63.y - e.y, r3 === 0)) {
    let n = (t63.next.y - t63.y) / (t63.next.x - t63.x), i = (e.next.y - e.y) / (e.next.x - e.x);
    r3 = n - i;
  }
  return r3;
}
function Sk(t63, e) {
  let r3 = Ck(t63, e);
  if (!r3) return e;
  let n = u0(r3, t63);
  return lo(n, n.next), lo(r3, r3.next);
}
function Ck(t63, e) {
  let r3 = e, n = t63.x, i = t63.y, o = -1 / 0, a;
  if (aa(t63, r3)) return r3;
  do {
    if (aa(t63, r3.next)) return r3.next;
    if (i <= r3.y && i >= r3.next.y && r3.next.y !== r3.y) {
      let p = r3.x + (i - r3.y) * (r3.next.x - r3.x) / (r3.next.y - r3.y);
      if (p <= n && p > o && (o = p, a = r3.x < r3.next.x ? r3 : r3.next, p === n)) return a;
    }
    r3 = r3.next;
  } while (r3 !== e);
  if (!a) return null;
  let s3 = a, l = a.x, u3 = a.y, c = 1 / 0;
  r3 = a;
  do {
    if (n >= r3.x && r3.x >= l && n !== r3.x && s0(i < u3 ? n : o, i, l, u3, i < u3 ? o : n, i, r3.x, r3.y)) {
      let p = Math.abs(i - r3.y) / (n - r3.x);
      ml(r3, t63) && (p < c || p === c && (r3.x > a.x || r3.x === a.x && Mk(a, r3))) && (a = r3, c = p);
    }
    r3 = r3.next;
  } while (r3 !== s3);
  return a;
}
function Mk(t63, e) {
  return at2(t63.prev, t63, e.prev) < 0 && at2(e.next, t63, t63.next) < 0;
}
function Ik(t63, e, r3, n) {
  let i = t63;
  do
    i.z === 0 && (i.z = ay(i.x, i.y, e, r3, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== t63);
  i.prevZ.nextZ = null, i.prevZ = null, Ak(i);
}
function Ak(t63) {
  let e, r3 = 1;
  do {
    let n = t63, i;
    t63 = null;
    let o = null;
    for (e = 0; n; ) {
      e++;
      let a = n, s3 = 0;
      for (let u3 = 0; u3 < r3 && (s3++, a = a.nextZ, !!a); u3++) ;
      let l = r3;
      for (; s3 > 0 || l > 0 && a; ) s3 !== 0 && (l === 0 || !a || n.z <= a.z) ? (i = n, n = n.nextZ, s3--) : (i = a, a = a.nextZ, l--), o ? o.nextZ = i : t63 = i, i.prevZ = o, o = i;
      n = a;
    }
    o.nextZ = null, r3 *= 2;
  } while (e > 1);
  return t63;
}
function ay(t63, e, r3, n, i) {
  return t63 = (t63 - r3) * i | 0, e = (e - n) * i | 0, t63 = (t63 | t63 << 8) & 16711935, t63 = (t63 | t63 << 4) & 252645135, t63 = (t63 | t63 << 2) & 858993459, t63 = (t63 | t63 << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t63 | e << 1;
}
function Ek(t63) {
  let e = t63, r3 = t63;
  do
    (e.x < r3.x || e.x === r3.x && e.y < r3.y) && (r3 = e), e = e.next;
  while (e !== t63);
  return r3;
}
function s0(t63, e, r3, n, i, o, a, s3) {
  return (i - a) * (e - s3) >= (t63 - a) * (o - s3) && (t63 - a) * (n - s3) >= (r3 - a) * (e - s3) && (r3 - a) * (o - s3) >= (i - a) * (n - s3);
}
function hl(t63, e, r3, n, i, o, a, s3) {
  return !(t63 === a && e === s3) && s0(t63, e, r3, n, i, o, a, s3);
}
function Lk(t63, e) {
  return t63.next.i !== e.i && t63.prev.i !== e.i && !Dk(t63, e) && (ml(t63, e) && ml(e, t63) && Rk(t63, e) && (at2(t63.prev, t63, e.prev) || at2(t63, e.prev, e)) || aa(t63, e) && at2(t63.prev, t63, t63.next) > 0 && at2(e.prev, e, e.next) > 0);
}
function at2(t63, e, r3) {
  return (e.y - t63.y) * (r3.x - e.x) - (e.x - t63.x) * (r3.y - e.y);
}
function aa(t63, e) {
  return t63.x === e.x && t63.y === e.y;
}
function l0(t63, e, r3, n) {
  let i = Tp(at2(t63, e, r3)), o = Tp(at2(t63, e, n)), a = Tp(at2(r3, n, t63)), s3 = Tp(at2(r3, n, e));
  return !!(i !== o && a !== s3 || i === 0 && wp(t63, r3, e) || o === 0 && wp(t63, n, e) || a === 0 && wp(r3, t63, n) || s3 === 0 && wp(r3, e, n));
}
function wp(t63, e, r3) {
  return e.x <= Math.max(t63.x, r3.x) && e.x >= Math.min(t63.x, r3.x) && e.y <= Math.max(t63.y, r3.y) && e.y >= Math.min(t63.y, r3.y);
}
function Tp(t63) {
  return t63 > 0 ? 1 : t63 < 0 ? -1 : 0;
}
function Dk(t63, e) {
  let r3 = t63;
  do {
    if (r3.i !== t63.i && r3.next.i !== t63.i && r3.i !== e.i && r3.next.i !== e.i && l0(r3, r3.next, t63, e)) return true;
    r3 = r3.next;
  } while (r3 !== t63);
  return false;
}
function ml(t63, e) {
  return at2(t63.prev, t63, t63.next) < 0 ? at2(t63, e, t63.next) >= 0 && at2(t63, t63.prev, e) >= 0 : at2(t63, e, t63.prev) < 0 || at2(t63, t63.next, e) < 0;
}
function Rk(t63, e) {
  let r3 = t63, n = false, i = (t63.x + e.x) / 2, o = (t63.y + e.y) / 2;
  do
    r3.y > o != r3.next.y > o && r3.next.y !== r3.y && i < (r3.next.x - r3.x) * (o - r3.y) / (r3.next.y - r3.y) + r3.x && (n = !n), r3 = r3.next;
  while (r3 !== t63);
  return n;
}
function u0(t63, e) {
  let r3 = sy(t63.i, t63.x, t63.y), n = sy(e.i, e.x, e.y), i = t63.next, o = e.prev;
  return t63.next = e, e.prev = t63, r3.next = i, i.prev = r3, n.next = r3, r3.prev = n, o.next = n, n.prev = o, n;
}
function o0(t63, e, r3, n) {
  let i = sy(t63, e, r3);
  return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
}
function dl(t63) {
  t63.next.prev = t63.prev, t63.prev.next = t63.next, t63.prevZ && (t63.prevZ.nextZ = t63.nextZ), t63.nextZ && (t63.nextZ.prevZ = t63.prevZ);
}
function sy(t63, e, r3) {
  return { i: t63, x: e, y: r3, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
}
function kk(t63, e, r3, n) {
  let i = 0;
  for (let o = e, a = r3 - n; o < r3; o += n) i += (t63[a] - t63[o]) * (t63[o + 1] + t63[a + 1]), a = o;
  return i;
}
$i();
var br = class {
  constructor(e, r3) {
    if (r3 > e) throw new Error("Min granularity must not be greater than base granularity.");
    this._baseZoomGranularity = e, this._minGranularity = r3;
  }
  getGranularityForZoomLevel(e) {
    let r3 = 1 << e;
    return Math.max(Math.floor(this._baseZoomGranularity / r3), this._minGranularity, 1);
  }
};
var Sp = class Sp2 {
  constructor(e) {
    this.fill = e.fill, this.line = e.line, this.tile = e.tile, this.stencil = e.stencil, this.circle = e.circle;
  }
};
Sp.noSubdivision = new Sp({ fill: new br(0, 0), line: new br(0, 0), tile: new br(0, 0), stencil: new br(0, 0), circle: 1 });
var fi = Sp;
X("SubdivisionGranularityExpression", br);
X("SubdivisionGranularitySetting", fi);
var fn = -32768;
var En = 32767;
var uy = class {
  constructor(e, r3) {
    this._vertexBuffer = [];
    this._vertexDictionary = /* @__PURE__ */ new Map();
    this._used = false;
    this._granularity = e, this._granularityCellSize = 8192 / e, this._canonical = r3;
  }
  _getKey(e, r3) {
    return e = e + 32768, r3 = r3 + 32768, e << 16 | r3 << 0;
  }
  _vertexToIndex(e, r3) {
    if (e < -32768 || r3 < -32768 || e > 32767 || r3 > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
    let n = Math.round(e) | 0, i = Math.round(r3) | 0, o = this._getKey(n, i);
    if (this._vertexDictionary.has(o)) return this._vertexDictionary.get(o);
    let a = this._vertexBuffer.length / 2;
    return this._vertexDictionary.set(o, a), this._vertexBuffer.push(n, i), a;
  }
  _subdivideTrianglesScanline(e) {
    if (this._granularity < 2) return Ok(this._vertexBuffer, e);
    let r3 = [], n = e.length;
    for (let i = 0; i < n; i += 3) {
      let o = [e[i + 0], e[i + 1], e[i + 2]], a = [this._vertexBuffer[e[i + 0] * 2 + 0], this._vertexBuffer[e[i + 0] * 2 + 1], this._vertexBuffer[e[i + 1] * 2 + 0], this._vertexBuffer[e[i + 1] * 2 + 1], this._vertexBuffer[e[i + 2] * 2 + 0], this._vertexBuffer[e[i + 2] * 2 + 1]], s3 = 1 / 0, l = 1 / 0, u3 = -1 / 0, c = -1 / 0;
      for (let g = 0; g < 3; g++) {
        let x = a[g * 2], b = a[g * 2 + 1];
        s3 = Math.min(s3, x), u3 = Math.max(u3, x), l = Math.min(l, b), c = Math.max(c, b);
      }
      if (s3 === u3 || l === c) continue;
      let p = Math.floor(s3 / this._granularityCellSize), h = Math.ceil(u3 / this._granularityCellSize), f = Math.floor(l / this._granularityCellSize), d = Math.ceil(c / this._granularityCellSize);
      if (p === h && f === d) {
        r3.push(...o);
        continue;
      }
      for (let g = f; g < d; g++) {
        let x = this._scanlineGenerateVertexRingForCellRow(g, a, o);
        Bk(this._vertexBuffer, x, r3);
      }
    }
    return r3;
  }
  _scanlineGenerateVertexRingForCellRow(e, r3, n) {
    let i = e * this._granularityCellSize, o = i + this._granularityCellSize, a = [];
    for (let s3 = 0; s3 < 3; s3++) {
      let l = r3[s3 * 2], u3 = r3[s3 * 2 + 1], c = r3[(s3 + 1) * 2 % 6], p = r3[((s3 + 1) * 2 + 1) % 6], h = r3[(s3 + 2) * 2 % 6], f = r3[((s3 + 2) * 2 + 1) % 6], d = c - l, g = p - u3, x = d === 0, b = g === 0, v3 = (i - u3) / g, P = (o - u3) / g, w3 = Math.min(v3, P), T = Math.max(v3, P);
      if (!b && (w3 >= 1 || T <= 0) || b && (u3 < i || u3 > o)) {
        p >= i && p <= o && a.push(n[(s3 + 1) % 3]);
        continue;
      }
      if (!b && w3 > 0) {
        let A = l + d * w3, E = u3 + g * w3;
        a.push(this._vertexToIndex(A, E));
      }
      let S = l + d * Math.max(w3, 0), C3 = l + d * Math.min(T, 1);
      if (x || this._generateIntraEdgeVertices(a, l, u3, c, p, S, C3), !b && T < 1) {
        let A = l + d * T, E = u3 + g * T;
        a.push(this._vertexToIndex(A, E));
      }
      (b || p >= i && p <= o) && a.push(n[(s3 + 1) % 3]), !b && (p <= i || p >= o) && this._generateInterEdgeVertices(a, l, u3, c, p, h, f, C3, i, o);
    }
    return a;
  }
  _generateIntraEdgeVertices(e, r3, n, i, o, a, s3) {
    let l = i - r3, u3 = o - n, c = u3 === 0, p = c ? Math.min(r3, i) : Math.min(a, s3), h = c ? Math.max(r3, i) : Math.max(a, s3), f = Math.floor(p / this._granularityCellSize) + 1, d = Math.ceil(h / this._granularityCellSize) - 1;
    if (c ? r3 < i : a < s3) for (let x = f; x <= d; x++) {
      let b = x * this._granularityCellSize, v3 = n + u3 * (b - r3) / l;
      e.push(this._vertexToIndex(b, v3));
    }
    else for (let x = d; x >= f; x--) {
      let b = x * this._granularityCellSize, v3 = n + u3 * (b - r3) / l;
      e.push(this._vertexToIndex(b, v3));
    }
  }
  _generateInterEdgeVertices(e, r3, n, i, o, a, s3, l, u3, c) {
    let p = o - n, h = a - i, f = s3 - o, d = (u3 - o) / f, g = (c - o) / f, x = Math.min(d, g), b = Math.max(d, g), v3 = i + h * x, P = Math.floor(Math.min(v3, l) / this._granularityCellSize) + 1, w3 = Math.ceil(Math.max(v3, l) / this._granularityCellSize) - 1, T = l < v3, S = f === 0;
    if (S && (s3 === u3 || s3 === c)) return;
    if (S || x >= 1 || b <= 0) {
      let A = r3 - a, E = n - s3, L = (u3 - s3) / E, F = (c - s3) / E, O = Math.min(L, F), z = a + A * O;
      P = Math.floor(Math.min(z, l) / this._granularityCellSize) + 1, w3 = Math.ceil(Math.max(z, l) / this._granularityCellSize) - 1, T = l < z;
    }
    let C3 = p > 0 ? c : u3;
    if (T) for (let A = P; A <= w3; A++) {
      let E = A * this._granularityCellSize;
      e.push(this._vertexToIndex(E, C3));
    }
    else for (let A = w3; A >= P; A--) {
      let E = A * this._granularityCellSize;
      e.push(this._vertexToIndex(E, C3));
    }
  }
  _generateOutline(e) {
    let r3 = [];
    for (let n of e) {
      let i = sa(n, this._granularity, true), o = this._pointArrayToIndices(i), a = [];
      for (let s3 = 1; s3 < o.length; s3++) a.push(o[s3 - 1]), a.push(o[s3]);
      r3.push(a);
    }
    return r3;
  }
  _handlePoles(e) {
    let r3 = false, n = false;
    this._canonical && (this._canonical.y === 0 && (r3 = true), this._canonical.y === (1 << this._canonical.z) - 1 && (n = true)), (r3 || n) && this._fillPoles(e, r3, n);
  }
  _ensureNoPoleVertices() {
    let e = this._vertexBuffer;
    for (let r3 = 0; r3 < e.length; r3 += 2) {
      let n = e[r3 + 1];
      n === fn && (e[r3 + 1] = fn + 1), n === En && (e[r3 + 1] = En - 1);
    }
  }
  _generatePoleQuad(e, r3, n, i, o, a) {
    i > o != (a === fn) ? (e.push(r3), e.push(n), e.push(this._vertexToIndex(i, a)), e.push(n), e.push(this._vertexToIndex(o, a)), e.push(this._vertexToIndex(i, a))) : (e.push(n), e.push(r3), e.push(this._vertexToIndex(i, a)), e.push(this._vertexToIndex(o, a)), e.push(n), e.push(this._vertexToIndex(i, a)));
  }
  _fillPoles(e, r3, n) {
    let i = this._vertexBuffer, o = 0, a = 8192, s3 = e.length;
    for (let l = 2; l < s3; l += 3) {
      let u3 = e[l - 2], c = e[l - 1], p = e[l], h = i[u3 * 2], f = i[u3 * 2 + 1], d = i[c * 2], g = i[c * 2 + 1], x = i[p * 2], b = i[p * 2 + 1];
      r3 && (f === o && g === o && this._generatePoleQuad(e, u3, c, h, d, fn), g === o && b === o && this._generatePoleQuad(e, c, p, d, x, fn), b === o && f === o && this._generatePoleQuad(e, p, u3, x, h, fn)), n && (f === a && g === a && this._generatePoleQuad(e, u3, c, h, d, En), g === a && b === a && this._generatePoleQuad(e, c, p, d, x, En), b === a && f === a && this._generatePoleQuad(e, p, u3, x, h, En));
    }
  }
  _initializeVertices(e) {
    for (let r3 = 0; r3 < e.length; r3 += 2) this._vertexToIndex(e[r3], e[r3 + 1]);
  }
  subdividePolygonInternal(e, r3) {
    if (this._used) throw new Error("Subdivision: multiple use not allowed.");
    this._used = true;
    let { flattened: n, holeIndices: i } = Fk(e);
    this._initializeVertices(n);
    let o;
    try {
      let s3 = ly(n, i), l = this._convertIndices(n, s3);
      o = this._subdivideTrianglesScanline(l);
    } catch (s3) {
      console.error(s3);
    }
    let a = [];
    return r3 && (a = this._generateOutline(e)), this._ensureNoPoleVertices(), this._handlePoles(o), { verticesFlattened: this._vertexBuffer, indicesTriangles: o, indicesLineList: a };
  }
  _convertIndices(e, r3) {
    let n = [];
    for (let i = 0; i < r3.length; i++) {
      let o = e[r3[i] * 2], a = e[r3[i] * 2 + 1];
      n.push(this._vertexToIndex(o, a));
    }
    return n;
  }
  _pointArrayToIndices(e) {
    let r3 = [];
    for (let n = 0; n < e.length; n++) {
      let i = e[n];
      r3.push(this._vertexToIndex(i.x, i.y));
    }
    return r3;
  }
};
function Cp(t63, e, r3, n = true) {
  return new uy(r3, e).subdividePolygonInternal(t63, n);
}
function sa(t63, e, r3 = false) {
  if (!t63 || t63.length < 1) return [];
  if (t63.length < 2) return [];
  let n = t63[0], i = t63[t63.length - 1], o = r3 && (n.x !== i.x || n.y !== i.y);
  if (e < 2) return o ? [...t63, t63[0]] : [...t63];
  let a = Math.floor(8192 / e), s3 = [];
  s3.push(new yl.default(t63[0].x, t63[0].y));
  let l = t63.length, u3 = o ? l : l - 1;
  for (let c = 0; c < u3; c++) {
    let p = t63[c], h = c < l - 1 ? t63[c + 1] : t63[0], f = p.x, d = p.y, g = h.x, x = h.y, b = f !== g, v3 = d !== x;
    if (!b && !v3) continue;
    let P = g - f, w3 = x - d, T = Math.abs(P), S = Math.abs(w3), C3 = f, A = d;
    for (; ; ) {
      let L = P > 0 ? (Math.floor(C3 / a) + 1) * a : (Math.ceil(C3 / a) - 1) * a, F = w3 > 0 ? (Math.floor(A / a) + 1) * a : (Math.ceil(A / a) - 1) * a, O = Math.abs(C3 - L), z = Math.abs(A - F), I = Math.abs(C3 - g), R = Math.abs(A - x), H = b ? O / T : Number.POSITIVE_INFINITY, W = v3 ? z / S : Number.POSITIVE_INFINITY;
      if ((I <= O || !b) && (R <= z || !v3)) break;
      if (H < W && b || !v3) {
        C3 = L, A = A + w3 * H;
        let $ = new yl.default(C3, Math.round(A));
        (s3[s3.length - 1].x !== $.x || s3[s3.length - 1].y !== $.y) && s3.push($);
      } else {
        C3 = C3 + P * W, A = F;
        let $ = new yl.default(Math.round(C3), A);
        (s3[s3.length - 1].x !== $.x || s3[s3.length - 1].y !== $.y) && s3.push($);
      }
    }
    let E = new yl.default(g, x);
    (s3[s3.length - 1].x !== E.x || s3[s3.length - 1].y !== E.y) && s3.push(E);
  }
  return s3;
}
function Fk(t63) {
  let e = [], r3 = [];
  for (let n of t63) if (n.length !== 0) {
    n !== t63[0] && e.push(r3.length / 2);
    for (let i = 0; i < n.length; i++) r3.push(n[i].x), r3.push(n[i].y);
  }
  return { flattened: r3, holeIndices: e };
}
function Ok(t63, e) {
  let r3 = [];
  for (let n = 0; n < e.length; n += 3) {
    let i = e[n], o = e[n + 1], a = e[n + 2], s3 = t63[i * 2], l = t63[i * 2 + 1], u3 = t63[o * 2], c = t63[o * 2 + 1], p = t63[a * 2], h = t63[a * 2 + 1], f = u3 - s3, d = c - l, g = p - s3, x = h - l;
    f * x - d * g > 0 ? (r3.push(i), r3.push(a), r3.push(o)) : (r3.push(i), r3.push(o), r3.push(a));
  }
  return r3;
}
function Bk(t63, e, r3) {
  if (e.length === 0) throw new Error("Subdivision vertex ring is empty.");
  let n = 0, i = t63[e[0] * 2];
  for (let l = 1; l < e.length; l++) {
    let u3 = t63[e[l] * 2];
    u3 < i && (i = u3, n = l);
  }
  let o = e.length, a = n, s3 = (a + 1) % o;
  for (; ; ) {
    let l = a - 1 >= 0 ? a - 1 : o - 1, u3 = (s3 + 1) % o, c = t63[e[l] * 2], p = t63[e[l] * 2 + 1], h = t63[e[u3] * 2], f = t63[e[u3] * 2 + 1], d = t63[e[a] * 2], g = t63[e[a] * 2 + 1], x = t63[e[s3] * 2], b = t63[e[s3] * 2 + 1], v3 = false;
    if (c < h) v3 = true;
    else if (c > h) v3 = false;
    else {
      let P = x - d, T = b - g, S = -P, C3 = g < b ? 1 : -1, A = ((c - d) * T + (p - g) * S) * C3, E = ((h - d) * T + (f - g) * S) * C3;
      A > E && (v3 = true);
    }
    if (v3) {
      let P = e[l], w3 = e[a], T = e[s3];
      P !== w3 && P !== T && w3 !== T && r3.push(T, w3, P), a--, a < 0 && (a = o - 1);
    } else {
      let P = e[u3], w3 = e[a], T = e[s3];
      P !== w3 && P !== T && w3 !== T && r3.push(T, w3, P), s3++, s3 >= o && (s3 = 0);
    }
    if (l === u3) break;
  }
}
$i();
function Mp(t63, e, r3, n, i, o, a, s3, l) {
  let u3 = i.length / 2, c = a && s3 && l;
  if (u3 < de2.MAX_VERTEX_ARRAY_LENGTH) {
    let p = e.prepareSegment(u3, r3, n), h = p.vertexLength;
    for (let g = 0; g < o.length; g += 3) n.emplaceBack(h + o[g], h + o[g + 1], h + o[g + 2]);
    p.vertexLength += u3, p.primitiveLength += o.length / 3;
    let f, d;
    c && (d = a.prepareSegment(u3, r3, s3), f = d.vertexLength, d.vertexLength += u3);
    for (let g = 0; g < i.length; g += 2) t63(i[g], i[g + 1]);
    if (c) for (let g = 0; g < l.length; g++) {
      let x = l[g];
      for (let b = 1; b < x.length; b += 2) s3.emplaceBack(f + x[b - 1], f + x[b]);
      d.primitiveLength += x.length / 2;
    }
  } else zk(e, r3, n, i, o, t63), c && Vk(a, r3, s3, i, l, t63), e.forceNewSegmentOnNextPrepare(), a?.forceNewSegmentOnNextPrepare();
}
function gl(t63, e, r3, n, i, o, a) {
  if (o) {
    let s3 = n.count;
    return r3(e[i * 2], e[i * 2 + 1]), t63[i] = n.count, n.count++, a.vertexLength++, s3;
  } else return t63[i];
}
function zk(t63, e, r3, n, i, o) {
  let a = [];
  for (let p = 0; p < n.length / 2; p++) a.push(-1);
  let s3 = { count: 0 }, l = 0, u3 = t63.getOrCreateLatestSegment(e, r3), c = u3.vertexLength;
  for (let p = 2; p < i.length; p += 3) {
    let h = i[p - 2], f = i[p - 1], d = i[p], g = a[h] < l, x = a[f] < l, b = a[d] < l, v3 = (g ? 1 : 0) + (x ? 1 : 0) + (b ? 1 : 0);
    u3.vertexLength + v3 > de2.MAX_VERTEX_ARRAY_LENGTH && (u3 = t63.createNewSegment(e, r3), l = s3.count, g = true, x = true, b = true, c = 0);
    let P = gl(a, n, o, s3, h, g, u3), w3 = gl(a, n, o, s3, f, x, u3), T = gl(a, n, o, s3, d, b, u3);
    r3.emplaceBack(c + P - l, c + w3 - l, c + T - l), u3.primitiveLength++;
  }
}
function Vk(t63, e, r3, n, i, o) {
  let a = [];
  for (let p = 0; p < n.length / 2; p++) a.push(-1);
  let s3 = { count: 0 }, l = 0, u3 = t63.getOrCreateLatestSegment(e, r3), c = u3.vertexLength;
  for (let p = 0; p < i.length; p++) {
    let h = i[p];
    for (let f = 1; f < i[p].length; f += 2) {
      let d = h[f - 1], g = h[f], x = a[d] < l, b = a[g] < l, v3 = (x ? 1 : 0) + (b ? 1 : 0);
      u3.vertexLength + v3 > de2.MAX_VERTEX_ARRAY_LENGTH && (u3 = t63.createNewSegment(e, r3), l = s3.count, x = true, b = true, c = 0);
      let P = gl(a, n, o, s3, d, x, u3), w3 = gl(a, n, o, s3, g, b, u3);
      r3.emplaceBack(c + P - l, c + w3 - l), u3.primitiveLength++;
    }
  }
}
var Uk = 500;
var xl = class {
  constructor(e) {
    this.zoom = e.zoom, this.globalState = e.globalState, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((r3) => r3.id), this.index = e.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new rp(), this.indexArray = new Qe(), this.indexArray2 = new ui(), this.programConfigurations = new Qt(e.layers, e.zoom), this.segments = new de2(), this.segments2 = new de2(), this.stateDependentLayerIds = this.layers.filter((r3) => r3.isStateDependent()).map((r3) => r3.id);
  }
  populate(e, r3, n) {
    this.hasPattern = ia("fill", this.layers, r3);
    let i = this.layers[0].layout.get("fill-sort-key"), o = !i.isConstant(), a = [];
    for (let { feature: s3, id: l, index: u3, sourceLayerIndex: c } of e) {
      let p = this.layers[0]._featureFilter.needGeometry, h = tr(s3, p);
      if (!this.layers[0]._featureFilter.filter(new Te(this.zoom, { globalState: this.globalState }), h, n)) continue;
      let f = o ? i.evaluate(h, {}, n, r3.availableImages) : void 0, d = { id: l, properties: s3.properties, type: s3.type, sourceLayerIndex: c, index: u3, geometry: p ? h.geometry : er(s3), patterns: {}, sortKey: f };
      a.push(d);
    }
    o && a.sort((s3, l) => s3.sortKey - l.sortKey);
    for (let s3 of a) {
      let { geometry: l, index: u3, sourceLayerIndex: c } = s3;
      if (this.hasPattern) {
        let h = oa("fill", this.layers, s3, this.zoom, r3);
        this.patternFeatures.push(h);
      } else this.addFeature(s3, l, u3, n, {}, r3.subdivisionGranularity);
      let p = e[u3].feature;
      r3.featureIndex.insert(p, l, u3, c, this.index);
    }
  }
  update(e, r3, n) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r3, this.stateDependentLayers, n);
  }
  addFeatures(e, r3, n) {
    for (let i of this.patternFeatures) this.addFeature(i, i.geometry, i.index, r3, n, e.subdivisionGranularity);
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e) {
    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, i0), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
  }
  addFeature(e, r3, n, i, o, a) {
    for (let s3 of Es(r3, Uk)) {
      let l = Cp(s3, i, a.fill.getGranularityForZoomLevel(i.z)), u3 = this.layoutVertexArray;
      Mp((c, p) => {
        u3.emplaceBack(c, p);
      }, this.segments, this.layoutVertexArray, this.indexArray, l.verticesFlattened, l.indicesTriangles, this.segments2, this.indexArray2, l.indicesLineList);
    }
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, o, i);
  }
};
X("FillBucket", xl, { omit: ["layers", "patternFeatures"] });
$i();
var c0;
var Nk = () => c0 = c0 || new Ue({ "fill-sort-key": new te(D.layout_fill["fill-sort-key"]) });
var p0;
var Gk = () => p0 = p0 || new Ue({ "fill-antialias": new q3(D.paint_fill["fill-antialias"]), "fill-opacity": new te(D.paint_fill["fill-opacity"]), "fill-color": new te(D.paint_fill["fill-color"]), "fill-outline-color": new te(D.paint_fill["fill-outline-color"]), "fill-translate": new q3(D.paint_fill["fill-translate"]), "fill-translate-anchor": new q3(D.paint_fill["fill-translate-anchor"]), "fill-pattern": new Mn2(D.paint_fill["fill-pattern"]) });
var h0 = { get paint() {
  return Gk();
}, get layout() {
  return Nk();
} };
var f0 = (t63) => t63.type === "fill";
var Ip = class extends it {
  constructor(e) {
    super(e, h0);
  }
  recalculate(e, r3) {
    super.recalculate(e, r3);
    let n = this.paint._values["fill-outline-color"];
    n.value.kind === "constant" && n.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
  }
  createBucket(e) {
    return new xl(e);
  }
  queryRadius() {
    return pi(this.paint.get("fill-translate"));
  }
  queryIntersectsFeature({ queryGeometry: e, geometry: r3, transform: n, pixelsToTileUnits: i }) {
    let o = hi(e, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -n.bearingInRadians, i);
    return yp(o, r3);
  }
  isTileClipped() {
    return true;
  }
};
$i();
$i();
$i();
var jk = ze([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4);
var m0 = ze([{ name: "a_centroid", components: 2, type: "Int16" }], 4);
var { members: d0, size: yX, alignment: gX } = jk;
var P0 = s(bl(), 1);
var tF = P0.default.VectorTileFeature.types;
var rF = 500;
var hy = Math.pow(2, 13);
function _l(t63, e, r3, n, i, o, a, s3) {
  t63.emplaceBack(e, r3, Math.floor(n * hy) * 2 + a, i * hy * 2, o * hy * 2, Math.round(s3));
}
var vl = class {
  constructor(e) {
    this.zoom = e.zoom, this.globalState = e.globalState, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((r3) => r3.id), this.index = e.index, this.hasPattern = false, this.layoutVertexArray = new np(), this.centroidVertexArray = new Et(), this.indexArray = new Qe(), this.programConfigurations = new Qt(e.layers, e.zoom), this.segments = new de2(), this.stateDependentLayerIds = this.layers.filter((r3) => r3.isStateDependent()).map((r3) => r3.id);
  }
  populate(e, r3, n) {
    this.features = [], this.hasPattern = ia("fill-extrusion", this.layers, r3);
    for (let { feature: i, id: o, index: a, sourceLayerIndex: s3 } of e) {
      let l = this.layers[0]._featureFilter.needGeometry, u3 = tr(i, l);
      if (!this.layers[0]._featureFilter.filter(new Te(this.zoom, { globalState: this.globalState }), u3, n)) continue;
      let c = { id: o, sourceLayerIndex: s3, index: a, geometry: l ? u3.geometry : er(i), properties: i.properties, type: i.type, patterns: {} };
      this.hasPattern ? this.features.push(oa("fill-extrusion", this.layers, c, this.zoom, r3)) : this.addFeature(c, c.geometry, a, n, {}, r3.subdivisionGranularity), r3.featureIndex.insert(i, c.geometry, a, s3, this.index, true);
    }
  }
  addFeatures(e, r3, n) {
    for (let i of this.features) {
      let { geometry: o } = i;
      this.addFeature(i, o, i.index, r3, n, e.subdivisionGranularity);
    }
  }
  update(e, r3, n) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r3, this.stateDependentLayers, n);
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e) {
    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, d0), this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, m0.members, true), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
  }
  addFeature(e, r3, n, i, o, a) {
    for (let s3 of Es(r3, rF)) {
      let l = { x: 0, y: 0, sampleCount: 0 }, u3 = this.layoutVertexArray.length;
      this.processPolygon(l, i, e, s3, a);
      let c = this.layoutVertexArray.length - u3, p = Math.floor(l.x / l.sampleCount), h = Math.floor(l.y / l.sampleCount);
      for (let f = 0; f < c; f++) this.centroidVertexArray.emplaceBack(p, h);
    }
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, o, i);
  }
  processPolygon(e, r3, n, i, o) {
    if (i.length < 1 || v0(i[0])) return;
    for (let p of i) p.length !== 0 && nF(e, p);
    let a = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, s3 = o.fill.getGranularityForZoomLevel(r3.z), l = tF[n.type] === "Polygon";
    for (let p of i) {
      if (p.length === 0 || v0(p)) continue;
      let h = sa(p, s3, l);
      this._generateSideFaces(h, a);
    }
    if (!l) return;
    let u3 = Cp(i, r3, s3, false), c = this.layoutVertexArray;
    Mp((p, h) => {
      _l(c, p, h, 0, 0, 1, 1, 0);
    }, this.segments, this.layoutVertexArray, this.indexArray, u3.verticesFlattened, u3.indicesTriangles);
  }
  _generateSideFaces(e, r3) {
    let n = 0;
    for (let i = 1; i < e.length; i++) {
      let o = e[i], a = e[i - 1];
      if (iF(o, a)) continue;
      r3.segment.vertexLength + 4 > de2.MAX_VERTEX_ARRAY_LENGTH && (r3.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
      let s3 = o.sub(a)._perp()._unit(), l = a.dist(o);
      n + l > 32768 && (n = 0), _l(this.layoutVertexArray, o.x, o.y, s3.x, s3.y, 0, 0, n), _l(this.layoutVertexArray, o.x, o.y, s3.x, s3.y, 0, 1, n), n += l, _l(this.layoutVertexArray, a.x, a.y, s3.x, s3.y, 0, 0, n), _l(this.layoutVertexArray, a.x, a.y, s3.x, s3.y, 0, 1, n);
      let u3 = r3.segment.vertexLength;
      this.indexArray.emplaceBack(u3, u3 + 2, u3 + 1), this.indexArray.emplaceBack(u3 + 1, u3 + 2, u3 + 3), r3.segment.vertexLength += 4, r3.segment.primitiveLength += 2;
    }
  }
};
function nF(t63, e) {
  for (let r3 = 0; r3 < e.length; r3++) {
    let n = e[r3];
    r3 === e.length - 1 && e[0].x === n.x && e[0].y === n.y || (t63.x += n.x, t63.y += n.y, t63.sampleCount++);
  }
}
X("FillExtrusionBucket", vl, { omit: ["layers", "features"] });
function iF(t63, e) {
  return t63.x === e.x && (t63.x < 0 || t63.x > 8192) || t63.y === e.y && (t63.y < 0 || t63.y > 8192);
}
function v0(t63) {
  return t63.every((e) => e.x < 0) || t63.every((e) => e.x > 8192) || t63.every((e) => e.y < 0) || t63.every((e) => e.y > 8192);
}
$i();
var w0;
var oF = () => w0 = w0 || new Ue({ "fill-extrusion-opacity": new q3(D["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new te(D["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new q3(D["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new q3(D["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Mn2(D["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new te(D["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new te(D["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new q3(D["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
var T0 = { get paint() {
  return oF();
} };
var Ep = s(fe(), 1);
var C0 = (t63) => t63.type === "fill-extrusion";
var Lp = class extends it {
  constructor(e) {
    super(e, T0);
  }
  createBucket(e) {
    return new vl(e);
  }
  queryRadius() {
    return pi(this.paint.get("fill-extrusion-translate"));
  }
  is3D() {
    return true;
  }
  queryIntersectsFeature({ queryGeometry: e, feature: r3, featureState: n, geometry: i, transform: o, pixelsToTileUnits: a, pixelPosMatrix: s3 }) {
    let l = hi(e, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -o.bearingInRadians, a), u3 = this.paint.get("fill-extrusion-height").evaluate(r3, n), c = this.paint.get("fill-extrusion-base").evaluate(r3, n), p = lF(l, s3, 0), h = sF(i, c, u3, s3), f = h[0], d = h[1];
    return aF(f, d, p);
  }
};
function Pl(t63, e) {
  return t63.x * e.x + t63.y * e.y;
}
function S0(t63, e) {
  if (t63.length === 1) {
    let r3 = 0, n = e[r3++], i;
    for (; !i || n.equals(i); ) if (i = e[r3++], !i) return 1 / 0;
    for (; r3 < e.length; r3++) {
      let o = e[r3], a = t63[0], s3 = i.sub(n), l = o.sub(n), u3 = a.sub(n), c = Pl(s3, s3), p = Pl(s3, l), h = Pl(l, l), f = Pl(u3, s3), d = Pl(u3, l), g = c * h - p * p, x = (h * f - p * d) / g, b = (c * d - p * f) / g, v3 = 1 - x - b, P = n.z * v3 + i.z * x + o.z * b;
      if (isFinite(P)) return P;
    }
    return 1 / 0;
  } else {
    let r3 = 1 / 0;
    for (let n of e) r3 = Math.min(r3, n.z);
    return r3;
  }
}
function aF(t63, e, r3) {
  let n = 1 / 0;
  yp(r3, e) && (n = S0(r3, e[0]));
  for (let i = 0; i < e.length; i++) {
    let o = e[i], a = t63[i];
    for (let s3 = 0; s3 < o.length - 1; s3++) {
      let l = o[s3], u3 = o[s3 + 1], c = a[s3], p = a[s3 + 1], h = [l, u3, p, c, l];
      dp(r3, h) && (n = Math.min(n, S0(r3, h)));
    }
  }
  return n === 1 / 0 ? false : n;
}
function sF(t63, e, r3, n) {
  let i = [], o = [], a = n[8] * e, s3 = n[9] * e, l = n[10] * e, u3 = n[11] * e, c = n[8] * r3, p = n[9] * r3, h = n[10] * r3, f = n[11] * r3;
  for (let d of t63) {
    let g = [], x = [];
    for (let b of d) {
      let v3 = b.x, P = b.y, w3 = n[0] * v3 + n[4] * P + n[12], T = n[1] * v3 + n[5] * P + n[13], S = n[2] * v3 + n[6] * P + n[14], C3 = n[3] * v3 + n[7] * P + n[15], A = w3 + a, E = T + s3, L = S + l, F = C3 + u3, O = w3 + c, z = T + p, I = S + h, R = C3 + f, H = new Ep.default(A / F, E / F);
      H.z = L / F, g.push(H);
      let W = new Ep.default(O / R, z / R);
      W.z = I / R, x.push(W);
    }
    i.push(g), o.push(x);
  }
  return [i, o];
}
function lF(t63, e, r3) {
  let n = [];
  for (let i of t63) {
    let o = [i.x, i.y, r3, 1];
    Ne.transformMat4(o, o, e), n.push(new Ep.default(o[0] / o[3], o[1] / o[3]));
  }
  return n;
}
$i();
$i();
$i();
var uF = ze([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4);
var { members: M0, size: sZ, alignment: lZ } = uF;
$i();
var cF = ze([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]);
var { members: I0, size: hZ, alignment: fZ } = cF;
var L0 = s(bl(), 1);
var pF = L0.default.VectorTileFeature.types;
var A0 = 63;
var hF = Math.cos(75 / 2 * (Math.PI / 180));
var fF = 15;
var mF = 20;
var dF = 15;
var D0 = 1 / 2;
var E0 = Math.pow(2, dF - 1) / D0;
var wl = class {
  constructor(e) {
    this.zoom = e.zoom, this.globalState = e.globalState, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((r3) => r3.id), this.index = e.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((r3) => {
      this.gradients[r3.id] = {};
    }), this.layoutVertexArray = new ip(), this.layoutVertexArray2 = new op(), this.indexArray = new Qe(), this.programConfigurations = new Qt(e.layers, e.zoom), this.segments = new de2(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((r3) => r3.isStateDependent()).map((r3) => r3.id);
  }
  populate(e, r3, n) {
    this.hasPattern = ia("line", this.layers, r3);
    let i = this.layers[0].layout.get("line-sort-key"), o = !i.isConstant(), a = [];
    for (let { feature: s3, id: l, index: u3, sourceLayerIndex: c } of e) {
      let p = this.layers[0]._featureFilter.needGeometry, h = tr(s3, p);
      if (!this.layers[0]._featureFilter.filter(new Te(this.zoom, { globalState: this.globalState }), h, n)) continue;
      let f = o ? i.evaluate(h, {}, n) : void 0, d = { id: l, properties: s3.properties, type: s3.type, sourceLayerIndex: c, index: u3, geometry: p ? h.geometry : er(s3), patterns: {}, sortKey: f };
      a.push(d);
    }
    o && a.sort((s3, l) => s3.sortKey - l.sortKey);
    for (let s3 of a) {
      let { geometry: l, index: u3, sourceLayerIndex: c } = s3;
      if (this.hasPattern) {
        let h = oa("line", this.layers, s3, this.zoom, r3);
        this.patternFeatures.push(h);
      } else this.addFeature(s3, l, u3, n, {}, r3.subdivisionGranularity);
      let p = e[u3].feature;
      r3.featureIndex.insert(p, l, u3, c, this.index);
    }
  }
  update(e, r3, n) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r3, this.stateDependentLayers, n);
  }
  addFeatures(e, r3, n) {
    for (let i of this.patternFeatures) this.addFeature(i, i.geometry, i.index, r3, n, e.subdivisionGranularity);
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e) {
    this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, I0)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, M0), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
  }
  lineFeatureClips(e) {
    if (e.properties && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_end")) {
      let r3 = +e.properties.mapbox_clip_start, n = +e.properties.mapbox_clip_end;
      return { start: r3, end: n };
    }
  }
  addFeature(e, r3, n, i, o, a) {
    let s3 = this.layers[0].layout, l = s3.get("line-join").evaluate(e, {}), u3 = s3.get("line-cap"), c = s3.get("line-miter-limit"), p = s3.get("line-round-limit");
    this.lineClips = this.lineFeatureClips(e);
    for (let h of r3) this.addLine(h, e, l, u3, c, p, i, a);
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, o, i);
  }
  addLine(e, r3, n, i, o, a, s3, l) {
    this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0;
    let u3 = s3 ? l.line.getGranularityForZoomLevel(s3.z) : 1;
    if (e = sa(e, u3), this.lineClips) {
      this.lineClipsArray.push(this.lineClips);
      for (let w3 = 0; w3 < e.length - 1; w3++) this.totalDistance += e[w3].dist(e[w3 + 1]);
      this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
    }
    let c = pF[r3.type] === "Polygon", p = e.length;
    for (; p >= 2 && e[p - 1].equals(e[p - 2]); ) p--;
    let h = 0;
    for (; h < p - 1 && e[h].equals(e[h + 1]); ) h++;
    if (p < (c ? 3 : 2)) return;
    n === "bevel" && (o = 1.05);
    let f = this.overscaling <= 16 ? fF * 8192 / (512 * this.overscaling) : 0, d = this.segments.prepareSegment(p * 10, this.layoutVertexArray, this.indexArray), g, x, b, v3, P;
    this.e1 = this.e2 = -1, c && (g = e[p - 2], P = e[h].sub(g)._unit()._perp());
    for (let w3 = h; w3 < p; w3++) {
      if (b = w3 === p - 1 ? c ? e[h + 1] : void 0 : e[w3 + 1], b && e[w3].equals(b)) continue;
      P && (v3 = P), g && (x = g), g = e[w3], P = b ? b.sub(g)._unit()._perp() : v3, v3 = v3 || P;
      let T = v3.add(P);
      (T.x !== 0 || T.y !== 0) && T._unit();
      let S = v3.x * P.x + v3.y * P.y, C3 = T.x * P.x + T.y * P.y, A = C3 !== 0 ? 1 / C3 : 1 / 0, E = 2 * Math.sqrt(2 - 2 * C3), L = C3 < hF && x && b, F = v3.x * P.y - v3.y * P.x > 0;
      if (L && w3 > h) {
        let I = g.dist(x);
        if (I > 2 * f) {
          let R = g.sub(g.sub(x)._mult(f / I)._round());
          this.updateDistance(x, R), this.addCurrentVertex(R, v3, 0, 0, d), x = R;
        }
      }
      let O = x && b, z = O ? n : c ? "butt" : i;
      if (O && z === "round" && (A < a ? z = "miter" : A <= 2 && (z = "fakeround")), z === "miter" && A > o && (z = "bevel"), z === "bevel" && (A > 2 && (z = "flipbevel"), A < o && (z = "miter")), x && this.updateDistance(x, g), z === "miter") T._mult(A), this.addCurrentVertex(g, T, 0, 0, d);
      else if (z === "flipbevel") {
        if (A > 100) T = P.mult(-1);
        else {
          let I = A * v3.add(P).mag() / v3.sub(P).mag();
          T._perp()._mult(I * (F ? -1 : 1));
        }
        this.addCurrentVertex(g, T, 0, 0, d), this.addCurrentVertex(g, T.mult(-1), 0, 0, d);
      } else if (z === "bevel" || z === "fakeround") {
        let I = -Math.sqrt(A * A - 1), R = F ? I : 0, H = F ? 0 : I;
        if (x && this.addCurrentVertex(g, v3, R, H, d), z === "fakeround") {
          let W = Math.round(E * 180 / Math.PI / mF);
          for (let $ = 1; $ < W; $++) {
            let he = $ / W;
            if (he !== 0.5) {
              let be = he - 0.5, ye = 1.0904 + S * (-3.2452 + S * (3.55645 - S * 1.43519)), Ze = 0.848013 + S * (-1.06021 + S * 0.215638);
              he = he + he * be * (he - 1) * (ye * be * be + Ze);
            }
            let Xe = P.sub(v3)._mult(he)._add(v3)._unit()._mult(F ? -1 : 1);
            this.addHalfVertex(g, Xe.x, Xe.y, false, F, 0, d);
          }
        }
        b && this.addCurrentVertex(g, P, -R, -H, d);
      } else if (z === "butt") this.addCurrentVertex(g, T, 0, 0, d);
      else if (z === "square") {
        let I = x ? 1 : -1;
        this.addCurrentVertex(g, T, I, I, d);
      } else z === "round" && (x && (this.addCurrentVertex(g, v3, 0, 0, d), this.addCurrentVertex(g, v3, 1, 1, d, true)), b && (this.addCurrentVertex(g, P, -1, -1, d, true), this.addCurrentVertex(g, P, 0, 0, d)));
      if (L && w3 < p - 1) {
        let I = g.dist(b);
        if (I > 2 * f) {
          let R = g.add(b.sub(g)._mult(f / I)._round());
          this.updateDistance(g, R), this.addCurrentVertex(R, P, 0, 0, d), g = R;
        }
      }
    }
  }
  addCurrentVertex(e, r3, n, i, o, a = false) {
    let s3 = r3.x + r3.y * n, l = r3.y - r3.x * n, u3 = -r3.x + r3.y * i, c = -r3.y - r3.x * i;
    this.addHalfVertex(e, s3, l, a, false, n, o), this.addHalfVertex(e, u3, c, a, true, -i, o), this.distance > E0 / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(e, r3, n, i, o, a));
  }
  addHalfVertex({ x: e, y: r3 }, n, i, o, a, s3, l) {
    let c = (this.lineClips ? this.scaledDistance * (E0 - 1) : this.scaledDistance) * D0;
    if (this.layoutVertexArray.emplaceBack((e << 1) + (o ? 1 : 0), (r3 << 1) + (a ? 1 : 0), Math.round(A0 * n) + 128, Math.round(A0 * i) + 128, (s3 === 0 ? 0 : s3 < 0 ? -1 : 1) + 1 | (c & 63) << 2, c >> 6), this.lineClips) {
      let h = this.scaledDistance - this.lineClips.start, f = this.lineClips.end - this.lineClips.start, d = h / f;
      this.layoutVertexArray2.emplaceBack(d, this.lineClipsArray.length);
    }
    let p = l.vertexLength++;
    this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, p, this.e2), l.primitiveLength++), a ? this.e2 = p : this.e1 = p;
  }
  updateScaledDistance() {
    this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
  }
  updateDistance(e, r3) {
    this.distance += e.dist(r3), this.updateScaledDistance();
  }
};
X("LineBucket", wl, { omit: ["layers", "patternFeatures"] });
$i();
var R0;
var yF = () => R0 = R0 || new Ue({ "line-cap": new q3(D.layout_line["line-cap"]), "line-join": new te(D.layout_line["line-join"]), "line-miter-limit": new q3(D.layout_line["line-miter-limit"]), "line-round-limit": new q3(D.layout_line["line-round-limit"]), "line-sort-key": new te(D.layout_line["line-sort-key"]) });
var k0;
var gF = () => k0 = k0 || new Ue({ "line-opacity": new te(D.paint_line["line-opacity"]), "line-color": new te(D.paint_line["line-color"]), "line-translate": new q3(D.paint_line["line-translate"]), "line-translate-anchor": new q3(D.paint_line["line-translate-anchor"]), "line-width": new te(D.paint_line["line-width"]), "line-gap-width": new te(D.paint_line["line-gap-width"]), "line-offset": new te(D.paint_line["line-offset"]), "line-blur": new te(D.paint_line["line-blur"]), "line-dasharray": new to(D.paint_line["line-dasharray"]), "line-pattern": new Mn2(D.paint_line["line-pattern"]), "line-gradient": new In(D.paint_line["line-gradient"]) });
var fy = { get paint() {
  return gF();
}, get layout() {
  return yF();
} };
var my = class extends te {
  possiblyEvaluate(e, r3) {
    return r3 = new Te(Math.floor(r3.zoom), { now: r3.now, fadeDuration: r3.fadeDuration, zoomHistory: r3.zoomHistory, transition: r3.transition }), super.possiblyEvaluate(e, r3);
  }
  evaluate(e, r3, n, i) {
    return r3 = Z({}, r3, { zoom: Math.floor(r3.zoom) }), super.evaluate(e, r3, n, i);
  }
};
var Dp;
var O0 = (t63) => t63.type === "line";
var Rp = class extends it {
  constructor(e) {
    super(e, fy), this.gradientVersion = 0, Dp || (Dp = new my(fy.paint.properties["line-width"].specification), Dp.useIntegerZoom = true);
  }
  _handleSpecialPaintPropertyUpdate(e) {
    if (e === "line-gradient") {
      let r3 = this.gradientExpression();
      W_(r3) ? this.stepInterpolant = r3._styleExpression.expression instanceof Ho : this.stepInterpolant = false, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
    }
  }
  gradientExpression() {
    return this._transitionablePaint._values["line-gradient"].value.expression;
  }
  recalculate(e, r3) {
    super.recalculate(e, r3), this.paint._values["line-floorwidth"] = Dp.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e);
  }
  createBucket(e) {
    return new wl(e);
  }
  queryRadius(e) {
    let r3 = e, n = F0(ao("line-width", this, r3), ao("line-gap-width", this, r3)), i = ao("line-offset", this, r3);
    return n / 2 + Math.abs(i) + pi(this.paint.get("line-translate"));
  }
  queryIntersectsFeature({ queryGeometry: e, feature: r3, featureState: n, geometry: i, transform: o, pixelsToTileUnits: a }) {
    let s3 = hi(e, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -o.bearingInRadians, a), l = a / 2 * F0(this.paint.get("line-width").evaluate(r3, n), this.paint.get("line-gap-width").evaluate(r3, n)), u3 = this.paint.get("line-offset").evaluate(r3, n);
    return u3 && (i = Nv(i, u3 * a)), zv(s3, i, l);
  }
  isTileClipped() {
    return true;
  }
};
function F0(t63, e) {
  return e > 0 ? e + 2 * t63 : t63;
}
$i();
$i();
$i();
var B0 = ze([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4);
var z0 = ze([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
var WZ = ze([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
var V0 = ze([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
var $Z = ze([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
var dy = ze([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4);
var U0 = ze([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
var KZ = ze([{ name: "triangle", components: 3, type: "Uint16" }]);
var JZ = ze([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]);
var QZ = ze([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]);
var eq = ze([{ type: "Float32", name: "offsetX" }]);
var tq = ze([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
var rq = ze([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
var Cl = s(fe(), 1);
$i();
function xF(t63, e, r3) {
  let n = e.layout.get("text-transform").evaluate(r3, {});
  return n === "uppercase" ? t63 = t63.toLocaleUpperCase() : n === "lowercase" && (t63 = t63.toLocaleLowerCase()), cn2.applyArabicShaping && (t63 = cn2.applyArabicShaping(t63)), t63;
}
function N0(t63, e, r3) {
  return t63.sections.forEach((n) => {
    n.text = xF(n.text, e, r3);
  }), t63;
}
$i();
function G0(t63) {
  let e = {}, r3 = {}, n = [], i = 0;
  function o(u3) {
    n.push(t63[u3]), i++;
  }
  function a(u3, c, p) {
    let h = r3[u3];
    return delete r3[u3], r3[c] = h, n[h].geometry[0].pop(), n[h].geometry[0] = n[h].geometry[0].concat(p[0]), h;
  }
  function s3(u3, c, p) {
    let h = e[c];
    return delete e[c], e[u3] = h, n[h].geometry[0].shift(), n[h].geometry[0] = p[0].concat(n[h].geometry[0]), h;
  }
  function l(u3, c, p) {
    let h = p ? c[0][c[0].length - 1] : c[0][0];
    return `${u3}:${h.x}:${h.y}`;
  }
  for (let u3 = 0; u3 < t63.length; u3++) {
    let c = t63[u3], p = c.geometry, h = c.text ? c.text.toString() : null;
    if (!h) {
      o(u3);
      continue;
    }
    let f = l(h, p), d = l(h, p, true);
    if (f in r3 && d in e && r3[f] !== e[d]) {
      let g = s3(f, d, p), x = a(f, d, n[g].geometry);
      delete e[f], delete r3[d], r3[l(h, n[x].geometry, true)] = x, n[g].geometry = null;
    } else f in r3 ? a(f, d, p) : d in e ? s3(f, d, p) : (o(u3), e[f] = i - 1, r3[d] = i - 1);
  }
  return n.filter((u3) => u3.geometry);
}
$i();
$i();
var j0 = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" };
$i();
var mi = 24;
$i();
var K0 = s(xy(), 1);
var $0 = 3;
function OF(t63, e, r3) {
  t63 === 1 && r3.readMessage(BF, e);
}
function BF(t63, e, r3) {
  if (t63 === 3) {
    let { id: n, bitmap: i, width: o, height: a, left: s3, top: l, advance: u3 } = r3.readMessage(zF, {});
    e.push({ id: n, bitmap: new so({ width: o + 2 * $0, height: a + 2 * $0 }, i), metrics: { width: o, height: a, left: s3, top: l, advance: u3 } });
  }
}
function zF(t63, e, r3) {
  t63 === 1 ? e.id = r3.readVarint() : t63 === 2 ? e.bitmap = r3.readBytes() : t63 === 3 ? e.width = r3.readVarint() : t63 === 4 ? e.height = r3.readVarint() : t63 === 5 ? e.left = r3.readSVarint() : t63 === 6 ? e.top = r3.readSVarint() : t63 === 7 && (e.advance = r3.readVarint());
}
function J0(t63) {
  return new K0.default(t63).readFields(OF, []);
}
$i();
function Q0(t63) {
  let { userImage: e } = t63;
  return e && e.render && e.render() ? (t63.data.replace(new Uint8Array(e.data.buffer)), true) : false;
}
$i();
$i();
function Tl(t63) {
  let e = 0, r3 = 0;
  for (let s3 of t63) e += s3.w * s3.h, r3 = Math.max(r3, s3.w);
  t63.sort((s3, l) => l.h - s3.h);
  let i = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), r3), h: 1 / 0 }], o = 0, a = 0;
  for (let s3 of t63) for (let l = i.length - 1; l >= 0; l--) {
    let u3 = i[l];
    if (!(s3.w > u3.w || s3.h > u3.h)) {
      if (s3.x = u3.x, s3.y = u3.y, a = Math.max(a, s3.y + s3.h), o = Math.max(o, s3.x + s3.w), s3.w === u3.w && s3.h === u3.h) {
        let c = i.pop();
        l < i.length && (i[l] = c);
      } else s3.h === u3.h ? (u3.x += s3.w, u3.w -= s3.w) : s3.w === u3.w ? (u3.y += s3.h, u3.h -= s3.h) : (i.push({ x: u3.x + s3.w, y: u3.y, w: u3.w - s3.w, h: s3.h }), u3.y += s3.h, u3.h -= s3.h);
      break;
    }
  }
  return { w: o, h: a, fill: e / (o * a) || 0 };
}
var rr = 1;
var pa = class {
  constructor(e, { pixelRatio: r3, version: n, stretchX: i, stretchY: o, content: a, textFitWidth: s3, textFitHeight: l }) {
    this.paddedRect = e, this.pixelRatio = r3, this.stretchX = i, this.stretchY = o, this.content = a, this.version = n, this.textFitWidth = s3, this.textFitHeight = l;
  }
  get tl() {
    return [this.paddedRect.x + rr, this.paddedRect.y + rr];
  }
  get br() {
    return [this.paddedRect.x + this.paddedRect.w - rr, this.paddedRect.y + this.paddedRect.h - rr];
  }
  get tlbr() {
    return this.tl.concat(this.br);
  }
  get displaySize() {
    return [(this.paddedRect.w - rr * 2) / this.pixelRatio, (this.paddedRect.h - rr * 2) / this.pixelRatio];
  }
};
var by = class {
  constructor(e, r3) {
    let n = {}, i = {};
    this.haveRenderCallbacks = [];
    let o = [];
    this.addImages(e, n, o), this.addImages(r3, i, o);
    let { w: a, h: s3 } = Tl(o), l = new Le2({ width: a || 1, height: s3 || 1 });
    for (let u3 in e) {
      let c = e[u3], p = n[u3].paddedRect;
      Le2.copy(c.data, l, { x: 0, y: 0 }, { x: p.x + rr, y: p.y + rr }, c.data);
    }
    for (let u3 in r3) {
      let c = r3[u3], p = i[u3].paddedRect, h = p.x + rr, f = p.y + rr, d = c.data.width, g = c.data.height;
      Le2.copy(c.data, l, { x: 0, y: 0 }, { x: h, y: f }, c.data), Le2.copy(c.data, l, { x: 0, y: g - 1 }, { x: h, y: f - 1 }, { width: d, height: 1 }), Le2.copy(c.data, l, { x: 0, y: 0 }, { x: h, y: f + g }, { width: d, height: 1 }), Le2.copy(c.data, l, { x: d - 1, y: 0 }, { x: h - 1, y: f }, { width: 1, height: g }), Le2.copy(c.data, l, { x: 0, y: 0 }, { x: h + d, y: f }, { width: 1, height: g });
    }
    this.image = l, this.iconPositions = n, this.patternPositions = i;
  }
  addImages(e, r3, n) {
    for (let i in e) {
      let o = e[i], a = { x: 0, y: 0, w: o.data.width + 2 * rr, h: o.data.height + 2 * rr };
      n.push(a), r3[i] = new pa(a, o), o.hasRenderCallback && this.haveRenderCallbacks.push(i);
    }
  }
  patchUpdatedImages(e, r3) {
    e.dispatchRenderCallbacks(this.haveRenderCallbacks);
    for (let n in e.updatedImages) this.patchUpdatedImage(this.iconPositions[n], e.getImage(n), r3), this.patchUpdatedImage(this.patternPositions[n], e.getImage(n), r3);
  }
  patchUpdatedImage(e, r3, n) {
    if (!e || !r3 || e.version === r3.version) return;
    e.version = r3.version;
    let [i, o] = e.tl;
    n.update(r3.data, void 0, { x: i, y: o });
  }
};
X("ImagePosition", pa);
X("ImageAtlas", by);
var uo = ((i) => (i[i.none = 0] = "none", i[i.horizontal = 1] = "horizontal", i[i.vertical = 2] = "vertical", i[i.horizontalOnly = 3] = "horizontalOnly", i))(uo || {});
function Op(t63) {
  let e = 0.5, r3 = 0.5;
  switch (t63) {
    case "right":
    case "top-right":
    case "bottom-right":
      e = 1;
      break;
    case "left":
    case "top-left":
    case "bottom-left":
      e = 0;
      break;
  }
  switch (t63) {
    case "bottom":
    case "bottom-right":
    case "bottom-left":
      r3 = 1;
      break;
    case "top":
    case "top-right":
    case "top-left":
      r3 = 0;
      break;
  }
  return { horizontalAlign: e, verticalAlign: r3 };
}
var r1 = s(bl(), 1);
$i();
var e1 = 255;
var Sl = 128;
var Bp = e1 * Sl;
function _y(t63, e) {
  let { expression: r3 } = e;
  if (r3.kind === "constant") return { kind: "constant", layoutSize: r3.evaluate(new Te(t63 + 1)) };
  if (r3.kind === "source") return { kind: "source" };
  {
    let { zoomStops: n, interpolationType: i } = r3, o = 0;
    for (; o < n.length && n[o] <= t63; ) o++;
    o = Math.max(0, o - 1);
    let a = o;
    for (; a < n.length && n[a] < t63 + 1; ) a++;
    a = Math.min(n.length - 1, a);
    let s3 = n[o], l = n[a];
    if (r3.kind === "composite") return { kind: "composite", minZoom: s3, maxZoom: l, interpolationType: i };
    let u3 = r3.evaluate(new Te(s3)), c = r3.evaluate(new Te(l));
    return { kind: "camera", minZoom: s3, maxZoom: l, minSize: u3, maxSize: c, interpolationType: i };
  }
}
function ha(t63, { uSize: e, uSizeT: r3 }, { lowerSize: n, upperSize: i }) {
  return t63.kind === "source" ? n / Sl : t63.kind === "composite" ? Fe.number(n / Sl, i / Sl, r3) : e;
}
function co(t63, e) {
  let r3 = 0, n = 0;
  if (t63.kind === "constant") n = t63.layoutSize;
  else if (t63.kind !== "source") {
    let { interpolationType: i, minZoom: o, maxZoom: a } = t63, s3 = i ? ce(jt.interpolationFactor(i, e, o, a), 0, 1) : 0;
    t63.kind === "camera" ? n = Fe.number(t63.minSize, t63.maxSize, s3) : r3 = s3;
  }
  return { uSizeT: r3, uSize: n };
}
$i();
function fa(t63, e, r3) {
  let n = "never", i = t63.get(e);
  return i ? n = i : t63.get(r3) && (n = "always"), n;
}
var UF = r1.default.VectorTileFeature.types;
var NF = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
function zp(t63, e, r3, n, i, o, a, s3, l, u3, c, p, h) {
  let f = s3 ? Math.min(Bp, Math.round(s3[0])) : 0, d = s3 ? Math.min(Bp, Math.round(s3[1])) : 0;
  t63.emplaceBack(e, r3, Math.round(n * 32), Math.round(i * 32), o, a, (f << 1) + (l ? 1 : 0), d, u3 * 16, c * 16, p * 256, h * 256);
}
function po(t63, e, r3) {
  t63.emplaceBack(e.x, e.y, r3), t63.emplaceBack(e.x, e.y, r3), t63.emplaceBack(e.x, e.y, r3), t63.emplaceBack(e.x, e.y, r3);
}
function GF(t63) {
  for (let e of t63.sections) if (wv(e.text)) return true;
  return false;
}
var Ml = class {
  constructor(e) {
    this.layoutVertexArray = new ap(), this.indexArray = new Qe(), this.programConfigurations = e, this.segments = new de2(), this.dynamicLayoutVertexArray = new sp(), this.opacityVertexArray = new lp(), this.hasVisibleVertices = false, this.placedSymbolArray = new Js();
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
  }
  upload(e, r3, n, i) {
    this.isEmpty() || (n && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, B0.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, r3), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, z0.members, true), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, NF, true), this.opacityVertexBuffer.itemSize = 1), (n || i) && this.programConfigurations.upload(e));
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
  }
};
X("SymbolBuffers", Ml);
var Il = class {
  constructor(e, r3, n) {
    this.layoutVertexArray = new e(), this.layoutAttributes = r3, this.indexArray = new n(), this.segments = new de2(), this.collisionVertexArray = new cp();
  }
  upload(e) {
    this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, V0.members, true);
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
  }
};
X("CollisionBuffers", Il);
var $r = class {
  constructor(e) {
    this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.globalState = e.globalState, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((l) => l.id), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [];
    let n = this.layers[0]._unevaluatedLayout._values;
    this.textSizeData = _y(this.zoom, n["text-size"]), this.iconSizeData = _y(this.zoom, n["icon-size"]);
    let i = this.layers[0].layout, o = i.get("symbol-sort-key"), a = i.get("symbol-z-order");
    this.canOverlap = fa(i, "text-overlap", "text-allow-overlap") !== "never" || fa(i, "icon-overlap", "icon-allow-overlap") !== "never" || i.get("text-ignore-placement") || i.get("icon-ignore-placement"), this.sortFeaturesByKey = a !== "viewport-y" && !o.isConstant();
    let s3 = a === "viewport-y" || a === "auto" && !this.sortFeaturesByKey;
    this.sortFeaturesByY = s3 && this.canOverlap, i.get("symbol-placement") === "point" && (this.writingModes = i.get("text-writing-mode").map((l) => uo[l])), this.stateDependentLayerIds = this.layers.filter((l) => l.isStateDependent()).map((l) => l.id), this.sourceID = e.sourceID;
  }
  createArrays() {
    this.text = new Ml(new Qt(this.layers, this.zoom, (e) => /^text/.test(e))), this.icon = new Ml(new Qt(this.layers, this.zoom, (e) => /^icon/.test(e))), this.glyphOffsetArray = new el(), this.lineVertexArray = new tl(), this.symbolInstances = new Qs(), this.textAnchorOffsets = new rl();
  }
  calculateGlyphDependencies(e, r3, n, i, o) {
    for (let a = 0; a < e.length; a++) if (r3[e.charCodeAt(a)] = true, (n || i) && o) {
      let s3 = j0[e.charAt(a)];
      s3 && (r3[s3.charCodeAt(0)] = true);
    }
  }
  populate(e, r3, n) {
    let i = this.layers[0], o = i.layout, a = o.get("text-font"), s3 = o.get("text-field"), l = o.get("icon-image"), u3 = (s3.value.kind !== "constant" || s3.value.value instanceof yr && !s3.value.value.isEmpty() || s3.value.value.toString().length > 0) && (a.value.kind !== "constant" || a.value.value.length > 0), c = l.value.kind !== "constant" || !!l.value.value || Object.keys(l.parameters).length > 0, p = o.get("symbol-sort-key");
    if (this.features = [], !u3 && !c) return;
    let h = r3.iconDependencies, f = r3.glyphDependencies, d = r3.availableImages, g = new Te(this.zoom, { globalState: this.globalState });
    for (let { feature: x, id: b, index: v3, sourceLayerIndex: P } of e) {
      let w3 = i._featureFilter.needGeometry, T = tr(x, w3);
      if (!i._featureFilter.filter(g, T, n)) continue;
      w3 || (T.geometry = er(x));
      let S;
      if (u3) {
        let L = i.getValueAndResolveTokens("text-field", T, n, d), F = yr.factory(L), O = this.hasRTLText = this.hasRTLText || GF(F);
        (!O || cn2.getRTLTextPluginStatus() === "unavailable" || O && cn2.isParsed()) && (S = N0(F, i, T));
      }
      let C3;
      if (c) {
        let L = i.getValueAndResolveTokens("icon-image", T, n, d);
        L instanceof Jt ? C3 = L : C3 = Jt.fromString(L);
      }
      if (!S && !C3) continue;
      let A = this.sortFeaturesByKey ? p.evaluate(T, {}, n) : void 0, E = { id: b, text: S, icon: C3, index: v3, sourceLayerIndex: P, geometry: T.geometry, properties: x.properties, type: UF[x.type], sortKey: A };
      if (this.features.push(E), C3 && (h[C3.name] = true), S) {
        let L = a.evaluate(T, {}, n).join(","), F = o.get("text-rotation-alignment") !== "viewport" && o.get("symbol-placement") !== "point";
        this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(2) >= 0;
        for (let O of S.sections) if (O.image) h[O.image.name] = true;
        else {
          let z = Hd(S.toString()), I = O.fontStack || L, R = f[I] = f[I] || {};
          this.calculateGlyphDependencies(O.text, R, F, this.allowVerticalPlacement, z);
        }
      }
    }
    o.get("symbol-placement") === "line" && (this.features = G0(this.features)), this.sortFeaturesByKey && this.features.sort((x, b) => x.sortKey - b.sortKey);
  }
  update(e, r3, n) {
    this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e, r3, this.layers, n), this.icon.programConfigurations.updatePaintArrays(e, r3, this.layers, n));
  }
  isEmpty() {
    return this.symbolInstances.length === 0 && !this.hasRTLText;
  }
  uploadPending() {
    return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
  }
  upload(e) {
    !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
  }
  destroyDebugData() {
    this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
  }
  destroy() {
    this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
  }
  addToLineVertexArray(e, r3) {
    let n = this.lineVertexArray.length;
    if (e.segment !== void 0) {
      let i = e.dist(r3[e.segment + 1]), o = e.dist(r3[e.segment]), a = {};
      for (let s3 = e.segment + 1; s3 < r3.length; s3++) a[s3] = { x: r3[s3].x, y: r3[s3].y, tileUnitDistanceFromAnchor: i }, s3 < r3.length - 1 && (i += r3[s3 + 1].dist(r3[s3]));
      for (let s3 = e.segment || 0; s3 >= 0; s3--) a[s3] = { x: r3[s3].x, y: r3[s3].y, tileUnitDistanceFromAnchor: o }, s3 > 0 && (o += r3[s3 - 1].dist(r3[s3]));
      for (let s3 = 0; s3 < r3.length; s3++) {
        let l = a[s3];
        this.lineVertexArray.emplaceBack(l.x, l.y, l.tileUnitDistanceFromAnchor);
      }
    }
    return { lineStartIndex: n, lineLength: this.lineVertexArray.length - n };
  }
  addSymbols(e, r3, n, i, o, a, s3, l, u3, c, p, h) {
    let f = e.indexArray, d = e.layoutVertexArray, g = e.segments.prepareSegment(4 * r3.length, d, f, this.canOverlap ? a.sortKey : void 0), x = this.glyphOffsetArray.length, b = g.vertexLength, v3 = this.allowVerticalPlacement && s3 === 2 ? Math.PI / 2 : 0, P = a.text && a.text.sections;
    for (let w3 = 0; w3 < r3.length; w3++) {
      let { tl: T, tr: S, bl: C3, br: A, tex: E, pixelOffsetTL: L, pixelOffsetBR: F, minFontScaleX: O, minFontScaleY: z, glyphOffset: I, isSDF: R, sectionIndex: H } = r3[w3], W = g.vertexLength, $ = I[1];
      zp(d, l.x, l.y, T.x, $ + T.y, E.x, E.y, n, R, L.x, L.y, O, z), zp(d, l.x, l.y, S.x, $ + S.y, E.x + E.w, E.y, n, R, F.x, L.y, O, z), zp(d, l.x, l.y, C3.x, $ + C3.y, E.x, E.y + E.h, n, R, L.x, F.y, O, z), zp(d, l.x, l.y, A.x, $ + A.y, E.x + E.w, E.y + E.h, n, R, F.x, F.y, O, z), po(e.dynamicLayoutVertexArray, l, v3), f.emplaceBack(W, W + 2, W + 1), f.emplaceBack(W + 1, W + 2, W + 3), g.vertexLength += 4, g.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(I[0]), (w3 === r3.length - 1 || H !== r3[w3 + 1].sectionIndex) && e.programConfigurations.populatePaintArrays(d.length, a, a.index, {}, h, P && P[H]);
    }
    e.placedSymbolArray.emplaceBack(l.x, l.y, x, this.glyphOffsetArray.length - x, b, u3, c, l.segment, n ? n[0] : 0, n ? n[1] : 0, i[0], i[1], s3, 0, false, 0, p);
  }
  _addCollisionDebugVertex(e, r3, n, i, o, a) {
    return r3.emplaceBack(0, 0), e.emplaceBack(n.x, n.y, i, o, Math.round(a.x), Math.round(a.y));
  }
  addCollisionDebugVertices(e, r3, n, i, o, a, s3) {
    let l = o.segments.prepareSegment(4, o.layoutVertexArray, o.indexArray), u3 = l.vertexLength, c = o.layoutVertexArray, p = o.collisionVertexArray, h = s3.anchorX, f = s3.anchorY;
    this._addCollisionDebugVertex(c, p, a, h, f, new Cl.default(e, r3)), this._addCollisionDebugVertex(c, p, a, h, f, new Cl.default(n, r3)), this._addCollisionDebugVertex(c, p, a, h, f, new Cl.default(n, i)), this._addCollisionDebugVertex(c, p, a, h, f, new Cl.default(e, i)), l.vertexLength += 4;
    let d = o.indexArray;
    d.emplaceBack(u3, u3 + 1), d.emplaceBack(u3 + 1, u3 + 2), d.emplaceBack(u3 + 2, u3 + 3), d.emplaceBack(u3 + 3, u3), l.primitiveLength += 4;
  }
  addDebugCollisionBoxes(e, r3, n, i) {
    for (let o = e; o < r3; o++) {
      let a = this.collisionBoxArray.get(o), s3 = a.x1, l = a.y1, u3 = a.x2, c = a.y2;
      this.addCollisionDebugVertices(s3, l, u3, c, i ? this.textCollisionBox : this.iconCollisionBox, a.anchorPoint, n);
    }
  }
  generateCollisionDebugBuffers() {
    this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Il(il2, dy.members, ui), this.iconCollisionBox = new Il(il2, dy.members, ui);
    for (let e = 0; e < this.symbolInstances.length; e++) {
      let r3 = this.symbolInstances.get(e);
      this.addDebugCollisionBoxes(r3.textBoxStartIndex, r3.textBoxEndIndex, r3, true), this.addDebugCollisionBoxes(r3.verticalTextBoxStartIndex, r3.verticalTextBoxEndIndex, r3, true), this.addDebugCollisionBoxes(r3.iconBoxStartIndex, r3.iconBoxEndIndex, r3, false), this.addDebugCollisionBoxes(r3.verticalIconBoxStartIndex, r3.verticalIconBoxEndIndex, r3, false);
    }
  }
  _deserializeCollisionBoxesForSymbol(e, r3, n, i, o, a, s3, l, u3) {
    let c = {};
    for (let p = r3; p < n; p++) {
      let h = e.get(p);
      c.textBox = { x1: h.x1, y1: h.y1, x2: h.x2, y2: h.y2, anchorPointX: h.anchorPointX, anchorPointY: h.anchorPointY }, c.textFeatureIndex = h.featureIndex;
      break;
    }
    for (let p = i; p < o; p++) {
      let h = e.get(p);
      c.verticalTextBox = { x1: h.x1, y1: h.y1, x2: h.x2, y2: h.y2, anchorPointX: h.anchorPointX, anchorPointY: h.anchorPointY }, c.verticalTextFeatureIndex = h.featureIndex;
      break;
    }
    for (let p = a; p < s3; p++) {
      let h = e.get(p);
      c.iconBox = { x1: h.x1, y1: h.y1, x2: h.x2, y2: h.y2, anchorPointX: h.anchorPointX, anchorPointY: h.anchorPointY }, c.iconFeatureIndex = h.featureIndex;
      break;
    }
    for (let p = l; p < u3; p++) {
      let h = e.get(p);
      c.verticalIconBox = { x1: h.x1, y1: h.y1, x2: h.x2, y2: h.y2, anchorPointX: h.anchorPointX, anchorPointY: h.anchorPointY }, c.verticalIconFeatureIndex = h.featureIndex;
      break;
    }
    return c;
  }
  deserializeCollisionBoxes(e) {
    this.collisionArrays = [];
    for (let r3 = 0; r3 < this.symbolInstances.length; r3++) {
      let n = this.symbolInstances.get(r3);
      this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, n.textBoxStartIndex, n.textBoxEndIndex, n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n.iconBoxStartIndex, n.iconBoxEndIndex, n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex));
    }
  }
  hasTextData() {
    return this.text.segments.get().length > 0;
  }
  hasIconData() {
    return this.icon.segments.get().length > 0;
  }
  hasDebugData() {
    return this.textCollisionBox && this.iconCollisionBox;
  }
  hasTextCollisionBoxData() {
    return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
  }
  hasIconCollisionBoxData() {
    return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
  }
  addIndicesForPlacedSymbol(e, r3) {
    let n = e.placedSymbolArray.get(r3), i = n.vertexStartIndex + n.numGlyphs * 4;
    for (let o = n.vertexStartIndex; o < i; o += 4) e.indexArray.emplaceBack(o, o + 2, o + 1), e.indexArray.emplaceBack(o + 1, o + 2, o + 3);
  }
  getSortedSymbolIndexes(e) {
    if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
    let r3 = Math.sin(e), n = Math.cos(e), i = [], o = [], a = [];
    for (let s3 = 0; s3 < this.symbolInstances.length; ++s3) {
      a.push(s3);
      let l = this.symbolInstances.get(s3);
      i.push(Math.round(r3 * l.anchorX + n * l.anchorY) | 0), o.push(l.featureIndex);
    }
    return a.sort((s3, l) => i[s3] - i[l] || o[l] - o[s3]), a;
  }
  addToSortKeyRanges(e, r3) {
    let n = this.sortKeyRanges[this.sortKeyRanges.length - 1];
    n && n.sortKey === r3 ? n.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({ sortKey: r3, symbolInstanceStart: e, symbolInstanceEnd: e + 1 });
  }
  sortFeatures(e) {
    if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
      this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
      for (let r3 of this.symbolInstanceIndexes) {
        let n = this.symbolInstances.get(r3);
        this.featureSortOrder.push(n.featureIndex), [n.rightJustifiedTextSymbolIndex, n.centerJustifiedTextSymbolIndex, n.leftJustifiedTextSymbolIndex].forEach((i, o, a) => {
          i >= 0 && a.indexOf(i) === o && this.addIndicesForPlacedSymbol(this.text, i);
        }), n.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, n.verticalPlacedTextSymbolIndex), n.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, n.placedIconSymbolIndex), n.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, n.verticalPlacedIconSymbolIndex);
      }
      this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
    }
  }
};
X("SymbolBucket", $r, { omit: ["layers", "collisionBoxArray", "features", "compareText"] });
$r.MAX_GLYPHS = 65535;
$r.addDynamicAttributes = po;
$i();
function n1(t63, e) {
  return e.replace(/{([^{}]+)}/g, (r3, n) => t63 && n in t63 ? String(t63[n]) : "");
}
$i();
var i1;
var jF = () => i1 = i1 || new Ue({ "symbol-placement": new q3(D.layout_symbol["symbol-placement"]), "symbol-spacing": new q3(D.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new q3(D.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new te(D.layout_symbol["symbol-sort-key"]), "symbol-z-order": new q3(D.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new q3(D.layout_symbol["icon-allow-overlap"]), "icon-overlap": new q3(D.layout_symbol["icon-overlap"]), "icon-ignore-placement": new q3(D.layout_symbol["icon-ignore-placement"]), "icon-optional": new q3(D.layout_symbol["icon-optional"]), "icon-rotation-alignment": new q3(D.layout_symbol["icon-rotation-alignment"]), "icon-size": new te(D.layout_symbol["icon-size"]), "icon-text-fit": new q3(D.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new q3(D.layout_symbol["icon-text-fit-padding"]), "icon-image": new te(D.layout_symbol["icon-image"]), "icon-rotate": new te(D.layout_symbol["icon-rotate"]), "icon-padding": new te(D.layout_symbol["icon-padding"]), "icon-keep-upright": new q3(D.layout_symbol["icon-keep-upright"]), "icon-offset": new te(D.layout_symbol["icon-offset"]), "icon-anchor": new te(D.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new q3(D.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new q3(D.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new q3(D.layout_symbol["text-rotation-alignment"]), "text-field": new te(D.layout_symbol["text-field"]), "text-font": new te(D.layout_symbol["text-font"]), "text-size": new te(D.layout_symbol["text-size"]), "text-max-width": new te(D.layout_symbol["text-max-width"]), "text-line-height": new q3(D.layout_symbol["text-line-height"]), "text-letter-spacing": new te(D.layout_symbol["text-letter-spacing"]), "text-justify": new te(D.layout_symbol["text-justify"]), "text-radial-offset": new te(D.layout_symbol["text-radial-offset"]), "text-variable-anchor": new q3(D.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new te(D.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new te(D.layout_symbol["text-anchor"]), "text-max-angle": new q3(D.layout_symbol["text-max-angle"]), "text-writing-mode": new q3(D.layout_symbol["text-writing-mode"]), "text-rotate": new te(D.layout_symbol["text-rotate"]), "text-padding": new q3(D.layout_symbol["text-padding"]), "text-keep-upright": new q3(D.layout_symbol["text-keep-upright"]), "text-transform": new te(D.layout_symbol["text-transform"]), "text-offset": new te(D.layout_symbol["text-offset"]), "text-allow-overlap": new q3(D.layout_symbol["text-allow-overlap"]), "text-overlap": new q3(D.layout_symbol["text-overlap"]), "text-ignore-placement": new q3(D.layout_symbol["text-ignore-placement"]), "text-optional": new q3(D.layout_symbol["text-optional"]) });
var o1;
var HF = () => o1 = o1 || new Ue({ "icon-opacity": new te(D.paint_symbol["icon-opacity"]), "icon-color": new te(D.paint_symbol["icon-color"]), "icon-halo-color": new te(D.paint_symbol["icon-halo-color"]), "icon-halo-width": new te(D.paint_symbol["icon-halo-width"]), "icon-halo-blur": new te(D.paint_symbol["icon-halo-blur"]), "icon-translate": new q3(D.paint_symbol["icon-translate"]), "icon-translate-anchor": new q3(D.paint_symbol["icon-translate-anchor"]), "text-opacity": new te(D.paint_symbol["text-opacity"]), "text-color": new te(D.paint_symbol["text-color"], { runtimeType: Br, getOverride: (t63) => t63.textColor, hasOverride: (t63) => !!t63.textColor }), "text-halo-color": new te(D.paint_symbol["text-halo-color"]), "text-halo-width": new te(D.paint_symbol["text-halo-width"]), "text-halo-blur": new te(D.paint_symbol["text-halo-blur"]), "text-translate": new q3(D.paint_symbol["text-translate"]), "text-translate-anchor": new q3(D.paint_symbol["text-translate-anchor"]) });
var Vp = { get paint() {
  return HF();
}, get layout() {
  return jF();
} };
$i();
var Al2 = class {
  constructor(e) {
    if (e.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
    this.type = e.property.overrides ? e.property.overrides.runtimeType : Zo, this.defaultValue = e;
  }
  evaluate(e) {
    if (e.formattedSection) {
      let r3 = this.defaultValue.property.overrides;
      if (r3 && r3.hasOverride(e.formattedSection)) return r3.getOverride(e.formattedSection);
    }
    return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default;
  }
  eachChild(e) {
    if (!this.defaultValue.isConstant()) {
      let r3 = this.defaultValue.value;
      e(r3._styleExpression.expression);
    }
  }
  outputDefined() {
    return false;
  }
  serialize() {
    return null;
  }
};
X("FormatSectionOverride", Al2, { omit: ["defaultValue"] });
var a1 = (t63) => t63.type === "symbol";
var Up = class t43 extends it {
  constructor(e) {
    super(e, Vp);
  }
  recalculate(e, r3) {
    if (super.recalculate(e, r3), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout.get("symbol-placement") !== "point" ? this.layout._values["icon-rotation-alignment"] = "map" : this.layout._values["icon-rotation-alignment"] = "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout.get("symbol-placement") !== "point" ? this.layout._values["text-rotation-alignment"] = "map" : this.layout._values["text-rotation-alignment"] = "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
      let n = this.layout.get("text-writing-mode");
      if (n) {
        let i = [];
        for (let o of n) i.indexOf(o) < 0 && i.push(o);
        this.layout._values["text-writing-mode"] = i;
      } else this.layout._values["text-writing-mode"] = ["horizontal"];
    }
    this._setPaintOverrides();
  }
  getValueAndResolveTokens(e, r3, n, i) {
    let o = this.layout.get(e).evaluate(r3, {}, n, i), a = this._unevaluatedLayout._values[e];
    return !a.isDataDriven() && !Ds(a.value) && o ? n1(r3.properties, o) : o;
  }
  createBucket(e) {
    return new $r(e);
  }
  queryRadius() {
    return 0;
  }
  queryIntersectsFeature() {
    throw new Error("Should take a different path in FeatureIndex");
  }
  _setPaintOverrides() {
    for (let e of Vp.paint.overridableProperties) {
      if (!t43.hasPaintOverride(this.layout, e)) continue;
      let r3 = this.paint.get(e), n = new Al2(r3), i = new Wi(n, r3.property.specification), o = null;
      r3.value.kind === "constant" || r3.value.kind === "source" ? o = new un("source", i) : o = new ni2("composite", i, r3.value.zoomStops), this.paint._values[e] = new Ft(r3.property, o, r3.parameters);
    }
  }
  _handleOverridablePaintPropertyUpdate(e, r3, n) {
    return !this.layout || r3.isDataDriven() || n.isDataDriven() ? false : t43.hasPaintOverride(this.layout, e);
  }
  static hasPaintOverride(e, r3) {
    let n = e.get("text-field"), i = Vp.paint.properties[r3], o = false, a = (s3) => {
      for (let l of s3) if (i.overrides && i.overrides.hasOverride(l)) {
        o = true;
        return;
      }
    };
    if (n.value.kind === "constant" && n.value.value instanceof yr) a(n.value.value.sections);
    else if (n.value.kind === "source") {
      let s3 = (u3) => {
        if (!o) if (u3 instanceof ti && ct(u3.value) === qo) {
          let c = u3.value;
          a(c.sections);
        } else u3 instanceof bs ? a(u3.sections) : u3.eachChild(s3);
      }, l = n.value;
      l._styleExpression && s3(l._styleExpression.expression);
    }
    return o;
  }
};
$i();
$i();
var s1;
var XF = () => s1 = s1 || new Ue({ "background-color": new q3(D.paint_background["background-color"]), "background-pattern": new to(D.paint_background["background-pattern"]), "background-opacity": new q3(D.paint_background["background-opacity"]) });
var l1 = { get paint() {
  return XF();
} };
var u1 = (t63) => t63.type === "background";
var Np = class extends it {
  constructor(e) {
    super(e, l1);
  }
};
$i();
$i();
var c1;
var ZF = () => c1 = c1 || new Ue({ "raster-opacity": new q3(D.paint_raster["raster-opacity"]), "raster-hue-rotate": new q3(D.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new q3(D.paint_raster["raster-brightness-min"]), "raster-brightness-max": new q3(D.paint_raster["raster-brightness-max"]), "raster-saturation": new q3(D.paint_raster["raster-saturation"]), "raster-contrast": new q3(D.paint_raster["raster-contrast"]), "raster-resampling": new q3(D.paint_raster["raster-resampling"]), "raster-fade-duration": new q3(D.paint_raster["raster-fade-duration"]) });
var p1 = { get paint() {
  return ZF();
} };
var h1 = (t63) => t63.type === "raster";
var Gp = class extends it {
  constructor(e) {
    super(e, p1);
  }
};
$i();
function f1(t63) {
  let e = [], r3 = t63.id;
  return r3 === void 0 && e.push({ message: `layers.${r3}: missing required property "id"` }), t63.render === void 0 && e.push({ message: `layers.${r3}: missing required method "render"` }), t63.renderingMode && t63.renderingMode !== "2d" && t63.renderingMode !== "3d" && e.push({ message: `layers.${r3}: property "renderingMode" must be either "2d" or "3d"` }), e;
}
var m1 = (t63) => t63.type === "custom";
var jp = class extends it {
  constructor(r3) {
    super(r3, {});
    this.onAdd = (r4) => {
      this.implementation.onAdd && this.implementation.onAdd(r4, r4.painter.context.gl);
    };
    this.onRemove = (r4) => {
      this.implementation.onRemove && this.implementation.onRemove(r4, r4.painter.context.gl);
    };
    this.implementation = r3;
  }
  is3D() {
    return this.implementation.renderingMode === "3d";
  }
  hasOffscreenPass() {
    return this.implementation.prerender !== void 0;
  }
  recalculate() {
  }
  updateTransitions() {
  }
  hasTransition() {
    return false;
  }
  serialize() {
    throw new Error("Custom layers cannot be serialized");
  }
};
function Hp(t63) {
  if (t63.type === "custom") return new jp(t63);
  switch (t63.type) {
    case "background":
      return new Np(t63);
    case "circle":
      return new xp(t63);
    case "color-relief":
      return new Pp(t63);
    case "fill":
      return new Ip(t63);
    case "fill-extrusion":
      return new Lp(t63);
    case "heatmap":
      return new _p(t63);
    case "hillshade":
      return new vp(t63);
    case "line":
      return new Rp(t63);
    case "raster":
      return new Gp(t63);
    case "symbol":
      return new Up(t63);
  }
}
$i();
$i();
function ma(t63) {
  let e = [];
  if (typeof t63 == "string") e.push({ id: "default", url: t63 });
  else if (t63 && t63.length > 0) {
    let r3 = [];
    for (let { id: n, url: i } of t63) {
      let o = `${n}${i}`;
      r3.indexOf(o) === -1 && (r3.push(o), e.push({ id: n, url: i }));
    }
  }
  return e;
}
function d1(t63, e, r3) {
  try {
    let n = new URL(t63);
    return n.pathname += `${e}${r3}`, n.toString();
  } catch {
    throw new Error(`Invalid sprite URL "${t63}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
  }
}
async function y1(t63, e, r3, n) {
  let i = ma(t63), o = r3 > 1 ? "@2x" : "", a = {}, s3 = {};
  for (let { id: l, url: u3 } of i) {
    let c = e.transformRequest(d1(u3, o, ".json"), "SpriteJSON");
    a[l] = Kn(c, n);
    let p = e.transformRequest(d1(u3, o, ".png"), "SpriteImage");
    s3[l] = Gt.getImage(p, n);
  }
  return await Promise.all([...Object.values(a), ...Object.values(s3)]), qF(a, s3);
}
async function qF(t63, e) {
  let r3 = {};
  for (let n in t63) {
    r3[n] = {};
    let i = ae.getImageCanvasContext((await e[n]).data), o = (await t63[n]).data;
    for (let a in o) {
      let { width: s3, height: l, x: u3, y: c, sdf: p, pixelRatio: h, stretchX: f, stretchY: d, content: g, textFitWidth: x, textFitHeight: b } = o[a], v3 = { width: s3, height: l, x: u3, y: c, context: i };
      r3[n][a] = { data: null, pixelRatio: h, sdf: p, stretchX: f, stretchY: d, content: g, textFitWidth: x, textFitHeight: b, spriteData: v3 };
    }
  }
  return r3;
}
$i();
var Xp = 1;
var Zp = class extends Ee {
  constructor() {
    super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new Le2({ width: 1, height: 1 }), this.dirty = true;
  }
  isLoaded() {
    return this.loaded;
  }
  setLoaded(e) {
    if (this.loaded !== e && (this.loaded = e, e)) {
      for (let { ids: r3, promiseResolve: n } of this.requestors) n(this._getImagesForIds(r3));
      this.requestors = [];
    }
  }
  getImage(e) {
    let r3 = this.images[e];
    if (r3 && !r3.data && r3.spriteData) {
      let n = r3.spriteData;
      r3.data = new Le2({ width: n.width, height: n.height }, n.context.getImageData(n.x, n.y, n.width, n.height).data), r3.spriteData = null;
    }
    return r3;
  }
  addImage(e, r3) {
    if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
    this._validate(e, r3) && (this.images[e] = r3);
  }
  _validate(e, r3) {
    let n = true, i = r3.data || r3.spriteData;
    return this._validateStretch(r3.stretchX, i && i.width) || (this.fire(new Q(new Error(`Image "${e}" has invalid "stretchX" value`))), n = false), this._validateStretch(r3.stretchY, i && i.height) || (this.fire(new Q(new Error(`Image "${e}" has invalid "stretchY" value`))), n = false), this._validateContent(r3.content, r3) || (this.fire(new Q(new Error(`Image "${e}" has invalid "content" value`))), n = false), n;
  }
  _validateStretch(e, r3) {
    if (!e) return true;
    let n = 0;
    for (let i of e) {
      if (i[0] < n || i[1] < i[0] || r3 < i[1]) return false;
      n = i[1];
    }
    return true;
  }
  _validateContent(e, r3) {
    if (!e) return true;
    if (e.length !== 4) return false;
    let n = r3.spriteData, i = n && n.width || r3.data.width, o = n && n.height || r3.data.height;
    return !(e[0] < 0 || i < e[0] || e[1] < 0 || o < e[1] || e[2] < 0 || i < e[2] || e[3] < 0 || o < e[3] || e[2] < e[0] || e[3] < e[1]);
  }
  updateImage(e, r3, n = true) {
    let i = this.getImage(e);
    if (n && (i.data.width !== r3.data.width || i.data.height !== r3.data.height)) throw new Error(`size mismatch between old image (${i.data.width}x${i.data.height}) and new image (${r3.data.width}x${r3.data.height}).`);
    r3.version = i.version + 1, this.images[e] = r3, this.updatedImages[e] = true;
  }
  removeImage(e) {
    let r3 = this.images[e];
    delete this.images[e], delete this.patterns[e], r3.userImage && r3.userImage.onRemove && r3.userImage.onRemove();
  }
  listImages() {
    return Object.keys(this.images);
  }
  getImages(e) {
    return new Promise((r3, n) => {
      let i = true;
      if (!this.isLoaded()) for (let o of e) this.images[o] || (i = false);
      this.isLoaded() || i ? r3(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: r3 });
    });
  }
  _getImagesForIds(e) {
    let r3 = {};
    for (let n of e) {
      let i = this.getImage(n);
      i || (this.fire(new U("styleimagemissing", { id: n })), i = this.getImage(n)), i ? r3[n] = { data: i.data.clone(), pixelRatio: i.pixelRatio, sdf: i.sdf, version: i.version, stretchX: i.stretchX, stretchY: i.stretchY, content: i.content, textFitWidth: i.textFitWidth, textFitHeight: i.textFitHeight, hasRenderCallback: !!(i.userImage && i.userImage.render) } : ve2(`Image "${n}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
    }
    return r3;
  }
  getPixelSize() {
    let { width: e, height: r3 } = this.atlasImage;
    return { width: e, height: r3 };
  }
  getPattern(e) {
    let r3 = this.patterns[e], n = this.getImage(e);
    if (!n) return null;
    if (r3 && r3.position.version === n.version) return r3.position;
    if (r3) r3.position.version = n.version;
    else {
      let i = n.data.width + Xp * 2, o = n.data.height + Xp * 2, a = { w: i, h: o, x: 0, y: 0 }, s3 = new pa(a, n);
      this.patterns[e] = { bin: a, position: s3 };
    }
    return this._updatePatternAtlas(), this.patterns[e].position;
  }
  bind(e) {
    let r3 = e.gl;
    this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new Se(e, this.atlasImage, r3.RGBA), this.atlasTexture.bind(r3.LINEAR, r3.CLAMP_TO_EDGE);
  }
  _updatePatternAtlas() {
    let e = [];
    for (let o in this.patterns) e.push(this.patterns[o].bin);
    let { w: r3, h: n } = Tl(e), i = this.atlasImage;
    i.resize({ width: r3 || 1, height: n || 1 });
    for (let o in this.patterns) {
      let { bin: a } = this.patterns[o], s3 = a.x + Xp, l = a.y + Xp, u3 = this.getImage(o).data, c = u3.width, p = u3.height;
      Le2.copy(u3, i, { x: 0, y: 0 }, { x: s3, y: l }, { width: c, height: p }), Le2.copy(u3, i, { x: 0, y: p - 1 }, { x: s3, y: l - 1 }, { width: c, height: 1 }), Le2.copy(u3, i, { x: 0, y: 0 }, { x: s3, y: l + p }, { width: c, height: 1 }), Le2.copy(u3, i, { x: c - 1, y: 0 }, { x: s3 - 1, y: l }, { width: 1, height: p }), Le2.copy(u3, i, { x: 0, y: 0 }, { x: s3 + c, y: l }, { width: 1, height: p });
    }
    this.dirty = true;
  }
  beginFrame() {
    this.callbackDispatchedThisFrame = {};
  }
  dispatchRenderCallbacks(e) {
    for (let r3 of e) {
      if (this.callbackDispatchedThisFrame[r3]) continue;
      this.callbackDispatchedThisFrame[r3] = true;
      let n = this.getImage(r3);
      n || ve2(`Image with ID: "${r3}" was not found`), Q0(n) && this.updateImage(r3, n);
    }
  }
};
$i();
$i();
async function g1(t63, e, r3, n) {
  let i = e * 256, o = i + 255, a = n.transformRequest(r3.replace("{fontstack}", t63).replace("{range}", `${i}-${o}`), "Glyphs"), s3 = await e_(a, new AbortController());
  if (!s3 || !s3.data) throw new Error(`Could not load glyph range. range: ${e}, ${i}-${o}`);
  let l = {};
  for (let u3 of J0(s3.data)) l[u3.id] = u3;
  return l;
}
$i();
var El = class {
  constructor({ fontSize: e = 24, buffer: r3 = 3, radius: n = 8, cutoff: i = 0.25, fontFamily: o = "sans-serif", fontWeight: a = "normal", fontStyle: s3 = "normal" } = {}) {
    this.buffer = r3, this.cutoff = i, this.radius = n;
    let l = this.size = e + r3 * 4, u3 = this._createCanvas(l), c = this.ctx = u3.getContext("2d", { willReadFrequently: true });
    c.font = `${s3} ${a} ${e}px ${o}`, c.textBaseline = "alphabetic", c.textAlign = "left", c.fillStyle = "black", this.gridOuter = new Float64Array(l * l), this.gridInner = new Float64Array(l * l), this.f = new Float64Array(l), this.z = new Float64Array(l + 1), this.v = new Uint16Array(l);
  }
  _createCanvas(e) {
    let r3 = document.createElement("canvas");
    return r3.width = r3.height = e, r3;
  }
  draw(e) {
    let { width: r3, actualBoundingBoxAscent: n, actualBoundingBoxDescent: i, actualBoundingBoxLeft: o, actualBoundingBoxRight: a } = this.ctx.measureText(e), s3 = Math.ceil(n), l = 0, u3 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(a - o))), c = Math.min(this.size - this.buffer, s3 + Math.ceil(i)), p = u3 + 2 * this.buffer, h = c + 2 * this.buffer, f = Math.max(p * h, 0), d = new Uint8ClampedArray(f), g = { data: d, width: p, height: h, glyphWidth: u3, glyphHeight: c, glyphTop: s3, glyphLeft: l, glyphAdvance: r3 };
    if (u3 === 0 || c === 0) return g;
    let { ctx: x, buffer: b, gridInner: v3, gridOuter: P } = this;
    x.clearRect(b, b, u3, c), x.fillText(e, b, b + s3);
    let w3 = x.getImageData(b, b, u3, c);
    P.fill(1e20, 0, f), v3.fill(0, 0, f);
    for (let T = 0; T < c; T++) for (let S = 0; S < u3; S++) {
      let C3 = w3.data[4 * (T * u3 + S) + 3] / 255;
      if (C3 === 0) continue;
      let A = (T + b) * p + S + b;
      if (C3 === 1) P[A] = 0, v3[A] = 1e20;
      else {
        let E = 0.5 - C3;
        P[A] = E > 0 ? E * E : 0, v3[A] = E < 0 ? E * E : 0;
      }
    }
    x1(P, 0, 0, p, h, p, this.f, this.v, this.z), x1(v3, b, b, u3, c, p, this.f, this.v, this.z);
    for (let T = 0; T < f; T++) {
      let S = Math.sqrt(P[T]) - Math.sqrt(v3[T]);
      d[T] = Math.round(255 - 255 * (S / this.radius + this.cutoff));
    }
    return g;
  }
};
function x1(t63, e, r3, n, i, o, a, s3, l) {
  for (let u3 = e; u3 < e + n; u3++) b1(t63, r3 * o + u3, o, i, a, s3, l);
  for (let u3 = r3; u3 < r3 + i; u3++) b1(t63, u3 * o + e, 1, n, a, s3, l);
}
function b1(t63, e, r3, n, i, o, a) {
  o[0] = 0, a[0] = -1e20, a[1] = 1e20, i[0] = t63[e];
  for (let s3 = 1, l = 0, u3 = 0; s3 < n; s3++) {
    i[s3] = t63[e + s3 * r3];
    let c = s3 * s3;
    do {
      let p = o[l];
      u3 = (i[s3] - i[p] + c - p * p) / (s3 - p) / 2;
    } while (u3 <= a[l] && --l > -1);
    l++, o[l] = s3, a[l] = u3, a[l + 1] = 1e20;
  }
  for (let s3 = 0, l = 0; s3 < n; s3++) {
    for (; a[l + 1] < s3; ) l++;
    let u3 = o[l], c = s3 - u3;
    t63[e + s3 * r3] = i[u3] + c * c;
  }
}
var da = class da2 {
  constructor(e, r3) {
    this.requestManager = e, this.localIdeographFontFamily = r3, this.entries = {};
  }
  setURL(e) {
    this.url = e;
  }
  async getGlyphs(e) {
    let r3 = [];
    for (let o in e) for (let a of e[o]) r3.push(this._getAndCacheGlyphsPromise(o, a));
    let n = await Promise.all(r3), i = {};
    for (let { stack: o, id: a, glyph: s3 } of n) i[o] || (i[o] = {}), i[o][a] = s3 && { id: s3.id, bitmap: s3.bitmap.clone(), metrics: s3.metrics };
    return i;
  }
  async _getAndCacheGlyphsPromise(e, r3) {
    let n = this.entries[e];
    n || (n = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} });
    let i = n.glyphs[r3];
    if (i !== void 0) return { stack: e, id: r3, glyph: i };
    if (i = this._tinySDF(n, e, r3), i) return n.glyphs[r3] = i, { stack: e, id: r3, glyph: i };
    let o = Math.floor(r3 / 256);
    if (o * 256 > 65535) throw new Error("glyphs > 65535 not supported");
    if (n.ranges[o]) return { stack: e, id: r3, glyph: i };
    if (!this.url) throw new Error("glyphsUrl is not set");
    if (!n.requests[o]) {
      let s3 = da2.loadGlyphRange(e, o, this.url, this.requestManager);
      n.requests[o] = s3;
    }
    let a = await n.requests[o];
    for (let s3 in a) this._doesCharSupportLocalGlyph(+s3) || (n.glyphs[+s3] = a[+s3]);
    return n.ranges[o] = true, { stack: e, id: r3, glyph: a[r3] || null };
  }
  _doesCharSupportLocalGlyph(e) {
    return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || ht["CJK Unified Ideographs"](e) || ht["Hangul Syllables"](e) || ht.Hiragana(e) || ht.Katakana(e) || ht["CJK Symbols and Punctuation"](e) || ht["Halfwidth and Fullwidth Forms"](e));
  }
  _tinySDF(e, r3, n) {
    let i = this.localIdeographFontFamily;
    if (!i || !this._doesCharSupportLocalGlyph(n)) return;
    let o = 2, a = e.tinySDF;
    if (!a) {
      let c = "400";
      /bold/i.test(r3) ? c = "900" : /medium/i.test(r3) ? c = "500" : /light/i.test(r3) && (c = "200"), a = e.tinySDF = new da2.TinySDF({ fontSize: 24 * o, buffer: 3 * o, radius: 8 * o, cutoff: 0.25, fontFamily: i, fontWeight: c });
    }
    let s3 = a.draw(String.fromCharCode(n));
    return { id: n, bitmap: new so({ width: s3.width || 30 * o, height: s3.height || 30 * o }, s3.data), metrics: { width: s3.glyphWidth / o || 24, height: s3.glyphHeight / o || 24, left: s3.glyphLeft / o + 0.5 || 0, top: s3.glyphTop / o - 27.5 || -8, advance: s3.glyphAdvance / o || 24, isDoubleResolution: true } };
  }
};
da.loadGlyphRange = g1, da.TinySDF = El;
var qp = da;
$i();
var Py = class {
  constructor() {
    this.specification = D.light.position;
  }
  possiblyEvaluate(e, r3) {
    return Vb(e.expression.evaluate(r3));
  }
  interpolate(e, r3, n) {
    return { x: Fe.number(e.x, r3.x, n), y: Fe.number(e.y, r3.y, n), z: Fe.number(e.z, r3.z, n) };
  }
};
var _1 = "-transition";
var vy;
var Yp = class extends Ee {
  constructor(e) {
    super(), vy = vy || new Ue({ anchor: new q3(D.light.anchor), position: new Py(), color: new q3(D.light.color), intensity: new q3(D.light.intensity) }), this._transitionable = new pn(vy), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
  }
  getLight() {
    return this._transitionable.serialize();
  }
  setLight(e, r3 = {}) {
    if (!this._validate(dv, e, r3)) for (let n in e) {
      let i = e[n];
      n.endsWith(_1) ? this._transitionable.setTransition(n.slice(0, -_1.length), i) : this._transitionable.setValue(n, i);
    }
  }
  updateTransitions(e) {
    this._transitioning = this._transitionable.transitioned(e, this._transitioning);
  }
  hasTransition() {
    return this._transitioning.hasTransition();
  }
  recalculate(e) {
    this.properties = this._transitioning.possiblyEvaluate(e);
  }
  _validate(e, r3, n) {
    return n && n.validate === false ? false : oi(this, e.call(Je, { value: r3, style: { glyphs: true, sprite: true }, styleSpec: D }));
  }
};
$i();
var YF = new Ue({ "sky-color": new q3(D.sky["sky-color"]), "horizon-color": new q3(D.sky["horizon-color"]), "fog-color": new q3(D.sky["fog-color"]), "fog-ground-blend": new q3(D.sky["fog-ground-blend"]), "horizon-fog-blend": new q3(D.sky["horizon-fog-blend"]), "sky-horizon-blend": new q3(D.sky["sky-horizon-blend"]), "atmosphere-blend": new q3(D.sky["atmosphere-blend"]) });
var v1 = "-transition";
var Wp = class extends Ee {
  constructor(e) {
    super(), this._transitionable = new pn(YF), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new Te(0));
  }
  setSky(e, r3 = {}) {
    if (!this._validate(yv, e, r3)) {
      e || (e = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
      for (let n in e) {
        let i = e[n];
        n.endsWith(v1) ? this._transitionable.setTransition(n.slice(0, -v1.length), i) : this._transitionable.setValue(n, i);
      }
    }
  }
  getSky() {
    return this._transitionable.serialize();
  }
  updateTransitions(e) {
    this._transitioning = this._transitionable.transitioned(e, this._transitioning);
  }
  hasTransition() {
    return this._transitioning.hasTransition();
  }
  recalculate(e) {
    this.properties = this._transitioning.possiblyEvaluate(e);
  }
  _validate(e, r3, n = {}) {
    return n?.validate === false ? false : oi(this, e.call(Je, Z({ value: r3, style: { glyphs: true, sprite: true }, styleSpec: D })));
  }
  calculateFogBlendOpacity(e) {
    return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1;
  }
};
$i();
var $p = class {
  constructor(e, r3) {
    this.width = e, this.height = r3, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
  }
  getDash(e, r3) {
    let n = e.join(",") + String(r3);
    return this.dashEntry[n] || (this.dashEntry[n] = this.addDash(e, r3)), this.dashEntry[n];
  }
  getDashRanges(e, r3, n) {
    let i = e.length % 2 === 1, o = [], a = i ? -e[e.length - 1] * n : 0, s3 = e[0] * n, l = true;
    o.push({ left: a, right: s3, isDash: l, zeroLength: e[0] === 0 });
    let u3 = e[0];
    for (let c = 1; c < e.length; c++) {
      l = !l;
      let p = e[c];
      a = u3 * n, u3 += p, s3 = u3 * n, o.push({ left: a, right: s3, isDash: l, zeroLength: p === 0 });
    }
    return o;
  }
  addRoundDash(e, r3, n) {
    let i = r3 / 2;
    for (let o = -n; o <= n; o++) {
      let a = this.nextRow + n + o, s3 = this.width * a, l = 0, u3 = e[l];
      for (let c = 0; c < this.width; c++) {
        c / u3.right > 1 && (u3 = e[++l]);
        let p = Math.abs(c - u3.left), h = Math.abs(c - u3.right), f = Math.min(p, h), d, g = o / n * (i + 1);
        if (u3.isDash) {
          let x = i - Math.abs(g);
          d = Math.sqrt(f * f + x * x);
        } else d = i - Math.sqrt(f * f + g * g);
        this.data[s3 + c] = Math.max(0, Math.min(255, d + 128));
      }
    }
  }
  addRegularDash(e) {
    for (let s3 = e.length - 1; s3 >= 0; --s3) {
      let l = e[s3], u3 = e[s3 + 1];
      l.zeroLength ? e.splice(s3, 1) : u3 && u3.isDash === l.isDash && (u3.left = l.left, e.splice(s3, 1));
    }
    let r3 = e[0], n = e[e.length - 1];
    r3.isDash === n.isDash && (r3.left = n.left - this.width, n.right = r3.right + this.width);
    let i = this.width * this.nextRow, o = 0, a = e[o];
    for (let s3 = 0; s3 < this.width; s3++) {
      s3 / a.right > 1 && (a = e[++o]);
      let l = Math.abs(s3 - a.left), u3 = Math.abs(s3 - a.right), c = Math.min(l, u3), p = a.isDash ? c : -c;
      this.data[i + s3] = Math.max(0, Math.min(255, p + 128));
    }
  }
  addDash(e, r3) {
    let n = r3 ? 7 : 0, i = 2 * n + 1;
    if (this.nextRow + i > this.height) return ve2("LineAtlas out of space"), null;
    let o = 0;
    for (let s3 = 0; s3 < e.length; s3++) o += e[s3];
    if (o !== 0) {
      let s3 = this.width / o, l = this.getDashRanges(e, this.width, s3);
      r3 ? this.addRoundDash(l, s3, n) : this.addRegularDash(l);
    }
    let a = { y: (this.nextRow + n + 0.5) / this.height, height: 2 * n / this.height, width: o };
    return this.nextRow += i, this.dirty = true, a;
  }
  bind(e) {
    let r3 = e.gl;
    this.texture ? (r3.bindTexture(r3.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, r3.texSubImage2D(r3.TEXTURE_2D, 0, 0, 0, this.width, this.height, r3.ALPHA, r3.UNSIGNED_BYTE, this.data))) : (this.texture = r3.createTexture(), r3.bindTexture(r3.TEXTURE_2D, this.texture), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_S, r3.REPEAT), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_T, r3.REPEAT), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MIN_FILTER, r3.LINEAR), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MAG_FILTER, r3.LINEAR), r3.texImage2D(r3.TEXTURE_2D, 0, r3.ALPHA, this.width, this.height, 0, r3.ALPHA, r3.UNSIGNED_BYTE, this.data));
  }
};
$i();
$i();
$i();
var Kp = class {
  constructor(e) {
    this._methodToThrottle = e, this._triggered = false, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
      this._triggered = false, this._methodToThrottle();
    });
  }
  trigger() {
    this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
      this._triggered = false, this._methodToThrottle();
    }, 0));
  }
  remove() {
    delete this._channel, this._methodToThrottle = () => {
    };
  }
};
var WF = { once: true };
var Jp = class {
  constructor(e, r3) {
    this.target = e, this.mapId = r3, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Kp(() => this.process()), this.subscription = ss(this.target, "message", (n) => this.receive(n), false), this.globalScope = Tn(self) ? e : window;
  }
  registerMessageHandler(e, r3) {
    this.messageHandlers[e] = r3;
  }
  sendAsync(e, r3) {
    return new Promise((n, i) => {
      let o = Math.round(Math.random() * 1e18).toString(36).substring(0, 10), a = r3 ? ss(r3.signal, "abort", () => {
        a?.unsubscribe(), delete this.resolveRejects[o];
        let u3 = { id: o, type: "<cancel>", origin: location.origin, targetMapId: e.targetMapId, sourceMapId: this.mapId };
        this.target.postMessage(u3);
      }, WF) : null;
      this.resolveRejects[o] = { resolve: (u3) => {
        a?.unsubscribe(), n(u3);
      }, reject: (u3) => {
        a?.unsubscribe(), i(u3);
      } };
      let s3 = [], l = { ...e, id: o, sourceMapId: this.mapId, origin: location.origin, data: $o(e.data, s3) };
      this.target.postMessage(l, { transfer: s3 });
    });
  }
  receive(e) {
    let r3 = e.data, n = r3.id;
    if (!(r3.origin !== "file://" && location.origin !== "file://" && r3.origin !== "resource://android" && location.origin !== "resource://android" && r3.origin !== location.origin) && !(r3.targetMapId && this.mapId !== r3.targetMapId)) {
      if (r3.type === "<cancel>") {
        delete this.tasks[n];
        let i = this.abortControllers[n];
        delete this.abortControllers[n], i && i.abort();
        return;
      }
      if (Tn(self) || r3.mustQueue) {
        this.tasks[n] = r3, this.taskQueue.push(n), this.invoker.trigger();
        return;
      }
      this.processTask(n, r3);
    }
  }
  process() {
    if (this.taskQueue.length === 0) return;
    let e = this.taskQueue.shift(), r3 = this.tasks[e];
    delete this.tasks[e], this.taskQueue.length > 0 && this.invoker.trigger(), r3 && this.processTask(e, r3);
  }
  async processTask(e, r3) {
    if (r3.type === "<response>") {
      let o = this.resolveRejects[e];
      if (delete this.resolveRejects[e], !o) return;
      r3.error ? o.reject(Ko(r3.error)) : o.resolve(Ko(r3.data));
      return;
    }
    if (!this.messageHandlers[r3.type]) {
      this.completeTask(e, new Error(`Could not find a registered handler for ${r3.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
      return;
    }
    let n = Ko(r3.data), i = new AbortController();
    this.abortControllers[e] = i;
    try {
      let o = await this.messageHandlers[r3.type](r3.sourceMapId, n, i);
      this.completeTask(e, null, o);
    } catch (o) {
      this.completeTask(e, o);
    }
  }
  completeTask(e, r3, n) {
    let i = [];
    delete this.abortControllers[e];
    let o = { id: e, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: r3 ? $o(r3) : null, data: $o(n, i) };
    this.target.postMessage(o, { transfer: i });
  }
  remove() {
    this.invoker.remove(), this.subscription.unsubscribe();
  }
};
$i();
$i();
$i();
$i();
var P1 = '(()=>{var Uy=Object.create;var ss=Object.defineProperty;var $y=Object.getOwnPropertyDescriptor;var jy=Object.getOwnPropertyNames;var qy=Object.getPrototypeOf,Wy=Object.prototype.hasOwnProperty;var ve=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),Xy=(t,e)=>{for(var r in e)ss(t,r,{get:e[r],enumerable:!0})},Hy=(t,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of jy(e))!Wy.call(t,i)&&i!==r&&ss(t,i,{get:()=>e[i],enumerable:!(n=$y(e,i))||n.enumerable});return t};var Y=(t,e,r)=>(r=t!=null?Uy(qy(t)):{},Hy(e||!t||!t.__esModule?ss(r,"default",{value:t,enumerable:!0}):r,t));var ye=ve((p0,au)=>{"use strict";au.exports=hr;function hr(t,e){this.x=t,this.y=e}hr.prototype={clone:function(){return new hr(this.x,this.y)},add:function(t){return this.clone()._add(t)},sub:function(t){return this.clone()._sub(t)},multByPoint:function(t){return this.clone()._multByPoint(t)},divByPoint:function(t){return this.clone()._divByPoint(t)},mult:function(t){return this.clone()._mult(t)},div:function(t){return this.clone()._div(t)},rotate:function(t){return this.clone()._rotate(t)},rotateAround:function(t,e){return this.clone()._rotateAround(t,e)},matMult:function(t){return this.clone()._matMult(t)},unit:function(){return this.clone()._unit()},perp:function(){return this.clone()._perp()},round:function(){return this.clone()._round()},mag:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},equals:function(t){return this.x===t.x&&this.y===t.y},dist:function(t){return Math.sqrt(this.distSqr(t))},distSqr:function(t){var e=t.x-this.x,r=t.y-this.y;return e*e+r*r},angle:function(){return Math.atan2(this.y,this.x)},angleTo:function(t){return Math.atan2(this.y-t.y,this.x-t.x)},angleWith:function(t){return this.angleWithSep(t.x,t.y)},angleWithSep:function(t,e){return Math.atan2(this.x*e-this.y*t,this.x*t+this.y*e)},_matMult:function(t){var e=t[0]*this.x+t[1]*this.y,r=t[2]*this.x+t[3]*this.y;return this.x=e,this.y=r,this},_add:function(t){return this.x+=t.x,this.y+=t.y,this},_sub:function(t){return this.x-=t.x,this.y-=t.y,this},_mult:function(t){return this.x*=t,this.y*=t,this},_div:function(t){return this.x/=t,this.y/=t,this},_multByPoint:function(t){return this.x*=t.x,this.y*=t.y,this},_divByPoint:function(t){return this.x/=t.x,this.y/=t.y,this},_unit:function(){return this._div(this.mag()),this},_perp:function(){var t=this.y;return this.y=this.x,this.x=-t,this},_rotate:function(t){var e=Math.cos(t),r=Math.sin(t),n=e*this.x-r*this.y,i=r*this.x+e*this.y;return this.x=n,this.y=i,this},_rotateAround:function(t,e){var r=Math.cos(t),n=Math.sin(t),i=e.x+r*(this.x-e.x)-n*(this.y-e.y),o=e.y+n*(this.x-e.x)+r*(this.y-e.y);return this.x=i,this.y=o,this},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}};hr.convert=function(t){return t instanceof hr?t:Array.isArray(t)?new hr(t[0],t[1]):t}});var uu=ve((f0,lu)=>{"use strict";lu.exports=su;function su(t,e,r,n){this.cx=3*t,this.bx=3*(r-t)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*e,this.by=3*(n-e)-this.cy,this.ay=1-this.cy-this.by,this.p1x=t,this.p1y=e,this.p2x=r,this.p2y=n}su.prototype={sampleCurveX:function(t){return((this.ax*t+this.bx)*t+this.cx)*t},sampleCurveY:function(t){return((this.ay*t+this.by)*t+this.cy)*t},sampleCurveDerivativeX:function(t){return(3*this.ax*t+2*this.bx)*t+this.cx},solveCurveX:function(t,e){if(e===void 0&&(e=1e-6),t<0)return 0;if(t>1)return 1;for(var r=t,n=0;n<8;n++){var i=this.sampleCurveX(r)-t;if(Math.abs(i)<e)return r;var o=this.sampleCurveDerivativeX(r);if(Math.abs(o)<1e-6)break;r=r-i/o}var a=0,s=1;for(r=t,n=0;n<20&&(i=this.sampleCurveX(r),!(Math.abs(i-t)<e));n++)t>i?a=r:s=r,r=(s-a)*.5+a;return r},solve:function(t,e){return this.sampleCurveY(this.solveCurveX(t,e))}}});var op=ve((Ov,el)=>{function Sg(t,e){var r,n,i,o,a,s,l,u,c,p;for(r=t.length&3,n=t.length-r,i=e,a=3432918353,l=461845907,p=0;p<n;)c=t.charCodeAt(p)&255|(t.charCodeAt(++p)&255)<<8|(t.charCodeAt(++p)&255)<<16|(t.charCodeAt(++p)&255)<<24,++p,c=(c&65535)*a+(((c>>>16)*a&65535)<<16)&4294967295,c=c<<15|c>>>17,c=(c&65535)*l+(((c>>>16)*l&65535)<<16)&4294967295,i^=c,i=i<<13|i>>>19,o=(i&65535)*5+(((i>>>16)*5&65535)<<16)&4294967295,i=(o&65535)+27492+(((o>>>16)+58964&65535)<<16);switch(c=0,r){case 3:c^=(t.charCodeAt(p+2)&255)<<16;case 2:c^=(t.charCodeAt(p+1)&255)<<8;case 1:c^=t.charCodeAt(p)&255,c=(c&65535)*a+(((c>>>16)*a&65535)<<16)&4294967295,c=c<<15|c>>>17,c=(c&65535)*l+(((c>>>16)*l&65535)<<16)&4294967295,i^=c}return i^=t.length,i^=i>>>16,i=(i&65535)*2246822507+(((i>>>16)*2246822507&65535)<<16)&4294967295,i^=i>>>13,i=(i&65535)*3266489909+(((i>>>16)*3266489909&65535)<<16)&4294967295,i^=i>>>16,i>>>0}typeof el<"u"&&(el.exports=Sg)});var ap=ve((Gv,tl)=>{function wg(t,e){for(var r=t.length,n=e^r,i=0,o;r>=4;)o=t.charCodeAt(i)&255|(t.charCodeAt(++i)&255)<<8|(t.charCodeAt(++i)&255)<<16|(t.charCodeAt(++i)&255)<<24,o=(o&65535)*1540483477+(((o>>>16)*1540483477&65535)<<16),o^=o>>>24,o=(o&65535)*1540483477+(((o>>>16)*1540483477&65535)<<16),n=(n&65535)*1540483477+(((n>>>16)*1540483477&65535)<<16)^o,r-=4,++i;switch(r){case 3:n^=(t.charCodeAt(i+2)&255)<<16;case 2:n^=(t.charCodeAt(i+1)&255)<<8;case 1:n^=t.charCodeAt(i)&255,n=(n&65535)*1540483477+(((n>>>16)*1540483477&65535)<<16)}return n^=n>>>13,n=(n&65535)*1540483477+(((n>>>16)*1540483477&65535)<<16),n^=n>>>15,n>>>0}typeof tl!==void 0&&(tl.exports=wg)});var rl=ve((Nv,ta)=>{var sp=op(),Ag=ap();ta.exports=sp;ta.exports.murmur3=sp;ta.exports.murmur2=Ag});var dl=ve((MS,jp)=>{"use strict";var cb=ye();jp.exports=Rr;function Rr(t,e,r,n,i){this.properties={},this.extent=r,this.type=0,this._pbf=t,this._geometry=-1,this._keys=n,this._values=i,t.readFields(pb,this,e)}function pb(t,e,r){t==1?e.id=r.readVarint():t==2?fb(r,e):t==3?e.type=r.readVarint():t==4&&(e._geometry=r.pos)}function fb(t,e){for(var r=t.readVarint()+t.pos;t.pos<r;){var n=e._keys[t.readVarint()],i=e._values[t.readVarint()];e.properties[n]=i}}Rr.types=["Unknown","Point","LineString","Polygon"];Rr.prototype.loadGeometry=function(){var t=this._pbf;t.pos=this._geometry;for(var e=t.readVarint()+t.pos,r=1,n=0,i=0,o=0,a=[],s;t.pos<e;){if(n<=0){var l=t.readVarint();r=l&7,n=l>>3}if(n--,r===1||r===2)i+=t.readSVarint(),o+=t.readSVarint(),r===1&&(s&&a.push(s),s=[]),s.push(new cb(i,o));else if(r===7)s&&s.push(s[0].clone());else throw new Error("unknown command "+r)}return s&&a.push(s),a};Rr.prototype.bbox=function(){var t=this._pbf;t.pos=this._geometry;for(var e=t.readVarint()+t.pos,r=1,n=0,i=0,o=0,a=1/0,s=-1/0,l=1/0,u=-1/0;t.pos<e;){if(n<=0){var c=t.readVarint();r=c&7,n=c>>3}if(n--,r===1||r===2)i+=t.readSVarint(),o+=t.readSVarint(),i<a&&(a=i),i>s&&(s=i),o<l&&(l=o),o>u&&(u=o);else if(r!==7)throw new Error("unknown command "+r)}return[a,l,s,u]};Rr.prototype.toGeoJSON=function(t,e,r){var n=this.extent*Math.pow(2,r),i=this.extent*t,o=this.extent*e,a=this.loadGeometry(),s=Rr.types[this.type],l,u;function c(y){for(var m=0;m<y.length;m++){var h=y[m],g=180-(h.y+o)*360/n;y[m]=[(h.x+i)*360/n-180,360/Math.PI*Math.atan(Math.exp(g*Math.PI/180))-90]}}switch(this.type){case 1:var p=[];for(l=0;l<a.length;l++)p[l]=a[l][0];a=p,c(a);break;case 2:for(l=0;l<a.length;l++)c(a[l]);break;case 3:for(a=yb(a),l=0;l<a.length;l++)for(u=0;u<a[l].length;u++)c(a[l][u]);break}a.length===1?a=a[0]:s="Multi"+s;var f={type:"Feature",geometry:{type:s,coordinates:a},properties:this.properties};return"id"in this&&(f.id=this.id),f};function yb(t){var e=t.length;if(e<=1)return[t];for(var r=[],n,i,o=0;o<e;o++){var a=mb(t[o]);a!==0&&(i===void 0&&(i=a<0),i===a<0?(n&&r.push(n),n=[t[o]]):n.push(t[o]))}return n&&r.push(n),r}function mb(t){for(var e=0,r=0,n=t.length,i=n-1,o,a;r<n;i=r++)o=t[r],a=t[i],e+=(a.x-o.x)*(o.y+a.y);return e}});var gl=ve((LS,Wp)=>{"use strict";var hb=dl();Wp.exports=qp;function qp(t,e){this.version=1,this.name=null,this.extent=4096,this.length=0,this._pbf=t,this._keys=[],this._values=[],this._features=[],t.readFields(db,this,e),this.length=this._features.length}function db(t,e,r){t===15?e.version=r.readVarint():t===1?e.name=r.readString():t===5?e.extent=r.readVarint():t===2?e._features.push(r.pos):t===3?e._keys.push(r.readString()):t===4&&e._values.push(gb(r))}function gb(t){for(var e=null,r=t.readVarint()+t.pos;t.pos<r;){var n=t.readVarint()>>3;e=n===1?t.readString():n===2?t.readFloat():n===3?t.readDouble():n===4?t.readVarint64():n===5?t.readVarint():n===6?t.readSVarint():n===7?t.readBoolean():null}return e}qp.prototype.feature=function(t){if(t<0||t>=this._features.length)throw new Error("feature index out of bounds");this._pbf.pos=this._features[t];var e=this._pbf.readVarint()+this._pbf.pos;return new hb(this._pbf,e,this.extent,this._keys,this._values)}});var Hp=ve((DS,Xp)=>{"use strict";var bb=gl();Xp.exports=xb;function xb(t,e){this.layers=t.readFields(vb,{},e)}function vb(t,e,r){if(t===3){var n=new bb(r,r.readVarint()+r.pos);n.length&&(e[n.name]=n)}}});var Rt=ve((BS,xa)=>{xa.exports.VectorTile=Hp();xa.exports.VectorTileFeature=dl();xa.exports.VectorTileLayer=gl()});var df=ve(Sl=>{Sl.read=function(t,e,r,n,i){var o,a,s=i*8-n-1,l=(1<<s)-1,u=l>>1,c=-7,p=r?i-1:0,f=r?-1:1,y=t[e+p];for(p+=f,o=y&(1<<-c)-1,y>>=-c,c+=s;c>0;o=o*256+t[e+p],p+=f,c-=8);for(a=o&(1<<-c)-1,o>>=-c,c+=n;c>0;a=a*256+t[e+p],p+=f,c-=8);if(o===0)o=1-u;else{if(o===l)return a?NaN:(y?-1:1)*(1/0);a=a+Math.pow(2,n),o=o-u}return(y?-1:1)*a*Math.pow(2,o-n)};Sl.write=function(t,e,r,n,i,o){var a,s,l,u=o*8-i-1,c=(1<<u)-1,p=c>>1,f=i===23?Math.pow(2,-24)-Math.pow(2,-77):0,y=n?0:o-1,m=n?1:-1,h=e<0||e===0&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(s=isNaN(e)?1:0,a=c):(a=Math.floor(Math.log(e)/Math.LN2),e*(l=Math.pow(2,-a))<1&&(a--,l*=2),a+p>=1?e+=f/l:e+=f*Math.pow(2,1-p),e*l>=2&&(a++,l/=2),a+p>=c?(s=0,a=c):a+p>=1?(s=(e*l-1)*Math.pow(2,i),a=a+p):(s=e*Math.pow(2,p-1)*Math.pow(2,i),a=0));i>=8;t[r+y]=s&255,y+=m,s/=256,i-=8);for(a=a<<i|s,u+=i;u>0;t[r+y]=a&255,y+=m,a/=256,u-=8);t[r+y-m]|=h*128}});var mi=ve((fA,Pf)=>{"use strict";Pf.exports=J;var Aa=df();function J(t){this.buf=ArrayBuffer.isView&&ArrayBuffer.isView(t)?t:new Uint8Array(t||0),this.pos=0,this.type=0,this.length=this.buf.length}J.Varint=0;J.Fixed64=1;J.Bytes=2;J.Fixed32=5;var wl=65536*65536,gf=1/wl,Ob=12,vf=typeof TextDecoder>"u"?null:new TextDecoder("utf-8");J.prototype={destroy:function(){this.buf=null},readFields:function(t,e,r){for(r=r||this.length;this.pos<r;){var n=this.readVarint(),i=n>>3,o=this.pos;this.type=n&7,t(i,e,this),this.pos===o&&this.skip(n)}return e},readMessage:function(t,e){return this.readFields(t,e,this.readVarint()+this.pos)},readFixed32:function(){var t=_a(this.buf,this.pos);return this.pos+=4,t},readSFixed32:function(){var t=xf(this.buf,this.pos);return this.pos+=4,t},readFixed64:function(){var t=_a(this.buf,this.pos)+_a(this.buf,this.pos+4)*wl;return this.pos+=8,t},readSFixed64:function(){var t=_a(this.buf,this.pos)+xf(this.buf,this.pos+4)*wl;return this.pos+=8,t},readFloat:function(){var t=Aa.read(this.buf,this.pos,!0,23,4);return this.pos+=4,t},readDouble:function(){var t=Aa.read(this.buf,this.pos,!0,52,8);return this.pos+=8,t},readVarint:function(t){var e=this.buf,r,n;return n=e[this.pos++],r=n&127,n<128||(n=e[this.pos++],r|=(n&127)<<7,n<128)||(n=e[this.pos++],r|=(n&127)<<14,n<128)||(n=e[this.pos++],r|=(n&127)<<21,n<128)?r:(n=e[this.pos],r|=(n&15)<<28,Gb(r,t,this))},readVarint64:function(){return this.readVarint(!0)},readSVarint:function(){var t=this.readVarint();return t%2===1?(t+1)/-2:t/2},readBoolean:function(){return!!this.readVarint()},readString:function(){var t=this.readVarint()+this.pos,e=this.pos;return this.pos=t,t-e>=Ob&&vf?ex(this.buf,e,t):Qb(this.buf,e,t)},readBytes:function(){var t=this.readVarint()+this.pos,e=this.buf.subarray(this.pos,t);return this.pos=t,e},readPackedVarint:function(t,e){if(this.type!==J.Bytes)return t.push(this.readVarint(e));var r=mt(this);for(t=t||[];this.pos<r;)t.push(this.readVarint(e));return t},readPackedSVarint:function(t){if(this.type!==J.Bytes)return t.push(this.readSVarint());var e=mt(this);for(t=t||[];this.pos<e;)t.push(this.readSVarint());return t},readPackedBoolean:function(t){if(this.type!==J.Bytes)return t.push(this.readBoolean());var e=mt(this);for(t=t||[];this.pos<e;)t.push(this.readBoolean());return t},readPackedFloat:function(t){if(this.type!==J.Bytes)return t.push(this.readFloat());var e=mt(this);for(t=t||[];this.pos<e;)t.push(this.readFloat());return t},readPackedDouble:function(t){if(this.type!==J.Bytes)return t.push(this.readDouble());var e=mt(this);for(t=t||[];this.pos<e;)t.push(this.readDouble());return t},readPackedFixed32:function(t){if(this.type!==J.Bytes)return t.push(this.readFixed32());var e=mt(this);for(t=t||[];this.pos<e;)t.push(this.readFixed32());return t},readPackedSFixed32:function(t){if(this.type!==J.Bytes)return t.push(this.readSFixed32());var e=mt(this);for(t=t||[];this.pos<e;)t.push(this.readSFixed32());return t},readPackedFixed64:function(t){if(this.type!==J.Bytes)return t.push(this.readFixed64());var e=mt(this);for(t=t||[];this.pos<e;)t.push(this.readFixed64());return t},readPackedSFixed64:function(t){if(this.type!==J.Bytes)return t.push(this.readSFixed64());var e=mt(this);for(t=t||[];this.pos<e;)t.push(this.readSFixed64());return t},skip:function(t){var e=t&7;if(e===J.Varint)for(;this.buf[this.pos++]>127;);else if(e===J.Bytes)this.pos=this.readVarint()+this.pos;else if(e===J.Fixed32)this.pos+=4;else if(e===J.Fixed64)this.pos+=8;else throw new Error("Unimplemented type: "+e)},writeTag:function(t,e){this.writeVarint(t<<3|e)},realloc:function(t){for(var e=this.length||16;e<this.pos+t;)e*=2;if(e!==this.length){var r=new Uint8Array(e);r.set(this.buf),this.buf=r,this.length=e}},finish:function(){return this.length=this.pos,this.pos=0,this.buf.subarray(0,this.length)},writeFixed32:function(t){this.realloc(4),Gr(this.buf,t,this.pos),this.pos+=4},writeSFixed32:function(t){this.realloc(4),Gr(this.buf,t,this.pos),this.pos+=4},writeFixed64:function(t){this.realloc(8),Gr(this.buf,t&-1,this.pos),Gr(this.buf,Math.floor(t*gf),this.pos+4),this.pos+=8},writeSFixed64:function(t){this.realloc(8),Gr(this.buf,t&-1,this.pos),Gr(this.buf,Math.floor(t*gf),this.pos+4),this.pos+=8},writeVarint:function(t){if(t=+t||0,t>268435455||t<0){Nb(t,this);return}this.realloc(4),this.buf[this.pos++]=t&127|(t>127?128:0),!(t<=127)&&(this.buf[this.pos++]=(t>>>=7)&127|(t>127?128:0),!(t<=127)&&(this.buf[this.pos++]=(t>>>=7)&127|(t>127?128:0),!(t<=127)&&(this.buf[this.pos++]=t>>>7&127)))},writeSVarint:function(t){this.writeVarint(t<0?-t*2-1:t*2)},writeBoolean:function(t){this.writeVarint(!!t)},writeString:function(t){t=String(t),this.realloc(t.length*4),this.pos++;var e=this.pos;this.pos=tx(this.buf,t,this.pos);var r=this.pos-e;r>=128&&bf(e,r,this),this.pos=e-1,this.writeVarint(r),this.pos+=r},writeFloat:function(t){this.realloc(4),Aa.write(this.buf,t,this.pos,!0,23,4),this.pos+=4},writeDouble:function(t){this.realloc(8),Aa.write(this.buf,t,this.pos,!0,52,8),this.pos+=8},writeBytes:function(t){var e=t.length;this.writeVarint(e),this.realloc(e);for(var r=0;r<e;r++)this.buf[this.pos++]=t[r]},writeRawMessage:function(t,e){this.pos++;var r=this.pos;t(e,this);var n=this.pos-r;n>=128&&bf(r,n,this),this.pos=r-1,this.writeVarint(n),this.pos+=n},writeMessage:function(t,e,r){this.writeTag(t,J.Bytes),this.writeRawMessage(e,r)},writePackedVarint:function(t,e){e.length&&this.writeMessage(t,jb,e)},writePackedSVarint:function(t,e){e.length&&this.writeMessage(t,qb,e)},writePackedBoolean:function(t,e){e.length&&this.writeMessage(t,Hb,e)},writePackedFloat:function(t,e){e.length&&this.writeMessage(t,Wb,e)},writePackedDouble:function(t,e){e.length&&this.writeMessage(t,Xb,e)},writePackedFixed32:function(t,e){e.length&&this.writeMessage(t,Zb,e)},writePackedSFixed32:function(t,e){e.length&&this.writeMessage(t,Jb,e)},writePackedFixed64:function(t,e){e.length&&this.writeMessage(t,Yb,e)},writePackedSFixed64:function(t,e){e.length&&this.writeMessage(t,Kb,e)},writeBytesField:function(t,e){this.writeTag(t,J.Bytes),this.writeBytes(e)},writeFixed32Field:function(t,e){this.writeTag(t,J.Fixed32),this.writeFixed32(e)},writeSFixed32Field:function(t,e){this.writeTag(t,J.Fixed32),this.writeSFixed32(e)},writeFixed64Field:function(t,e){this.writeTag(t,J.Fixed64),this.writeFixed64(e)},writeSFixed64Field:function(t,e){this.writeTag(t,J.Fixed64),this.writeSFixed64(e)},writeVarintField:function(t,e){this.writeTag(t,J.Varint),this.writeVarint(e)},writeSVarintField:function(t,e){this.writeTag(t,J.Varint),this.writeSVarint(e)},writeStringField:function(t,e){this.writeTag(t,J.Bytes),this.writeString(e)},writeFloatField:function(t,e){this.writeTag(t,J.Fixed32),this.writeFloat(e)},writeDoubleField:function(t,e){this.writeTag(t,J.Fixed64),this.writeDouble(e)},writeBooleanField:function(t,e){this.writeVarintField(t,!!e)}};function Gb(t,e,r){var n=r.buf,i,o;if(o=n[r.pos++],i=(o&112)>>4,o<128||(o=n[r.pos++],i|=(o&127)<<3,o<128)||(o=n[r.pos++],i|=(o&127)<<10,o<128)||(o=n[r.pos++],i|=(o&127)<<17,o<128)||(o=n[r.pos++],i|=(o&127)<<24,o<128)||(o=n[r.pos++],i|=(o&1)<<31,o<128))return Or(t,i,e);throw new Error("Expected varint not more than 10 bytes")}function mt(t){return t.type===J.Bytes?t.readVarint()+t.pos:t.pos+1}function Or(t,e,r){return r?e*4294967296+(t>>>0):(e>>>0)*4294967296+(t>>>0)}function Nb(t,e){var r,n;if(t>=0?(r=t%4294967296|0,n=t/4294967296|0):(r=~(-t%4294967296),n=~(-t/4294967296),r^4294967295?r=r+1|0:(r=0,n=n+1|0)),t>=18446744073709552e3||t<-18446744073709552e3)throw new Error("Given varint doesn\'t fit into 10 bytes");e.realloc(10),Ub(r,n,e),$b(n,e)}function Ub(t,e,r){r.buf[r.pos++]=t&127|128,t>>>=7,r.buf[r.pos++]=t&127|128,t>>>=7,r.buf[r.pos++]=t&127|128,t>>>=7,r.buf[r.pos++]=t&127|128,t>>>=7,r.buf[r.pos]=t&127}function $b(t,e){var r=(t&7)<<4;e.buf[e.pos++]|=r|((t>>>=3)?128:0),t&&(e.buf[e.pos++]=t&127|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=t&127|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=t&127|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=t&127|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=t&127)))))}function bf(t,e,r){var n=e<=16383?1:e<=2097151?2:e<=268435455?3:Math.floor(Math.log(e)/(Math.LN2*7));r.realloc(n);for(var i=r.pos-1;i>=t;i--)r.buf[i+n]=r.buf[i]}function jb(t,e){for(var r=0;r<t.length;r++)e.writeVarint(t[r])}function qb(t,e){for(var r=0;r<t.length;r++)e.writeSVarint(t[r])}function Wb(t,e){for(var r=0;r<t.length;r++)e.writeFloat(t[r])}function Xb(t,e){for(var r=0;r<t.length;r++)e.writeDouble(t[r])}function Hb(t,e){for(var r=0;r<t.length;r++)e.writeBoolean(t[r])}function Zb(t,e){for(var r=0;r<t.length;r++)e.writeFixed32(t[r])}function Jb(t,e){for(var r=0;r<t.length;r++)e.writeSFixed32(t[r])}function Yb(t,e){for(var r=0;r<t.length;r++)e.writeFixed64(t[r])}function Kb(t,e){for(var r=0;r<t.length;r++)e.writeSFixed64(t[r])}function _a(t,e){return(t[e]|t[e+1]<<8|t[e+2]<<16)+t[e+3]*16777216}function Gr(t,e,r){t[r]=e,t[r+1]=e>>>8,t[r+2]=e>>>16,t[r+3]=e>>>24}function xf(t,e){return(t[e]|t[e+1]<<8|t[e+2]<<16)+(t[e+3]<<24)}function Qb(t,e,r){for(var n="",i=e;i<r;){var o=t[i],a=null,s=o>239?4:o>223?3:o>191?2:1;if(i+s>r)break;var l,u,c;s===1?o<128&&(a=o):s===2?(l=t[i+1],(l&192)===128&&(a=(o&31)<<6|l&63,a<=127&&(a=null))):s===3?(l=t[i+1],u=t[i+2],(l&192)===128&&(u&192)===128&&(a=(o&15)<<12|(l&63)<<6|u&63,(a<=2047||a>=55296&&a<=57343)&&(a=null))):s===4&&(l=t[i+1],u=t[i+2],c=t[i+3],(l&192)===128&&(u&192)===128&&(c&192)===128&&(a=(o&15)<<18|(l&63)<<12|(u&63)<<6|c&63,(a<=65535||a>=1114112)&&(a=null))),a===null?(a=65533,s=1):a>65535&&(a-=65536,n+=String.fromCharCode(a>>>10&1023|55296),a=56320|a&1023),n+=String.fromCharCode(a),i+=s}return n}function ex(t,e,r){return vf.decode(t.subarray(e,r))}function tx(t,e,r){for(var n=0,i,o;n<e.length;n++){if(i=e.charCodeAt(n),i>55295&&i<57344)if(o)if(i<56320){t[r++]=239,t[r++]=191,t[r++]=189,o=i;continue}else i=o-55296<<10|i-56320|65536,o=null;else{i>56319||n+1===e.length?(t[r++]=239,t[r++]=191,t[r++]=189):o=i;continue}else o&&(t[r++]=239,t[r++]=191,t[r++]=189,o=null);i<128?t[r++]=i:(i<2048?t[r++]=i>>6|192:(i<65536?t[r++]=i>>12|224:(t[r++]=i>>18|240,t[r++]=i>>12&63|128),t[r++]=i>>6&63|128),t[r++]=i&63|128)}return r}});var gy=ve((iT,dy)=>{dy.exports=Ha;function Ha(t,e){var r=t&&t.type,n;if(r==="FeatureCollection")for(n=0;n<t.features.length;n++)Ha(t.features[n],e);else if(r==="GeometryCollection")for(n=0;n<t.geometries.length;n++)Ha(t.geometries[n],e);else if(r==="Feature")Ha(t.geometry,e);else if(r==="Polygon")my(t.coordinates,e);else if(r==="MultiPolygon")for(n=0;n<t.coordinates.length;n++)my(t.coordinates[n],e);return t}function my(t,e){if(t.length!==0){hy(t[0],e);for(var r=1;r<t.length;r++)hy(t[r],!e)}}function hy(t,e){for(var r=0,n=0,i=0,o=t.length,a=o-1;i<o;a=i++){var s=(t[i][0]-t[a][0])*(t[a][1]+t[i][1]),l=r+s;n+=Math.abs(r)>=Math.abs(s)?r-l+s:s-l+r,r=l}r+n>=0!=!!e&&t.reverse()}});var Py=ve((sT,vy)=>{"use strict";var Ux=ye(),$x=Rt().VectorTileFeature;vy.exports=xy;function xy(t,e){this.options=e||{},this.features=t,this.length=t.length}xy.prototype.feature=function(t){return new Ja(this.features[t],this.options.extent)};function Ja(t,e){this.id=typeof t.id=="number"?t.id:void 0,this.type=t.type,this.rawGeometry=t.type===1?[t.geometry]:t.geometry,this.properties=t.tags,this.extent=e||4096}Ja.prototype.loadGeometry=function(){var t=this.rawGeometry;this.geometry=[];for(var e=0;e<t.length;e++){for(var r=t[e],n=[],i=0;i<r.length;i++)n.push(new Ux(r[i][0],r[i][1]));this.geometry.push(n)}return this.geometry};Ja.prototype.bbox=function(){this.geometry||this.loadGeometry();for(var t=this.geometry,e=1/0,r=-1/0,n=1/0,i=-1/0,o=0;o<t.length;o++)for(var a=t[o],s=0;s<a.length;s++){var l=a[s];e=Math.min(e,l.x),r=Math.max(r,l.x),n=Math.min(n,l.y),i=Math.max(i,l.y)}return[e,n,r,i]};Ja.prototype.toGeoJSON=$x.prototype.toGeoJSON});var Ay=ve((lT,Li)=>{var jx=mi(),wy=Py();Li.exports=Ul;Li.exports.fromVectorTileJs=Ul;Li.exports.fromGeojsonVt=qx;Li.exports.GeoJSONWrapper=wy;function Ul(t){var e=new jx;return Wx(t,e),e.finish()}function qx(t,e){e=e||{};var r={};for(var n in t)r[n]=new wy(t[n].features,e),r[n].name=n,r[n].version=e.version,r[n].extent=e.extent;return Ul({layers:r})}function Wx(t,e){for(var r in t.layers)e.writeMessage(3,Xx,t.layers[r])}function Xx(t,e){e.writeVarintField(15,t.version||1),e.writeStringField(1,t.name||""),e.writeVarintField(5,t.extent||4096);var r,n={keys:[],values:[],keycache:{},valuecache:{}};for(r=0;r<t.length;r++)n.feature=t.feature(r),e.writeMessage(2,Hx,n);var i=n.keys;for(r=0;r<i.length;r++)e.writeStringField(3,i[r]);var o=n.values;for(r=0;r<o.length;r++)e.writeMessage(4,Yx,o[r])}function Hx(t,e){var r=t.feature;r.id!==void 0&&e.writeVarintField(1,r.id),e.writeMessage(2,Zx,t),e.writeVarintField(3,r.type),e.writeMessage(4,Jx,r)}function Zx(t,e){var r=t.feature,n=t.keys,i=t.values,o=t.keycache,a=t.valuecache;for(var s in r.properties){var l=r.properties[s],u=o[s];if(l!==null){typeof u>"u"&&(n.push(s),u=n.length-1,o[s]=u),e.writeVarint(u);var c=typeof l;c!=="string"&&c!=="boolean"&&c!=="number"&&(l=JSON.stringify(l));var p=c+":"+l,f=a[p];typeof f>"u"&&(i.push(l),f=i.length-1,a[p]=f),e.writeVarint(f)}}}function Nl(t,e){return(e<<3)+(t&7)}function Sy(t){return t<<1^t>>31}function Jx(t,e){for(var r=t.loadGeometry(),n=t.type,i=0,o=0,a=r.length,s=0;s<a;s++){var l=r[s],u=1;n===1&&(u=l.length),e.writeVarint(Nl(1,u));for(var c=n===3?l.length-1:l.length,p=0;p<c;p++){p===1&&n!==1&&e.writeVarint(Nl(2,c-1));var f=l[p].x-i,y=l[p].y-o;e.writeVarint(Sy(f)),e.writeVarint(Sy(y)),i+=f,o+=y}n===3&&e.writeVarint(Nl(7,1))}}function Yx(t,e){var r=typeof t;r==="string"?e.writeStringField(1,t):r==="boolean"?e.writeBooleanField(7,t):r==="number"&&(t%1!==0?e.writeDoubleField(3,t):t<0?e.writeSVarintField(6,t):e.writeVarintField(5,t))}});var km=Y(ye(),1),Pu=Y(uu(),1);var ls;function cu(){return ls==null&&(ls=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")&&typeof createImageBitmap=="function"),ls}var qi;function pu(){if(qi==null&&(qi=!1,cu())){let r=new OffscreenCanvas(5,5).getContext("2d",{willReadFrequently:!0});if(r){for(let i=0;i<5*5;i++){let o=i*4;r.fillStyle=`rgb(${o},${o+1},${o+2})`,r.fillRect(i%5,Math.floor(i/5),1,1)}let n=r.getImageData(0,0,5,5).data;for(let i=0;i<5*5*4;i++)if(i%4!==3&&n[i]!==i){qi=!0;break}}}return qi||!1}var Jr=1e-6,Yr=typeof Float32Array<"u"?Float32Array:Array,Kr=Math.random;var d0=Math.PI/180;Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)});var Wi={};Xy(Wi,{add:()=>em,ceil:()=>tm,clone:()=>Jy,copy:()=>Ky,create:()=>fu,cross:()=>fm,dist:()=>Am,distance:()=>du,div:()=>wm,divide:()=>hu,dot:()=>pm,equals:()=>vm,exactEquals:()=>xm,floor:()=>rm,forEach:()=>Cm,fromValues:()=>Yy,inverse:()=>um,len:()=>Im,length:()=>bu,lerp:()=>ym,max:()=>im,min:()=>nm,mul:()=>Sm,multiply:()=>mu,negate:()=>lm,normalize:()=>cm,random:()=>mm,round:()=>om,scale:()=>am,scaleAndAdd:()=>sm,set:()=>Qy,sqrDist:()=>_m,sqrLen:()=>Tm,squaredDistance:()=>gu,squaredLength:()=>xu,str:()=>bm,sub:()=>Pm,subtract:()=>yu,transformMat4:()=>hm,transformQuat:()=>dm,zero:()=>gm});function fu(){var t=new Yr(4);return Yr!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function Jy(t){var e=new Yr(4);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}function Yy(t,e,r,n){var i=new Yr(4);return i[0]=t,i[1]=e,i[2]=r,i[3]=n,i}function Ky(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}function Qy(t,e,r,n,i){return t[0]=e,t[1]=r,t[2]=n,t[3]=i,t}function em(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t}function yu(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t[3]=e[3]-r[3],t}function mu(t,e,r){return t[0]=e[0]*r[0],t[1]=e[1]*r[1],t[2]=e[2]*r[2],t[3]=e[3]*r[3],t}function hu(t,e,r){return t[0]=e[0]/r[0],t[1]=e[1]/r[1],t[2]=e[2]/r[2],t[3]=e[3]/r[3],t}function tm(t,e){return t[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t[2]=Math.ceil(e[2]),t[3]=Math.ceil(e[3]),t}function rm(t,e){return t[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t[2]=Math.floor(e[2]),t[3]=Math.floor(e[3]),t}function nm(t,e,r){return t[0]=Math.min(e[0],r[0]),t[1]=Math.min(e[1],r[1]),t[2]=Math.min(e[2],r[2]),t[3]=Math.min(e[3],r[3]),t}function im(t,e,r){return t[0]=Math.max(e[0],r[0]),t[1]=Math.max(e[1],r[1]),t[2]=Math.max(e[2],r[2]),t[3]=Math.max(e[3],r[3]),t}function om(t,e){return t[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t[2]=Math.round(e[2]),t[3]=Math.round(e[3]),t}function am(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t}function sm(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t[3]=e[3]+r[3]*n,t}function du(t,e){var r=e[0]-t[0],n=e[1]-t[1],i=e[2]-t[2],o=e[3]-t[3];return Math.hypot(r,n,i,o)}function gu(t,e){var r=e[0]-t[0],n=e[1]-t[1],i=e[2]-t[2],o=e[3]-t[3];return r*r+n*n+i*i+o*o}function bu(t){var e=t[0],r=t[1],n=t[2],i=t[3];return Math.hypot(e,r,n,i)}function xu(t){var e=t[0],r=t[1],n=t[2],i=t[3];return e*e+r*r+n*n+i*i}function lm(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=-e[3],t}function um(t,e){return t[0]=1/e[0],t[1]=1/e[1],t[2]=1/e[2],t[3]=1/e[3],t}function cm(t,e){var r=e[0],n=e[1],i=e[2],o=e[3],a=r*r+n*n+i*i+o*o;return a>0&&(a=1/Math.sqrt(a)),t[0]=r*a,t[1]=n*a,t[2]=i*a,t[3]=o*a,t}function pm(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3]}function fm(t,e,r,n){var i=r[0]*n[1]-r[1]*n[0],o=r[0]*n[2]-r[2]*n[0],a=r[0]*n[3]-r[3]*n[0],s=r[1]*n[2]-r[2]*n[1],l=r[1]*n[3]-r[3]*n[1],u=r[2]*n[3]-r[3]*n[2],c=e[0],p=e[1],f=e[2],y=e[3];return t[0]=p*u-f*l+y*s,t[1]=-(c*u)+f*a-y*o,t[2]=c*l-p*a+y*i,t[3]=-(c*s)+p*o-f*i,t}function ym(t,e,r,n){var i=e[0],o=e[1],a=e[2],s=e[3];return t[0]=i+n*(r[0]-i),t[1]=o+n*(r[1]-o),t[2]=a+n*(r[2]-a),t[3]=s+n*(r[3]-s),t}function mm(t,e){e=e||1;var r,n,i,o,a,s;do r=Kr()*2-1,n=Kr()*2-1,a=r*r+n*n;while(a>=1);do i=Kr()*2-1,o=Kr()*2-1,s=i*i+o*o;while(s>=1);var l=Math.sqrt((1-a)/s);return t[0]=e*r,t[1]=e*n,t[2]=e*i*l,t[3]=e*o*l,t}function hm(t,e,r){var n=e[0],i=e[1],o=e[2],a=e[3];return t[0]=r[0]*n+r[4]*i+r[8]*o+r[12]*a,t[1]=r[1]*n+r[5]*i+r[9]*o+r[13]*a,t[2]=r[2]*n+r[6]*i+r[10]*o+r[14]*a,t[3]=r[3]*n+r[7]*i+r[11]*o+r[15]*a,t}function dm(t,e,r){var n=e[0],i=e[1],o=e[2],a=r[0],s=r[1],l=r[2],u=r[3],c=u*n+s*o-l*i,p=u*i+l*n-a*o,f=u*o+a*i-s*n,y=-a*n-s*i-l*o;return t[0]=c*u+y*-a+p*-l-f*-s,t[1]=p*u+y*-s+f*-a-c*-l,t[2]=f*u+y*-l+c*-s-p*-a,t[3]=e[3],t}function gm(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t}function bm(t){return"vec4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"}function xm(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]}function vm(t,e){var r=t[0],n=t[1],i=t[2],o=t[3],a=e[0],s=e[1],l=e[2],u=e[3];return Math.abs(r-a)<=Jr*Math.max(1,Math.abs(r),Math.abs(a))&&Math.abs(n-s)<=Jr*Math.max(1,Math.abs(n),Math.abs(s))&&Math.abs(i-l)<=Jr*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(o-u)<=Jr*Math.max(1,Math.abs(o),Math.abs(u))}var Pm=yu,Sm=mu,wm=hu,Am=du,_m=gu,Im=bu,Tm=xu,Cm=function(){var t=fu();return function(e,r,n,i,o,a){var s,l;for(r||(r=4),n||(n=0),i?l=Math.min(i*r+n,e.length):l=e.length,s=n;s<l;s+=r)t[0]=e[s],t[1]=e[s+1],t[2]=e[s+2],t[3]=e[s+3],o(t,t,a),e[s]=t[0],e[s+1]=t[1],e[s+2]=t[2],e[s+3]=t[3];return e}}();function Su(t){if(t<=0)return 0;if(t>=1)return 1;let e=t*t,r=e*t;return 4*(t<.5?r:3*(t-e)+r-.75)}function Fm(t,e,r,n){let i=new Pu.default(t,e,r,n);return o=>i.solve(o)}var A0=Fm(.25,.1,.25,1);function it(t,e,r){return Math.min(r,Math.max(e,t))}function wu(t,e,r){let n=r-e,i=((t-e)%n+n)%n+e;return i===e?r:i}function de(t,...e){for(let r of e)for(let n in r)t[n]=r[n];return t}function Au(t){return Math.log(t)/Math.LN2%1===0}function tn(t,e,r){let n={};for(let i in t)n[i]=e.call(r||this,t[i],i,t);return n}function _u(t,e,r){let n={};for(let i in t)e.call(r||this,t[i],i,t)&&(n[i]=t[i]);return n}function nt(t){return Array.isArray(t)?t.map(nt):typeof t=="object"&&t?tn(t,nt):t}var vu={};function ce(t){vu[t]||(typeof console<"u"&&console.warn(t),vu[t]=!0)}function ot(t,e,r){return(r.y-t.y)*(e.x-t.x)>(e.y-t.y)*(r.x-t.x)}function at(t){return typeof WorkerGlobalScope<"u"&&typeof t<"u"&&t instanceof WorkerGlobalScope}function vt(t){return typeof ImageBitmap<"u"&&t instanceof ImageBitmap}function Em(t,e,r,n,i){let o=Math.max(-e,0)*4,l=(Math.max(0,r)-r)*n*4+o,u=n*4,c=Math.max(0,e),p=Math.max(0,r),f=Math.min(t.width,e+n),y=Math.min(t.height,r+i);return{rect:{x:c,y:p,width:f-c,height:y-p},layout:[{offset:l,stride:u}]}}async function Mm(t,e,r,n,i){if(typeof VideoFrame>"u")throw new Error("VideoFrame not supported");let o=new VideoFrame(t,{timestamp:0});try{let a=o?.format;if(!a||!(a.startsWith("BGR")||a.startsWith("RGB")))throw new Error(`Unrecognized format ${a}`);let s=a.startsWith("BGR"),l=new Uint8ClampedArray(n*i*4);if(await o.copyTo(l,Em(t,e,r,n,i)),s)for(let u=0;u<l.length;u+=4){let c=l[u];l[u]=l[u+2],l[u+2]=c}return l}finally{o.close()}}var Qr,en;function Lm(t,e,r,n,i){let o=t.width,a=t.height;(!Qr||!en)&&(Qr=new OffscreenCanvas(o,a),en=Qr.getContext("2d",{willReadFrequently:!0})),Qr.width=o,Qr.height=a,en.drawImage(t,0,0,o,a);let s=en.getImageData(e,r,n,i);return en.clearRect(0,0,o,a),s.data}async function Iu(t,e,r,n,i){if(pu())try{return await Mm(t,e,r,n,i)}catch{}return Lm(t,e,r,n,i)}function us(t,e,r,n){return t.addEventListener(e,r,n),{unsubscribe:()=>{t.removeEventListener(e,r,n)}}}function cs(t){return t*Math.PI/180}var Xi=25,Hi=0;var $t=class t{constructor(e,r,n){let i=this.cells=[];if(e instanceof ArrayBuffer){this.arrayBuffer=e;let a=new Int32Array(this.arrayBuffer);e=a[0],r=a[1],n=a[2],this.d=r+2*n;for(let u=0;u<this.d*this.d;u++){let c=a[3+u],p=a[3+u+1];i.push(c===p?null:a.subarray(c,p))}let s=a[3+i.length],l=a[3+i.length+1];this.keys=a.subarray(s,l),this.bboxes=a.subarray(l),this.insert=this._insertReadonly}else{this.d=r+2*n;for(let a=0;a<this.d*this.d;a++)i.push([]);this.keys=[],this.bboxes=[]}this.n=r,this.extent=e,this.padding=n,this.scale=r/e,this.uid=0;let o=n/r*e;this.min=-o,this.max=e+o}insert(e,r,n,i,o){this._forEachCell(r,n,i,o,this._insertCell,this.uid++,void 0,void 0),this.keys.push(e),this.bboxes.push(r),this.bboxes.push(n),this.bboxes.push(i),this.bboxes.push(o)}_insertReadonly(){throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")}_insertCell(e,r,n,i,o,a){this.cells[o].push(a)}query(e,r,n,i,o){let a=this.min,s=this.max;if(e<=a&&r<=a&&s<=n&&s<=i&&!o)return Array.prototype.slice.call(this.keys);{let l=[],u={};return this._forEachCell(e,r,n,i,this._queryCell,l,u,o),l}}_queryCell(e,r,n,i,o,a,s,l){let u=this.cells[o];if(u!==null){let c=this.keys,p=this.bboxes;for(let f=0;f<u.length;f++){let y=u[f];if(s[y]===void 0){let m=y*4;(l?l(p[m+0],p[m+1],p[m+2],p[m+3]):e<=p[m+2]&&r<=p[m+3]&&n>=p[m+0]&&i>=p[m+1])?(s[y]=!0,a.push(c[y])):s[y]=!1}}}}_forEachCell(e,r,n,i,o,a,s,l){let u=this._convertToCellCoord(e),c=this._convertToCellCoord(r),p=this._convertToCellCoord(n),f=this._convertToCellCoord(i);for(let y=u;y<=p;y++)for(let m=c;m<=f;m++){let h=this.d*m+y;if(!(l&&!l(this._convertFromCellCoord(y),this._convertFromCellCoord(m),this._convertFromCellCoord(y+1),this._convertFromCellCoord(m+1)))&&o.call(this,e,r,n,i,h,a,s,l))return}}_convertFromCellCoord(e){return(e-this.padding)/this.scale}_convertToCellCoord(e){return Math.max(0,Math.min(this.d-1,Math.floor(e*this.scale)+this.padding))}toArrayBuffer(){if(this.arrayBuffer)return this.arrayBuffer;let e=this.cells,r=3+this.cells.length+1+1,n=0;for(let a=0;a<this.cells.length;a++)n+=this.cells[a].length;let i=new Int32Array(r+n+this.keys.length+this.bboxes.length);i[0]=this.extent,i[1]=this.n,i[2]=this.padding;let o=r;for(let a=0;a<e.length;a++){let s=e[a];i[3+a]=o,i.set(s,o),o+=s.length}return i[3+e.length]=o,i.set(this.keys,o),o+=this.keys.length,i[3+e.length+1]=o,i.set(this.bboxes,o),o+=this.bboxes.length,i.buffer}static serialize(e,r){let n=e.toArrayBuffer();return r&&r.push(n),{buffer:n}}static deserialize(e){return new t(e.buffer)}};var Dm=8,Bm={version:{required:!0,type:"enum",values:[8]},name:{type:"string"},metadata:{type:"*"},center:{type:"array",value:"number"},centerAltitude:{type:"number"},zoom:{type:"number"},bearing:{type:"number",default:0,period:360,units:"degrees"},pitch:{type:"number",default:0,units:"degrees"},roll:{type:"number",default:0,units:"degrees"},state:{type:"state",default:{}},light:{type:"light"},sky:{type:"sky"},projection:{type:"projection"},terrain:{type:"terrain"},sources:{required:!0,type:"sources"},sprite:{type:"sprite"},glyphs:{type:"string"},transition:{type:"transition"},layers:{required:!0,type:"array",value:"layer"}},Vm={"*":{type:"source"}},Rm=["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],zm={type:{required:!0,type:"enum",values:{vector:{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},scheme:{type:"enum",values:{xyz:{},tms:{}},default:"xyz"},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},attribution:{type:"string"},promoteId:{type:"promoteId"},volatile:{type:"boolean",default:!1},"*":{type:"*"}},Om={type:{required:!0,type:"enum",values:{raster:{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},tileSize:{type:"number",default:512,units:"pixels"},scheme:{type:"enum",values:{xyz:{},tms:{}},default:"xyz"},attribution:{type:"string"},volatile:{type:"boolean",default:!1},"*":{type:"*"}},Gm={type:{required:!0,type:"enum",values:{"raster-dem":{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},tileSize:{type:"number",default:512,units:"pixels"},attribution:{type:"string"},encoding:{type:"enum",values:{terrarium:{},mapbox:{},custom:{}},default:"mapbox"},redFactor:{type:"number",default:1},blueFactor:{type:"number",default:1},greenFactor:{type:"number",default:1},baseShift:{type:"number",default:0},volatile:{type:"boolean",default:!1},"*":{type:"*"}},Nm={type:{required:!0,type:"enum",values:{geojson:{}}},data:{required:!0,type:"*"},maxzoom:{type:"number",default:18},attribution:{type:"string"},buffer:{type:"number",default:128,maximum:512,minimum:0},filter:{type:"*"},tolerance:{type:"number",default:.375},cluster:{type:"boolean",default:!1},clusterRadius:{type:"number",default:50,minimum:0},clusterMaxZoom:{type:"number"},clusterMinPoints:{type:"number"},clusterProperties:{type:"*"},lineMetrics:{type:"boolean",default:!1},generateId:{type:"boolean",default:!1},promoteId:{type:"promoteId"}},Um={type:{required:!0,type:"enum",values:{video:{}}},urls:{required:!0,type:"array",value:"string"},coordinates:{required:!0,type:"array",length:4,value:{type:"array",length:2,value:"number"}}},$m={type:{required:!0,type:"enum",values:{image:{}}},url:{required:!0,type:"string"},coordinates:{required:!0,type:"array",length:4,value:{type:"array",length:2,value:"number"}}},jm={id:{type:"string",required:!0},type:{type:"enum",values:{fill:{},line:{},symbol:{},circle:{},heatmap:{},"fill-extrusion":{},raster:{},hillshade:{},"color-relief":{},background:{}},required:!0},metadata:{type:"*"},source:{type:"string"},"source-layer":{type:"string"},minzoom:{type:"number",minimum:0,maximum:24},maxzoom:{type:"number",minimum:0,maximum:24},filter:{type:"filter"},layout:{type:"layout"},paint:{type:"paint"}},qm=["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_color-relief","layout_background"],Wm={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Xm={"fill-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Hm={"circle-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Zm={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Jm={"line-cap":{type:"enum",values:{butt:{},round:{},square:{}},default:"butt",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"line-join":{type:"enum",values:{bevel:{},round:{},miter:{}},default:"miter",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{type:"number",default:2,requires:[{"line-join":"miter"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-round-limit":{type:"number",default:1.05,requires:[{"line-join":"round"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Ym={"symbol-placement":{type:"enum",values:{point:{},line:{},"line-center":{}},default:"point",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"symbol-spacing":{type:"number",default:250,minimum:1,units:"pixels",requires:[{"symbol-placement":"line"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{type:"boolean",default:!1,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{type:"enum",values:{auto:{},"viewport-y":{},source:{}},default:"auto",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{type:"boolean",default:!1,requires:["icon-image",{"!":"icon-overlap"}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-overlap":{type:"enum",values:{never:{},always:{},cooperative:{}},requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{type:"boolean",default:!1,requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-optional":{type:"boolean",default:!1,requires:["icon-image","text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-size":{type:"number",default:1,minimum:0,units:"factor of the original icon size",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{type:"enum",values:{none:{},width:{},height:{},both:{}},default:"none",requires:["icon-image","text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{type:"array",value:"number",length:4,default:[0,0,0,0],units:"pixels",requires:["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-image":{type:"resolvedImage",tokens:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{type:"number",default:0,period:360,units:"degrees",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{type:"padding",default:[2],units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-keep-upright":{type:"boolean",default:!1,requires:["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-offset":{type:"array",value:"number",length:2,default:[0,0],requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{type:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},default:"center",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{type:"enum",values:{map:{},viewport:{},"viewport-glyph":{},auto:{}},default:"auto",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-field":{type:"formatted",default:"",tokens:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-font":{type:"array",value:"string",default:["Open Sans Regular","Arial Unicode MS Regular"],requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-size":{type:"number",default:16,minimum:0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{type:"number",default:10,minimum:0,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{type:"number",default:1.2,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-letter-spacing":{type:"number",default:0,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-justify":{type:"enum",values:{auto:{},left:{},center:{},right:{}},default:"center",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{type:"number",units:"ems",default:0,requires:["text-field"],"property-type":"data-driven",expression:{interpolated:!0,parameters:["zoom","feature"]}},"text-variable-anchor":{type:"array",value:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-variable-anchor-offset":{type:"variableAnchorOffsetCollection",requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-anchor":{type:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},default:"center",requires:["text-field",{"!":"text-variable-anchor"}],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{type:"number",default:45,units:"degrees",requires:["text-field",{"symbol-placement":["line","line-center"]}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-writing-mode":{type:"array",value:"enum",values:{horizontal:{},vertical:{}},requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-rotate":{type:"number",default:0,period:360,units:"degrees",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-padding":{type:"number",default:2,minimum:0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-keep-upright":{type:"boolean",default:!0,requires:["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-transform":{type:"enum",values:{none:{},uppercase:{},lowercase:{}},default:"none",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-offset":{type:"array",value:"number",units:"ems",length:2,default:[0,0],requires:["text-field",{"!":"text-radial-offset"}],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{type:"boolean",default:!1,requires:["text-field",{"!":"text-overlap"}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-overlap":{type:"enum",values:{never:{},always:{},cooperative:{}},requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{type:"boolean",default:!1,requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-optional":{type:"boolean",default:!1,requires:["text-field","icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Km={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Qm={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},eh={type:"array",value:"*"},th={type:"enum",values:{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},in:{},"!in":{},all:{},any:{},none:{},has:{},"!has":{}}},rh={type:"enum",values:{Point:{},LineString:{},Polygon:{}}},nh={type:"array",minimum:0,maximum:24,value:["number","color"],length:2},ih={type:"array",value:"*",minimum:1},oh={anchor:{type:"enum",default:"viewport",values:{map:{},viewport:{}},"property-type":"data-constant",transition:!1,expression:{interpolated:!1,parameters:["zoom"]}},position:{type:"array",default:[1.15,210,30],length:3,value:"number","property-type":"data-constant",transition:!0,expression:{interpolated:!0,parameters:["zoom"]}},color:{type:"color","property-type":"data-constant",default:"#ffffff",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},intensity:{type:"number","property-type":"data-constant",default:.5,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0}},ah={"sky-color":{type:"color","property-type":"data-constant",default:"#88C6FC",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"horizon-color":{type:"color","property-type":"data-constant",default:"#ffffff",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"fog-color":{type:"color","property-type":"data-constant",default:"#ffffff",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"fog-ground-blend":{type:"number","property-type":"data-constant",default:.5,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"horizon-fog-blend":{type:"number","property-type":"data-constant",default:.8,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"sky-horizon-blend":{type:"number","property-type":"data-constant",default:.8,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"atmosphere-blend":{type:"number","property-type":"data-constant",default:.8,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0}},sh={source:{type:"string",required:!0},exaggeration:{type:"number",minimum:0,default:1}},lh={type:{type:"projectionDefinition",default:"mercator","property-type":"data-constant",transition:!1,expression:{interpolated:!0,parameters:["zoom"]}}},uh=["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_color-relief","paint_background"],ch={"fill-antialias":{type:"boolean",default:!0,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"fill-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{type:"color",transition:!0,requires:[{"!":"fill-pattern"},{"fill-antialias":!0}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["fill-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"}},ph={"line-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"line-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["line-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"line-width":{type:"number",default:1,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{type:"number",default:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{type:"array",value:"number",minimum:0,transition:!0,units:"line widths",requires:[{"!":"line-pattern"}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"cross-faded"},"line-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-gradient":{type:"color",transition:!1,requires:[{"!":"line-dasharray"},{"!":"line-pattern"},{source:"geojson",has:{lineMetrics:!0}}],expression:{interpolated:!0,parameters:["line-progress"]},"property-type":"color-ramp"}},fh={"circle-radius":{type:"number",default:5,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{type:"number",default:0,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["circle-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{type:"enum",values:{map:{},viewport:{}},default:"map",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{type:"enum",values:{map:{},viewport:{}},default:"viewport",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"}},yh={"heatmap-radius":{type:"number",default:30,minimum:1,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{type:"number",default:1,minimum:0,transition:!1,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{type:"number",default:1,minimum:0,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"heatmap-color":{type:"color",default:["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",.1,"royalblue",.3,"cyan",.5,"lime",.7,"yellow",1,"red"],transition:!1,expression:{interpolated:!0,parameters:["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},mh={"icon-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{type:"color",default:"#000000",transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{type:"color",default:"rgba(0, 0, 0, 0)",transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["icon-image","icon-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{type:"color",default:"#000000",transition:!0,overridable:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{type:"color",default:"rgba(0, 0, 0, 0)",transition:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["text-field","text-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"}},hh={"raster-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{type:"number",default:0,period:360,transition:!0,units:"degrees",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{type:"number",default:0,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-saturation":{type:"number",default:0,minimum:-1,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-contrast":{type:"number",default:0,minimum:-1,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-resampling":{type:"enum",values:{linear:{},nearest:{}},default:"linear",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{type:"number",default:300,minimum:0,transition:!1,units:"milliseconds",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},dh={"hillshade-illumination-direction":{type:"numberArray",default:335,minimum:0,maximum:359,transition:!1,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-illumination-altitude":{type:"numberArray",default:45,minimum:0,maximum:90,transition:!1,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{type:"enum",values:{map:{},viewport:{}},default:"viewport",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{type:"number",default:.5,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{type:"colorArray",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{type:"colorArray",default:"#FFFFFF",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-method":{type:"enum",values:{standard:{},basic:{},combined:{},igor:{},multidirectional:{}},default:"standard",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"}},gh={"background-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"background-pattern"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"background-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"cross-faded"},"background-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},bh={duration:{type:"number",default:300,minimum:0,units:"milliseconds"},delay:{type:"number",default:0,minimum:0,units:"milliseconds"}},xh={"*":{type:"string"}},P={$version:Dm,$root:Bm,sources:Vm,source:Rm,source_vector:zm,source_raster:Om,source_raster_dem:Gm,source_geojson:Nm,source_video:Um,source_image:$m,layer:jm,layout:qm,layout_background:Wm,layout_fill:Xm,layout_circle:Hm,layout_heatmap:Zm,"layout_fill-extrusion":{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_line:Jm,layout_symbol:Ym,layout_raster:Km,layout_hillshade:Qm,"layout_color-relief":{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},filter:eh,filter_operator:th,geometry_type:rh,function:{expression:{type:"expression"},stops:{type:"array",value:"function_stop"},base:{type:"number",default:1,minimum:0},property:{type:"string",default:"$zoom"},type:{type:"enum",values:{identity:{},exponential:{},interval:{},categorical:{}},default:"exponential"},colorSpace:{type:"enum",values:{rgb:{},lab:{},hcl:{}},default:"rgb"},default:{type:"*",required:!1}},function_stop:nh,expression:ih,light:oh,sky:ah,terrain:sh,projection:lh,paint:uh,paint_fill:ch,"paint_fill-extrusion":{"fill-extrusion-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"fill-extrusion-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["fill-extrusion-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"},"fill-extrusion-height":{type:"number",default:0,minimum:0,units:"meters",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{type:"number",default:0,minimum:0,units:"meters",transition:!0,requires:["fill-extrusion-height"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{type:"boolean",default:!0,transition:!1,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"}},paint_line:ph,paint_circle:fh,paint_heatmap:yh,paint_symbol:mh,paint_raster:hh,paint_hillshade:dh,"paint_color-relief":{"color-relief-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"color-relief-color":{type:"color",transition:!1,expression:{interpolated:!0,parameters:["elevation"]},"property-type":"color-ramp"}},paint_background:gh,transition:bh,"property-type":{"data-driven":{type:"property-type"},"cross-faded":{type:"property-type"},"cross-faded-data-driven":{type:"property-type"},"color-ramp":{type:"property-type"},"data-constant":{type:"property-type"},constant:{type:"property-type"}},promoteId:xh},vh=["type","source","source-layer","minzoom","maxzoom","filter","layout"];var C=class{constructor(e,r,n,i){this.message=(e?`${e}: `:"")+n,i&&(this.identifier=i),r!=null&&r.__line__&&(this.line=r.__line__)}};function xr(t,...e){for(let r of e)for(let n in r)t[n]=r[n];return t}var Ve=class extends Error{constructor(e,r){super(r),this.message=r,this.key=e}},vs=class t{constructor(e,r=[]){this.parent=e,this.bindings={};for(let[n,i]of r)this.bindings[n]=i}concat(e){return new t(this,e)}get(e){if(this.bindings[e])return this.bindings[e];if(this.parent)return this.parent.get(e);throw new Error(`${e} not found in scope.`)}has(e){return this.bindings[e]?!0:this.parent?this.parent.has(e):!1}},wr={kind:"null"},k={kind:"number"},$={kind:"string"},U={kind:"boolean"},ze={kind:"color"},yo={kind:"projectionDefinition"},Wt={kind:"object"},N={kind:"value"},Ph={kind:"error"},mo={kind:"collator"},Ar={kind:"formatted"},ho={kind:"padding"},an={kind:"colorArray"},go={kind:"numberArray"},vn={kind:"resolvedImage"},bo={kind:"variableAnchorOffsetCollection"};function Ce(t,e){return{kind:"array",itemType:t,N:e}}function ie(t){if(t.kind==="array"){let e=ie(t.itemType);return typeof t.N=="number"?`array<${e}, ${t.N}>`:t.itemType.kind==="value"?"array":`array<${e}>`}else return t.kind}var Sh=[wr,k,$,U,ze,yo,Ar,Wt,Ce(N),ho,go,an,vn,bo];function sn(t,e){if(e.kind==="error")return null;if(t.kind==="array"){if(e.kind==="array"&&(e.N===0&&e.itemType.kind==="value"||!sn(t.itemType,e.itemType))&&(typeof t.N!="number"||t.N===e.N))return null}else{if(t.kind===e.kind)return null;if(t.kind==="value"){for(let r of Sh)if(!sn(r,e))return null}}return`Expected ${ie(t)} but found ${ie(e)} instead.`}function zs(t,e){return e.some(r=>r.kind===t.kind)}function Xt(t,e){return e.some(r=>r==="null"?t===null:r==="array"?Array.isArray(t):r==="object"?t&&!Array.isArray(t)&&typeof t=="object":r===typeof t)}function Pt(t,e){return t.kind==="array"&&e.kind==="array"?t.itemType.kind===e.itemType.kind&&typeof t.N=="number":t.kind===e.kind}var Xu=.96422,Hu=1,Zu=.82521,Ju=4/29,br=6/29,Yu=3*br*br,wh=br*br*br,Ah=Math.PI/180,_h=180/Math.PI;function Ku(t){return t=t%360,t<0&&(t+=360),t}function Qu([t,e,r,n]){t=ps(t),e=ps(e),r=ps(r);let i,o,a=fs((.2225045*t+.7168786*e+.0606169*r)/Hu);t===e&&e===r?i=o=a:(i=fs((.4360747*t+.3850649*e+.1430804*r)/Xu),o=fs((.0139322*t+.0971045*e+.7141733*r)/Zu));let s=116*a-16;return[s<0?0:s,500*(i-a),200*(a-o),n]}function ps(t){return t<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)}function fs(t){return t>wh?Math.pow(t,1/3):t/Yu+Ju}function ec([t,e,r,n]){let i=(t+16)/116,o=isNaN(e)?i:i+e/500,a=isNaN(r)?i:i-r/200;return i=Hu*ms(i),o=Xu*ms(o),a=Zu*ms(a),[ys(3.1338561*o-1.6168667*i-.4906146*a),ys(-.9787684*o+1.9161415*i+.033454*a),ys(.0719453*o-.2289914*i+1.4052427*a),n]}function ys(t){return t=t<=.00304?12.92*t:1.055*Math.pow(t,1/2.4)-.055,t<0?0:t>1?1:t}function ms(t){return t>br?t*t*t:Yu*(t-Ju)}function Ih(t){let[e,r,n,i]=Qu(t),o=Math.sqrt(r*r+n*n);return[Math.round(o*1e4)?Ku(Math.atan2(n,r)*_h):NaN,o,e,i]}function Th([t,e,r,n]){return t=isNaN(t)?0:t*Ah,ec([r,Math.cos(t)*e,Math.sin(t)*e,n])}function Ch([t,e,r,n]){t=Ku(t),e/=100,r/=100;function i(o){let a=(o+t/30)%12,s=e*Math.min(r,1-r);return r-s*Math.max(-1,Math.min(a-3,9-a,1))}return[i(0),i(8),i(4),n]}var kh=Object.hasOwn||function(e,r){return Object.prototype.hasOwnProperty.call(e,r)};function nn(t,e){return kh(t,e)?t[e]:void 0}function Fh(t){if(t=t.toLowerCase().trim(),t==="transparent")return[0,0,0,0];let e=nn(Eh,t);if(e){let[i,o,a]=e;return[i/255,o/255,a/255,1]}if(t.startsWith("#")&&/^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t)){let o=t.length<6?1:2,a=1;return[Zi(t.slice(a,a+=o)),Zi(t.slice(a,a+=o)),Zi(t.slice(a,a+=o)),Zi(t.slice(a,a+o)||"ff")]}if(t.startsWith("rgb")){let i=/^rgba?\\(\\s*([\\de.+-]+)(%)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)(%)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)(%)?(?:\\s*([,\\/])\\s*([\\de.+-]+)(%)?)?\\s*\\)$/,o=t.match(i);if(o){let[a,s,l,u,c,p,f,y,m,h,g,d]=o,x=[u||" ",f||" ",h].join("");if(x==="  "||x==="  /"||x===",,"||x===",,,"){let b=[l,p,m].join(""),v=b==="%%%"?100:b===""?255:0;if(v){let S=[dr(+s/v,0,1),dr(+c/v,0,1),dr(+y/v,0,1),g?Tu(+g,d):1];if(Cu(S))return S}}return}}let r=/^hsla?\\(\\s*([\\de.+-]+)(?:deg)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)%(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)%(?:\\s*([,\\/])\\s*([\\de.+-]+)(%)?)?\\s*\\)$/,n=t.match(r);if(n){let[i,o,a,s,l,u,c,p,f]=n,y=[a||" ",l||" ",c].join("");if(y==="  "||y==="  /"||y===",,"||y===",,,"){let m=[+o,dr(+s,0,100),dr(+u,0,100),p?Tu(+p,f):1];if(Cu(m))return Ch(m)}}}function Zi(t){return parseInt(t.padEnd(2,t),16)/255}function Tu(t,e){return dr(e?t/100:t,0,1)}function dr(t,e,r){return Math.min(Math.max(e,t),r)}function Cu(t){return!t.some(Number.isNaN)}var Eh={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]};function wt(t,e,r){return t+r*(e-t)}function vr(t,e,r){return t.map((n,i)=>wt(n,e[i],r))}function Mh(t){return t==="rgb"||t==="hcl"||t==="lab"}var H=class t{constructor(e,r,n,i=1,o=!0){this.r=e,this.g=r,this.b=n,this.a=i,o||(this.r*=i,this.g*=i,this.b*=i,i||this.overwriteGetter("rgb",[e,r,n,i]))}static parse(e){if(e instanceof t)return e;if(typeof e!="string")return;let r=Fh(e);if(r)return new t(...r,!1)}get rgb(){let{r:e,g:r,b:n,a:i}=this,o=i||1/0;return this.overwriteGetter("rgb",[e/o,r/o,n/o,i])}get hcl(){return this.overwriteGetter("hcl",Ih(this.rgb))}get lab(){return this.overwriteGetter("lab",Qu(this.rgb))}overwriteGetter(e,r){return Object.defineProperty(this,e,{value:r}),r}toString(){let[e,r,n,i]=this.rgb;return`rgba(${[e,r,n].map(o=>Math.round(o*255)).join(",")},${i})`}static interpolate(e,r,n,i="rgb"){switch(i){case"rgb":{let[o,a,s,l]=vr(e.rgb,r.rgb,n);return new t(o,a,s,l,!1)}case"hcl":{let[o,a,s,l]=e.hcl,[u,c,p,f]=r.hcl,y,m;if(!isNaN(o)&&!isNaN(u)){let b=u-o;u>o&&b>180?b-=360:u<o&&o-u>180&&(b+=360),y=o+n*b}else isNaN(o)?isNaN(u)?y=NaN:(y=u,(s===1||s===0)&&(m=c)):(y=o,(p===1||p===0)&&(m=a));let[h,g,d,x]=Th([y,m??wt(a,c,n),wt(s,p,n),wt(l,f,n)]);return new t(h,g,d,x,!1)}case"lab":{let[o,a,s,l]=ec(vr(e.lab,r.lab,n));return new t(o,a,s,l,!1)}}}};H.black=new H(0,0,0,1);H.white=new H(1,1,1,1);H.transparent=new H(0,0,0,0);H.red=new H(1,0,0,1);var ln=class{constructor(e,r,n){e?this.sensitivity=r?"variant":"case":this.sensitivity=r?"accent":"base",this.locale=n,this.collator=new Intl.Collator(this.locale?this.locale:[],{sensitivity:this.sensitivity,usage:"search"})}compare(e,r){return this.collator.compare(e,r)}resolvedLocale(){return new Intl.Collator(this.locale?this.locale:[]).resolvedOptions().locale}},Lh=["bottom","center","top"],un=class{constructor(e,r,n,i,o,a){this.text=e,this.image=r,this.scale=n,this.fontStack=i,this.textColor=o,this.verticalAlign=a}},Fe=class t{constructor(e){this.sections=e}static fromString(e){return new t([new un(e,null,null,null,null,null)])}isEmpty(){return this.sections.length===0?!0:!this.sections.some(e=>e.text.length!==0||e.image&&e.image.name.length!==0)}static factory(e){return e instanceof t?e:t.fromString(e)}toString(){return this.sections.length===0?"":this.sections.map(e=>e.text).join("")}},Oe=class t{constructor(e){this.values=e.slice()}static parse(e){if(e instanceof t)return e;if(typeof e=="number")return new t([e,e,e,e]);if(Array.isArray(e)&&!(e.length<1||e.length>4)){for(let r of e)if(typeof r!="number")return;switch(e.length){case 1:e=[e[0],e[0],e[0],e[0]];break;case 2:e=[e[0],e[1],e[0],e[1]];break;case 3:e=[e[0],e[1],e[2],e[1]];break}return new t(e)}}toString(){return JSON.stringify(this.values)}static interpolate(e,r,n){return new t(vr(e.values,r.values,n))}},Ge=class t{constructor(e){this.values=e.slice()}static parse(e){if(e instanceof t)return e;if(typeof e=="number")return new t([e]);if(Array.isArray(e)){for(let r of e)if(typeof r!="number")return;return new t(e)}}toString(){return JSON.stringify(this.values)}static interpolate(e,r,n){return new t(vr(e.values,r.values,n))}},Pe=class t{constructor(e){this.values=e.slice()}static parse(e){if(e instanceof t)return e;if(typeof e=="string"){let n=H.parse(e);return n?new t([n]):void 0}if(!Array.isArray(e))return;let r=[];for(let n of e){if(typeof n!="string")return;let i=H.parse(n);if(!i)return;r.push(i)}return new t(r)}toString(){return JSON.stringify(this.values)}static interpolate(e,r,n,i="rgb"){let o=[];if(e.values.length!=r.values.length)throw new Error(`colorArray: Arrays have mismatched length (${e.values.length} vs. ${r.values.length}), cannot interpolate.`);for(let a=0;a<e.values.length;a++)o.push(H.interpolate(e.values[a],r.values[a],n,i));return new t(o)}},ne=class extends Error{constructor(e){super(e),this.name="RuntimeError"}toJSON(){return this.message}},Dh=new Set(["center","left","right","top","bottom","top-left","top-right","bottom-left","bottom-right"]),Ee=class t{constructor(e){this.values=e.slice()}static parse(e){if(e instanceof t)return e;if(!(!Array.isArray(e)||e.length<1||e.length%2!==0)){for(let r=0;r<e.length;r+=2){let n=e[r],i=e[r+1];if(typeof n!="string"||!Dh.has(n)||!Array.isArray(i)||i.length!==2||typeof i[0]!="number"||typeof i[1]!="number")return}return new t(e)}}toString(){return JSON.stringify(this.values)}static interpolate(e,r,n){let i=e.values,o=r.values;if(i.length!==o.length)throw new ne(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${r.toString()}`);let a=[];for(let s=0;s<i.length;s+=2){if(i[s]!==o[s])throw new ne(`Cannot interpolate values containing mismatched anchors. from[${s}]: ${i[s]}, to[${s}]: ${o[s]}`);a.push(i[s]);let[l,u]=i[s+1],[c,p]=o[s+1];a.push([wt(l,c,n),wt(u,p,n)])}return new t(a)}},Se=class t{constructor(e){this.name=e.name,this.available=e.available}toString(){return this.name}static fromString(e){return e?new t({name:e,available:!1}):null}},At=class t{constructor(e,r,n){this.from=e,this.to=r,this.transition=n}static interpolate(e,r,n){return new t(e,r,n)}static parse(e){if(e instanceof t)return e;if(Array.isArray(e)&&e.length===3&&typeof e[0]=="string"&&typeof e[1]=="string"&&typeof e[2]=="number")return new t(e[0],e[1],e[2]);if(typeof e=="object"&&typeof e.from=="string"&&typeof e.to=="string"&&typeof e.transition=="number")return new t(e.from,e.to,e.transition);if(typeof e=="string")return new t(e,e,1)}};function tc(t,e,r,n){return typeof t=="number"&&t>=0&&t<=255&&typeof e=="number"&&e>=0&&e<=255&&typeof r=="number"&&r>=0&&r<=255?typeof n>"u"||typeof n=="number"&&n>=0&&n<=1?null:`Invalid rgba value [${[t,e,r,n].join(", ")}]: \'a\' must be between 0 and 1.`:`Invalid rgba value [${(typeof n=="number"?[t,e,r,n]:[t,e,r]).join(", ")}]: \'r\', \'g\', and \'b\' must be between 0 and 255.`}function cn(t){if(t===null||typeof t=="string"||typeof t=="boolean"||typeof t=="number"||t instanceof At||t instanceof H||t instanceof ln||t instanceof Fe||t instanceof Oe||t instanceof Ge||t instanceof Pe||t instanceof Ee||t instanceof Se)return!0;if(Array.isArray(t)){for(let e of t)if(!cn(e))return!1;return!0}else if(typeof t=="object"){for(let e in t)if(!cn(t[e]))return!1;return!0}else return!1}function ue(t){if(t===null)return wr;if(typeof t=="string")return $;if(typeof t=="boolean")return U;if(typeof t=="number")return k;if(t instanceof H)return ze;if(t instanceof At)return yo;if(t instanceof ln)return mo;if(t instanceof Fe)return Ar;if(t instanceof Oe)return ho;if(t instanceof Ge)return go;if(t instanceof Pe)return an;if(t instanceof Ee)return bo;if(t instanceof Se)return vn;if(Array.isArray(t)){let e=t.length,r;for(let n of t){let i=ue(n);if(!r)r=i;else{if(r===i)continue;r=N;break}}return Ce(r||N,e)}else return Wt}function on(t){let e=typeof t;return t===null?"":e==="string"||e==="number"||e==="boolean"?String(t):t instanceof H||t instanceof At||t instanceof Fe||t instanceof Oe||t instanceof Ge||t instanceof Pe||t instanceof Ee||t instanceof Se?t.toString():JSON.stringify(t)}var _t=class t{constructor(e,r){this.type=e,this.value=r}static parse(e,r){if(e.length!==2)return r.error(`\'literal\' expression requires exactly one argument, but found ${e.length-1} instead.`);if(!cn(e[1]))return r.error("invalid value");let n=e[1],i=ue(n),o=r.expectedType;return i.kind==="array"&&i.N===0&&o&&o.kind==="array"&&(typeof o.N!="number"||o.N===0)&&(i=o),new t(i,n)}evaluate(){return this.value}eachChild(){}outputDefined(){return!0}},Ji={string:$,number:k,boolean:U,object:Wt},$e=class t{constructor(e,r){this.type=e,this.args=r}static parse(e,r){if(e.length<2)return r.error("Expected at least one argument.");let n=1,i,o=e[0];if(o==="array"){let s;if(e.length>2){let u=e[1];if(typeof u!="string"||!(u in Ji)||u==="object")return r.error(\'The item type argument of "array" must be one of string, number, boolean\',1);s=Ji[u],n++}else s=N;let l;if(e.length>3){if(e[2]!==null&&(typeof e[2]!="number"||e[2]<0||e[2]!==Math.floor(e[2])))return r.error(\'The length argument to "array" must be a positive integer literal\',2);l=e[2],n++}i=Ce(s,l)}else{if(!Ji[o])throw new Error(`Types doesn\'t contain name = ${o}`);i=Ji[o]}let a=[];for(;n<e.length;n++){let s=r.parse(e[n],n,N);if(!s)return null;a.push(s)}return new t(i,a)}evaluate(e){for(let r=0;r<this.args.length;r++){let n=this.args[r].evaluate(e);if(sn(this.type,ue(n))){if(r===this.args.length-1)throw new ne(`Expected value to be of type ${ie(this.type)}, but found ${ie(ue(n))} instead.`)}else return n}throw new Error}eachChild(e){this.args.forEach(e)}outputDefined(){return this.args.every(e=>e.outputDefined())}},ku={"to-boolean":U,"to-color":ze,"to-number":k,"to-string":$},St=class t{constructor(e,r){this.type=e,this.args=r}static parse(e,r){if(e.length<2)return r.error("Expected at least one argument.");let n=e[0];if(!ku[n])throw new Error(`Can\'t parse ${n} as it is not part of the known types`);if((n==="to-boolean"||n==="to-string")&&e.length!==2)return r.error("Expected one argument.");let i=ku[n],o=[];for(let a=1;a<e.length;a++){let s=r.parse(e[a],a,N);if(!s)return null;o.push(s)}return new t(i,o)}evaluate(e){switch(this.type.kind){case"boolean":return!!this.args[0].evaluate(e);case"color":{let r,n;for(let i of this.args){if(r=i.evaluate(e),n=null,r instanceof H)return r;if(typeof r=="string"){let o=e.parseColor(r);if(o)return o}else if(Array.isArray(r)&&(r.length<3||r.length>4?n=`Invalid rgba value ${JSON.stringify(r)}: expected an array containing either three or four numeric values.`:n=tc(r[0],r[1],r[2],r[3]),!n))return new H(r[0]/255,r[1]/255,r[2]/255,r[3])}throw new ne(n||`Could not parse color from value \'${typeof r=="string"?r:JSON.stringify(r)}\'`)}case"padding":{let r;for(let n of this.args){r=n.evaluate(e);let i=Oe.parse(r);if(i)return i}throw new ne(`Could not parse padding from value \'${typeof r=="string"?r:JSON.stringify(r)}\'`)}case"numberArray":{let r;for(let n of this.args){r=n.evaluate(e);let i=Ge.parse(r);if(i)return i}throw new ne(`Could not parse numberArray from value \'${typeof r=="string"?r:JSON.stringify(r)}\'`)}case"colorArray":{let r;for(let n of this.args){r=n.evaluate(e);let i=Pe.parse(r);if(i)return i}throw new ne(`Could not parse colorArray from value \'${typeof r=="string"?r:JSON.stringify(r)}\'`)}case"variableAnchorOffsetCollection":{let r;for(let n of this.args){r=n.evaluate(e);let i=Ee.parse(r);if(i)return i}throw new ne(`Could not parse variableAnchorOffsetCollection from value \'${typeof r=="string"?r:JSON.stringify(r)}\'`)}case"number":{let r=null;for(let n of this.args){if(r=n.evaluate(e),r===null)return 0;let i=Number(r);if(!isNaN(i))return i}throw new ne(`Could not convert ${JSON.stringify(r)} to number.`)}case"formatted":return Fe.fromString(on(this.args[0].evaluate(e)));case"resolvedImage":return Se.fromString(on(this.args[0].evaluate(e)));case"projectionDefinition":return this.args[0].evaluate(e);default:return on(this.args[0].evaluate(e))}}eachChild(e){this.args.forEach(e)}outputDefined(){return this.args.every(e=>e.outputDefined())}},Bh=["Unknown","Point","LineString","Polygon"],eo=class{constructor(){this.globals=null,this.feature=null,this.featureState=null,this.formattedSection=null,this._parseColorCache=new Map,this.availableImages=null,this.canonical=null}id(){return this.feature&&"id"in this.feature?this.feature.id:null}geometryType(){return this.feature?typeof this.feature.type=="number"?Bh[this.feature.type]:this.feature.type:null}geometry(){return this.feature&&"geometry"in this.feature?this.feature.geometry:null}canonicalID(){return this.canonical}properties(){return this.feature&&this.feature.properties||{}}parseColor(e){let r=this._parseColorCache.get(e);return r||(r=H.parse(e),this._parseColorCache.set(e,r)),r}},to=class t{constructor(e,r,n=[],i,o=new vs,a=[]){this.registry=e,this.path=n,this.key=n.map(s=>`[${s}]`).join(""),this.scope=o,this.errors=a,this.expectedType=i,this._isConstant=r}parse(e,r,n,i,o={}){return r?this.concat(r,n,i)._parse(e,o):this._parse(e,o)}_parse(e,r){(e===null||typeof e=="string"||typeof e=="boolean"||typeof e=="number")&&(e=["literal",e]);function n(i,o,a){return a==="assert"?new $e(o,[i]):a==="coerce"?new St(o,[i]):i}if(Array.isArray(e)){if(e.length===0)return this.error(\'Expected an array with at least one element. If you wanted a literal array, use ["literal", []].\');let i=e[0];if(typeof i!="string")return this.error(`Expression name must be a string, but found ${typeof i} instead. If you wanted a literal array, use ["literal", [...]].`,0),null;let o=this.registry[i];if(o){let a=o.parse(e,this);if(!a)return null;if(this.expectedType){let s=this.expectedType,l=a.type;if((s.kind==="string"||s.kind==="number"||s.kind==="boolean"||s.kind==="object"||s.kind==="array")&&l.kind==="value")a=n(a,s,r.typeAnnotation||"assert");else if(s.kind==="projectionDefinition"&&["string","array"].includes(l.kind)||["color","formatted","resolvedImage"].includes(s.kind)&&["value","string"].includes(l.kind)||["padding","numberArray"].includes(s.kind)&&["value","number","array"].includes(l.kind)||s.kind==="colorArray"&&["value","string","array"].includes(l.kind)||s.kind==="variableAnchorOffsetCollection"&&["value","array"].includes(l.kind))a=n(a,s,r.typeAnnotation||"coerce");else if(this.checkSubtype(s,l))return null}if(!(a instanceof _t)&&a.type.kind!=="resolvedImage"&&this._isConstant(a)){let s=new eo;try{a=new _t(a.type,a.evaluate(s))}catch(l){return this.error(l.message),null}}return a}return this.error(`Unknown expression "${i}". If you wanted a literal array, use ["literal", [...]].`,0)}else return typeof e>"u"?this.error("\'undefined\' value invalid. Use null instead."):typeof e=="object"?this.error(\'Bare objects invalid. Use ["literal", {...}] instead.\'):this.error(`Expected an array, but found ${typeof e} instead.`)}concat(e,r,n){let i=typeof e=="number"?this.path.concat(e):this.path,o=n?this.scope.concat(n):this.scope;return new t(this.registry,this._isConstant,i,r||null,o,this.errors)}error(e,...r){let n=`${this.key}${r.map(i=>`[${i}]`).join("")}`;this.errors.push(new Ve(n,e))}checkSubtype(e,r){let n=sn(e,r);return n&&this.error(n),n}},ro=class t{constructor(e,r){this.type=r.type,this.bindings=[].concat(e),this.result=r}evaluate(e){return this.result.evaluate(e)}eachChild(e){for(let r of this.bindings)e(r[1]);e(this.result)}static parse(e,r){if(e.length<4)return r.error(`Expected at least 3 arguments, but found ${e.length-1} instead.`);let n=[];for(let o=1;o<e.length-1;o+=2){let a=e[o];if(typeof a!="string")return r.error(`Expected string, but found ${typeof a} instead.`,o);if(/[^a-zA-Z0-9_]/.test(a))return r.error("Variable names must contain only alphanumeric characters or \'_\'.",o);let s=r.parse(e[o+1],o+1);if(!s)return null;n.push([a,s])}let i=r.parse(e[e.length-1],e.length-1,r.expectedType,n);return i?new t(n,i):null}outputDefined(){return this.result.outputDefined()}},no=class t{constructor(e,r){this.type=r.type,this.name=e,this.boundExpression=r}static parse(e,r){if(e.length!==2||typeof e[1]!="string")return r.error("\'var\' expression requires exactly one string literal argument.");let n=e[1];return r.scope.has(n)?new t(n,r.scope.get(n)):r.error(`Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`,1)}evaluate(e){return this.boundExpression.evaluate(e)}eachChild(){}outputDefined(){return!1}},Ps=class t{constructor(e,r,n){this.type=e,this.index=r,this.input=n}static parse(e,r){if(e.length!==3)return r.error(`Expected 2 arguments, but found ${e.length-1} instead.`);let n=r.parse(e[1],1,k),i=r.parse(e[2],2,Ce(r.expectedType||N));if(!n||!i)return null;let o=i.type;return new t(o.itemType,n,i)}evaluate(e){let r=this.index.evaluate(e),n=this.input.evaluate(e);if(r<0)throw new ne(`Array index out of bounds: ${r} < 0.`);if(r>=n.length)throw new ne(`Array index out of bounds: ${r} > ${n.length-1}.`);if(r!==Math.floor(r))throw new ne(`Array index must be an integer, but found ${r} instead.`);return n[r]}eachChild(e){e(this.index),e(this.input)}outputDefined(){return!1}},Ss=class t{constructor(e,r){this.type=U,this.needle=e,this.haystack=r}static parse(e,r){if(e.length!==3)return r.error(`Expected 2 arguments, but found ${e.length-1} instead.`);let n=r.parse(e[1],1,N),i=r.parse(e[2],2,N);return!n||!i?null:zs(n.type,[U,$,k,wr,N])?new t(n,i):r.error(`Expected first argument to be of type boolean, string, number or null, but found ${ie(n.type)} instead`)}evaluate(e){let r=this.needle.evaluate(e),n=this.haystack.evaluate(e);if(!n)return!1;if(!Xt(r,["boolean","string","number","null"]))throw new ne(`Expected first argument to be of type boolean, string, number or null, but found ${ie(ue(r))} instead.`);if(!Xt(n,["string","array"]))throw new ne(`Expected second argument to be of type array or string, but found ${ie(ue(n))} instead.`);return n.indexOf(r)>=0}eachChild(e){e(this.needle),e(this.haystack)}outputDefined(){return!0}},ws=class t{constructor(e,r,n){this.type=k,this.needle=e,this.haystack=r,this.fromIndex=n}static parse(e,r){if(e.length<=2||e.length>=5)return r.error(`Expected 3 or 4 arguments, but found ${e.length-1} instead.`);let n=r.parse(e[1],1,N),i=r.parse(e[2],2,N);if(!n||!i)return null;if(!zs(n.type,[U,$,k,wr,N]))return r.error(`Expected first argument to be of type boolean, string, number or null, but found ${ie(n.type)} instead`);if(e.length===4){let o=r.parse(e[3],3,k);return o?new t(n,i,o):null}else return new t(n,i)}evaluate(e){let r=this.needle.evaluate(e),n=this.haystack.evaluate(e);if(!Xt(r,["boolean","string","number","null"]))throw new ne(`Expected first argument to be of type boolean, string, number or null, but found ${ie(ue(r))} instead.`);let i;if(this.fromIndex&&(i=this.fromIndex.evaluate(e)),Xt(n,["string"])){let o=n.indexOf(r,i);return o===-1?-1:[...n.slice(0,o)].length}else{if(Xt(n,["array"]))return n.indexOf(r,i);throw new ne(`Expected second argument to be of type array or string, but found ${ie(ue(n))} instead.`)}}eachChild(e){e(this.needle),e(this.haystack),this.fromIndex&&e(this.fromIndex)}outputDefined(){return!1}},As=class t{constructor(e,r,n,i,o,a){this.inputType=e,this.type=r,this.input=n,this.cases=i,this.outputs=o,this.otherwise=a}static parse(e,r){if(e.length<5)return r.error(`Expected at least 4 arguments, but found only ${e.length-1}.`);if(e.length%2!==1)return r.error("Expected an even number of arguments.");let n,i;r.expectedType&&r.expectedType.kind!=="value"&&(i=r.expectedType);let o={},a=[];for(let u=2;u<e.length-1;u+=2){let c=e[u],p=e[u+1];Array.isArray(c)||(c=[c]);let f=r.concat(u);if(c.length===0)return f.error("Expected at least one branch label.");for(let m of c){if(typeof m!="number"&&typeof m!="string")return f.error("Branch labels must be numbers or strings.");if(typeof m=="number"&&Math.abs(m)>Number.MAX_SAFE_INTEGER)return f.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);if(typeof m=="number"&&Math.floor(m)!==m)return f.error("Numeric branch labels must be integer values.");if(!n)n=ue(m);else if(f.checkSubtype(n,ue(m)))return null;if(typeof o[String(m)]<"u")return f.error("Branch labels must be unique.");o[String(m)]=a.length}let y=r.parse(p,u,i);if(!y)return null;i=i||y.type,a.push(y)}let s=r.parse(e[1],1,N);if(!s)return null;let l=r.parse(e[e.length-1],e.length-1,i);return!l||s.type.kind!=="value"&&r.concat(1).checkSubtype(n,s.type)?null:new t(n,i,s,o,a,l)}evaluate(e){let r=this.input.evaluate(e);return(ue(r)===this.inputType&&this.outputs[this.cases[r]]||this.otherwise).evaluate(e)}eachChild(e){e(this.input),this.outputs.forEach(e),e(this.otherwise)}outputDefined(){return this.outputs.every(e=>e.outputDefined())&&this.otherwise.outputDefined()}},_s=class t{constructor(e,r,n){this.type=e,this.branches=r,this.otherwise=n}static parse(e,r){if(e.length<4)return r.error(`Expected at least 3 arguments, but found only ${e.length-1}.`);if(e.length%2!==0)return r.error("Expected an odd number of arguments.");let n;r.expectedType&&r.expectedType.kind!=="value"&&(n=r.expectedType);let i=[];for(let a=1;a<e.length-1;a+=2){let s=r.parse(e[a],a,U);if(!s)return null;let l=r.parse(e[a+1],a+1,n);if(!l)return null;i.push([s,l]),n=n||l.type}let o=r.parse(e[e.length-1],e.length-1,n);if(!o)return null;if(!n)throw new Error("Can\'t infer output type");return new t(n,i,o)}evaluate(e){for(let[r,n]of this.branches)if(r.evaluate(e))return n.evaluate(e);return this.otherwise.evaluate(e)}eachChild(e){for(let[r,n]of this.branches)e(r),e(n);e(this.otherwise)}outputDefined(){return this.branches.every(([e,r])=>r.outputDefined())&&this.otherwise.outputDefined()}},Is=class t{constructor(e,r,n,i){this.type=e,this.input=r,this.beginIndex=n,this.endIndex=i}static parse(e,r){if(e.length<=2||e.length>=5)return r.error(`Expected 3 or 4 arguments, but found ${e.length-1} instead.`);let n=r.parse(e[1],1,N),i=r.parse(e[2],2,k);if(!n||!i)return null;if(!zs(n.type,[Ce(N),$,N]))return r.error(`Expected first argument to be of type array or string, but found ${ie(n.type)} instead`);if(e.length===4){let o=r.parse(e[3],3,k);return o?new t(n.type,n,i,o):null}else return new t(n.type,n,i)}evaluate(e){let r=this.input.evaluate(e),n=this.beginIndex.evaluate(e),i;if(this.endIndex&&(i=this.endIndex.evaluate(e)),Xt(r,["string"]))return[...r].slice(n,i).join("");if(Xt(r,["array"]))return r.slice(n,i);throw new ne(`Expected first argument to be of type array or string, but found ${ie(ue(r))} instead.`)}eachChild(e){e(this.input),e(this.beginIndex),this.endIndex&&e(this.endIndex)}outputDefined(){return!1}};function xo(t,e){let r=t.length-1,n=0,i=r,o=0,a,s;for(;n<=i;)if(o=Math.floor((n+i)/2),a=t[o],s=t[o+1],a<=e){if(o===r||e<s)return o;n=o+1}else if(a>e)i=o-1;else throw new ne("Input is not a number.");return 0}var Pr=class t{constructor(e,r,n){this.type=e,this.input=r,this.labels=[],this.outputs=[];for(let[i,o]of n)this.labels.push(i),this.outputs.push(o)}static parse(e,r){if(e.length-1<4)return r.error(`Expected at least 4 arguments, but found only ${e.length-1}.`);if((e.length-1)%2!==0)return r.error("Expected an even number of arguments.");let n=r.parse(e[1],1,k);if(!n)return null;let i=[],o=null;r.expectedType&&r.expectedType.kind!=="value"&&(o=r.expectedType);for(let a=1;a<e.length;a+=2){let s=a===1?-1/0:e[a],l=e[a+1],u=a,c=a+1;if(typeof s!="number")return r.error(\'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.\',u);if(i.length&&i[i.length-1][0]>=s)return r.error(\'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.\',u);let p=r.parse(l,c,o);if(!p)return null;o=o||p.type,i.push([s,p])}return new t(o,n,i)}evaluate(e){let r=this.labels,n=this.outputs;if(r.length===1)return n[0].evaluate(e);let i=this.input.evaluate(e);if(i<=r[0])return n[0].evaluate(e);let o=r.length;if(i>=r[o-1])return n[o-1].evaluate(e);let a=xo(r,i);return n[a].evaluate(e)}eachChild(e){e(this.input);for(let r of this.outputs)e(r)}outputDefined(){return this.outputs.every(e=>e.outputDefined())}};function Vh(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var hs,Fu;function Rh(){if(Fu)return hs;Fu=1,hs=t;function t(e,r,n,i){this.cx=3*e,this.bx=3*(n-e)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*r,this.by=3*(i-r)-this.cy,this.ay=1-this.cy-this.by,this.p1x=e,this.p1y=r,this.p2x=n,this.p2y=i}return t.prototype={sampleCurveX:function(e){return((this.ax*e+this.bx)*e+this.cx)*e},sampleCurveY:function(e){return((this.ay*e+this.by)*e+this.cy)*e},sampleCurveDerivativeX:function(e){return(3*this.ax*e+2*this.bx)*e+this.cx},solveCurveX:function(e,r){if(r===void 0&&(r=1e-6),e<0)return 0;if(e>1)return 1;for(var n=e,i=0;i<8;i++){var o=this.sampleCurveX(n)-e;if(Math.abs(o)<r)return n;var a=this.sampleCurveDerivativeX(n);if(Math.abs(a)<1e-6)break;n=n-o/a}var s=0,l=1;for(n=e,i=0;i<20&&(o=this.sampleCurveX(n),!(Math.abs(o-e)<r));i++)e>o?s=n:l=n,n=(l-s)*.5+s;return n},solve:function(e,r){return this.sampleCurveY(this.solveCurveX(e,r))}},hs}var zh=Rh(),Oh=Vh(zh),ke=class t{constructor(e,r,n,i,o){this.type=e,this.operator=r,this.interpolation=n,this.input=i,this.labels=[],this.outputs=[];for(let[a,s]of o)this.labels.push(a),this.outputs.push(s)}static interpolationFactor(e,r,n,i){let o=0;if(e.name==="exponential")o=ds(r,e.base,n,i);else if(e.name==="linear")o=ds(r,1,n,i);else if(e.name==="cubic-bezier"){let a=e.controlPoints;o=new Oh(a[0],a[1],a[2],a[3]).solve(ds(r,1,n,i))}return o}static parse(e,r){let[n,i,o,...a]=e;if(!Array.isArray(i)||i.length===0)return r.error("Expected an interpolation type expression.",1);if(i[0]==="linear")i={name:"linear"};else if(i[0]==="exponential"){let u=i[1];if(typeof u!="number")return r.error("Exponential interpolation requires a numeric base.",1,1);i={name:"exponential",base:u}}else if(i[0]==="cubic-bezier"){let u=i.slice(1);if(u.length!==4||u.some(c=>typeof c!="number"||c<0||c>1))return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",1);i={name:"cubic-bezier",controlPoints:u}}else return r.error(`Unknown interpolation type ${String(i[0])}`,1,0);if(e.length-1<4)return r.error(`Expected at least 4 arguments, but found only ${e.length-1}.`);if((e.length-1)%2!==0)return r.error("Expected an even number of arguments.");if(o=r.parse(o,2,k),!o)return null;let s=[],l=null;(n==="interpolate-hcl"||n==="interpolate-lab")&&r.expectedType!=an?l=ze:r.expectedType&&r.expectedType.kind!=="value"&&(l=r.expectedType);for(let u=0;u<a.length;u+=2){let c=a[u],p=a[u+1],f=u+3,y=u+4;if(typeof c!="number")return r.error(\'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.\',f);if(s.length&&s[s.length-1][0]>=c)return r.error(\'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.\',f);let m=r.parse(p,y,l);if(!m)return null;l=l||m.type,s.push([c,m])}return!Pt(l,k)&&!Pt(l,yo)&&!Pt(l,ze)&&!Pt(l,ho)&&!Pt(l,go)&&!Pt(l,an)&&!Pt(l,bo)&&!Pt(l,Ce(k))?r.error(`Type ${ie(l)} is not interpolatable.`):new t(l,n,i,o,s)}evaluate(e){let r=this.labels,n=this.outputs;if(r.length===1)return n[0].evaluate(e);let i=this.input.evaluate(e);if(i<=r[0])return n[0].evaluate(e);let o=r.length;if(i>=r[o-1])return n[o-1].evaluate(e);let a=xo(r,i),s=r[a],l=r[a+1],u=t.interpolationFactor(this.interpolation,i,s,l),c=n[a].evaluate(e),p=n[a+1].evaluate(e);switch(this.operator){case"interpolate":switch(this.type.kind){case"number":return wt(c,p,u);case"color":return H.interpolate(c,p,u);case"padding":return Oe.interpolate(c,p,u);case"colorArray":return Pe.interpolate(c,p,u);case"numberArray":return Ge.interpolate(c,p,u);case"variableAnchorOffsetCollection":return Ee.interpolate(c,p,u);case"array":return vr(c,p,u);case"projectionDefinition":return At.interpolate(c,p,u)}case"interpolate-hcl":switch(this.type.kind){case"color":return H.interpolate(c,p,u,"hcl");case"colorArray":return Pe.interpolate(c,p,u,"hcl")}case"interpolate-lab":switch(this.type.kind){case"color":return H.interpolate(c,p,u,"lab");case"colorArray":return Pe.interpolate(c,p,u,"lab")}}}eachChild(e){e(this.input);for(let r of this.outputs)e(r)}outputDefined(){return this.outputs.every(e=>e.outputDefined())}};function ds(t,e,r,n){let i=n-r,o=t-r;return i===0?0:e===1?o/i:(Math.pow(e,o)-1)/(Math.pow(e,i)-1)}var lt={color:H.interpolate,number:wt,padding:Oe.interpolate,numberArray:Ge.interpolate,colorArray:Pe.interpolate,variableAnchorOffsetCollection:Ee.interpolate,array:vr},io=class t{constructor(e,r){this.type=e,this.args=r}static parse(e,r){if(e.length<2)return r.error("Expected at least one argument.");let n=null,i=r.expectedType;i&&i.kind!=="value"&&(n=i);let o=[];for(let s of e.slice(1)){let l=r.parse(s,1+o.length,n,void 0,{typeAnnotation:"omit"});if(!l)return null;n=n||l.type,o.push(l)}if(!n)throw new Error("No output type");return i&&o.some(s=>sn(i,s.type))?new t(N,o):new t(n,o)}evaluate(e){let r=null,n=0,i;for(let o of this.args)if(n++,r=o.evaluate(e),r&&r instanceof Se&&!r.available&&(i||(i=r.name),r=null,n===this.args.length&&(r=i)),r!==null)break;return r}eachChild(e){this.args.forEach(e)}outputDefined(){return this.args.every(e=>e.outputDefined())}};function Eu(t,e){return t==="=="||t==="!="?e.kind==="boolean"||e.kind==="string"||e.kind==="number"||e.kind==="null"||e.kind==="value":e.kind==="string"||e.kind==="number"||e.kind==="value"}function Gh(t,e,r){return e===r}function Nh(t,e,r){return e!==r}function Uh(t,e,r){return e<r}function $h(t,e,r){return e>r}function jh(t,e,r){return e<=r}function qh(t,e,r){return e>=r}function rc(t,e,r,n){return n.compare(e,r)===0}function Wh(t,e,r,n){return!rc(t,e,r,n)}function Xh(t,e,r,n){return n.compare(e,r)<0}function Hh(t,e,r,n){return n.compare(e,r)>0}function Zh(t,e,r,n){return n.compare(e,r)<=0}function Jh(t,e,r,n){return n.compare(e,r)>=0}function _r(t,e,r){let n=t!=="=="&&t!=="!=";return class nc{constructor(o,a,s){this.type=U,this.lhs=o,this.rhs=a,this.collator=s,this.hasUntypedArgument=o.type.kind==="value"||a.type.kind==="value"}static parse(o,a){if(o.length!==3&&o.length!==4)return a.error("Expected two or three arguments.");let s=o[0],l=a.parse(o[1],1,N);if(!l)return null;if(!Eu(s,l.type))return a.concat(1).error(`"${s}" comparisons are not supported for type \'${ie(l.type)}\'.`);let u=a.parse(o[2],2,N);if(!u)return null;if(!Eu(s,u.type))return a.concat(2).error(`"${s}" comparisons are not supported for type \'${ie(u.type)}\'.`);if(l.type.kind!==u.type.kind&&l.type.kind!=="value"&&u.type.kind!=="value")return a.error(`Cannot compare types \'${ie(l.type)}\' and \'${ie(u.type)}\'.`);n&&(l.type.kind==="value"&&u.type.kind!=="value"?l=new $e(u.type,[l]):l.type.kind!=="value"&&u.type.kind==="value"&&(u=new $e(l.type,[u])));let c=null;if(o.length===4){if(l.type.kind!=="string"&&u.type.kind!=="string"&&l.type.kind!=="value"&&u.type.kind!=="value")return a.error("Cannot use collator to compare non-string types.");if(c=a.parse(o[3],3,mo),!c)return null}return new nc(l,u,c)}evaluate(o){let a=this.lhs.evaluate(o),s=this.rhs.evaluate(o);if(n&&this.hasUntypedArgument){let l=ue(a),u=ue(s);if(l.kind!==u.kind||!(l.kind==="string"||l.kind==="number"))throw new ne(`Expected arguments for "${t}" to be (string, string) or (number, number), but found (${l.kind}, ${u.kind}) instead.`)}if(this.collator&&!n&&this.hasUntypedArgument){let l=ue(a),u=ue(s);if(l.kind!=="string"||u.kind!=="string")return e(o,a,s)}return this.collator?r(o,a,s,this.collator.evaluate(o)):e(o,a,s)}eachChild(o){o(this.lhs),o(this.rhs),this.collator&&o(this.collator)}outputDefined(){return!0}}}var Yh=_r("==",Gh,rc),Kh=_r("!=",Nh,Wh),Qh=_r("<",Uh,Xh),ed=_r(">",$h,Hh),td=_r("<=",jh,Zh),rd=_r(">=",qh,Jh),oo=class t{constructor(e,r,n){this.type=mo,this.locale=n,this.caseSensitive=e,this.diacriticSensitive=r}static parse(e,r){if(e.length!==2)return r.error("Expected one argument.");let n=e[1];if(typeof n!="object"||Array.isArray(n))return r.error("Collator options argument must be an object.");let i=r.parse(n["case-sensitive"]===void 0?!1:n["case-sensitive"],1,U);if(!i)return null;let o=r.parse(n["diacritic-sensitive"]===void 0?!1:n["diacritic-sensitive"],1,U);if(!o)return null;let a=null;return n.locale&&(a=r.parse(n.locale,1,$),!a)?null:new t(i,o,a)}evaluate(e){return new ln(this.caseSensitive.evaluate(e),this.diacriticSensitive.evaluate(e),this.locale?this.locale.evaluate(e):null)}eachChild(e){e(this.caseSensitive),e(this.diacriticSensitive),this.locale&&e(this.locale)}outputDefined(){return!1}},Ts=class t{constructor(e,r,n,i,o){this.type=$,this.number=e,this.locale=r,this.currency=n,this.minFractionDigits=i,this.maxFractionDigits=o}static parse(e,r){if(e.length!==3)return r.error("Expected two arguments.");let n=r.parse(e[1],1,k);if(!n)return null;let i=e[2];if(typeof i!="object"||Array.isArray(i))return r.error("NumberFormat options argument must be an object.");let o=null;if(i.locale&&(o=r.parse(i.locale,1,$),!o))return null;let a=null;if(i.currency&&(a=r.parse(i.currency,1,$),!a))return null;let s=null;if(i["min-fraction-digits"]&&(s=r.parse(i["min-fraction-digits"],1,k),!s))return null;let l=null;return i["max-fraction-digits"]&&(l=r.parse(i["max-fraction-digits"],1,k),!l)?null:new t(n,o,a,s,l)}evaluate(e){return new Intl.NumberFormat(this.locale?this.locale.evaluate(e):[],{style:this.currency?"currency":"decimal",currency:this.currency?this.currency.evaluate(e):void 0,minimumFractionDigits:this.minFractionDigits?this.minFractionDigits.evaluate(e):void 0,maximumFractionDigits:this.maxFractionDigits?this.maxFractionDigits.evaluate(e):void 0}).format(this.number.evaluate(e))}eachChild(e){e(this.number),this.locale&&e(this.locale),this.currency&&e(this.currency),this.minFractionDigits&&e(this.minFractionDigits),this.maxFractionDigits&&e(this.maxFractionDigits)}outputDefined(){return!1}},pn=class t{constructor(e){this.type=Ar,this.sections=e}static parse(e,r){if(e.length<2)return r.error("Expected at least one argument.");let n=e[1];if(!Array.isArray(n)&&typeof n=="object")return r.error("First argument must be an image or text section.");let i=[],o=!1;for(let a=1;a<=e.length-1;++a){let s=e[a];if(o&&typeof s=="object"&&!Array.isArray(s)){o=!1;let l=null;if(s["font-scale"]&&(l=r.parse(s["font-scale"],1,k),!l))return null;let u=null;if(s["text-font"]&&(u=r.parse(s["text-font"],1,Ce($)),!u))return null;let c=null;if(s["text-color"]&&(c=r.parse(s["text-color"],1,ze),!c))return null;let p=null;if(s["vertical-align"]){if(typeof s["vertical-align"]=="string"&&!Lh.includes(s["vertical-align"]))return r.error(`\'vertical-align\' must be one of: \'bottom\', \'center\', \'top\' but found \'${s["vertical-align"]}\' instead.`);if(p=r.parse(s["vertical-align"],1,$),!p)return null}let f=i[i.length-1];f.scale=l,f.font=u,f.textColor=c,f.verticalAlign=p}else{let l=r.parse(e[a],1,N);if(!l)return null;let u=l.type.kind;if(u!=="string"&&u!=="value"&&u!=="null"&&u!=="resolvedImage")return r.error("Formatted text type must be \'string\', \'value\', \'image\' or \'null\'.");o=!0,i.push({content:l,scale:null,font:null,textColor:null,verticalAlign:null})}}return new t(i)}evaluate(e){let r=n=>{let i=n.content.evaluate(e);return ue(i)===vn?new un("",i,null,null,null,n.verticalAlign?n.verticalAlign.evaluate(e):null):new un(on(i),null,n.scale?n.scale.evaluate(e):null,n.font?n.font.evaluate(e).join(","):null,n.textColor?n.textColor.evaluate(e):null,n.verticalAlign?n.verticalAlign.evaluate(e):null)};return new Fe(this.sections.map(r))}eachChild(e){for(let r of this.sections)e(r.content),r.scale&&e(r.scale),r.font&&e(r.font),r.textColor&&e(r.textColor),r.verticalAlign&&e(r.verticalAlign)}outputDefined(){return!1}},Cs=class t{constructor(e){this.type=vn,this.input=e}static parse(e,r){if(e.length!==2)return r.error("Expected two arguments.");let n=r.parse(e[1],1,$);return n?new t(n):r.error("No image name provided.")}evaluate(e){let r=this.input.evaluate(e),n=Se.fromString(r);return n&&e.availableImages&&(n.available=e.availableImages.indexOf(r)>-1),n}eachChild(e){e(this.input)}outputDefined(){return!1}},ks=class t{constructor(e){this.type=k,this.input=e}static parse(e,r){if(e.length!==2)return r.error(`Expected 1 argument, but found ${e.length-1} instead.`);let n=r.parse(e[1],1);return n?n.type.kind!=="array"&&n.type.kind!=="string"&&n.type.kind!=="value"?r.error(`Expected argument of type string or array, but found ${ie(n.type)} instead.`):new t(n):null}evaluate(e){let r=this.input.evaluate(e);if(typeof r=="string")return[...r].length;if(Array.isArray(r))return r.length;throw new ne(`Expected value to be of type string or array, but found ${ie(ue(r))} instead.`)}eachChild(e){e(this.input)}outputDefined(){return!1}},He=8192;function nd(t,e){let r=id(t[0]),n=ad(t[1]),i=Math.pow(2,e.z);return[Math.round(r*i*He),Math.round(n*i*He)]}function Os(t,e){let r=Math.pow(2,e.z),n=(t[0]/He+e.x)/r,i=(t[1]/He+e.y)/r;return[od(n),sd(i)]}function id(t){return(180+t)/360}function od(t){return t*360-180}function ad(t){return(180-180/Math.PI*Math.log(Math.tan(Math.PI/4+t*Math.PI/360)))/360}function sd(t){return 360/Math.PI*Math.atan(Math.exp((180-t*360)*Math.PI/180))-90}function Pn(t,e){t[0]=Math.min(t[0],e[0]),t[1]=Math.min(t[1],e[1]),t[2]=Math.max(t[2],e[0]),t[3]=Math.max(t[3],e[1])}function fn(t,e){return!(t[0]<=e[0]||t[2]>=e[2]||t[1]<=e[1]||t[3]>=e[3])}function ld(t,e,r){return e[1]>t[1]!=r[1]>t[1]&&t[0]<(r[0]-e[0])*(t[1]-e[1])/(r[1]-e[1])+e[0]}function ud(t,e,r){let n=t[0]-e[0],i=t[1]-e[1],o=t[0]-r[0],a=t[1]-r[1];return n*a-o*i===0&&n*o<=0&&i*a<=0}function vo(t,e,r,n){let i=[e[0]-t[0],e[1]-t[1]],o=[n[0]-r[0],n[1]-r[1]];return yd(o,i)===0?!1:!!(Mu(t,e,r,n)&&Mu(r,n,t,e))}function cd(t,e,r){for(let n of r)for(let i=0;i<n.length-1;++i)if(vo(t,e,n[i],n[i+1]))return!0;return!1}function Ir(t,e,r=!1){let n=!1;for(let i of e)for(let o=0;o<i.length-1;o++){if(ud(t,i[o],i[o+1]))return r;ld(t,i[o],i[o+1])&&(n=!n)}return n}function pd(t,e){for(let r of e)if(Ir(t,r))return!0;return!1}function ic(t,e){for(let r of t)if(!Ir(r,e))return!1;for(let r=0;r<t.length-1;++r)if(cd(t[r],t[r+1],e))return!1;return!0}function fd(t,e){for(let r of e)if(ic(t,r))return!0;return!1}function yd(t,e){return t[0]*e[1]-t[1]*e[0]}function Mu(t,e,r,n){let i=t[0]-r[0],o=t[1]-r[1],a=e[0]-r[0],s=e[1]-r[1],l=n[0]-r[0],u=n[1]-r[1],c=i*u-l*o,p=a*u-l*s;return c>0&&p<0||c<0&&p>0}function Gs(t,e,r){let n=[];for(let i=0;i<t.length;i++){let o=[];for(let a=0;a<t[i].length;a++){let s=nd(t[i][a],r);Pn(e,s),o.push(s)}n.push(o)}return n}function oc(t,e,r){let n=[];for(let i=0;i<t.length;i++){let o=Gs(t[i],e,r);n.push(o)}return n}function ac(t,e,r,n){if(t[0]<r[0]||t[0]>r[2]){let i=n*.5,o=t[0]-r[0]>i?-n:r[0]-t[0]>i?n:0;o===0&&(o=t[0]-r[2]>i?-n:r[2]-t[0]>i?n:0),t[0]+=o}Pn(e,t)}function md(t){t[0]=t[1]=1/0,t[2]=t[3]=-1/0}function Lu(t,e,r,n){let i=Math.pow(2,n.z)*He,o=[n.x*He,n.y*He],a=[];for(let s of t)for(let l of s){let u=[l.x+o[0],l.y+o[1]];ac(u,e,r,i),a.push(u)}return a}function Du(t,e,r,n){let i=Math.pow(2,n.z)*He,o=[n.x*He,n.y*He],a=[];for(let s of t){let l=[];for(let u of s){let c=[u.x+o[0],u.y+o[1]];Pn(e,c),l.push(c)}a.push(l)}if(e[2]-e[0]<=i/2){md(e);for(let s of a)for(let l of s)ac(l,e,r,i)}return a}function hd(t,e){let r=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],i=t.canonicalID();if(e.type==="Polygon"){let o=Gs(e.coordinates,n,i),a=Lu(t.geometry(),r,n,i);if(!fn(r,n))return!1;for(let s of a)if(!Ir(s,o))return!1}if(e.type==="MultiPolygon"){let o=oc(e.coordinates,n,i),a=Lu(t.geometry(),r,n,i);if(!fn(r,n))return!1;for(let s of a)if(!pd(s,o))return!1}return!0}function dd(t,e){let r=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],i=t.canonicalID();if(e.type==="Polygon"){let o=Gs(e.coordinates,n,i),a=Du(t.geometry(),r,n,i);if(!fn(r,n))return!1;for(let s of a)if(!ic(s,o))return!1}if(e.type==="MultiPolygon"){let o=oc(e.coordinates,n,i),a=Du(t.geometry(),r,n,i);if(!fn(r,n))return!1;for(let s of a)if(!fd(s,o))return!1}return!0}var yn=class t{constructor(e,r){this.type=U,this.geojson=e,this.geometries=r}static parse(e,r){if(e.length!==2)return r.error(`\'within\' expression requires exactly one argument, but found ${e.length-1} instead.`);if(cn(e[1])){let n=e[1];if(n.type==="FeatureCollection"){let i=[];for(let o of n.features){let{type:a,coordinates:s}=o.geometry;a==="Polygon"&&i.push(s),a==="MultiPolygon"&&i.push(...s)}if(i.length){let o={type:"MultiPolygon",coordinates:i};return new t(n,o)}}else if(n.type==="Feature"){let i=n.geometry.type;if(i==="Polygon"||i==="MultiPolygon")return new t(n,n.geometry)}else if(n.type==="Polygon"||n.type==="MultiPolygon")return new t(n,n)}return r.error("\'within\' expression requires valid geojson object that contains polygon geometry type.")}evaluate(e){if(e.geometry()!=null&&e.canonicalID()!=null){if(e.geometryType()==="Point")return hd(e,this.geometries);if(e.geometryType()==="LineString")return dd(e,this.geometries)}return!1}eachChild(){}outputDefined(){return!0}},ao=class{constructor(e=[],r=(n,i)=>n<i?-1:n>i?1:0){if(this.data=e,this.length=this.data.length,this.compare=r,this.length>0)for(let n=(this.length>>1)-1;n>=0;n--)this._down(n)}push(e){this.data.push(e),this._up(this.length++)}pop(){if(this.length===0)return;let e=this.data[0],r=this.data.pop();return--this.length>0&&(this.data[0]=r,this._down(0)),e}peek(){return this.data[0]}_up(e){let{data:r,compare:n}=this,i=r[e];for(;e>0;){let o=e-1>>1,a=r[o];if(n(i,a)>=0)break;r[e]=a,e=o}r[e]=i}_down(e){let{data:r,compare:n}=this,i=this.length>>1,o=r[e];for(;e<i;){let a=(e<<1)+1,s=a+1;if(s<this.length&&n(r[s],r[a])<0&&(a=s),n(r[a],o)>=0)break;r[e]=r[a],e=a}r[e]=o}};function sc(t,e,r=0,n=t.length-1,i=gd){for(;n>r;){if(n-r>600){let l=n-r+1,u=e-r+1,c=Math.log(l),p=.5*Math.exp(2*c/3),f=.5*Math.sqrt(c*p*(l-p)/l)*(u-l/2<0?-1:1),y=Math.max(r,Math.floor(e-u*p/l+f)),m=Math.min(n,Math.floor(e+(l-u)*p/l+f));sc(t,e,y,m,i)}let o=t[e],a=r,s=n;for(rn(t,r,e),i(t[n],o)>0&&rn(t,r,n);a<s;){for(rn(t,a,s),a++,s--;i(t[a],o)<0;)a++;for(;i(t[s],o)>0;)s--}i(t[r],o)===0?rn(t,r,s):(s++,rn(t,s,n)),s<=e&&(r=s+1),e<=s&&(n=s-1)}}function rn(t,e,r){let n=t[e];t[e]=t[r],t[r]=n}function gd(t,e){return t<e?-1:t>e?1:0}function Yt(t,e){if(t.length<=1)return[t];let n=[],i,o;for(let a of t){let s=xd(a);s!==0&&(a.area=Math.abs(s),o===void 0&&(o=s<0),o===s<0?(i&&n.push(i),i=[a]):i.push(a))}if(i&&n.push(i),e>1)for(let a=0;a<n.length;a++)n[a].length<=e||(sc(n[a],e,1,n[a].length-1,bd),n[a]=n[a].slice(0,e));return n}function bd(t,e){return e.area-t.area}function xd(t){let e=0;for(let r=0,n=t.length,i=n-1,o,a;r<n;i=r++)o=t[r],a=t[i],e+=(a.x-o.x)*(o.y+a.y);return e}var vd=6378.137,Bu=1/298.257223563,Vu=Bu*(2-Bu),Ru=Math.PI/180,mn=class{constructor(e){let r=Ru*vd*1e3,n=Math.cos(e*Ru),i=1/(1-Vu*(1-n*n)),o=Math.sqrt(i);this.kx=r*o*n,this.ky=r*o*i*(1-Vu)}distance(e,r){let n=this.wrap(e[0]-r[0])*this.kx,i=(e[1]-r[1])*this.ky;return Math.sqrt(n*n+i*i)}pointOnLine(e,r){let n=1/0,i,o,a,s;for(let l=0;l<e.length-1;l++){let u=e[l][0],c=e[l][1],p=this.wrap(e[l+1][0]-u)*this.kx,f=(e[l+1][1]-c)*this.ky,y=0;(p!==0||f!==0)&&(y=(this.wrap(r[0]-u)*this.kx*p+(r[1]-c)*this.ky*f)/(p*p+f*f),y>1?(u=e[l+1][0],c=e[l+1][1]):y>0&&(u+=p/this.kx*y,c+=f/this.ky*y)),p=this.wrap(r[0]-u)*this.kx,f=(r[1]-c)*this.ky;let m=p*p+f*f;m<n&&(n=m,i=u,o=c,a=l,s=y)}return{point:[i,o],index:a,t:Math.max(0,Math.min(1,s))}}wrap(e){for(;e<-180;)e+=360;for(;e>180;)e-=360;return e}},Fs=100,Es=50;function lc(t,e){return e[0]-t[0]}function so(t){return t[1]-t[0]+1}function st(t,e){return t[1]>=t[0]&&t[1]<e}function Ms(t,e){if(t[0]>t[1])return[null,null];let r=so(t);if(e){if(r===2)return[t,null];let i=Math.floor(r/2);return[[t[0],t[0]+i],[t[0]+i,t[1]]]}if(r===1)return[t,null];let n=Math.floor(r/2)-1;return[[t[0],t[0]+n],[t[0]+n+1,t[1]]]}function Ls(t,e){if(!st(e,t.length))return[1/0,1/0,-1/0,-1/0];let r=[1/0,1/0,-1/0,-1/0];for(let n=e[0];n<=e[1];++n)Pn(r,t[n]);return r}function Ds(t){let e=[1/0,1/0,-1/0,-1/0];for(let r of t)for(let n of r)Pn(e,n);return e}function zu(t){return t[0]!==-1/0&&t[1]!==-1/0&&t[2]!==1/0&&t[3]!==1/0}function Ns(t,e,r){if(!zu(t)||!zu(e))return NaN;let n=0,i=0;return t[2]<e[0]&&(n=e[0]-t[2]),t[0]>e[2]&&(n=t[0]-e[2]),t[1]>e[3]&&(i=t[1]-e[3]),t[3]<e[1]&&(i=e[1]-t[3]),r.distance([0,0],[n,i])}function qt(t,e,r){let n=r.pointOnLine(e,t);return r.distance(t,n.point)}function Us(t,e,r,n,i){let o=Math.min(qt(t,[r,n],i),qt(e,[r,n],i)),a=Math.min(qt(r,[t,e],i),qt(n,[t,e],i));return Math.min(o,a)}function Pd(t,e,r,n,i){if(!(st(e,t.length)&&st(n,r.length)))return 1/0;let a=1/0;for(let s=e[0];s<e[1];++s){let l=t[s],u=t[s+1];for(let c=n[0];c<n[1];++c){let p=r[c],f=r[c+1];if(vo(l,u,p,f))return 0;a=Math.min(a,Us(l,u,p,f,i))}}return a}function Sd(t,e,r,n,i){if(!(st(e,t.length)&&st(n,r.length)))return NaN;let a=1/0;for(let s=e[0];s<=e[1];++s)for(let l=n[0];l<=n[1];++l)if(a=Math.min(a,i.distance(t[s],r[l])),a===0)return a;return a}function wd(t,e,r){if(Ir(t,e,!0))return 0;let n=1/0;for(let i of e){let o=i[0],a=i[i.length-1];if(o!==a&&(n=Math.min(n,qt(t,[a,o],r)),n===0))return n;let s=r.pointOnLine(i,t);if(n=Math.min(n,r.distance(t,s.point)),n===0)return n}return n}function Ad(t,e,r,n){if(!st(e,t.length))return NaN;for(let o=e[0];o<=e[1];++o)if(Ir(t[o],r,!0))return 0;let i=1/0;for(let o=e[0];o<e[1];++o){let a=t[o],s=t[o+1];for(let l of r)for(let u=0,c=l.length,p=c-1;u<c;p=u++){let f=l[p],y=l[u];if(vo(a,s,f,y))return 0;i=Math.min(i,Us(a,s,f,y,n))}}return i}function Ou(t,e){for(let r of t)for(let n of r)if(Ir(n,e,!0))return!0;return!1}function _d(t,e,r,n=1/0){let i=Ds(t),o=Ds(e);if(n!==1/0&&Ns(i,o,r)>=n)return n;if(fn(i,o)){if(Ou(t,e))return 0}else if(Ou(e,t))return 0;let a=1/0;for(let s of t)for(let l=0,u=s.length,c=u-1;l<u;c=l++){let p=s[c],f=s[l];for(let y of e)for(let m=0,h=y.length,g=h-1;m<h;g=m++){let d=y[g],x=y[m];if(vo(p,f,d,x))return 0;a=Math.min(a,Us(p,f,d,x,r))}}return a}function Gu(t,e,r,n,i,o){if(!o)return;let a=Ns(Ls(n,o),i,r);a<e&&t.push([a,o,[0,0]])}function Yi(t,e,r,n,i,o,a){if(!o||!a)return;let s=Ns(Ls(n,o),Ls(i,a),r);s<e&&t.push([s,o,a])}function lo(t,e,r,n,i=1/0){let o=Math.min(n.distance(t[0],r[0][0]),i);if(o===0)return o;let a=new ao([[0,[0,t.length-1],[0,0]]],lc),s=Ds(r);for(;a.length>0;){let l=a.pop();if(l[0]>=o)continue;let u=l[1],c=e?Es:Fs;if(so(u)<=c){if(!st(u,t.length))return NaN;if(e){let p=Ad(t,u,r,n);if(isNaN(p)||p===0)return p;o=Math.min(o,p)}else for(let p=u[0];p<=u[1];++p){let f=wd(t[p],r,n);if(o=Math.min(o,f),o===0)return 0}}else{let p=Ms(u,e);Gu(a,o,n,t,s,p[0]),Gu(a,o,n,t,s,p[1])}}return o}function uo(t,e,r,n,i,o=1/0){let a=Math.min(o,i.distance(t[0],r[0]));if(a===0)return a;let s=new ao([[0,[0,t.length-1],[0,r.length-1]]],lc);for(;s.length>0;){let l=s.pop();if(l[0]>=a)continue;let u=l[1],c=l[2],p=e?Es:Fs,f=n?Es:Fs;if(so(u)<=p&&so(c)<=f){if(!st(u,t.length)&&st(c,r.length))return NaN;let y;if(e&&n)y=Pd(t,u,r,c,i),a=Math.min(a,y);else if(e&&!n){let m=t.slice(u[0],u[1]+1);for(let h=c[0];h<=c[1];++h)if(y=qt(r[h],m,i),a=Math.min(a,y),a===0)return a}else if(!e&&n){let m=r.slice(c[0],c[1]+1);for(let h=u[0];h<=u[1];++h)if(y=qt(t[h],m,i),a=Math.min(a,y),a===0)return a}else y=Sd(t,u,r,c,i),a=Math.min(a,y)}else{let y=Ms(u,e),m=Ms(c,n);Yi(s,a,i,t,r,y[0],m[0]),Yi(s,a,i,t,r,y[0],m[1]),Yi(s,a,i,t,r,y[1],m[0]),Yi(s,a,i,t,r,y[1],m[1])}}return a}function Id(t,e){let r=t.geometry(),n=r.flat().map(a=>Os([a.x,a.y],t.canonical));if(r.length===0)return NaN;let i=new mn(n[0][1]),o=1/0;for(let a of e){switch(a.type){case"Point":o=Math.min(o,uo(n,!1,[a.coordinates],!1,i,o));break;case"LineString":o=Math.min(o,uo(n,!1,a.coordinates,!0,i,o));break;case"Polygon":o=Math.min(o,lo(n,!1,a.coordinates,i,o));break}if(o===0)return o}return o}function Td(t,e){let r=t.geometry(),n=r.flat().map(a=>Os([a.x,a.y],t.canonical));if(r.length===0)return NaN;let i=new mn(n[0][1]),o=1/0;for(let a of e){switch(a.type){case"Point":o=Math.min(o,uo(n,!0,[a.coordinates],!1,i,o));break;case"LineString":o=Math.min(o,uo(n,!0,a.coordinates,!0,i,o));break;case"Polygon":o=Math.min(o,lo(n,!0,a.coordinates,i,o));break}if(o===0)return o}return o}function Cd(t,e){let r=t.geometry();if(r.length===0||r[0].length===0)return NaN;let n=Yt(r,0).map(a=>a.map(s=>s.map(l=>Os([l.x,l.y],t.canonical)))),i=new mn(n[0][0][0][1]),o=1/0;for(let a of e)for(let s of n){switch(a.type){case"Point":o=Math.min(o,lo([a.coordinates],!1,s,i,o));break;case"LineString":o=Math.min(o,lo(a.coordinates,!0,s,i,o));break;case"Polygon":o=Math.min(o,_d(s,a.coordinates,i,o));break}if(o===0)return o}return o}function gs(t){return t.type==="MultiPolygon"?t.coordinates.map(e=>({type:"Polygon",coordinates:e})):t.type==="MultiLineString"?t.coordinates.map(e=>({type:"LineString",coordinates:e})):t.type==="MultiPoint"?t.coordinates.map(e=>({type:"Point",coordinates:e})):[t]}var hn=class t{constructor(e,r){this.type=k,this.geojson=e,this.geometries=r}static parse(e,r){if(e.length!==2)return r.error(`\'distance\' expression requires exactly one argument, but found ${e.length-1} instead.`);if(cn(e[1])){let n=e[1];if(n.type==="FeatureCollection")return new t(n,n.features.map(i=>gs(i.geometry)).flat());if(n.type==="Feature")return new t(n,gs(n.geometry));if("type"in n&&"coordinates"in n)return new t(n,gs(n))}return r.error("\'distance\' expression requires valid geojson object that contains polygon geometry type.")}evaluate(e){if(e.geometry()!=null&&e.canonicalID()!=null){if(e.geometryType()==="Point")return Id(e,this.geometries);if(e.geometryType()==="LineString")return Td(e,this.geometries);if(e.geometryType()==="Polygon")return Cd(e,this.geometries)}return NaN}eachChild(){}outputDefined(){return!0}},dn=class t{constructor(e){this.type=N,this.key=e}static parse(e,r){if(e.length!==2)return r.error(`Expected 1 argument, but found ${e.length-1} instead.`);let n=e[1];return n==null?r.error("Global state property must be defined."):typeof n!="string"?r.error(`Global state property must be string, but found ${typeof e[1]} instead.`):new t(n)}evaluate(e){var r;let n=(r=e.globals)===null||r===void 0?void 0:r.globalState;return!n||Object.keys(n).length===0?null:nn(n,this.key)}eachChild(){}outputDefined(){return!1}},Kt={"==":Yh,"!=":Kh,">":ed,"<":Qh,">=":rd,"<=":td,array:$e,at:Ps,boolean:$e,case:_s,coalesce:io,collator:oo,format:pn,image:Cs,in:Ss,"index-of":ws,interpolate:ke,"interpolate-hcl":ke,"interpolate-lab":ke,length:ks,let:ro,literal:_t,match:As,number:$e,"number-format":Ts,object:$e,slice:Is,step:Pr,string:$e,"to-boolean":St,"to-color":St,"to-number":St,"to-string":St,var:no,within:yn,distance:hn,"global-state":dn},Ze=class t{constructor(e,r,n,i){this.name=e,this.type=r,this._evaluate=n,this.args=i}evaluate(e){return this._evaluate(e,this.args)}eachChild(e){this.args.forEach(e)}outputDefined(){return!1}static parse(e,r){let n=e[0],i=t.definitions[n];if(!i)return r.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`,0);let o=Array.isArray(i)?i[0]:i.type,a=Array.isArray(i)?[[i[1],i[2]]]:i.overloads,s=a.filter(([u])=>!Array.isArray(u)||u.length===e.length-1),l=null;for(let[u,c]of s){l=new to(r.registry,co,r.path,null,r.scope);let p=[],f=!1;for(let y=1;y<e.length;y++){let m=e[y],h=Array.isArray(u)?u[y-1]:u.type,g=l.parse(m,1+p.length,h);if(!g){f=!0;break}p.push(g)}if(!f){if(Array.isArray(u)&&u.length!==p.length){l.error(`Expected ${u.length} arguments, but found ${p.length} instead.`);continue}for(let y=0;y<p.length;y++){let m=Array.isArray(u)?u[y]:u.type,h=p[y];l.concat(y+1).checkSubtype(m,h.type)}if(l.errors.length===0)return new t(n,o,c,p)}}if(s.length===1)r.errors.push(...l.errors);else{let c=(s.length?s:a).map(([f])=>Fd(f)).join(" | "),p=[];for(let f=1;f<e.length;f++){let y=r.parse(e[f],1+p.length);if(!y)return null;p.push(ie(y.type))}r.error(`Expected arguments of type ${c}, but found (${p.join(", ")}) instead.`)}return null}static register(e,r){t.definitions=r;for(let n in r)e[n]=t}};function Nu(t,[e,r,n,i]){e=e.evaluate(t),r=r.evaluate(t),n=n.evaluate(t);let o=i?i.evaluate(t):1,a=tc(e,r,n,o);if(a)throw new ne(a);return new H(e/255,r/255,n/255,o,!1)}function Uu(t,e){return t in e}function bs(t,e){let r=e[t];return typeof r>"u"?null:r}function kd(t,e,r,n){for(;r<=n;){let i=r+n>>1;if(e[i]===t)return!0;e[i]>t?n=i-1:r=i+1}return!1}function jt(t){return{type:t}}Ze.register(Kt,{error:[Ph,[$],(t,[e])=>{throw new ne(e.evaluate(t))}],typeof:[$,[N],(t,[e])=>ie(ue(e.evaluate(t)))],"to-rgba":[Ce(k,4),[ze],(t,[e])=>{let[r,n,i,o]=e.evaluate(t).rgb;return[r*255,n*255,i*255,o]}],rgb:[ze,[k,k,k],Nu],rgba:[ze,[k,k,k,k],Nu],has:{type:U,overloads:[[[$],(t,[e])=>Uu(e.evaluate(t),t.properties())],[[$,Wt],(t,[e,r])=>Uu(e.evaluate(t),r.evaluate(t))]]},get:{type:N,overloads:[[[$],(t,[e])=>bs(e.evaluate(t),t.properties())],[[$,Wt],(t,[e,r])=>bs(e.evaluate(t),r.evaluate(t))]]},"feature-state":[N,[$],(t,[e])=>bs(e.evaluate(t),t.featureState||{})],properties:[Wt,[],t=>t.properties()],"geometry-type":[$,[],t=>t.geometryType()],id:[N,[],t=>t.id()],zoom:[k,[],t=>t.globals.zoom],"heatmap-density":[k,[],t=>t.globals.heatmapDensity||0],elevation:[k,[],t=>t.globals.elevation||0],"line-progress":[k,[],t=>t.globals.lineProgress||0],accumulated:[N,[],t=>t.globals.accumulated===void 0?null:t.globals.accumulated],"+":[k,jt(k),(t,e)=>{let r=0;for(let n of e)r+=n.evaluate(t);return r}],"*":[k,jt(k),(t,e)=>{let r=1;for(let n of e)r*=n.evaluate(t);return r}],"-":{type:k,overloads:[[[k,k],(t,[e,r])=>e.evaluate(t)-r.evaluate(t)],[[k],(t,[e])=>-e.evaluate(t)]]},"/":[k,[k,k],(t,[e,r])=>e.evaluate(t)/r.evaluate(t)],"%":[k,[k,k],(t,[e,r])=>e.evaluate(t)%r.evaluate(t)],ln2:[k,[],()=>Math.LN2],pi:[k,[],()=>Math.PI],e:[k,[],()=>Math.E],"^":[k,[k,k],(t,[e,r])=>Math.pow(e.evaluate(t),r.evaluate(t))],sqrt:[k,[k],(t,[e])=>Math.sqrt(e.evaluate(t))],log10:[k,[k],(t,[e])=>Math.log(e.evaluate(t))/Math.LN10],ln:[k,[k],(t,[e])=>Math.log(e.evaluate(t))],log2:[k,[k],(t,[e])=>Math.log(e.evaluate(t))/Math.LN2],sin:[k,[k],(t,[e])=>Math.sin(e.evaluate(t))],cos:[k,[k],(t,[e])=>Math.cos(e.evaluate(t))],tan:[k,[k],(t,[e])=>Math.tan(e.evaluate(t))],asin:[k,[k],(t,[e])=>Math.asin(e.evaluate(t))],acos:[k,[k],(t,[e])=>Math.acos(e.evaluate(t))],atan:[k,[k],(t,[e])=>Math.atan(e.evaluate(t))],min:[k,jt(k),(t,e)=>Math.min(...e.map(r=>r.evaluate(t)))],max:[k,jt(k),(t,e)=>Math.max(...e.map(r=>r.evaluate(t)))],abs:[k,[k],(t,[e])=>Math.abs(e.evaluate(t))],round:[k,[k],(t,[e])=>{let r=e.evaluate(t);return r<0?-Math.round(-r):Math.round(r)}],floor:[k,[k],(t,[e])=>Math.floor(e.evaluate(t))],ceil:[k,[k],(t,[e])=>Math.ceil(e.evaluate(t))],"filter-==":[U,[$,N],(t,[e,r])=>t.properties()[e.value]===r.value],"filter-id-==":[U,[N],(t,[e])=>t.id()===e.value],"filter-type-==":[U,[$],(t,[e])=>t.geometryType()===e.value],"filter-<":[U,[$,N],(t,[e,r])=>{let n=t.properties()[e.value],i=r.value;return typeof n==typeof i&&n<i}],"filter-id-<":[U,[N],(t,[e])=>{let r=t.id(),n=e.value;return typeof r==typeof n&&r<n}],"filter->":[U,[$,N],(t,[e,r])=>{let n=t.properties()[e.value],i=r.value;return typeof n==typeof i&&n>i}],"filter-id->":[U,[N],(t,[e])=>{let r=t.id(),n=e.value;return typeof r==typeof n&&r>n}],"filter-<=":[U,[$,N],(t,[e,r])=>{let n=t.properties()[e.value],i=r.value;return typeof n==typeof i&&n<=i}],"filter-id-<=":[U,[N],(t,[e])=>{let r=t.id(),n=e.value;return typeof r==typeof n&&r<=n}],"filter->=":[U,[$,N],(t,[e,r])=>{let n=t.properties()[e.value],i=r.value;return typeof n==typeof i&&n>=i}],"filter-id->=":[U,[N],(t,[e])=>{let r=t.id(),n=e.value;return typeof r==typeof n&&r>=n}],"filter-has":[U,[N],(t,[e])=>e.value in t.properties()],"filter-has-id":[U,[],t=>t.id()!==null&&t.id()!==void 0],"filter-type-in":[U,[Ce($)],(t,[e])=>e.value.indexOf(t.geometryType())>=0],"filter-id-in":[U,[Ce(N)],(t,[e])=>e.value.indexOf(t.id())>=0],"filter-in-small":[U,[$,Ce(N)],(t,[e,r])=>r.value.indexOf(t.properties()[e.value])>=0],"filter-in-large":[U,[$,Ce(N)],(t,[e,r])=>kd(t.properties()[e.value],r.value,0,r.value.length-1)],all:{type:U,overloads:[[[U,U],(t,[e,r])=>e.evaluate(t)&&r.evaluate(t)],[jt(U),(t,e)=>{for(let r of e)if(!r.evaluate(t))return!1;return!0}]]},any:{type:U,overloads:[[[U,U],(t,[e,r])=>e.evaluate(t)||r.evaluate(t)],[jt(U),(t,e)=>{for(let r of e)if(r.evaluate(t))return!0;return!1}]]},"!":[U,[U],(t,[e])=>!e.evaluate(t)],"is-supported-script":[U,[$],(t,[e])=>{let r=t.globals&&t.globals.isSupportedScript;return r?r(e.evaluate(t)):!0}],upcase:[$,[$],(t,[e])=>e.evaluate(t).toUpperCase()],downcase:[$,[$],(t,[e])=>e.evaluate(t).toLowerCase()],concat:[$,jt(N),(t,e)=>e.map(r=>on(r.evaluate(t))).join("")],"resolved-locale":[$,[mo],(t,[e])=>e.evaluate(t).resolvedLocale()]});function Fd(t){return Array.isArray(t)?`(${t.map(ie).join(", ")})`:`(${ie(t.type)}...)`}function co(t){if(t instanceof no)return co(t.boundExpression);if(t instanceof Ze&&t.name==="error")return!1;if(t instanceof oo)return!1;if(t instanceof yn)return!1;if(t instanceof hn)return!1;if(t instanceof dn)return!1;let e=t instanceof St||t instanceof $e,r=!0;return t.eachChild(n=>{e?r=r&&co(n):r=r&&n instanceof _t}),r?Po(t)&&So(t,["zoom","heatmap-density","elevation","line-progress","accumulated","is-supported-script"]):!1}function Po(t){if(t instanceof Ze){if(t.name==="get"&&t.args.length===1)return!1;if(t.name==="feature-state")return!1;if(t.name==="has"&&t.args.length===1)return!1;if(t.name==="properties"||t.name==="geometry-type"||t.name==="id")return!1;if(/^filter-/.test(t.name))return!1}if(t instanceof yn||t instanceof hn)return!1;let e=!0;return t.eachChild(r=>{e&&!Po(r)&&(e=!1)}),e}function gn(t){if(t instanceof Ze&&t.name==="feature-state")return!1;let e=!0;return t.eachChild(r=>{e&&!gn(r)&&(e=!1)}),e}function So(t,e){if(t instanceof Ze&&e.indexOf(t.name)>=0)return!1;let r=!0;return t.eachChild(n=>{r&&!So(n,e)&&(r=!1)}),r}function Bs(t){return{result:"success",value:t}}function gr(t){return{result:"error",value:t}}function It(t){return t["property-type"]==="data-driven"||t["property-type"]==="cross-faded-data-driven"}function uc(t){return!!t.expression&&t.expression.parameters.indexOf("zoom")>-1}function $s(t){return!!t.expression&&t.expression.interpolated}function j(t){return t instanceof Number?"number":t instanceof String?"string":t instanceof Boolean?"boolean":Array.isArray(t)?"array":t===null?"null":typeof t}function wo(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&ue(t)===Wt}function Ed(t){return t}function Md(t){switch(t.type){case"color":return H.parse;case"padding":return Oe.parse;case"numberArray":return Ge.parse;case"colorArray":return Pe.parse;default:return null}}function Ld(t){switch(t){case"exponential":return pc;case"interval":return Bd;case"categorical":return Dd;case"identity":return Vd;default:throw new Error(`Unknown function type "${t}"`)}}function cc(t,e){let r=t.stops&&typeof t.stops[0][0]=="object",n=r||t.property!==void 0,i=r||!n,o=t.type||($s(e)?"exponential":"interval"),a=Md(e);if(a&&(t=xr({},t),t.stops&&(t.stops=t.stops.map(c=>[c[0],a(c[1])])),t.default?t.default=a(t.default):t.default=a(e.default)),t.colorSpace&&!Mh(t.colorSpace))throw new Error(`Unknown color space: "${t.colorSpace}"`);let s=Ld(o),l,u;if(o==="categorical"){l=Object.create(null);for(let c of t.stops)l[c[0]]=c[1];u=typeof t.stops[0][0]}if(r){let c={},p=[];for(let m=0;m<t.stops.length;m++){let h=t.stops[m],g=h[0].zoom;c[g]===void 0&&(c[g]={zoom:g,type:t.type,property:t.property,default:t.default,stops:[]},p.push(g)),c[g].stops.push([h[0].value,h[1]])}let f=[];for(let m of p)f.push([c[m].zoom,cc(c[m],e)]);let y={name:"linear"};return{kind:"composite",interpolationType:y,interpolationFactor:ke.interpolationFactor.bind(void 0,y),zoomStops:f.map(m=>m[0]),evaluate({zoom:m},h){return pc({stops:f,base:t.base},e,m).evaluate(m,h)}}}else if(i){let c=o==="exponential"?{name:"exponential",base:t.base!==void 0?t.base:1}:null;return{kind:"camera",interpolationType:c,interpolationFactor:ke.interpolationFactor.bind(void 0,c),zoomStops:t.stops.map(p=>p[0]),evaluate:({zoom:p})=>s(t,e,p,l,u)}}else return{kind:"source",evaluate(c,p){let f=p&&p.properties?p.properties[t.property]:void 0;return f===void 0?Sn(t.default,e.default):s(t,e,f,l,u)}}}function Sn(t,e,r){if(t!==void 0)return t;if(e!==void 0)return e;if(r!==void 0)return r}function Dd(t,e,r,n,i){let o=typeof r===i?n[r]:void 0;return Sn(o,t.default,e.default)}function Bd(t,e,r){if(j(r)!=="number")return Sn(t.default,e.default);let n=t.stops.length;if(n===1||r<=t.stops[0][0])return t.stops[0][1];if(r>=t.stops[n-1][0])return t.stops[n-1][1];let i=xo(t.stops.map(o=>o[0]),r);return t.stops[i][1]}function pc(t,e,r){let n=t.base!==void 0?t.base:1;if(j(r)!=="number")return Sn(t.default,e.default);let i=t.stops.length;if(i===1||r<=t.stops[0][0])return t.stops[0][1];if(r>=t.stops[i-1][0])return t.stops[i-1][1];let o=xo(t.stops.map(c=>c[0]),r),a=Rd(r,n,t.stops[o][0],t.stops[o+1][0]),s=t.stops[o][1],l=t.stops[o+1][1],u=lt[e.type]||Ed;return typeof s.evaluate=="function"?{evaluate(...c){let p=s.evaluate.apply(void 0,c),f=l.evaluate.apply(void 0,c);if(!(p===void 0||f===void 0))return u(p,f,a,t.colorSpace)}}:u(s,l,a,t.colorSpace)}function Vd(t,e,r){switch(e.type){case"color":r=H.parse(r);break;case"formatted":r=Fe.fromString(r.toString());break;case"resolvedImage":r=Se.fromString(r.toString());break;case"padding":r=Oe.parse(r);break;case"colorArray":r=Pe.parse(r);break;case"numberArray":r=Ge.parse(r);break;default:j(r)!==e.type&&(e.type!=="enum"||!e.values[r])&&(r=void 0)}return Sn(r,t.default,e.default)}function Rd(t,e,r,n){let i=n-r,o=t-r;return i===0?0:e===1?o/i:(Math.pow(e,o)-1)/(Math.pow(e,i)-1)}var Ht=class{constructor(e,r){this.expression=e,this._warningHistory={},this._evaluator=new eo,this._defaultValue=r?Od(r):null,this._enumValues=r&&r.type==="enum"?r.values:null}evaluateWithoutErrorHandling(e,r,n,i,o,a){return this._evaluator.globals=e,this._evaluator.feature=r,this._evaluator.featureState=n,this._evaluator.canonical=i,this._evaluator.availableImages=o||null,this._evaluator.formattedSection=a,this.expression.evaluate(this._evaluator)}evaluate(e,r,n,i,o,a){this._evaluator.globals=e,this._evaluator.feature=r||null,this._evaluator.featureState=n||null,this._evaluator.canonical=i,this._evaluator.availableImages=o||null,this._evaluator.formattedSection=a||null;try{let s=this.expression.evaluate(this._evaluator);if(s==null||typeof s=="number"&&s!==s)return this._defaultValue;if(this._enumValues&&!(s in this._enumValues))throw new ne(`Expected value to be one of ${Object.keys(this._enumValues).map(l=>JSON.stringify(l)).join(", ")}, but found ${JSON.stringify(s)} instead.`);return s}catch(s){return this._warningHistory[s.message]||(this._warningHistory[s.message]=!0,typeof console<"u"&&console.warn(s.message)),this._defaultValue}}};function wn(t){return Array.isArray(t)&&t.length>0&&typeof t[0]=="string"&&t[0]in Kt}function Qt(t,e){let r=new to(Kt,co,[],e?zd(e):void 0),n=r.parse(t,void 0,void 0,void 0,e&&e.type==="string"?{typeAnnotation:"coerce"}:void 0);return n?Bs(new Ht(n,e)):gr(r.errors)}var Je=class{constructor(e,r){this.kind=e,this._styleExpression=r,this.isStateDependent=e!=="constant"&&!gn(r.expression),this.globalStateRefs=Ao(r.expression)}evaluateWithoutErrorHandling(e,r,n,i,o,a){return this._styleExpression.evaluateWithoutErrorHandling(e,r,n,i,o,a)}evaluate(e,r,n,i,o,a){return this._styleExpression.evaluate(e,r,n,i,o,a)}},Tt=class{constructor(e,r,n,i){this.kind=e,this.zoomStops=n,this._styleExpression=r,this.isStateDependent=e!=="camera"&&!gn(r.expression),this.globalStateRefs=Ao(r.expression),this.interpolationType=i}evaluateWithoutErrorHandling(e,r,n,i,o,a){return this._styleExpression.evaluateWithoutErrorHandling(e,r,n,i,o,a)}evaluate(e,r,n,i,o,a){return this._styleExpression.evaluate(e,r,n,i,o,a)}interpolationFactor(e,r,n){return this.interpolationType?ke.interpolationFactor(this.interpolationType,e,r,n):0}};function fc(t){return t._styleExpression!==void 0}function yc(t,e){let r=Qt(t,e);if(r.result==="error")return r;let n=r.value.expression,i=Po(n);if(!i&&!It(e))return gr([new Ve("","data expressions not supported")]);let o=So(n,["zoom"]);if(!o&&!uc(e))return gr([new Ve("","zoom expressions not supported")]);let a=Qi(n);if(!a&&!o)return gr([new Ve("",\'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.\')]);if(a instanceof Ve)return gr([a]);if(a instanceof ke&&!$s(e))return gr([new Ve("",\'"interpolate" expressions cannot be used with this property\')]);if(!a)return Bs(i?new Je("constant",r.value):new Je("source",r.value));let s=a instanceof ke?a.interpolation:void 0;return Bs(i?new Tt("camera",r.value,a.labels,s):new Tt("composite",r.value,a.labels,s))}var bn=class t{constructor(e,r){this._parameters=e,this._specification=r,xr(this,cc(this._parameters,this._specification))}static deserialize(e){return new t(e._parameters,e._specification)}static serialize(e){return{_parameters:e._parameters,_specification:e._specification}}};function mc(t,e){if(wo(t))return new bn(t,e);if(wn(t)){let r=yc(t,e);if(r.result==="error")throw new Error(r.value.map(n=>`${n.key}: ${n.message}`).join(", "));return r.value}else{let r=t;return e.type==="color"&&typeof t=="string"?r=H.parse(t):e.type==="padding"&&(typeof t=="number"||Array.isArray(t))?r=Oe.parse(t):e.type==="numberArray"&&(typeof t=="number"||Array.isArray(t))?r=Ge.parse(t):e.type==="colorArray"&&(typeof t=="string"||Array.isArray(t))?r=Pe.parse(t):e.type==="variableAnchorOffsetCollection"&&Array.isArray(t)?r=Ee.parse(t):e.type==="projectionDefinition"&&typeof t=="string"&&(r=At.parse(t)),{globalStateRefs:new Set,kind:"constant",evaluate:()=>r}}}function Qi(t){let e=null;if(t instanceof ro)e=Qi(t.result);else if(t instanceof io){for(let r of t.args)if(e=Qi(r),e)break}else(t instanceof Pr||t instanceof ke)&&t.input instanceof Ze&&t.input.name==="zoom"&&(e=t);return e instanceof Ve||t.eachChild(r=>{let n=Qi(r);n instanceof Ve?e=n:!e&&n?e=new Ve("",\'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.\'):e&&n&&e!==n&&(e=new Ve("",\'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.\'))}),e}function Ao(t,e=new Set){return t instanceof dn&&e.add(t.key),t.eachChild(r=>{Ao(r,e)}),e}function zd(t){let e={color:ze,string:$,number:k,enum:$,boolean:U,formatted:Ar,padding:ho,numberArray:go,colorArray:an,projectionDefinition:yo,resolvedImage:vn,variableAnchorOffsetCollection:bo};return t.type==="array"?Ce(e[t.value]||N,t.length):e[t.type]}function Od(t){if(t.type==="color"&&wo(t.default))return new H(0,0,0,0);switch(t.type){case"color":return H.parse(t.default)||null;case"padding":return Oe.parse(t.default)||null;case"numberArray":return Ge.parse(t.default)||null;case"colorArray":return Pe.parse(t.default)||null;case"variableAnchorOffsetCollection":return Ee.parse(t.default)||null;case"projectionDefinition":return At.parse(t.default)||null;default:return t.default===void 0?null:t.default}}function js(t){if(t===!0||t===!1)return!0;if(!Array.isArray(t)||t.length===0)return!1;switch(t[0]){case"has":return t.length>=2&&t[1]!=="$id"&&t[1]!=="$type";case"in":return t.length>=3&&(typeof t[1]!="string"||Array.isArray(t[2]));case"!in":case"!has":case"none":return!1;case"==":case"!=":case">":case">=":case"<":case"<=":return t.length!==3||Array.isArray(t[1])||Array.isArray(t[2]);case"any":case"all":for(let e of t.slice(1))if(!js(e)&&typeof e!="boolean")return!1;return!0;default:return!0}}var Gd={type:"boolean",default:!1,transition:!1,"property-type":"data-driven",expression:{interpolated:!1,parameters:["zoom","feature"]}};function Ct(t){if(t==null)return{filter:()=>!0,needGeometry:!1,getGlobalStateRefs:()=>new Set};js(t)||(t=po(t));let e=Qt(t,Gd);if(e.result==="error")throw new Error(e.value.map(r=>`${r.key}: ${r.message}`).join(", "));{let r=hc(t);return{filter:(n,i,o)=>e.value.evaluate(n,i,{},o),needGeometry:r,getGlobalStateRefs:()=>Ao(e.value.expression)}}}function Nd(t,e){return t<e?-1:t>e?1:0}function hc(t){if(!Array.isArray(t))return!1;if(t[0]==="within"||t[0]==="distance")return!0;for(let e=1;e<t.length;e++)if(hc(t[e]))return!0;return!1}function po(t){if(!t)return!0;let e=t[0];return t.length<=1?e!=="any":e==="=="?xs(t[1],t[2],"=="):e==="!="?Ki(xs(t[1],t[2],"==")):e==="<"||e===">"||e==="<="||e===">="?xs(t[1],t[2],e):e==="any"?Ud(t.slice(1)):e==="all"?["all"].concat(t.slice(1).map(po)):e==="none"?["all"].concat(t.slice(1).map(po).map(Ki)):e==="in"?$u(t[1],t.slice(2)):e==="!in"?Ki($u(t[1],t.slice(2))):e==="has"?ju(t[1]):e==="!has"?Ki(ju(t[1])):!0}function xs(t,e,r){switch(t){case"$type":return[`filter-type-${r}`,e];case"$id":return[`filter-id-${r}`,e];default:return[`filter-${r}`,t,e]}}function Ud(t){return["any"].concat(t.map(po))}function $u(t,e){if(e.length===0)return!1;switch(t){case"$type":return["filter-type-in",["literal",e]];case"$id":return["filter-id-in",["literal",e]];default:return e.length>200&&!e.some(r=>typeof r!=typeof e[0])?["filter-in-large",t,["literal",e.sort(Nd)]]:["filter-in-small",t,["literal",e]]}}function ju(t){switch(t){case"$type":return!0;case"$id":return["filter-has-id"];default:return["filter-has",t]}}function Ki(t){return["!",t]}function Vs(t){let e=typeof t;if(e==="number"||e==="boolean"||e==="string"||t===void 0||t===null)return JSON.stringify(t);if(Array.isArray(t)){let i="[";for(let o of t)i+=`${Vs(o)},`;return`${i}]`}let r=Object.keys(t).sort(),n="{";for(let i=0;i<r.length;i++)n+=`${JSON.stringify(r[i])}:${Vs(t[r[i]])},`;return`${n}}`}function $d(t){let e="";for(let r of vh)e+=`/${Vs(t[r])}`;return e}function dc(t,e){let r={};for(let i=0;i<t.length;i++){let o=e&&e[t[i].id]||$d(t[i]);e&&(e[t[i].id]=o);let a=r[o];a||(a=r[o]=[]),a.push(t[i])}let n=[];for(let i in r)n.push(r[i]);return n}function gc(t){let e=t.key,r=t.value;return r?[new C(e,r,"constants have been deprecated as of v8")]:[]}function le(t){return t instanceof Number||t instanceof String||t instanceof Boolean?t.valueOf():t}function Zt(t){if(Array.isArray(t))return t.map(Zt);if(t instanceof Object&&!(t instanceof Number||t instanceof String||t instanceof Boolean)){let e={};for(let r in t)e[r]=Zt(t[r]);return e}return le(t)}function Re(t){let e=t.key,r=t.value,n=t.valueSpec||{},i=t.objectElementValidators||{},o=t.style,a=t.styleSpec,s=t.validateSpec,l=[],u=j(r);if(u!=="object")return[new C(e,r,`object expected, ${u} found`)];for(let c in r){let p=c.split(".")[0],f=nn(n,p)||n["*"],y;if(nn(i,p))y=i[p];else if(nn(n,p))y=s;else if(i["*"])y=i["*"];else if(n["*"])y=s;else{l.push(new C(e,r[c],`unknown property "${c}"`));continue}l=l.concat(y({key:(e&&`${e}.`)+c,value:r[c],valueSpec:f,style:o,styleSpec:a,object:r,objectKey:c,validateSpec:s},r))}for(let c in n)i[c]||n[c].required&&n[c].default===void 0&&r[c]===void 0&&l.push(new C(e,r,`missing required property "${c}"`));return l}function qs(t){let e=t.value,r=t.valueSpec,n=t.validateSpec,i=t.style,o=t.styleSpec,a=t.key,s=t.arrayElementValidator||n;if(j(e)!=="array")return[new C(a,e,`array expected, ${j(e)} found`)];if(r.length&&e.length!==r.length)return[new C(a,e,`array length ${r.length} expected, length ${e.length} found`)];if(r["min-length"]&&e.length<r["min-length"])return[new C(a,e,`array length at least ${r["min-length"]} expected, length ${e.length} found`)];let l={type:r.value,values:r.values};o.$version<7&&(l.function=r.function),j(r.value)==="object"&&(l=r.value);let u=[];for(let c=0;c<e.length;c++)u=u.concat(s({array:e,arrayIndex:c,value:e[c],valueSpec:l,validateSpec:t.validateSpec,style:i,styleSpec:o,key:`${a}[${c}]`}));return u}function _o(t){let e=t.key,r=t.value,n=t.valueSpec,i=j(r);return i==="number"&&r!==r&&(i="NaN"),i!=="number"?[new C(e,r,`number expected, ${i} found`)]:"minimum"in n&&r<n.minimum?[new C(e,r,`${r} is less than the minimum value ${n.minimum}`)]:"maximum"in n&&r>n.maximum?[new C(e,r,`${r} is greater than the maximum value ${n.maximum}`)]:[]}function bc(t){let e=t.valueSpec,r=le(t.value.type),n,i={},o,a,s=r!=="categorical"&&t.value.property===void 0,l=!s,u=j(t.value.stops)==="array"&&j(t.value.stops[0])==="array"&&j(t.value.stops[0][0])==="object",c=Re({key:t.key,value:t.value,valueSpec:t.styleSpec.function,validateSpec:t.validateSpec,style:t.style,styleSpec:t.styleSpec,objectElementValidators:{stops:p,default:m}});return r==="identity"&&s&&c.push(new C(t.key,t.value,\'missing required property "property"\')),r!=="identity"&&!t.value.stops&&c.push(new C(t.key,t.value,\'missing required property "stops"\')),r==="exponential"&&t.valueSpec.expression&&!$s(t.valueSpec)&&c.push(new C(t.key,t.value,"exponential functions not supported")),t.styleSpec.$version>=8&&(l&&!It(t.valueSpec)?c.push(new C(t.key,t.value,"property functions not supported")):s&&!uc(t.valueSpec)&&c.push(new C(t.key,t.value,"zoom functions not supported"))),(r==="categorical"||u)&&t.value.property===void 0&&c.push(new C(t.key,t.value,\'"property" property is required\')),c;function p(h){if(r==="identity")return[new C(h.key,h.value,\'identity function may not have a "stops" property\')];let g=[],d=h.value;return g=g.concat(qs({key:h.key,value:d,valueSpec:h.valueSpec,validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec,arrayElementValidator:f})),j(d)==="array"&&d.length===0&&g.push(new C(h.key,d,"array must have at least one stop")),g}function f(h){let g=[],d=h.value,x=h.key;if(j(d)!=="array")return[new C(x,d,`array expected, ${j(d)} found`)];if(d.length!==2)return[new C(x,d,`array length 2 expected, length ${d.length} found`)];if(u){if(j(d[0])!=="object")return[new C(x,d,`object expected, ${j(d[0])} found`)];if(d[0].zoom===void 0)return[new C(x,d,"object stop key must have zoom")];if(d[0].value===void 0)return[new C(x,d,"object stop key must have value")];if(a&&a>le(d[0].zoom))return[new C(x,d[0].zoom,"stop zoom values must appear in ascending order")];le(d[0].zoom)!==a&&(a=le(d[0].zoom),o=void 0,i={}),g=g.concat(Re({key:`${x}[0]`,value:d[0],valueSpec:{zoom:{}},validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec,objectElementValidators:{zoom:_o,value:y}}))}else g=g.concat(y({key:`${x}[0]`,value:d[0],validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec},d));return wn(Zt(d[1]))?g.concat([new C(`${x}[1]`,d[1],"expressions are not allowed in function stops.")]):g.concat(h.validateSpec({key:`${x}[1]`,value:d[1],valueSpec:e,validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec}))}function y(h,g){let d=j(h.value),x=le(h.value),b=h.value!==null?h.value:g;if(!n)n=d;else if(d!==n)return[new C(h.key,b,`${d} stop domain type must match previous stop domain type ${n}`)];if(d!=="number"&&d!=="string"&&d!=="boolean")return[new C(h.key,b,"stop domain value must be a number, string, or boolean")];if(d!=="number"&&r!=="categorical"){let v=`number expected, ${d} found`;return It(e)&&r===void 0&&(v+=\'\\nIf you intended to use a categorical function, specify `"type": "categorical"`.\'),[new C(h.key,b,v)]}return r==="categorical"&&d==="number"&&(!isFinite(x)||Math.floor(x)!==x)?[new C(h.key,b,`integer expected, found ${x}`)]:r!=="categorical"&&d==="number"&&o!==void 0&&x<o?[new C(h.key,b,"stop domain values must appear in ascending order")]:(o=x,r==="categorical"&&x in i?[new C(h.key,b,"stop domain values must be unique")]:(i[x]=!0,[]))}function m(h){return h.validateSpec({key:h.key,value:h.value,valueSpec:e,validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec})}}function Sr(t){let e=(t.expressionContext==="property"?yc:Qt)(Zt(t.value),t.valueSpec);if(e.result==="error")return e.value.map(n=>new C(`${t.key}${n.key}`,t.value,n.message));let r=e.value.expression||e.value._styleExpression.expression;if(t.expressionContext==="property"&&t.propertyKey==="text-font"&&!r.outputDefined())return[new C(t.key,t.value,`Invalid data expression for "${t.propertyKey}". Output values must be contained as literals within the expression.`)];if(t.expressionContext==="property"&&t.propertyType==="layout"&&!gn(r))return[new C(t.key,t.value,\'"feature-state" data expressions are not supported with layout properties.\')];if(t.expressionContext==="filter"&&!gn(r))return[new C(t.key,t.value,\'"feature-state" data expressions are not supported with filters.\')];if(t.expressionContext&&t.expressionContext.indexOf("cluster")===0){if(!So(r,["zoom","feature-state"]))return[new C(t.key,t.value,\'"zoom" and "feature-state" expressions are not supported with cluster properties.\')];if(t.expressionContext==="cluster-initial"&&!Po(r))return[new C(t.key,t.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]}return[]}function jd(t){let e=t.value,r=t.key,n=j(e);return n!=="boolean"?[new C(r,e,`boolean expected, ${n} found`)]:[]}function Rs(t){let e=t.key,r=t.value,n=j(r);return n!=="string"?[new C(e,r,`color expected, ${n} found`)]:H.parse(String(r))?[]:[new C(e,r,`color expected, "${r}" found`)]}function xn(t){let e=t.key,r=t.value,n=t.valueSpec,i=[];return Array.isArray(n.values)?n.values.indexOf(le(r))===-1&&i.push(new C(e,r,`expected one of [${n.values.join(", ")}], ${JSON.stringify(r)} found`)):Object.keys(n.values).indexOf(le(r))===-1&&i.push(new C(e,r,`expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(r)} found`)),i}function Ws(t){return js(Zt(t.value))?Sr(xr({},t,{expressionContext:"filter",valueSpec:{value:"boolean"}})):xc(t)}function xc(t){let e=t.value,r=t.key;if(j(e)!=="array")return[new C(r,e,`array expected, ${j(e)} found`)];let n=t.styleSpec,i,o=[];if(e.length<1)return[new C(r,e,"filter array must have at least 1 element")];switch(o=o.concat(xn({key:`${r}[0]`,value:e[0],valueSpec:n.filter_operator,style:t.style,styleSpec:t.styleSpec})),le(e[0])){case"<":case"<=":case">":case">=":e.length>=2&&le(e[1])==="$type"&&o.push(new C(r,e,`"$type" cannot be use with operator "${e[0]}"`));case"==":case"!=":e.length!==3&&o.push(new C(r,e,`filter array for operator "${e[0]}" must have 3 elements`));case"in":case"!in":e.length>=2&&(i=j(e[1]),i!=="string"&&o.push(new C(`${r}[1]`,e[1],`string expected, ${i} found`)));for(let a=2;a<e.length;a++)i=j(e[a]),le(e[1])==="$type"?o=o.concat(xn({key:`${r}[${a}]`,value:e[a],valueSpec:n.geometry_type,style:t.style,styleSpec:t.styleSpec})):i!=="string"&&i!=="number"&&i!=="boolean"&&o.push(new C(`${r}[${a}]`,e[a],`string, number, or boolean expected, ${i} found`));break;case"any":case"all":case"none":for(let a=1;a<e.length;a++)o=o.concat(xc({key:`${r}[${a}]`,value:e[a],style:t.style,styleSpec:t.styleSpec}));break;case"has":case"!has":i=j(e[1]),e.length!==2?o.push(new C(r,e,`filter array for "${e[0]}" operator must have 2 elements`)):i!=="string"&&o.push(new C(`${r}[1]`,e[1],`string expected, ${i} found`));break}return o}function vc(t,e){let r=t.key,n=t.validateSpec,i=t.style,o=t.styleSpec,a=t.value,s=t.objectKey,l=o[`${e}_${t.layerType}`];if(!l)return[];let u=s.match(/^(.*)-transition$/);if(e==="paint"&&u&&l[u[1]]&&l[u[1]].transition)return n({key:r,value:a,valueSpec:o.transition,style:i,styleSpec:o});let c=t.valueSpec||l[s];if(!c)return[new C(r,a,`unknown property "${s}"`)];let p;if(j(a)==="string"&&It(c)&&!c.tokens&&(p=/^{([^}]+)}$/.exec(a)))return[new C(r,a,`"${s}" does not support interpolation syntax\nUse an identity property function instead: \\`{ "type": "identity", "property": ${JSON.stringify(p[1])} }\\`.`)];let f=[];return t.layerType==="symbol"&&(s==="text-field"&&i&&!i.glyphs&&f.push(new C(r,a,\'use of "text-field" requires a style "glyphs" property\')),s==="text-font"&&wo(Zt(a))&&le(a.type)==="identity"&&f.push(new C(r,a,\'"text-font" does not support identity functions\'))),f.concat(n({key:t.key,value:a,valueSpec:c,style:i,styleSpec:o,expressionContext:"property",propertyType:e,propertyKey:s}))}function Pc(t){return vc(t,"paint")}function Sc(t){return vc(t,"layout")}function wc(t){let e=[],r=t.value,n=t.key,i=t.style,o=t.styleSpec;if(j(r)!=="object")return[new C(n,r,`object expected, ${j(r)} found`)];!r.type&&!r.ref&&e.push(new C(n,r,\'either "type" or "ref" is required\'));let a=le(r.type),s=le(r.ref);if(r.id){let l=le(r.id);for(let u=0;u<t.arrayIndex;u++){let c=i.layers[u];le(c.id)===l&&e.push(new C(n,r.id,`duplicate layer id "${r.id}", previously used at line ${c.id.__line__}`))}}if("ref"in r){["type","source","source-layer","filter","layout"].forEach(u=>{u in r&&e.push(new C(n,r[u],`"${u}" is prohibited for ref layers`))});let l;i.layers.forEach(u=>{le(u.id)===s&&(l=u)}),l?l.ref?e.push(new C(n,r.ref,"ref cannot reference another ref layer")):a=le(l.type):e.push(new C(n,r.ref,`ref layer "${s}" not found`))}else if(a!=="background")if(!r.source)e.push(new C(n,r,\'missing required property "source"\'));else{let l=i.sources&&i.sources[r.source],u=l&&le(l.type);l?u==="vector"&&a==="raster"?e.push(new C(n,r.source,`layer "${r.id}" requires a raster source`)):u!=="raster-dem"&&a==="hillshade"?e.push(new C(n,r.source,`layer "${r.id}" requires a raster-dem source`)):u!=="raster-dem"&&a==="color-relief"?e.push(new C(n,r.source,`layer "${r.id}" requires a raster-dem source`)):u==="raster"&&a!=="raster"?e.push(new C(n,r.source,`layer "${r.id}" requires a vector source`)):u==="vector"&&!r["source-layer"]?e.push(new C(n,r,`layer "${r.id}" must specify a "source-layer"`)):u==="raster-dem"&&a!=="hillshade"&&a!=="color-relief"?e.push(new C(n,r.source,"raster-dem source can only be used with layer type \'hillshade\' or \'color-relief\'.")):a==="line"&&r.paint&&r.paint["line-gradient"]&&(u!=="geojson"||!l.lineMetrics)&&e.push(new C(n,r,`layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \\`lineMetrics\\` enabled.`)):e.push(new C(n,r.source,`source "${r.source}" not found`))}return e=e.concat(Re({key:n,value:r,valueSpec:o.layer,style:t.style,styleSpec:t.styleSpec,validateSpec:t.validateSpec,objectElementValidators:{"*"(){return[]},type(){return t.validateSpec({key:`${n}.type`,value:r.type,valueSpec:o.layer.type,style:t.style,styleSpec:t.styleSpec,validateSpec:t.validateSpec,object:r,objectKey:"type"})},filter:Ws,layout(l){return Re({layer:r,key:l.key,value:l.value,style:l.style,styleSpec:l.styleSpec,validateSpec:l.validateSpec,objectElementValidators:{"*"(u){return Sc(xr({layerType:a},u))}}})},paint(l){return Re({layer:r,key:l.key,value:l.value,style:l.style,styleSpec:l.styleSpec,validateSpec:l.validateSpec,objectElementValidators:{"*"(u){return Pc(xr({layerType:a},u))}}})}}})),e}function Jt(t){let e=t.value,r=t.key,n=j(e);return n!=="string"?[new C(r,e,`string expected, ${n} found`)]:[]}function qd(t){var e;let r=(e=t.sourceName)!==null&&e!==void 0?e:"",n=t.value,i=t.styleSpec,o=i.source_raster_dem,a=t.style,s=[],l=j(n);if(n===void 0)return s;if(l!=="object")return s.push(new C("source_raster_dem",n,`object expected, ${l} found`)),s;let c=le(n.encoding)==="custom",p=["redFactor","greenFactor","blueFactor","baseShift"],f=t.value.encoding?`"${t.value.encoding}"`:"Default";for(let y in n)!c&&p.includes(y)?s.push(new C(y,n[y],`In "${r}": "${y}" is only valid when "encoding" is set to "custom". ${f} encoding found`)):o[y]?s=s.concat(t.validateSpec({key:y,value:n[y],valueSpec:o[y],validateSpec:t.validateSpec,style:a,styleSpec:i})):s.push(new C(y,n[y],`unknown property "${y}"`));return s}var qu={promoteId:Wd};function Ac(t){let e=t.value,r=t.key,n=t.styleSpec,i=t.style,o=t.validateSpec;if(!e.type)return[new C(r,e,\'"type" is required\')];let a=le(e.type),s;switch(a){case"vector":case"raster":return s=Re({key:r,value:e,valueSpec:n[`source_${a.replace("-","_")}`],style:t.style,styleSpec:n,objectElementValidators:qu,validateSpec:o}),s;case"raster-dem":return s=qd({sourceName:r,value:e,style:t.style,styleSpec:n,validateSpec:o}),s;case"geojson":if(s=Re({key:r,value:e,valueSpec:n.source_geojson,style:i,styleSpec:n,validateSpec:o,objectElementValidators:qu}),e.cluster)for(let l in e.clusterProperties){let[u,c]=e.clusterProperties[l],p=typeof u=="string"?[u,["accumulated"],["get",l]]:u;s.push(...Sr({key:`${r}.${l}.map`,value:c,expressionContext:"cluster-map"})),s.push(...Sr({key:`${r}.${l}.reduce`,value:p,expressionContext:"cluster-reduce"}))}return s;case"video":return Re({key:r,value:e,valueSpec:n.source_video,style:i,validateSpec:o,styleSpec:n});case"image":return Re({key:r,value:e,valueSpec:n.source_image,style:i,validateSpec:o,styleSpec:n});case"canvas":return[new C(r,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];default:return xn({key:`${r}.type`,value:e.type,valueSpec:{values:["vector","raster","raster-dem","geojson","video","image"]}})}}function Wd({key:t,value:e}){if(j(e)==="string")return Jt({key:t,value:e});{let r=[];for(let n in e)r.push(...Jt({key:`${t}.${n}`,value:e[n]}));return r}}function _c(t){let e=t.value,r=t.styleSpec,n=r.light,i=t.style,o=[],a=j(e);if(e===void 0)return o;if(a!=="object")return o=o.concat([new C("light",e,`object expected, ${a} found`)]),o;for(let s in e){let l=s.match(/^(.*)-transition$/);l&&n[l[1]]&&n[l[1]].transition?o=o.concat(t.validateSpec({key:s,value:e[s],valueSpec:r.transition,validateSpec:t.validateSpec,style:i,styleSpec:r})):n[s]?o=o.concat(t.validateSpec({key:s,value:e[s],valueSpec:n[s],validateSpec:t.validateSpec,style:i,styleSpec:r})):o=o.concat([new C(s,e[s],`unknown property "${s}"`)])}return o}function Ic(t){let e=t.value,r=t.styleSpec,n=r.sky,i=t.style,o=j(e);if(e===void 0)return[];if(o!=="object")return[new C("sky",e,`object expected, ${o} found`)];let a=[];for(let s in e)n[s]?a=a.concat(t.validateSpec({key:s,value:e[s],valueSpec:n[s],style:i,styleSpec:r})):a=a.concat([new C(s,e[s],`unknown property "${s}"`)]);return a}function Tc(t){let e=t.value,r=t.styleSpec,n=r.terrain,i=t.style,o=[],a=j(e);if(e===void 0)return o;if(a!=="object")return o=o.concat([new C("terrain",e,`object expected, ${a} found`)]),o;for(let s in e)n[s]?o=o.concat(t.validateSpec({key:s,value:e[s],valueSpec:n[s],validateSpec:t.validateSpec,style:i,styleSpec:r})):o=o.concat([new C(s,e[s],`unknown property "${s}"`)]);return o}function Xd(t){return Jt(t).length===0?[]:Sr(t)}function Hd(t){return Jt(t).length===0?[]:Sr(t)}function Zd(t){let e=t.key,r=t.value;if(j(r)==="array"){if(r.length<1||r.length>4)return[new C(e,r,`padding requires 1 to 4 values; ${r.length} values found`)];let i={type:"number"},o=[];for(let a=0;a<r.length;a++)o=o.concat(t.validateSpec({key:`${e}[${a}]`,value:r[a],validateSpec:t.validateSpec,valueSpec:i}));return o}else return _o({key:e,value:r,valueSpec:{}})}function Jd(t){let e=t.key,r=t.value;if(j(r)==="array"){let i={type:"number"};if(r.length<1)return[new C(e,r,"array length at least 1 expected, length 0 found")];let o=[];for(let a=0;a<r.length;a++)o=o.concat(t.validateSpec({key:`${e}[${a}]`,value:r[a],validateSpec:t.validateSpec,valueSpec:i}));return o}else return _o({key:e,value:r,valueSpec:{}})}function Yd(t){let e=t.key,r=t.value;if(j(r)==="array"){if(r.length<1)return[new C(e,r,"array length at least 1 expected, length 0 found")];let i=[];for(let o=0;o<r.length;o++)i=i.concat(Rs({key:`${e}[${o}]`,value:r[o]}));return i}else return Rs({key:e,value:r})}function Kd(t){let e=t.key,r=t.value,n=j(r),i=t.styleSpec;if(n!=="array"||r.length<1||r.length%2!==0)return[new C(e,r,"variableAnchorOffsetCollection requires a non-empty array of even length")];let o=[];for(let a=0;a<r.length;a+=2)o=o.concat(xn({key:`${e}[${a}]`,value:r[a],valueSpec:i.layout_symbol["text-anchor"]})),o=o.concat(qs({key:`${e}[${a+1}]`,value:r[a+1],valueSpec:{length:2,value:"number"},validateSpec:t.validateSpec,style:t.style,styleSpec:i}));return o}function Cc(t){let e=[],r=t.value,n=t.key;if(Array.isArray(r)){let i=[],o=[];for(let a in r){r[a].id&&i.includes(r[a].id)&&e.push(new C(n,r,`all the sprites\' ids must be unique, but ${r[a].id} is duplicated`)),i.push(r[a].id),r[a].url&&o.includes(r[a].url)&&e.push(new C(n,r,`all the sprites\' URLs must be unique, but ${r[a].url} is duplicated`)),o.push(r[a].url);let s={id:{type:"string",required:!0},url:{type:"string",required:!0}};e=e.concat(Re({key:`${n}[${a}]`,value:r[a],valueSpec:s,validateSpec:t.validateSpec}))}return e}else return Jt({key:n,value:r})}function Qd(t){let e=t.value,r=t.styleSpec,n=r.projection,i=t.style,o=j(e);if(e===void 0)return[];if(o!=="object")return[new C("projection",e,`object expected, ${o} found`)];let a=[];for(let s in e)n[s]?a=a.concat(t.validateSpec({key:s,value:e[s],valueSpec:n[s],style:i,styleSpec:r})):a=a.concat([new C(s,e[s],`unknown property "${s}"`)]);return a}function eg(t){let e=t.key,r=t.value;r=r instanceof String?r.valueOf():r;let n=j(r);return n==="array"&&!rg(r)&&!tg(r)?[new C(e,r,`projection expected, invalid array ${JSON.stringify(r)} found`)]:["array","string"].includes(n)?[]:[new C(e,r,`projection expected, invalid type "${n}" found`)]}function tg(t){return!!["interpolate","step","literal"].includes(t[0])}function rg(t){return Array.isArray(t)&&t.length===3&&typeof t[0]=="string"&&typeof t[1]=="string"&&typeof t[2]=="number"}function ng(t){return!!t&&t.constructor===Object}function kc(t){return ng(t.value)?[]:[new C(t.key,t.value,`object expected, ${j(t.value)} found`)]}var Wu={"*"(){return[]},array:qs,boolean:jd,number:_o,color:Rs,constants:gc,enum:xn,filter:Ws,function:bc,layer:wc,object:Re,source:Ac,light:_c,sky:Ic,terrain:Tc,projection:Qd,projectionDefinition:eg,string:Jt,formatted:Xd,resolvedImage:Hd,padding:Zd,numberArray:Jd,colorArray:Yd,variableAnchorOffsetCollection:Kd,sprite:Cc,state:kc};function fo(t){let e=t.value,r=t.valueSpec,n=t.styleSpec;return t.validateSpec=fo,r.expression&&wo(le(e))?bc(t):r.expression&&wn(Zt(e))?Sr(t):r.type&&Wu[r.type]?Wu[r.type](t):Re(xr({},t,{valueSpec:r.type?n[r.type]:r}))}function Fc(t){let e=t.value,r=t.key,n=Jt(t);return n.length||(e.indexOf("{fontstack}")===-1&&n.push(new C(r,e,\'"glyphs" url must include a "{fontstack}" token\')),e.indexOf("{range}")===-1&&n.push(new C(r,e,\'"glyphs" url must include a "{range}" token\'))),n}function Me(t,e=P){let r=[];return r=r.concat(fo({key:"",value:t,valueSpec:e.$root,styleSpec:e,style:t,validateSpec:fo,objectElementValidators:{glyphs:Fc,"*"(){return[]}}})),t.constants&&(r=r.concat(gc({key:"constants",value:t.constants}))),Ec(r)}Me.source=qe(je(Ac));Me.sprite=qe(je(Cc));Me.glyphs=qe(je(Fc));Me.light=qe(je(_c));Me.sky=qe(je(Ic));Me.terrain=qe(je(Tc));Me.state=qe(je(kc));Me.layer=qe(je(wc));Me.filter=qe(je(Ws));Me.paintProperty=qe(je(Pc));Me.layoutProperty=qe(je(Sc));function je(t){return function(e){return t({...e,validateSpec:fo})}}function Ec(t){return[].concat(t).sort((e,r)=>e.line-r.line)}function qe(t){return function(...e){return Ec(t.apply(this,e))}}var Mc="AbortError";function Lc(t){return t.message===Mc}function Xs(){return new Error(Mc)}var Io={MAX_PARALLEL_IMAGE_REQUESTS:16,MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME:8,MAX_TILE_CACHE_ZOOM_LEVELS:5,REGISTERED_PROTOCOLS:{},WORKER_URL:""};function Dc(t){return Io.REGISTERED_PROTOCOLS[t.substring(0,t.indexOf("://"))]}function Bc(t,e){Io.REGISTERED_PROTOCOLS[t]=e}function Vc(t){delete Io.REGISTERED_PROTOCOLS[t]}var Rc="global-dispatcher",er=class extends Error{constructor(e,r,n,i){super(`AJAXError: ${r} (${e}): ${n}`),this.status=e,this.statusText=r,this.url=n,this.body=i}},Oc=()=>at(self)?self.worker&&self.worker.referrer:(window.location.protocol==="blob:"?window.parent:window).location.href,ig=t=>/^file:/.test(t)||/^file:/.test(Oc())&&!/^\\w+:/.test(t);async function og(t,e){let r=new Request(t.url,{method:t.method||"GET",body:t.body,credentials:t.credentials,headers:t.headers,cache:t.cache,referrer:Oc(),signal:e.signal});t.type==="json"&&!r.headers.has("Accept")&&r.headers.set("Accept","application/json");let n;try{n=await fetch(r)}catch(a){throw new er(0,a.message,t.url,new Blob)}if(!n.ok){let a=await n.blob();throw new er(n.status,n.statusText,t.url,a)}let i;t.type==="arrayBuffer"||t.type==="image"?i=n.arrayBuffer():t.type==="json"?i=n.json():i=n.text();let o=await i;if(e.signal.aborted)throw Xs();return{data:o,cacheControl:n.headers.get("Cache-Control"),expires:n.headers.get("Expires")}}function ag(t,e){return new Promise((r,n)=>{let i=new XMLHttpRequest;i.open(t.method||"GET",t.url,!0),(t.type==="arrayBuffer"||t.type==="image")&&(i.responseType="arraybuffer");for(let o in t.headers)i.setRequestHeader(o,t.headers[o]);t.type==="json"&&(i.responseType="text",t.headers?.Accept||i.setRequestHeader("Accept","application/json")),i.withCredentials=t.credentials==="include",i.onerror=()=>{n(new Error(i.statusText))},i.onload=()=>{if(!e.signal.aborted)if((i.status>=200&&i.status<300||i.status===0)&&i.response!==null){let o=i.response;if(t.type==="json")try{o=JSON.parse(i.response)}catch(a){n(a);return}r({data:o,cacheControl:i.getResponseHeader("Cache-Control"),expires:i.getResponseHeader("Expires")})}else{let o=new Blob([i.response],{type:i.getResponseHeader("Content-Type")});n(new er(i.status,i.statusText,t.url,o))}},e.signal.addEventListener("abort",()=>{i.abort(),n(Xs())}),i.send(t.body)})}var Gc=function(t,e){if(/:\\/\\//.test(t.url)&&!/^https?:|^file:/.test(t.url)){let r=Dc(t.url);if(r)return r(t,e);if(at(self)&&self.worker&&self.worker.actor)return self.worker.actor.sendAsync({type:"GR",data:t,targetMapId:Rc},e)}if(!ig(t.url)){if(fetch&&Request&&AbortController&&Object.prototype.hasOwnProperty.call(Request.prototype,"signal"))return og(t,e);if(at(self)&&self.worker&&self.worker.actor)return self.worker.actor.sendAsync({type:"GR",data:t,mustQueue:!0,targetMapId:Rc},e)}return ag(t,e)},Nc=(t,e)=>Gc(de(t,{type:"json"}),e),Uc=(t,e)=>Gc(de(t,{type:"arrayBuffer"}),e);var ut={};function I(t,e,r={}){if(ut[t])throw new Error(`${t} is already registered.`);Object.defineProperty(e,"_classRegistryKey",{value:t,writeable:!1}),ut[t]={klass:e,omit:r.omit||[],shallow:r.shallow||[]}}I("Object",Object);I("Set",Set);I("TransferableGridIndex",$t);I("Color",H);I("Error",Error);I("AJAXError",er);I("ResolvedImage",Se);I("StylePropertyFunction",bn);I("StyleExpression",Ht,{omit:["_evaluator"]});I("ZoomDependentExpression",Tt);I("ZoomConstantExpression",Je);I("CompoundExpression",Ze,{omit:["_evaluate"]});for(let t in Kt)Kt[t]._classRegistryKey||I(`Expression_${t}`,Kt[t]);function $c(t){return t&&typeof ArrayBuffer<"u"&&(t instanceof ArrayBuffer||t.constructor&&t.constructor.name==="ArrayBuffer")}function Hs(t){let e=t.constructor;return t.$name||e._classRegistryKey}function sg(t){if(t===null||typeof t!="object")return!1;let e=Hs(t);return!!(e&&e!=="Object")}function jc(t){return!sg(t)&&(t==null||typeof t=="boolean"||typeof t=="number"||typeof t=="string"||t instanceof Boolean||t instanceof Number||t instanceof String||t instanceof Date||t instanceof RegExp||t instanceof Blob||t instanceof Error||$c(t)||vt(t)||ArrayBuffer.isView(t)||t instanceof ImageData)}function Tr(t,e){if(jc(t)){if(($c(t)||vt(t))&&e&&e.push(t),ArrayBuffer.isView(t)){let o=t;e&&e.push(o.buffer)}return t instanceof ImageData&&e&&e.push(t.data.buffer),t}if(Array.isArray(t)){let o=[];for(let a of t)o.push(Tr(a,e));return o}if(typeof t!="object")throw new Error(`can\'t serialize object of type ${typeof t}`);let r=Hs(t);if(!r)throw new Error(`can\'t serialize object of unregistered class ${t.constructor.name}`);if(!ut[r])throw new Error(`${r} is not registered.`);let{klass:n}=ut[r],i=n.serialize?n.serialize(t,e):{};if(n.serialize){if(e&&i===e[e.length-1])throw new Error("statically serialized object won\'t survive transfer of $name property")}else{for(let o in t){if(!t.hasOwnProperty(o)||ut[r].omit.indexOf(o)>=0)continue;let a=t[o];i[o]=ut[r].shallow.indexOf(o)>=0?a:Tr(a,e)}t instanceof Error&&(i.message=t.message)}if(i.$name)throw new Error("$name property is reserved for worker serialization logic.");return r!=="Object"&&(i.$name=r),i}function Cr(t){if(jc(t))return t;if(Array.isArray(t))return t.map(Cr);if(typeof t!="object")throw new Error(`can\'t deserialize object of type ${typeof t}`);let e=Hs(t)||"Object";if(!ut[e])throw new Error(`can\'t deserialize unregistered class ${e}`);let{klass:r}=ut[e];if(!r)throw new Error(`can\'t deserialize unregistered class ${e}`);if(r.deserialize)return r.deserialize(t);let n=Object.create(r.prototype);for(let i of Object.keys(t)){if(i==="$name")continue;let o=t[i];n[i]=ut[e].shallow.indexOf(i)>=0?o:Cr(o)}return n}var To=class{constructor(e){this._methodToThrottle=e,this._triggered=!1,typeof MessageChannel<"u"&&(this._channel=new MessageChannel,this._channel.port2.onmessage=()=>{this._triggered=!1,this._methodToThrottle()})}trigger(){this._triggered||(this._triggered=!0,this._channel?this._channel.port1.postMessage(!0):setTimeout(()=>{this._triggered=!1,this._methodToThrottle()},0))}remove(){delete this._channel,this._methodToThrottle=()=>{}}};var lg={once:!0},Co=class{constructor(e,r){this.target=e,this.mapId=r,this.resolveRejects={},this.tasks={},this.taskQueue=[],this.abortControllers={},this.messageHandlers={},this.invoker=new To(()=>this.process()),this.subscription=us(this.target,"message",n=>this.receive(n),!1),this.globalScope=at(self)?e:window}registerMessageHandler(e,r){this.messageHandlers[e]=r}sendAsync(e,r){return new Promise((n,i)=>{let o=Math.round(Math.random()*1e18).toString(36).substring(0,10),a=r?us(r.signal,"abort",()=>{a?.unsubscribe(),delete this.resolveRejects[o];let u={id:o,type:"<cancel>",origin:location.origin,targetMapId:e.targetMapId,sourceMapId:this.mapId};this.target.postMessage(u)},lg):null;this.resolveRejects[o]={resolve:u=>{a?.unsubscribe(),n(u)},reject:u=>{a?.unsubscribe(),i(u)}};let s=[],l={...e,id:o,sourceMapId:this.mapId,origin:location.origin,data:Tr(e.data,s)};this.target.postMessage(l,{transfer:s})})}receive(e){let r=e.data,n=r.id;if(!(r.origin!=="file://"&&location.origin!=="file://"&&r.origin!=="resource://android"&&location.origin!=="resource://android"&&r.origin!==location.origin)&&!(r.targetMapId&&this.mapId!==r.targetMapId)){if(r.type==="<cancel>"){delete this.tasks[n];let i=this.abortControllers[n];delete this.abortControllers[n],i&&i.abort();return}if(at(self)||r.mustQueue){this.tasks[n]=r,this.taskQueue.push(n),this.invoker.trigger();return}this.processTask(n,r)}}process(){if(this.taskQueue.length===0)return;let e=this.taskQueue.shift(),r=this.tasks[e];delete this.tasks[e],this.taskQueue.length>0&&this.invoker.trigger(),r&&this.processTask(e,r)}async processTask(e,r){if(r.type==="<response>"){let o=this.resolveRejects[e];if(delete this.resolveRejects[e],!o)return;r.error?o.reject(Cr(r.error)):o.resolve(Cr(r.data));return}if(!this.messageHandlers[r.type]){this.completeTask(e,new Error(`Could not find a registered handler for ${r.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));return}let n=Cr(r.data),i=new AbortController;this.abortControllers[e]=i;try{let o=await this.messageHandlers[r.type](r.sourceMapId,n,i);this.completeTask(e,null,o)}catch(o){this.completeTask(e,o)}}completeTask(e,r,n){let i=[];delete this.abortControllers[e];let o={id:e,type:"<response>",sourceMapId:this.mapId,origin:location.origin,error:r?Tr(r):null,data:Tr(n,i)};this.target.postMessage(o,{transfer:i})}remove(){this.invoker.remove(),this.subscription.unsubscribe()}};function qc(t,e,r){r[t]&&r[t].indexOf(e)!==-1||(r[t]=r[t]||[],r[t].push(e))}function Zs(t,e,r){if(r&&r[t]){let n=r[t].indexOf(e);n!==-1&&r[t].splice(n,1)}}var ko=class{constructor(e,r={}){de(this,r),this.type=e}},An=class extends ko{constructor(e,r={}){super("error",de({error:e},r))}},Fo=class{on(e,r){return this._listeners=this._listeners||{},qc(e,r,this._listeners),{unsubscribe:()=>{this.off(e,r)}}}off(e,r){return Zs(e,r,this._listeners),Zs(e,r,this._oneTimeListeners),this}once(e,r){return r?(this._oneTimeListeners=this._oneTimeListeners||{},qc(e,r,this._oneTimeListeners),this):new Promise(n=>this.once(e,n))}fire(e,r){typeof e=="string"&&(e=new ko(e,r||{}));let n=e.type;if(this.listens(n)){e.target=this;let i=this._listeners&&this._listeners[n]?this._listeners[n].slice():[];for(let s of i)s.call(this,e);let o=this._oneTimeListeners&&this._oneTimeListeners[n]?this._oneTimeListeners[n].slice():[];for(let s of o)Zs(n,s,this._oneTimeListeners),s.call(this,e);let a=this._eventedParent;a&&(de(e,typeof this._eventedParentData=="function"?this._eventedParentData():this._eventedParentData),a.fire(e))}else e instanceof An&&console.error(e.error);return this}listens(e){return this._listeners&&this._listeners[e]&&this._listeners[e].length>0||this._oneTimeListeners&&this._oneTimeListeners[e]&&this._oneTimeListeners[e].length>0||this._eventedParent&&this._eventedParent.listens(e)}setEventedParent(e,r){return this._eventedParent=e,this._eventedParentData=r,this}};var ct=Me,K0=ct.source,Q0=ct.light,ev=ct.sky,tv=ct.terrain,rv=ct.filter,Wc=ct.paintProperty,Xc=ct.layoutProperty;function Hc(t,e){let r=!1;if(e&&e.length)for(let n of e)t.fire(new An(new Error(n.message))),r=!0;return r}var _n=class{constructor(){this.first=!0}update(e,r){let n=Math.floor(e);return this.first?(this.first=!1,this.lastIntegerZoom=n,this.lastIntegerZoomTime=0,this.lastZoom=e,this.lastFloorZoom=n,!0):(this.lastFloorZoom>n?(this.lastIntegerZoom=n+1,this.lastIntegerZoomTime=r):this.lastFloorZoom<n&&(this.lastIntegerZoom=n,this.lastIntegerZoomTime=r),e!==this.lastZoom?(this.lastZoom=e,this.lastFloorZoom=n,!0):!1)}};var q={"Latin-1 Supplement":t=>t>=128&&t<=255,"Hangul Jamo":t=>t>=4352&&t<=4607,Khmer:t=>t>=6016&&t<=6143,"General Punctuation":t=>t>=8192&&t<=8303,"Letterlike Symbols":t=>t>=8448&&t<=8527,"Number Forms":t=>t>=8528&&t<=8591,"Miscellaneous Technical":t=>t>=8960&&t<=9215,"Control Pictures":t=>t>=9216&&t<=9279,"Optical Character Recognition":t=>t>=9280&&t<=9311,"Enclosed Alphanumerics":t=>t>=9312&&t<=9471,"Geometric Shapes":t=>t>=9632&&t<=9727,"Miscellaneous Symbols":t=>t>=9728&&t<=9983,"Miscellaneous Symbols and Arrows":t=>t>=11008&&t<=11263,"Ideographic Description Characters":t=>t>=12272&&t<=12287,"CJK Symbols and Punctuation":t=>t>=12288&&t<=12351,Hiragana:t=>t>=12352&&t<=12447,Katakana:t=>t>=12448&&t<=12543,Kanbun:t=>t>=12688&&t<=12703,"CJK Strokes":t=>t>=12736&&t<=12783,"Enclosed CJK Letters and Months":t=>t>=12800&&t<=13055,"CJK Compatibility":t=>t>=13056&&t<=13311,"Yijing Hexagram Symbols":t=>t>=19904&&t<=19967,"CJK Unified Ideographs":t=>t>=19968&&t<=40959,"Hangul Syllables":t=>t>=44032&&t<=55215,"Private Use Area":t=>t>=57344&&t<=63743,"Vertical Forms":t=>t>=65040&&t<=65055,"CJK Compatibility Forms":t=>t>=65072&&t<=65103,"Small Form Variants":t=>t>=65104&&t<=65135,"Halfwidth and Fullwidth Forms":t=>t>=65280&&t<=65519};function In(t){for(let e of t)if(Eo(e.charCodeAt(0)))return!0;return!1}function Zc(t){for(let e of t)if(!pg(e.charCodeAt(0)))return!1;return!0}function Js(t){let e=t.map(r=>{try{return new RegExp(`\\\\p{sc=${r}}`,"u").source}catch{return null}}).filter(r=>r);return new RegExp(e.join("|"),"u")}var ug=["Arab","Dupl","Mong","Ougr","Syrc"],cg=Js(ug);function pg(t){return!cg.test(String.fromCodePoint(t))}var fg=["Bopo","Hani","Hira","Kana","Kits","Nshu","Tang","Yiii"],Jc=Js(fg);function Yc(t){return t<11904?!1:q["CJK Compatibility Forms"](t)||q["CJK Compatibility"](t)||q["CJK Strokes"](t)||q["CJK Symbols and Punctuation"](t)||q["Enclosed CJK Letters and Months"](t)||q["Halfwidth and Fullwidth Forms"](t)||q["Ideographic Description Characters"](t)||q["Vertical Forms"](t)?!0:Jc.test(String.fromCodePoint(t))}function Eo(t){return t===746||t===747?!0:t<4352?!1:!!(q["CJK Compatibility Forms"](t)&&!(t>=65097&&t<=65103)||q["CJK Compatibility"](t)||q["CJK Strokes"](t)||q["CJK Symbols and Punctuation"](t)&&!(t>=12296&&t<=12305)&&!(t>=12308&&t<=12319)&&t!==12336||q["Enclosed CJK Letters and Months"](t)||q["Ideographic Description Characters"](t)||q.Kanbun(t)||q.Katakana(t)&&t!==12540||q["Halfwidth and Fullwidth Forms"](t)&&t!==65288&&t!==65289&&t!==65293&&!(t>=65306&&t<=65310)&&t!==65339&&t!==65341&&t!==65343&&!(t>=65371&&t<=65503)&&t!==65507&&!(t>=65512&&t<=65519)||q["Small Form Variants"](t)&&!(t>=65112&&t<=65118)&&!(t>=65123&&t<=65126)||q["Vertical Forms"](t)||q["Yijing Hexagram Symbols"](t)||/\\p{sc=Cans}/u.test(String.fromCodePoint(t))||/\\p{sc=Hang}/u.test(String.fromCodePoint(t))||Jc.test(String.fromCodePoint(t)))}function yg(t){return!!(q["Latin-1 Supplement"](t)&&(t===167||t===169||t===174||t===177||t===188||t===189||t===190||t===215||t===247)||q["General Punctuation"](t)&&(t===8214||t===8224||t===8225||t===8240||t===8241||t===8251||t===8252||t===8258||t===8263||t===8264||t===8265||t===8273)||q["Letterlike Symbols"](t)||q["Number Forms"](t)||q["Miscellaneous Technical"](t)&&(t>=8960&&t<=8967||t>=8972&&t<=8991||t>=8996&&t<=9e3||t===9003||t>=9085&&t<=9114||t>=9150&&t<=9165||t===9167||t>=9169&&t<=9179||t>=9186&&t<=9215)||q["Control Pictures"](t)&&t!==9251||q["Optical Character Recognition"](t)||q["Enclosed Alphanumerics"](t)||q["Geometric Shapes"](t)||q["Miscellaneous Symbols"](t)&&!(t>=9754&&t<=9759)||q["Miscellaneous Symbols and Arrows"](t)&&(t>=11026&&t<=11055||t>=11088&&t<=11097||t>=11192&&t<=11243)||q["CJK Symbols and Punctuation"](t)||q.Katakana(t)||q["Private Use Area"](t)||q["CJK Compatibility Forms"](t)||q["Small Form Variants"](t)||q["Halfwidth and Fullwidth Forms"](t)||t===8734||t===8756||t===8757||t>=9984&&t<=10087||t>=10102&&t<=10131||t===65532||t===65533)}function Ys(t){return!(Eo(t)||yg(t))}function Kc(t){return/\\p{sc=Arab}/u.test(String.fromCodePoint(t))}var mg=["Adlm","Arab","Armi","Avst","Chrs","Cprt","Egyp","Elym","Gara","Hatr","Hebr","Hung","Khar","Lydi","Mand","Mani","Mend","Merc","Mero","Narb","Nbat","Nkoo","Orkh","Palm","Phli","Phlp","Phnx","Prti","Rohg","Samr","Sarb","Sogo","Syrc","Thaa","Todr","Yezi"],hg=Js(mg);function Qc(t){return hg.test(String.fromCodePoint(t))}function dg(t,e){return!(!e&&Qc(t)||t>=2304&&t<=3583||t>=3840&&t<=4255||q.Khmer(t))}function ep(t){for(let e of t)if(Qc(e.charCodeAt(0)))return!0;return!1}function tp(t,e){for(let r of t)if(!dg(r.charCodeAt(0),e))return!1;return!0}var Ks=class{constructor(){this.TIMEOUT=5e3;this.applyArabicShaping=null;this.processBidirectionalText=null;this.processStyledBidirectionalText=null;this.pluginStatus="unavailable";this.pluginURL=null;this.loadScriptResolve=()=>{}}setState(e){this.pluginStatus=e.pluginStatus,this.pluginURL=e.pluginURL}getState(){return{pluginStatus:this.pluginStatus,pluginURL:this.pluginURL}}setMethods(e){if(we.isParsed())throw new Error("RTL text plugin already registered.");this.applyArabicShaping=e.applyArabicShaping,this.processBidirectionalText=e.processBidirectionalText,this.processStyledBidirectionalText=e.processStyledBidirectionalText,this.loadScriptResolve()}isParsed(){return this.applyArabicShaping!=null&&this.processBidirectionalText!=null&&this.processStyledBidirectionalText!=null}getRTLTextPluginStatus(){return this.pluginStatus}async syncState(e,r){if(this.isParsed())return this.getState();if(e.pluginStatus!=="loading")return this.setState(e),e;let n=e.pluginURL,i=new Promise(s=>{this.loadScriptResolve=s});r(n);let o=new Promise(s=>setTimeout(()=>s(),this.TIMEOUT));if(await Promise.race([i,o]),this.isParsed()){let s={pluginStatus:"loaded",pluginURL:n};return this.setState(s),s}throw this.setState({pluginStatus:"error",pluginURL:""}),new Error(`RTL Text Plugin failed to import scripts from ${n}`)}},we=new Ks;var W=class{constructor(e,r){this.zoom=e,r?(this.now=r.now||0,this.fadeDuration=r.fadeDuration||0,this.zoomHistory=r.zoomHistory||new _n,this.transition=r.transition||{},this.globalState=r.globalState||{}):(this.now=0,this.fadeDuration=0,this.zoomHistory=new _n,this.transition={},this.globalState={})}isSupportedScript(e){return tp(e,we.getRTLTextPluginStatus()==="loaded")}crossFadingFactor(){return this.fadeDuration===0?1:Math.min((this.now-this.zoomHistory.lastIntegerZoomTime)/this.fadeDuration,1)}getCrossfadeParameters(){let e=this.zoom,r=e-Math.floor(e),n=this.crossFadingFactor();return e>this.zoomHistory.lastIntegerZoom?{fromScale:2,toScale:1,t:r+(1-r)*n}:{fromScale:.5,toScale:1,t:1-(1-n)*r}}};var kr=class{constructor(e,r){this.property=e,this.value=r,this.expression=mc(r===void 0?e.specification.default:r,e.specification)}isDataDriven(){return this.expression.kind==="source"||this.expression.kind==="composite"}getGlobalStateRefs(){return this.expression.globalStateRefs||new Set}possiblyEvaluate(e,r,n){return this.property.possiblyEvaluate(this,e,r,n)}},Tn=class{constructor(e){this.property=e,this.value=new kr(e,void 0)}transitioned(e,r){return new Lo(this.property,this.value,r,de({},e.transition,this.transition),e.now)}untransitioned(){return new Lo(this.property,this.value,null,{},0)}},Mo=class{constructor(e){this._properties=e,this._values=Object.create(e.defaultTransitionablePropertyValues)}getValue(e){return nt(this._values[e].value.value)}setValue(e,r){Object.prototype.hasOwnProperty.call(this._values,e)||(this._values[e]=new Tn(this._values[e].property)),this._values[e].value=new kr(this._values[e].property,r===null?void 0:nt(r))}getTransition(e){return nt(this._values[e].transition)}setTransition(e,r){Object.prototype.hasOwnProperty.call(this._values,e)||(this._values[e]=new Tn(this._values[e].property)),this._values[e].transition=nt(r)||void 0}serialize(){let e={};for(let r of Object.keys(this._values)){let n=this.getValue(r);n!==void 0&&(e[r]=n);let i=this.getTransition(r);i!==void 0&&(e[`${r}-transition`]=i)}return e}transitioned(e,r){let n=new Do(this._properties);for(let i of Object.keys(this._values))n._values[i]=this._values[i].transitioned(e,r._values[i]);return n}untransitioned(){let e=new Do(this._properties);for(let r of Object.keys(this._values))e._values[r]=this._values[r].untransitioned();return e}},Lo=class{constructor(e,r,n,i,o){this.property=e,this.value=r,this.begin=o+i.delay||0,this.end=this.begin+i.duration||0,e.specification.transition&&(i.delay||i.duration)&&(this.prior=n)}possiblyEvaluate(e,r,n){let i=e.now||0,o=this.value.possiblyEvaluate(e,r,n),a=this.prior;if(a){if(i>this.end)return this.prior=null,o;if(this.value.isDataDriven())return this.prior=null,o;if(i<this.begin)return a.possiblyEvaluate(e,r,n);{let s=(i-this.begin)/(this.end-this.begin);return this.property.interpolate(a.possiblyEvaluate(e,r,n),o,Su(s))}}else return o}},Do=class{constructor(e){this._properties=e,this._values=Object.create(e.defaultTransitioningPropertyValues)}possiblyEvaluate(e,r,n){let i=new kt(this._properties);for(let o of Object.keys(this._values))i._values[o]=this._values[o].possiblyEvaluate(e,r,n);return i}hasTransition(){for(let e of Object.keys(this._values))if(this._values[e].prior)return!0;return!1}},Bo=class{constructor(e){this._properties=e,this._values=Object.create(e.defaultPropertyValues)}hasValue(e){return this._values[e].value!==void 0}getValue(e){return nt(this._values[e].value)}setValue(e,r){this._values[e]=new kr(this._values[e].property,r===null?void 0:nt(r))}serialize(){let e={};for(let r of Object.keys(this._values)){let n=this.getValue(r);n!==void 0&&(e[r]=n)}return e}possiblyEvaluate(e,r,n){let i=new kt(this._properties);for(let o of Object.keys(this._values))i._values[o]=this._values[o].possiblyEvaluate(e,r,n);return i}},ge=class{constructor(e,r,n){this.property=e,this.value=r,this.parameters=n}isConstant(){return this.value.kind==="constant"}constantOr(e){return this.value.kind==="constant"?this.value.value:e}evaluate(e,r,n,i){return this.property.evaluate(this.value,this.parameters,e,r,n,i)}},kt=class{constructor(e){this._properties=e,this._values=Object.create(e.defaultPossiblyEvaluatedValues)}get(e){return this._values[e]}},F=class{constructor(e){this.specification=e}possiblyEvaluate(e,r){if(e.isDataDriven())throw new Error("Value should not be data driven");return e.expression.evaluate(r)}interpolate(e,r,n){let i=this.specification.type,o=lt[i];return o?o(e,r,n):e}},L=class{constructor(e,r){this.specification=e,this.overrides=r}possiblyEvaluate(e,r,n,i){return e.expression.kind==="constant"||e.expression.kind==="camera"?new ge(this,{kind:"constant",value:e.expression.evaluate(r,null,{},n,i)},r):new ge(this,e.expression,r)}interpolate(e,r,n){if(e.value.kind!=="constant"||r.value.kind!=="constant")return e;if(e.value.value===void 0||r.value.value===void 0)return new ge(this,{kind:"constant",value:void 0},e.parameters);let i=this.specification.type,o=lt[i];if(o){let a=o(e.value.value,r.value.value,n);return new ge(this,{kind:"constant",value:a},e.parameters)}else return e}evaluate(e,r,n,i,o,a){return e.kind==="constant"?e.value:e.evaluate(r,n,i,o,a)}},pt=class extends L{possiblyEvaluate(e,r,n,i){if(e.value===void 0)return new ge(this,{kind:"constant",value:void 0},r);if(e.expression.kind==="constant"){let o=e.expression.evaluate(r,null,{},n,i),s=e.property.specification.type==="resolvedImage"&&typeof o!="string"?o.name:o,l=this._calculate(s,s,s,r);return new ge(this,{kind:"constant",value:l},r)}else if(e.expression.kind==="camera"){let o=this._calculate(e.expression.evaluate({zoom:r.zoom-1}),e.expression.evaluate({zoom:r.zoom}),e.expression.evaluate({zoom:r.zoom+1}),r);return new ge(this,{kind:"constant",value:o},r)}else return new ge(this,e.expression,r)}evaluate(e,r,n,i,o,a){if(e.kind==="source"){let s=e.evaluate(r,n,i,o,a);return this._calculate(s,s,s,r)}else return e.kind==="composite"?this._calculate(e.evaluate({zoom:Math.floor(r.zoom)-1},n,i),e.evaluate({zoom:Math.floor(r.zoom)},n,i),e.evaluate({zoom:Math.floor(r.zoom)+1},n,i),r):e.value}_calculate(e,r,n,i){return i.zoom>i.zoomHistory.lastIntegerZoom?{from:e,to:r}:{from:n,to:r}}interpolate(e){return e}},tr=class{constructor(e){this.specification=e}possiblyEvaluate(e,r,n,i){if(e.value!==void 0)if(e.expression.kind==="constant"){let o=e.expression.evaluate(r,null,{},n,i);return this._calculate(o,o,o,r)}else return this._calculate(e.expression.evaluate(new W(Math.floor(r.zoom-1),r)),e.expression.evaluate(new W(Math.floor(r.zoom),r)),e.expression.evaluate(new W(Math.floor(r.zoom+1),r)),r)}_calculate(e,r,n,i){return i.zoom>i.zoomHistory.lastIntegerZoom?{from:e,to:r}:{from:n,to:r}}interpolate(e){return e}},ft=class{constructor(e){this.specification=e}possiblyEvaluate(e,r,n,i){return!!e.expression.evaluate(r,null,{},n,i)}interpolate(){return!1}},ee=class{constructor(e){this.properties=e,this.defaultPropertyValues={},this.defaultTransitionablePropertyValues={},this.defaultTransitioningPropertyValues={},this.defaultPossiblyEvaluatedValues={},this.overridableProperties=[];for(let r in e){let n=e[r];n.specification.overridable&&this.overridableProperties.push(r);let i=this.defaultPropertyValues[r]=new kr(n,void 0),o=this.defaultTransitionablePropertyValues[r]=new Tn(n);this.defaultTransitioningPropertyValues[r]=o.untransitioned(),this.defaultPossiblyEvaluatedValues[r]=i.possiblyEvaluate({})}}};I("DataDrivenProperty",L);I("DataConstantProperty",F);I("CrossFadedDataDrivenProperty",pt);I("CrossFadedProperty",tr);I("ColorRampProperty",ft);var Vo="-transition",oe=class extends Fo{constructor(e,r){if(super(),this.id=e.id,this.type=e.type,this._featureFilter={filter:()=>!0,needGeometry:!1,getGlobalStateRefs:()=>new Set},e.type!=="custom"&&(e=e,this.metadata=e.metadata,this.minzoom=e.minzoom,this.maxzoom=e.maxzoom,e.type!=="background"&&(this.source=e.source,this.sourceLayer=e["source-layer"],this.filter=e.filter,this._featureFilter=Ct(e.filter)),r.layout&&(this._unevaluatedLayout=new Bo(r.layout)),r.paint)){this._transitionablePaint=new Mo(r.paint);for(let n in e.paint)this.setPaintProperty(n,e.paint[n],{validate:!1});for(let n in e.layout)this.setLayoutProperty(n,e.layout[n],{validate:!1});this._transitioningPaint=this._transitionablePaint.untransitioned(),this.paint=new kt(r.paint)}}setFilter(e){this.filter=e,this._featureFilter=Ct(e)}getCrossfadeParameters(){return this._crossfadeParameters}getLayoutProperty(e){return e==="visibility"?this.visibility:this._unevaluatedLayout.getValue(e)}getLayoutAffectingGlobalStateRefs(){let e=new Set;if(this._unevaluatedLayout)for(let r in this._unevaluatedLayout._values){let n=this._unevaluatedLayout._values[r];for(let i of n.getGlobalStateRefs())e.add(i)}for(let r of this._featureFilter.getGlobalStateRefs())e.add(r);return e}setLayoutProperty(e,r,n={}){if(r!=null){let i=`layers.${this.id}.layout.${e}`;if(this._validate(Xc,i,e,r,n))return}if(e==="visibility"){this.visibility=r;return}this._unevaluatedLayout.setValue(e,r)}getPaintProperty(e){return e.endsWith(Vo)?this._transitionablePaint.getTransition(e.slice(0,-Vo.length)):this._transitionablePaint.getValue(e)}setPaintProperty(e,r,n={}){if(r!=null){let i=`layers.${this.id}.paint.${e}`;if(this._validate(Wc,i,e,r,n))return!1}if(e.endsWith(Vo))return this._transitionablePaint.setTransition(e.slice(0,-Vo.length),r||void 0),!1;{let i=this._transitionablePaint._values[e],o=i.property.specification["property-type"]==="cross-faded-data-driven",a=i.value.isDataDriven(),s=i.value;this._transitionablePaint.setValue(e,r),this._handleSpecialPaintPropertyUpdate(e);let l=this._transitionablePaint._values[e].value;return l.isDataDriven()||a||o||this._handleOverridablePaintPropertyUpdate(e,s,l)}}_handleSpecialPaintPropertyUpdate(e){}_handleOverridablePaintPropertyUpdate(e,r,n){return!1}isHidden(e){return this.minzoom&&e<this.minzoom||this.maxzoom&&e>=this.maxzoom?!0:this.visibility==="none"}updateTransitions(e){this._transitioningPaint=this._transitionablePaint.transitioned(e,this._transitioningPaint)}hasTransition(){return this._transitioningPaint.hasTransition()}recalculate(e,r){e.getCrossfadeParameters&&(this._crossfadeParameters=e.getCrossfadeParameters()),this._unevaluatedLayout&&(this.layout=this._unevaluatedLayout.possiblyEvaluate(e,void 0,r)),this.paint=this._transitioningPaint.possiblyEvaluate(e,void 0,r)}serialize(){let e={id:this.id,type:this.type,source:this.source,"source-layer":this.sourceLayer,metadata:this.metadata,minzoom:this.minzoom,maxzoom:this.maxzoom,filter:this.filter,layout:this._unevaluatedLayout&&this._unevaluatedLayout.serialize(),paint:this._transitionablePaint&&this._transitionablePaint.serialize()};return this.visibility&&(e.layout=e.layout||{},e.layout.visibility=this.visibility),_u(e,(r,n)=>r!==void 0&&!(n==="layout"&&!Object.keys(r).length)&&!(n==="paint"&&!Object.keys(r).length))}_validate(e,r,n,i,o={}){return o&&o.validate===!1?!1:Hc(this,e.call(ct,{key:r,layerType:this.type,objectKey:n,value:i,styleSpec:P,style:{glyphs:!0,sprite:!0}}))}is3D(){return!1}isTileClipped(){return!1}hasOffscreenPass(){return!1}resize(){}isStateDependent(){for(let e in this.paint._values){let r=this.paint.get(e);if(!(!(r instanceof ge)||!It(r.property.specification))&&(r.value.kind==="source"||r.value.kind==="composite")&&r.value.isStateDependent)return!0}return!1}};var gg={Int8:Int8Array,Uint8:Uint8Array,Int16:Int16Array,Uint16:Uint16Array,Int32:Int32Array,Uint32:Uint32Array,Float32:Float32Array},Ft=class{constructor(e,r){this._structArray=e,this._pos1=r*this.size,this._pos2=this._pos1/2,this._pos4=this._pos1/4,this._pos8=this._pos1/8}},bg=128,xg=5,te=class{constructor(){this.isTransferred=!1,this.capacity=-1,this.resize(0)}static serialize(e,r){return e._trim(),r&&(e.isTransferred=!0,r.push(e.arrayBuffer)),{length:e.length,arrayBuffer:e.arrayBuffer}}static deserialize(e){let r=Object.create(this.prototype);return r.arrayBuffer=e.arrayBuffer,r.length=e.length,r.capacity=e.arrayBuffer.byteLength/r.bytesPerElement,r._refreshViews(),r}_trim(){this.length!==this.capacity&&(this.capacity=this.length,this.arrayBuffer=this.arrayBuffer.slice(0,this.length*this.bytesPerElement),this._refreshViews())}clear(){this.length=0}resize(e){this.reserve(e),this.length=e}reserve(e){if(e>this.capacity){this.capacity=Math.max(e,Math.floor(this.capacity*xg),bg),this.arrayBuffer=new ArrayBuffer(this.capacity*this.bytesPerElement);let r=this.uint8;this._refreshViews(),r&&this.uint8.set(r)}}_refreshViews(){throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")}};function Q(t,e=1){let r=0,n=0,i=t.map(a=>{let s=vg(a.type),l=r=rp(r,Math.max(e,s)),u=a.components||1;return n=Math.max(n,s),r+=s*u,{name:a.name,type:a.type,components:u,offset:l}}),o=rp(r,Math.max(n,e));return{members:i,size:o,alignment:e}}function vg(t){return gg[t].BYTES_PER_ELEMENT}function rp(t,e){return Math.ceil(t/e)*e}var np=Y(ye(),1),rr=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(e,r){let n=this.length;return this.resize(n+1),this.emplace(n,e,r)}emplace(e,r,n){let i=e*2;return this.int16[i+0]=r,this.int16[i+1]=n,e}};rr.prototype.bytesPerElement=4;I("StructArrayLayout2i4",rr);var Cn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(e,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,e,r,n)}emplace(e,r,n,i){let o=e*3;return this.int16[o+0]=r,this.int16[o+1]=n,this.int16[o+2]=i,e}};Cn.prototype.bytesPerElement=6;I("StructArrayLayout3i6",Cn);var Ro=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(e,r,n,i){let o=this.length;return this.resize(o+1),this.emplace(o,e,r,n,i)}emplace(e,r,n,i,o){let a=e*4;return this.int16[a+0]=r,this.int16[a+1]=n,this.int16[a+2]=i,this.int16[a+3]=o,e}};Ro.prototype.bytesPerElement=8;I("StructArrayLayout4i8",Ro);var kn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o,a){let s=this.length;return this.resize(s+1),this.emplace(s,e,r,n,i,o,a)}emplace(e,r,n,i,o,a,s){let l=e*6;return this.int16[l+0]=r,this.int16[l+1]=n,this.int16[l+2]=i,this.int16[l+3]=o,this.int16[l+4]=a,this.int16[l+5]=s,e}};kn.prototype.bytesPerElement=12;I("StructArrayLayout2i4i12",kn);var Fn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o,a){let s=this.length;return this.resize(s+1),this.emplace(s,e,r,n,i,o,a)}emplace(e,r,n,i,o,a,s){let l=e*4,u=e*8;return this.int16[l+0]=r,this.int16[l+1]=n,this.uint8[u+4]=i,this.uint8[u+5]=o,this.uint8[u+6]=a,this.uint8[u+7]=s,e}};Fn.prototype.bytesPerElement=8;I("StructArrayLayout2i4ub8",Fn);var Et=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(e,r){let n=this.length;return this.resize(n+1),this.emplace(n,e,r)}emplace(e,r,n){let i=e*2;return this.float32[i+0]=r,this.float32[i+1]=n,e}};Et.prototype.bytesPerElement=8;I("StructArrayLayout2f8",Et);var En=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o,a,s,l,u,c){let p=this.length;return this.resize(p+1),this.emplace(p,e,r,n,i,o,a,s,l,u,c)}emplace(e,r,n,i,o,a,s,l,u,c,p){let f=e*10;return this.uint16[f+0]=r,this.uint16[f+1]=n,this.uint16[f+2]=i,this.uint16[f+3]=o,this.uint16[f+4]=a,this.uint16[f+5]=s,this.uint16[f+6]=l,this.uint16[f+7]=u,this.uint16[f+8]=c,this.uint16[f+9]=p,e}};En.prototype.bytesPerElement=20;I("StructArrayLayout10ui20",En);var Mn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o,a,s,l,u,c,p,f){let y=this.length;return this.resize(y+1),this.emplace(y,e,r,n,i,o,a,s,l,u,c,p,f)}emplace(e,r,n,i,o,a,s,l,u,c,p,f,y){let m=e*12;return this.int16[m+0]=r,this.int16[m+1]=n,this.int16[m+2]=i,this.int16[m+3]=o,this.uint16[m+4]=a,this.uint16[m+5]=s,this.uint16[m+6]=l,this.uint16[m+7]=u,this.int16[m+8]=c,this.int16[m+9]=p,this.int16[m+10]=f,this.int16[m+11]=y,e}};Mn.prototype.bytesPerElement=24;I("StructArrayLayout4i4ui4i24",Mn);var Ln=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(e,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,e,r,n)}emplace(e,r,n,i){let o=e*3;return this.float32[o+0]=r,this.float32[o+1]=n,this.float32[o+2]=i,e}};Ln.prototype.bytesPerElement=12;I("StructArrayLayout3f12",Ln);var Dn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer)}emplaceBack(e){let r=this.length;return this.resize(r+1),this.emplace(r,e)}emplace(e,r){let n=e*1;return this.uint32[n+0]=r,e}};Dn.prototype.bytesPerElement=4;I("StructArrayLayout1ul4",Dn);var Bn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o,a,s,l,u){let c=this.length;return this.resize(c+1),this.emplace(c,e,r,n,i,o,a,s,l,u)}emplace(e,r,n,i,o,a,s,l,u,c){let p=e*10,f=e*5;return this.int16[p+0]=r,this.int16[p+1]=n,this.int16[p+2]=i,this.int16[p+3]=o,this.int16[p+4]=a,this.int16[p+5]=s,this.uint32[f+3]=l,this.uint16[p+8]=u,this.uint16[p+9]=c,e}};Bn.prototype.bytesPerElement=20;I("StructArrayLayout6i1ul2ui20",Bn);var Vn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o,a){let s=this.length;return this.resize(s+1),this.emplace(s,e,r,n,i,o,a)}emplace(e,r,n,i,o,a,s){let l=e*6;return this.int16[l+0]=r,this.int16[l+1]=n,this.int16[l+2]=i,this.int16[l+3]=o,this.int16[l+4]=a,this.int16[l+5]=s,e}};Vn.prototype.bytesPerElement=12;I("StructArrayLayout2i2i2i12",Vn);var zo=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o){let a=this.length;return this.resize(a+1),this.emplace(a,e,r,n,i,o)}emplace(e,r,n,i,o,a){let s=e*4,l=e*8;return this.float32[s+0]=r,this.float32[s+1]=n,this.float32[s+2]=i,this.int16[l+6]=o,this.int16[l+7]=a,e}};zo.prototype.bytesPerElement=16;I("StructArrayLayout2f1f2i16",zo);var Rn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o,a){let s=this.length;return this.resize(s+1),this.emplace(s,e,r,n,i,o,a)}emplace(e,r,n,i,o,a,s){let l=e*16,u=e*4,c=e*8;return this.uint8[l+0]=r,this.uint8[l+1]=n,this.float32[u+1]=i,this.float32[u+2]=o,this.int16[c+6]=a,this.int16[c+7]=s,e}};Rn.prototype.bytesPerElement=16;I("StructArrayLayout2ub2f2i16",Rn);var zn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(e,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,e,r,n)}emplace(e,r,n,i){let o=e*3;return this.uint16[o+0]=r,this.uint16[o+1]=n,this.uint16[o+2]=i,e}};zn.prototype.bytesPerElement=6;I("StructArrayLayout3ui6",zn);var On=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o,a,s,l,u,c,p,f,y,m,h,g,d){let x=this.length;return this.resize(x+1),this.emplace(x,e,r,n,i,o,a,s,l,u,c,p,f,y,m,h,g,d)}emplace(e,r,n,i,o,a,s,l,u,c,p,f,y,m,h,g,d,x){let b=e*24,v=e*12,S=e*48;return this.int16[b+0]=r,this.int16[b+1]=n,this.uint16[b+2]=i,this.uint16[b+3]=o,this.uint32[v+2]=a,this.uint32[v+3]=s,this.uint32[v+4]=l,this.uint16[b+10]=u,this.uint16[b+11]=c,this.uint16[b+12]=p,this.float32[v+7]=f,this.float32[v+8]=y,this.uint8[S+36]=m,this.uint8[S+37]=h,this.uint8[S+38]=g,this.uint32[v+10]=d,this.int16[b+22]=x,e}};On.prototype.bytesPerElement=48;I("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48",On);var Gn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o,a,s,l,u,c,p,f,y,m,h,g,d,x,b,v,S,A,w,T,E,D,B,z){let M=this.length;return this.resize(M+1),this.emplace(M,e,r,n,i,o,a,s,l,u,c,p,f,y,m,h,g,d,x,b,v,S,A,w,T,E,D,B,z)}emplace(e,r,n,i,o,a,s,l,u,c,p,f,y,m,h,g,d,x,b,v,S,A,w,T,E,D,B,z,M){let _=e*32,V=e*16;return this.int16[_+0]=r,this.int16[_+1]=n,this.int16[_+2]=i,this.int16[_+3]=o,this.int16[_+4]=a,this.int16[_+5]=s,this.int16[_+6]=l,this.int16[_+7]=u,this.uint16[_+8]=c,this.uint16[_+9]=p,this.uint16[_+10]=f,this.uint16[_+11]=y,this.uint16[_+12]=m,this.uint16[_+13]=h,this.uint16[_+14]=g,this.uint16[_+15]=d,this.uint16[_+16]=x,this.uint16[_+17]=b,this.uint16[_+18]=v,this.uint16[_+19]=S,this.uint16[_+20]=A,this.uint16[_+21]=w,this.uint16[_+22]=T,this.uint32[V+12]=E,this.float32[V+13]=D,this.float32[V+14]=B,this.uint16[_+30]=z,this.uint16[_+31]=M,e}};Gn.prototype.bytesPerElement=64;I("StructArrayLayout8i15ui1ul2f2ui64",Gn);var nr=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(e){let r=this.length;return this.resize(r+1),this.emplace(r,e)}emplace(e,r){let n=e*1;return this.float32[n+0]=r,e}};nr.prototype.bytesPerElement=4;I("StructArrayLayout1f4",nr);var Nn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(e,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,e,r,n)}emplace(e,r,n,i){let o=e*6,a=e*3;return this.uint16[o+0]=r,this.float32[a+1]=n,this.float32[a+2]=i,e}};Nn.prototype.bytesPerElement=12;I("StructArrayLayout1ui2f12",Nn);var Un=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(e,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,e,r,n)}emplace(e,r,n,i){let o=e*2,a=e*4;return this.uint32[o+0]=r,this.uint16[a+2]=n,this.uint16[a+3]=i,e}};Un.prototype.bytesPerElement=8;I("StructArrayLayout1ul2ui8",Un);var $n=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(e,r){let n=this.length;return this.resize(n+1),this.emplace(n,e,r)}emplace(e,r,n){let i=e*2;return this.uint16[i+0]=r,this.uint16[i+1]=n,e}};$n.prototype.bytesPerElement=4;I("StructArrayLayout2ui4",$n);var Oo=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(e){let r=this.length;return this.resize(r+1),this.emplace(r,e)}emplace(e,r){let n=e*1;return this.uint16[n+0]=r,e}};Oo.prototype.bytesPerElement=2;I("StructArrayLayout1ui2",Oo);var Fr=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(e,r,n,i){let o=this.length;return this.resize(o+1),this.emplace(o,e,r,n,i)}emplace(e,r,n,i,o){let a=e*4;return this.float32[a+0]=r,this.float32[a+1]=n,this.float32[a+2]=i,this.float32[a+3]=o,e}};Fr.prototype.bytesPerElement=16;I("StructArrayLayout4f16",Fr);var Go=class extends Ft{get anchorPointX(){return this._structArray.int16[this._pos2+0]}get anchorPointY(){return this._structArray.int16[this._pos2+1]}get x1(){return this._structArray.int16[this._pos2+2]}get y1(){return this._structArray.int16[this._pos2+3]}get x2(){return this._structArray.int16[this._pos2+4]}get y2(){return this._structArray.int16[this._pos2+5]}get featureIndex(){return this._structArray.uint32[this._pos4+3]}get sourceLayerIndex(){return this._structArray.uint16[this._pos2+8]}get bucketIndex(){return this._structArray.uint16[this._pos2+9]}get anchorPoint(){return new np.default(this.anchorPointX,this.anchorPointY)}};Go.prototype.size=20;var jn=class extends Bn{get(e){return new Go(this,e)}};I("CollisionBoxArray",jn);var No=class extends Ft{get anchorX(){return this._structArray.int16[this._pos2+0]}get anchorY(){return this._structArray.int16[this._pos2+1]}get glyphStartIndex(){return this._structArray.uint16[this._pos2+2]}get numGlyphs(){return this._structArray.uint16[this._pos2+3]}get vertexStartIndex(){return this._structArray.uint32[this._pos4+2]}get lineStartIndex(){return this._structArray.uint32[this._pos4+3]}get lineLength(){return this._structArray.uint32[this._pos4+4]}get segment(){return this._structArray.uint16[this._pos2+10]}get lowerSize(){return this._structArray.uint16[this._pos2+11]}get upperSize(){return this._structArray.uint16[this._pos2+12]}get lineOffsetX(){return this._structArray.float32[this._pos4+7]}get lineOffsetY(){return this._structArray.float32[this._pos4+8]}get writingMode(){return this._structArray.uint8[this._pos1+36]}get placedOrientation(){return this._structArray.uint8[this._pos1+37]}set placedOrientation(e){this._structArray.uint8[this._pos1+37]=e}get hidden(){return this._structArray.uint8[this._pos1+38]}set hidden(e){this._structArray.uint8[this._pos1+38]=e}get crossTileID(){return this._structArray.uint32[this._pos4+10]}set crossTileID(e){this._structArray.uint32[this._pos4+10]=e}get associatedIconIndex(){return this._structArray.int16[this._pos2+22]}};No.prototype.size=48;var qn=class extends On{get(e){return new No(this,e)}};I("PlacedSymbolArray",qn);var Uo=class extends Ft{get anchorX(){return this._structArray.int16[this._pos2+0]}get anchorY(){return this._structArray.int16[this._pos2+1]}get rightJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+2]}get centerJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+3]}get leftJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+4]}get verticalPlacedTextSymbolIndex(){return this._structArray.int16[this._pos2+5]}get placedIconSymbolIndex(){return this._structArray.int16[this._pos2+6]}get verticalPlacedIconSymbolIndex(){return this._structArray.int16[this._pos2+7]}get key(){return this._structArray.uint16[this._pos2+8]}get textBoxStartIndex(){return this._structArray.uint16[this._pos2+9]}get textBoxEndIndex(){return this._structArray.uint16[this._pos2+10]}get verticalTextBoxStartIndex(){return this._structArray.uint16[this._pos2+11]}get verticalTextBoxEndIndex(){return this._structArray.uint16[this._pos2+12]}get iconBoxStartIndex(){return this._structArray.uint16[this._pos2+13]}get iconBoxEndIndex(){return this._structArray.uint16[this._pos2+14]}get verticalIconBoxStartIndex(){return this._structArray.uint16[this._pos2+15]}get verticalIconBoxEndIndex(){return this._structArray.uint16[this._pos2+16]}get featureIndex(){return this._structArray.uint16[this._pos2+17]}get numHorizontalGlyphVertices(){return this._structArray.uint16[this._pos2+18]}get numVerticalGlyphVertices(){return this._structArray.uint16[this._pos2+19]}get numIconVertices(){return this._structArray.uint16[this._pos2+20]}get numVerticalIconVertices(){return this._structArray.uint16[this._pos2+21]}get useRuntimeCollisionCircles(){return this._structArray.uint16[this._pos2+22]}get crossTileID(){return this._structArray.uint32[this._pos4+12]}set crossTileID(e){this._structArray.uint32[this._pos4+12]=e}get textBoxScale(){return this._structArray.float32[this._pos4+13]}get collisionCircleDiameter(){return this._structArray.float32[this._pos4+14]}get textAnchorOffsetStartIndex(){return this._structArray.uint16[this._pos2+30]}get textAnchorOffsetEndIndex(){return this._structArray.uint16[this._pos2+31]}};Uo.prototype.size=64;var Wn=class extends Gn{get(e){return new Uo(this,e)}};I("SymbolInstanceArray",Wn);var Xn=class extends nr{getoffsetX(e){return this.float32[e*1+0]}};I("GlyphOffsetArray",Xn);var Hn=class extends Cn{getx(e){return this.int16[e*3+0]}gety(e){return this.int16[e*3+1]}gettileUnitDistanceFromAnchor(e){return this.int16[e*3+2]}};I("SymbolLineVertexArray",Hn);var $o=class extends Ft{get textAnchor(){return this._structArray.uint16[this._pos2+0]}get textOffset0(){return this._structArray.float32[this._pos4+1]}get textOffset1(){return this._structArray.float32[this._pos4+2]}};$o.prototype.size=12;var Zn=class extends Nn{get(e){return new $o(this,e)}};I("TextAnchorOffsetArray",Zn);var jo=class extends Ft{get featureIndex(){return this._structArray.uint32[this._pos4+0]}get sourceLayerIndex(){return this._structArray.uint16[this._pos2+2]}get bucketIndex(){return this._structArray.uint16[this._pos2+3]}};jo.prototype.size=8;var Jn=class extends Un{get(e){return new jo(this,e)}};I("FeatureIndexArray",Jn);var qo=class extends rr{};var Wo=class extends rr{},Xo=class extends rr{},Ho=class extends kn{};var Zo=class extends Fn{},Jo=class extends Et{},yt=class extends En{},Yo=class extends Mn{},Ko=class extends Ln{},Qo=class extends Dn{},Yn=class extends Vn{};var ea=class extends Rn{};var Le=class extends zn{},Mt=class extends $n{};var Pg=Q([{name:"a_pos",components:2,type:"Int16"}],4);var{members:ip,size:kv,alignment:Fv}=Pg;var pe=class t{constructor(e=[]){this._forceNewSegmentOnNextPrepare=!1;this.segments=e}prepareSegment(e,r,n,i){let o=this.segments[this.segments.length-1];return e>t.MAX_VERTEX_ARRAY_LENGTH&&ce(`Max vertices per segment is ${t.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}. Consider using the \\`fillLargeMeshArrays\\` function if you require meshes with more than ${t.MAX_VERTEX_ARRAY_LENGTH} vertices.`),this._forceNewSegmentOnNextPrepare||!o||o.vertexLength+e>t.MAX_VERTEX_ARRAY_LENGTH||o.sortKey!==i?this.createNewSegment(r,n,i):o}createNewSegment(e,r,n){let i={vertexOffset:e.length,primitiveOffset:r.length,vertexLength:0,primitiveLength:0,vaos:{}};return n!==void 0&&(i.sortKey=n),this._forceNewSegmentOnNextPrepare=!1,this.segments.push(i),i}getOrCreateLatestSegment(e,r,n){return this.prepareSegment(0,e,r,n)}forceNewSegmentOnNextPrepare(){this._forceNewSegmentOnNextPrepare=!0}get(){return this.segments}destroy(){for(let e of this.segments)for(let r in e.vaos)e.vaos[r].destroy()}static simpleSegment(e,r,n,i){return new t([{vertexOffset:e,primitiveOffset:r,vertexLength:n,primitiveLength:i,vaos:{},sortKey:0}])}};pe.MAX_VERTEX_ARRAY_LENGTH=Math.pow(2,16)-1;I("SegmentVector",pe);function Qs(t,e){return t=it(Math.floor(t),0,255),e=it(Math.floor(e),0,255),256*t+e}var Kn=Q([{name:"a_pattern_from",components:4,type:"Uint16"},{name:"a_pattern_to",components:4,type:"Uint16"},{name:"a_pixel_ratio_from",components:1,type:"Uint16"},{name:"a_pixel_ratio_to",components:1,type:"Uint16"}]);var up=Y(rl(),1);var Qn=class t{constructor(){this.ids=[],this.positions=[],this.indexed=!1}add(e,r,n,i){this.ids.push(lp(e)),this.positions.push(r,n,i)}getPositions(e){if(!this.indexed)throw new Error("Trying to get index, but feature positions are not indexed");let r=lp(e),n=0,i=this.ids.length-1;for(;n<i;){let a=n+i>>1;this.ids[a]>=r?i=a:n=a+1}let o=[];for(;this.ids[n]===r;){let a=this.positions[3*n],s=this.positions[3*n+1],l=this.positions[3*n+2];o.push({index:a,start:s,end:l}),n++}return o}static serialize(e,r){let n=new Float64Array(e.ids),i=new Uint32Array(e.positions);return nl(n,i,0,n.length-1),r&&r.push(n.buffer,i.buffer),{ids:n,positions:i}}static deserialize(e){let r=new t;return r.ids=e.ids,r.positions=e.positions,r.indexed=!0,r}};function lp(t){let e=+t;return!isNaN(e)&&e<=Number.MAX_SAFE_INTEGER?e:(0,up.default)(String(t))}function nl(t,e,r,n){for(;r<n;){let i=t[r+n>>1],o=r-1,a=n+1;for(;;){do o++;while(t[o]<i);do a--;while(t[a]>i);if(o>=a)break;ra(t,o,a),ra(e,3*o,3*a),ra(e,3*o+1,3*a+1),ra(e,3*o+2,3*a+2)}a-r<n-a?(nl(t,e,r,a),r=a+1):(nl(t,e,a+1,n),n=a)}}function ra(t,e,r){let n=t[e];t[e]=t[r],t[r]=n}I("FeaturePositionMap",Qn);var ei=class{constructor(e,r){this.gl=e.gl,this.location=r}};var Er=class extends ei{constructor(e,r){super(e,r),this.current=0}set(e){this.current!==e&&(this.current=e,this.gl.uniform1f(this.location,e))}};var na=class extends ei{constructor(e,r){super(e,r),this.current=[0,0,0,0]}set(e){(e[0]!==this.current[0]||e[1]!==this.current[1]||e[2]!==this.current[2]||e[3]!==this.current[3])&&(this.current=e,this.gl.uniform4f(this.location,e[0],e[1],e[2],e[3]))}},ia=class extends ei{constructor(e,r){super(e,r),this.current=H.transparent}set(e){(e.r!==this.current.r||e.g!==this.current.g||e.b!==this.current.b||e.a!==this.current.a)&&(this.current=e,this.gl.uniform4f(this.location,e.r,e.g,e.b,e.a))}};var qv=new Float32Array(16);function il(t){return[Qs(255*t.r,255*t.g),Qs(255*t.b,255*t.a)]}var ir=class{constructor(e,r,n){this.value=e,this.uniformNames=r.map(i=>`u_${i}`),this.type=n}setUniform(e,r,n){e.set(n.constantOr(this.value))}getBinding(e,r,n){return this.type==="color"?new ia(e,r):new Er(e,r)}},Lt=class{constructor(e,r){this.uniformNames=r.map(n=>`u_${n}`),this.patternFrom=null,this.patternTo=null,this.pixelRatioFrom=1,this.pixelRatioTo=1}setConstantPatternPositions(e,r){this.pixelRatioFrom=r.pixelRatio,this.pixelRatioTo=e.pixelRatio,this.patternFrom=r.tlbr,this.patternTo=e.tlbr}setUniform(e,r,n,i){let o=i==="u_pattern_to"?this.patternTo:i==="u_pattern_from"?this.patternFrom:i==="u_pixel_ratio_to"?this.pixelRatioTo:i==="u_pixel_ratio_from"?this.pixelRatioFrom:null;o&&e.set(o)}getBinding(e,r,n){return n.substr(0,9)==="u_pattern"?new na(e,r):new Er(e,r)}},We=class{constructor(e,r,n,i){this.expression=e,this.type=n,this.maxValue=0,this.paintVertexAttributes=r.map(o=>({name:`a_${o}`,type:"Float32",components:n==="color"?2:1,offset:0})),this.paintVertexArray=new i}populatePaintArray(e,r,n,i,o){let a=this.paintVertexArray.length,s=this.expression.evaluate(new W(0),r,{},i,[],o);this.paintVertexArray.resize(e),this._setPaintValue(a,e,s)}updatePaintArray(e,r,n,i){let o=this.expression.evaluate({zoom:0},n,i);this._setPaintValue(e,r,o)}_setPaintValue(e,r,n){if(this.type==="color"){let i=il(n);for(let o=e;o<r;o++)this.paintVertexArray.emplace(o,i[0],i[1])}else{for(let i=e;i<r;i++)this.paintVertexArray.emplace(i,n);this.maxValue=Math.max(this.maxValue,Math.abs(n))}}upload(e){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=e.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent))}destroy(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy()}},De=class{constructor(e,r,n,i,o,a){this.expression=e,this.uniformNames=r.map(s=>`u_${s}_t`),this.type=n,this.useIntegerZoom=i,this.zoom=o,this.maxValue=0,this.paintVertexAttributes=r.map(s=>({name:`a_${s}`,type:"Float32",components:n==="color"?4:2,offset:0})),this.paintVertexArray=new a}populatePaintArray(e,r,n,i,o){let a=this.expression.evaluate(new W(this.zoom),r,{},i,[],o),s=this.expression.evaluate(new W(this.zoom+1),r,{},i,[],o),l=this.paintVertexArray.length;this.paintVertexArray.resize(e),this._setPaintValue(l,e,a,s)}updatePaintArray(e,r,n,i){let o=this.expression.evaluate({zoom:this.zoom},n,i),a=this.expression.evaluate({zoom:this.zoom+1},n,i);this._setPaintValue(e,r,o,a)}_setPaintValue(e,r,n,i){if(this.type==="color"){let o=il(n),a=il(i);for(let s=e;s<r;s++)this.paintVertexArray.emplace(s,o[0],o[1],a[0],a[1])}else{for(let o=e;o<r;o++)this.paintVertexArray.emplace(o,n,i);this.maxValue=Math.max(this.maxValue,Math.abs(n),Math.abs(i))}}upload(e){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=e.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent))}destroy(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy()}setUniform(e,r){let n=this.useIntegerZoom?Math.floor(r.zoom):r.zoom,i=it(this.expression.interpolationFactor(n,this.zoom,this.zoom+1),0,1);e.set(i)}getBinding(e,r,n){return new Er(e,r)}},Ye=class{constructor(e,r,n,i,o,a){this.expression=e,this.type=r,this.useIntegerZoom=n,this.zoom=i,this.layerId=a,this.zoomInPaintVertexArray=new o,this.zoomOutPaintVertexArray=new o}populatePaintArray(e,r,n){let i=this.zoomInPaintVertexArray.length;this.zoomInPaintVertexArray.resize(e),this.zoomOutPaintVertexArray.resize(e),this._setPaintValues(i,e,r.patterns&&r.patterns[this.layerId],n)}updatePaintArray(e,r,n,i,o){this._setPaintValues(e,r,n.patterns&&n.patterns[this.layerId],o)}_setPaintValues(e,r,n,i){if(!i||!n)return;let{min:o,mid:a,max:s}=n,l=i[o],u=i[a],c=i[s];if(!(!l||!u||!c))for(let p=e;p<r;p++)this.zoomInPaintVertexArray.emplace(p,u.tl[0],u.tl[1],u.br[0],u.br[1],l.tl[0],l.tl[1],l.br[0],l.br[1],u.pixelRatio,l.pixelRatio),this.zoomOutPaintVertexArray.emplace(p,u.tl[0],u.tl[1],u.br[0],u.br[1],c.tl[0],c.tl[1],c.br[0],c.br[1],u.pixelRatio,c.pixelRatio)}upload(e){this.zoomInPaintVertexArray&&this.zoomInPaintVertexArray.arrayBuffer&&this.zoomOutPaintVertexArray&&this.zoomOutPaintVertexArray.arrayBuffer&&(this.zoomInPaintVertexBuffer=e.createVertexBuffer(this.zoomInPaintVertexArray,Kn.members,this.expression.isStateDependent),this.zoomOutPaintVertexBuffer=e.createVertexBuffer(this.zoomOutPaintVertexArray,Kn.members,this.expression.isStateDependent))}destroy(){this.zoomOutPaintVertexBuffer&&this.zoomOutPaintVertexBuffer.destroy(),this.zoomInPaintVertexBuffer&&this.zoomInPaintVertexBuffer.destroy()}},oa=class{constructor(e,r,n){this.binders={},this._buffers=[];let i=[];for(let o in e.paint._values){if(!n(o))continue;let a=e.paint.get(o);if(!(a instanceof ge)||!It(a.property.specification))continue;let s=_g(o,e.type),l=a.value,u=a.property.specification.type,c=a.property.useIntegerZoom,p=a.property.specification["property-type"],f=p==="cross-faded"||p==="cross-faded-data-driven";if(l.kind==="constant")this.binders[o]=f?new Lt(l.value,s):new ir(l.value,s,u),i.push(`/u_${o}`);else if(l.kind==="source"||f){let y=cp(o,u,"source");this.binders[o]=f?new Ye(l,u,c,r,y,e.id):new We(l,s,u,y),i.push(`/a_${o}`)}else{let y=cp(o,u,"composite");this.binders[o]=new De(l,s,u,c,r,y),i.push(`/z_${o}`)}}this.cacheKey=i.sort().join("")}getMaxValue(e){let r=this.binders[e];return r instanceof We||r instanceof De?r.maxValue:0}populatePaintArrays(e,r,n,i,o){for(let a in this.binders){let s=this.binders[a];(s instanceof We||s instanceof De||s instanceof Ye)&&s.populatePaintArray(e,r,n,i,o)}}setConstantPatternPositions(e,r){for(let n in this.binders){let i=this.binders[n];i instanceof Lt&&i.setConstantPatternPositions(e,r)}}updatePaintArrays(e,r,n,i,o){let a=!1;for(let s in e){let l=r.getPositions(s);for(let u of l){let c=n.feature(u.index);for(let p in this.binders){let f=this.binders[p];if((f instanceof We||f instanceof De||f instanceof Ye)&&f.expression.isStateDependent===!0){let y=i.paint.get(p);f.expression=y.value,f.updatePaintArray(u.start,u.end,c,e[s],o),a=!0}}}}return a}defines(){let e=[];for(let r in this.binders){let n=this.binders[r];(n instanceof ir||n instanceof Lt)&&e.push(...n.uniformNames.map(i=>`#define HAS_UNIFORM_${i}`))}return e}getBinderAttributes(){let e=[];for(let r in this.binders){let n=this.binders[r];if(n instanceof We||n instanceof De)for(let i=0;i<n.paintVertexAttributes.length;i++)e.push(n.paintVertexAttributes[i].name);else if(n instanceof Ye)for(let i=0;i<Kn.members.length;i++)e.push(Kn.members[i].name)}return e}getBinderUniforms(){let e=[];for(let r in this.binders){let n=this.binders[r];if(n instanceof ir||n instanceof Lt||n instanceof De)for(let i of n.uniformNames)e.push(i)}return e}getPaintVertexBuffers(){return this._buffers}getUniforms(e,r){let n=[];for(let i in this.binders){let o=this.binders[i];if(o instanceof ir||o instanceof Lt||o instanceof De){for(let a of o.uniformNames)if(r[a]){let s=o.getBinding(e,r[a],a);n.push({name:a,property:i,binding:s})}}}return n}setUniforms(e,r,n,i){for(let{name:o,property:a,binding:s}of r)this.binders[a].setUniform(s,i,n.get(a),o)}updatePaintBuffers(e){this._buffers=[];for(let r in this.binders){let n=this.binders[r];if(e&&n instanceof Ye){let i=e.fromScale===2?n.zoomInPaintVertexBuffer:n.zoomOutPaintVertexBuffer;i&&this._buffers.push(i)}else(n instanceof We||n instanceof De)&&n.paintVertexBuffer&&this._buffers.push(n.paintVertexBuffer)}}upload(e){for(let r in this.binders){let n=this.binders[r];(n instanceof We||n instanceof De||n instanceof Ye)&&n.upload(e)}this.updatePaintBuffers()}destroy(){for(let e in this.binders){let r=this.binders[e];(r instanceof We||r instanceof De||r instanceof Ye)&&r.destroy()}}},Ae=class{constructor(e,r,n=()=>!0){this.programConfigurations={};for(let i of e)this.programConfigurations[i.id]=new oa(i,r,n);this.needsUpload=!1,this._featureMap=new Qn,this._bufferOffset=0}populatePaintArrays(e,r,n,i,o,a){for(let s in this.programConfigurations)this.programConfigurations[s].populatePaintArrays(e,r,i,o,a);r.id!==void 0&&this._featureMap.add(r.id,n,this._bufferOffset,e),this._bufferOffset=e,this.needsUpload=!0}updatePaintArrays(e,r,n,i){for(let o of n)this.needsUpload=this.programConfigurations[o.id].updatePaintArrays(e,this._featureMap,r,o,i)||this.needsUpload}get(e){return this.programConfigurations[e]}upload(e){if(this.needsUpload){for(let r in this.programConfigurations)this.programConfigurations[r].upload(e);this.needsUpload=!1}}destroy(){for(let e in this.programConfigurations)this.programConfigurations[e].destroy()}};function _g(t,e){return{"text-opacity":["opacity"],"icon-opacity":["opacity"],"text-color":["fill_color"],"icon-color":["fill_color"],"text-halo-color":["halo_color"],"icon-halo-color":["halo_color"],"text-halo-blur":["halo_blur"],"icon-halo-blur":["halo_blur"],"text-halo-width":["halo_width"],"icon-halo-width":["halo_width"],"line-gap-width":["gapwidth"],"line-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"],"fill-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"],"fill-extrusion-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"]}[t]||[t.replace(`${e}-`,"").replace(/-/g,"_")]}function Ig(t){return{"line-pattern":{source:yt,composite:yt},"fill-pattern":{source:yt,composite:yt},"fill-extrusion-pattern":{source:yt,composite:yt}}[t]}function cp(t,e,r){let n={color:{source:Et,composite:Fr},number:{source:nr,composite:Et}},i=Ig(t);return i&&i[r]||n[e][r]}I("ConstantBinder",ir);I("CrossFadedConstantBinder",Lt);I("SourceExpressionBinder",We);I("CrossFadedCompositeBinder",Ye);I("CompositeExpressionBinder",De);I("ProgramConfiguration",oa,{omit:["_buffers"]});I("ProgramConfigurationSet",Ae);var Tg=15,ol=Math.pow(2,Tg-1)-1,pp=-ol-1;function _e(t){let e=8192/t.extent,r=t.loadGeometry();for(let n=0;n<r.length;n++){let i=r[n];for(let o=0;o<i.length;o++){let a=i[o],s=Math.round(a.x*e),l=Math.round(a.y*e);a.x=it(s,pp,ol),a.y=it(l,pp,ol),(s<a.x||s>a.x+1||l<a.y||l>a.y+1)&&ce("Geometry exceeds allowed extent, reduce your vector tile buffer size")}}return r}function Ne(t,e){return{type:t.type,id:t.id,properties:t.properties,geometry:e?_e(t):[]}}var fp=-32768;function Cg(t,e,r,n,i){t.emplaceBack(fp+e*8+n,fp+r*8+i)}var or=class{constructor(e){this.zoom=e.zoom,this.globalState=e.globalState,this.overscaling=e.overscaling,this.layers=e.layers,this.layerIds=this.layers.map(r=>r.id),this.index=e.index,this.hasPattern=!1,this.layoutVertexArray=new Wo,this.indexArray=new Le,this.segments=new pe,this.programConfigurations=new Ae(e.layers,e.zoom),this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(e,r,n){let i=this.layers[0],o=[],a=null,s=!1,l=i.type==="heatmap";if(i.type==="circle"){let c=i;a=c.layout.get("circle-sort-key"),s=!a.isConstant(),l=l||c.paint.get("circle-pitch-alignment")==="map"}let u=l?r.subdivisionGranularity.circle:1;for(let{feature:c,id:p,index:f,sourceLayerIndex:y}of e){let m=this.layers[0]._featureFilter.needGeometry,h=Ne(c,m);if(!this.layers[0]._featureFilter.filter(new W(this.zoom,{globalState:this.globalState}),h,n))continue;let g=s?a.evaluate(h,{},n):void 0,d={id:p,properties:c.properties,type:c.type,sourceLayerIndex:y,index:f,geometry:m?h.geometry:_e(c),patterns:{},sortKey:g};o.push(d)}s&&o.sort((c,p)=>c.sortKey-p.sortKey);for(let c of o){let{geometry:p,index:f,sourceLayerIndex:y}=c,m=e[f].feature;this.addFeature(c,p,f,n,u),r.featureIndex.insert(m,p,f,y,this.index)}}update(e,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(e,r,this.stateDependentLayers,n)}isEmpty(){return this.layoutVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(e){this.uploaded||(this.layoutVertexBuffer=e.createVertexBuffer(this.layoutVertexArray,ip),this.indexBuffer=e.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(e),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy())}addFeature(e,r,n,i,o=1){let a;switch(o){case 1:a=[0,7];break;case 3:a=[0,2,5,7];break;case 5:a=[0,1,3,4,6,7];break;case 7:a=[0,1,2,3,4,5,6,7];break;default:throw new Error(`Invalid circle bucket granularity: ${o}; valid values are 1, 3, 5, 7.`)}let s=a.length;for(let l of r)for(let u of l){let c=u.x,p=u.y;if(c<0||c>=8192||p<0||p>=8192)continue;let f=this.segments.prepareSegment(s*s,this.layoutVertexArray,this.indexArray,e.sortKey),y=f.vertexLength;for(let m=0;m<s;m++)for(let h=0;h<s;h++)Cg(this.layoutVertexArray,c,p,a[h],a[m]);for(let m=0;m<s-1;m++)for(let h=0;h<s-1;h++){let g=y+m*s+h,d=y+(m+1)*s+h;this.indexArray.emplaceBack(g,d+1,g+1),this.indexArray.emplaceBack(g,d,d+1)}f.vertexLength+=s*s,f.primitiveLength+=(s-1)*(s-1)*2}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,e,n,{},i)}};I("CircleBucket",or,{omit:["layers"]});var ti=Y(ye(),1);function mp(t,e){for(let r=0;r<t.length;r++)if(Mr(e,t[r]))return!0;for(let r=0;r<e.length;r++)if(Mr(t,e[r]))return!0;return!!sl(t,e)}function hp(t,e,r){return!!(Mr(t,e)||al(e,t,r))}function aa(t,e){if(t.length===1)return yp(e,t[0]);for(let r=0;r<e.length;r++){let n=e[r];for(let i=0;i<n.length;i++)if(Mr(t,n[i]))return!0}for(let r=0;r<t.length;r++)if(yp(e,t[r]))return!0;for(let r=0;r<e.length;r++)if(sl(t,e[r]))return!0;return!1}function dp(t,e,r){for(let n=0;n<e.length;n++){let i=e[n];if(t.length>=3){for(let o=0;o<i.length;o++)if(Mr(t,i[o]))return!0}if(kg(t,i,r))return!0}return!1}function kg(t,e,r){if(t.length>1){if(sl(t,e))return!0;for(let n=0;n<e.length;n++)if(al(e[n],t,r))return!0}for(let n=0;n<t.length;n++)if(al(t[n],e,r))return!0;return!1}function sl(t,e){if(t.length===0||e.length===0)return!1;for(let r=0;r<t.length-1;r++){let n=t[r],i=t[r+1];for(let o=0;o<e.length-1;o++){let a=e[o],s=e[o+1];if(Fg(n,i,a,s))return!0}}return!1}function Fg(t,e,r,n){return ot(t,r,n)!==ot(e,r,n)&&ot(t,e,r)!==ot(t,e,n)}function al(t,e,r){let n=r*r;if(e.length===1)return t.distSqr(e[0])<n;for(let i=1;i<e.length;i++){let o=e[i-1],a=e[i];if(ll(t,o,a)<n)return!0}return!1}function ll(t,e,r){let n=e.distSqr(r);if(n===0)return t.distSqr(e);let i=((t.x-e.x)*(r.x-e.x)+(t.y-e.y)*(r.y-e.y))/n;return i<0?t.distSqr(e):i>1?t.distSqr(r):t.distSqr(r.sub(e)._mult(i)._add(e))}function yp(t,e){let r=!1,n,i,o;for(let a=0;a<t.length;a++){n=t[a];for(let s=0,l=n.length-1;s<n.length;l=s++)i=n[s],o=n[l],i.y>e.y!=o.y>e.y&&e.x<(o.x-i.x)*(e.y-i.y)/(o.y-i.y)+i.x&&(r=!r)}return r}function Mr(t,e){let r=!1;for(let n=0,i=t.length-1;n<t.length;i=n++){let o=t[n],a=t[i];o.y>e.y!=a.y>e.y&&e.x<(a.x-o.x)*(e.y-o.y)/(a.y-o.y)+o.x&&(r=!r)}return r}function gp(t,e,r,n,i){for(let a of t)if(e<=a.x&&r<=a.y&&n>=a.x&&i>=a.y)return!0;let o=[new ti.default(e,r),new ti.default(e,i),new ti.default(n,i),new ti.default(n,r)];if(t.length>2){for(let a of o)if(Mr(t,a))return!0}for(let a=0;a<t.length-1;a++){let s=t[a],l=t[a+1];if(Eg(s,l,o))return!0}return!1}function Eg(t,e,r){let n=r[0],i=r[2];if(t.x<n.x&&e.x<n.x||t.x>i.x&&e.x>i.x||t.y<n.y&&e.y<n.y||t.y>i.y&&e.y>i.y)return!1;let o=ot(t,e,r[0]);return o!==ot(t,e,r[1])||o!==ot(t,e,r[2])||o!==ot(t,e,r[3])}var sa=Y(ye(),1);function ar(t,e,r){let n=e.paint.get(t).value;return n.kind==="constant"?n.value:r.programConfigurations.get(e.id).getMaxValue(t)}function Dt(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1])}function Bt(t,e,r,n,i){if(!e[0]&&!e[1])return t;let o=sa.default.convert(e)._mult(i);r==="viewport"&&o._rotate(-n);let a=[];for(let s=0;s<t.length;s++){let l=t[s];a.push(l.sub(o))}return a}function bp(t,e){let r=[];for(let n=0;n<t.length;n++){let i=t[n],o=[];for(let a=0;a<i.length;a++){let s=i[a-1],l=i[a],u=i[a+1],c=a===0?new sa.default(0,0):l.sub(s)._unit()._perp(),p=a===i.length-1?new sa.default(0,0):u.sub(l)._unit()._perp(),f=c._add(p)._unit(),y=f.x*p.x+f.y*p.y;y!==0&&f._mult(1/y),o.push(f._mult(e)._add(l))}r.push(o)}return r}var xp,Mg=()=>xp=xp||new ee({"circle-sort-key":new L(P.layout_circle["circle-sort-key"])}),vp,Lg=()=>vp=vp||new ee({"circle-radius":new L(P.paint_circle["circle-radius"]),"circle-color":new L(P.paint_circle["circle-color"]),"circle-blur":new L(P.paint_circle["circle-blur"]),"circle-opacity":new L(P.paint_circle["circle-opacity"]),"circle-translate":new F(P.paint_circle["circle-translate"]),"circle-translate-anchor":new F(P.paint_circle["circle-translate-anchor"]),"circle-pitch-scale":new F(P.paint_circle["circle-pitch-scale"]),"circle-pitch-alignment":new F(P.paint_circle["circle-pitch-alignment"]),"circle-stroke-width":new L(P.paint_circle["circle-stroke-width"]),"circle-stroke-color":new L(P.paint_circle["circle-stroke-color"]),"circle-stroke-opacity":new L(P.paint_circle["circle-stroke-opacity"])}),Pp={get paint(){return Lg()},get layout(){return Mg()}};var Sp=Y(ye(),1);var la=class extends oe{constructor(e){super(e,Pp)}createBucket(e){return new or(e)}queryRadius(e){let r=e;return ar("circle-radius",this,r)+ar("circle-stroke-width",this,r)+Dt(this.paint.get("circle-translate"))}queryIntersectsFeature({queryGeometry:e,feature:r,featureState:n,geometry:i,transform:o,pixelsToTileUnits:a,unwrappedTileID:s,getElevation:l}){let u=Bt(e,this.paint.get("circle-translate"),this.paint.get("circle-translate-anchor"),-o.bearingInRadians,a),c=this.paint.get("circle-radius").evaluate(r,n),p=this.paint.get("circle-stroke-width").evaluate(r,n),f=c+p,y=this.paint.get("circle-pitch-alignment")==="map",m=y?u:Dg(u,o,s,l),h=y?f*a:f;for(let g of i)for(let d of g){let x=y?d:wp(d,o,s,l),b=h,v=o.projectTileCoordinates(d.x,d.y,s,l).signedDistanceFromCamera;if(this.paint.get("circle-pitch-scale")==="viewport"&&this.paint.get("circle-pitch-alignment")==="map"?b*=v/o.cameraToCenterDistance:this.paint.get("circle-pitch-scale")==="map"&&this.paint.get("circle-pitch-alignment")==="viewport"&&(b*=o.cameraToCenterDistance/v),hp(m,x,b))return!0}return!1}};function wp(t,e,r,n){let i=e.projectTileCoordinates(t.x,t.y,r,n).point;return new Sp.default((i.x*.5+.5)*e.width,(-i.y*.5+.5)*e.height)}function Dg(t,e,r,n){return t.map(i=>wp(i,e,r,n))}var ri=class extends or{};I("HeatmapBucket",ri,{omit:["layers"]});var Ap,Bg=()=>Ap=Ap||new ee({"heatmap-radius":new L(P.paint_heatmap["heatmap-radius"]),"heatmap-weight":new L(P.paint_heatmap["heatmap-weight"]),"heatmap-intensity":new F(P.paint_heatmap["heatmap-intensity"]),"heatmap-color":new ft(P.paint_heatmap["heatmap-color"]),"heatmap-opacity":new F(P.paint_heatmap["heatmap-opacity"])}),_p={get paint(){return Bg()}};function ul(t,{width:e,height:r},n,i){if(!i)i=new Uint8Array(e*r*n);else if(i instanceof Uint8ClampedArray)i=new Uint8Array(i.buffer);else if(i.length!==e*r*n)throw new RangeError(`mismatched image size. expected: ${i.length} but got: ${e*r*n}`);return t.width=e,t.height=r,t.data=i,t}function Ip(t,{width:e,height:r},n){if(e===t.width&&r===t.height)return;let i=ul({},{width:e,height:r},n);cl(t,i,{x:0,y:0},{x:0,y:0},{width:Math.min(t.width,e),height:Math.min(t.height,r)},n),t.width=e,t.height=r,t.data=i.data}function cl(t,e,r,n,i,o){if(i.width===0||i.height===0)return e;if(i.width>t.width||i.height>t.height||r.x>t.width-i.width||r.y>t.height-i.height)throw new RangeError("out of range source coordinates for image copy");if(i.width>e.width||i.height>e.height||n.x>e.width-i.width||n.y>e.height-i.height)throw new RangeError("out of range destination coordinates for image copy");let a=t.data,s=e.data;if(a===s)throw new Error("srcData equals dstData, so image is already copied");for(let l=0;l<i.height;l++){let u=((r.y+l)*t.width+r.x)*o,c=((n.y+l)*e.width+n.x)*o;for(let p=0;p<i.width*o;p++)s[c+p]=a[u+p]}return e}var sr=class t{constructor(e,r){ul(this,e,1,r)}resize(e){Ip(this,e,1)}clone(){return new t({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(e,r,n,i,o){cl(e,r,n,i,o,1)}},fe=class t{constructor(e,r){ul(this,e,4,r)}resize(e){Ip(this,e,4)}replace(e,r){r?this.data.set(e):e instanceof Uint8ClampedArray?this.data=new Uint8Array(e.buffer):this.data=e}clone(){return new t({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(e,r,n,i,o){cl(e,r,n,i,o,4)}setPixel(e,r,n){let i=(e*this.width+r)*4;this.data[i+0]=Math.round(n.r*255/n.a),this.data[i+1]=Math.round(n.g*255/n.a),this.data[i+2]=Math.round(n.b*255/n.a),this.data[i+3]=Math.round(n.a*255)}};I("AlphaImage",sr);I("RGBAImage",fe);function Tp(t){let e={},r=t.resolution||256,n=t.clips?t.clips.length:1,i=t.image||new fe({width:r,height:n});if(!Au(r))throw new Error(`width is not a power of 2 - ${r}`);let o=(a,s,l)=>{e[t.evaluationKey]=l;let u=t.expression.evaluate(e);i.setPixel(a/4/r,s/4,u)};if(t.clips)for(let a=0,s=0;a<n;++a,s+=r*4)for(let l=0,u=0;l<r;l++,u+=4){let c=l/(r-1),{start:p,end:f}=t.clips[a],y=p*(1-c)+f*c;o(s,u,y)}else for(let a=0,s=0;a<r;a++,s+=4){let l=a/(r-1);o(0,s,l)}return i}var Cp="big-fb";var ua=class extends oe{createBucket(e){return new ri(e)}constructor(e){super(e,_p),this.heatmapFbos=new Map,this._updateColorRamp()}_handleSpecialPaintPropertyUpdate(e){e==="heatmap-color"&&this._updateColorRamp()}_updateColorRamp(){let e=this._transitionablePaint._values["heatmap-color"].value.expression;this.colorRamp=Tp({expression:e,evaluationKey:"heatmapDensity",image:this.colorRamp}),this.colorRampTexture=null}resize(){this.heatmapFbos.has(Cp)&&this.heatmapFbos.delete(Cp)}queryRadius(){return 0}queryIntersectsFeature(){return!1}hasOffscreenPass(){return this.paint.get("heatmap-opacity")!==0&&this.visibility!=="none"}};var kp,Vg=()=>kp=kp||new ee({"hillshade-illumination-direction":new F(P.paint_hillshade["hillshade-illumination-direction"]),"hillshade-illumination-altitude":new F(P.paint_hillshade["hillshade-illumination-altitude"]),"hillshade-illumination-anchor":new F(P.paint_hillshade["hillshade-illumination-anchor"]),"hillshade-exaggeration":new F(P.paint_hillshade["hillshade-exaggeration"]),"hillshade-shadow-color":new F(P.paint_hillshade["hillshade-shadow-color"]),"hillshade-highlight-color":new F(P.paint_hillshade["hillshade-highlight-color"]),"hillshade-accent-color":new F(P.paint_hillshade["hillshade-accent-color"]),"hillshade-method":new F(P.paint_hillshade["hillshade-method"])}),Fp={get paint(){return Vg()}};var ca=class extends oe{constructor(e){super(e,Fp),this.recalculate({zoom:0,zoomHistory:{}},void 0)}getIlluminationProperties(){let e=this.paint.get("hillshade-illumination-direction").values,r=this.paint.get("hillshade-illumination-altitude").values,n=this.paint.get("hillshade-highlight-color").values,i=this.paint.get("hillshade-shadow-color").values,o=Math.max(e.length,r.length,n.length,i.length);e=e.concat(Array(o-e.length).fill(e.at(-1))),r=r.concat(Array(o-r.length).fill(r.at(-1))),n=n.concat(Array(o-n.length).fill(n.at(-1))),i=i.concat(Array(o-i.length).fill(i.at(-1)));let a=r.map(cs);return{directionRadians:e.map(cs),altitudeRadians:a,shadowColor:i,highlightColor:n}}hasOffscreenPass(){return this.paint.get("hillshade-exaggeration")!==0&&this.visibility!=="none"}};var Ep,Rg=()=>Ep=Ep||new ee({"color-relief-opacity":new F(P["paint_color-relief"]["color-relief-opacity"]),"color-relief-color":new ft(P["paint_color-relief"]["color-relief-color"])}),Mp={get paint(){return Rg()}};var ni=class{constructor(e,r,n,i){this.context=e,this.format=n,this.texture=e.gl.createTexture(),this.update(r,i)}update(e,r,n){let{width:i,height:o}=e,a=(!this.size||this.size[0]!==i||this.size[1]!==o)&&!n,{context:s}=this,{gl:l}=s;if(this.useMipmap=!!(r&&r.useMipmap),l.bindTexture(l.TEXTURE_2D,this.texture),s.pixelStoreUnpackFlipY.set(!1),s.pixelStoreUnpack.set(1),s.pixelStoreUnpackPremultiplyAlpha.set(this.format===l.RGBA&&(!r||r.premultiply!==!1)),a)this.size=[i,o],e instanceof HTMLImageElement||e instanceof HTMLCanvasElement||e instanceof HTMLVideoElement||e instanceof ImageData||vt(e)?l.texImage2D(l.TEXTURE_2D,0,this.format,this.format,l.UNSIGNED_BYTE,e):l.texImage2D(l.TEXTURE_2D,0,this.format,i,o,0,this.format,l.UNSIGNED_BYTE,e.data);else{let{x:u,y:c}=n||{x:0,y:0};e instanceof HTMLImageElement||e instanceof HTMLCanvasElement||e instanceof HTMLVideoElement||e instanceof ImageData||vt(e)?l.texSubImage2D(l.TEXTURE_2D,0,u,c,l.RGBA,l.UNSIGNED_BYTE,e):l.texSubImage2D(l.TEXTURE_2D,0,u,c,i,o,l.RGBA,l.UNSIGNED_BYTE,e.data)}this.useMipmap&&this.isSizePowerOfTwo()&&l.generateMipmap(l.TEXTURE_2D),s.pixelStoreUnpackFlipY.setDefault(),s.pixelStoreUnpack.setDefault(),s.pixelStoreUnpackPremultiplyAlpha.setDefault()}bind(e,r,n){let{context:i}=this,{gl:o}=i;o.bindTexture(o.TEXTURE_2D,this.texture),n===o.LINEAR_MIPMAP_NEAREST&&!this.isSizePowerOfTwo()&&(n=o.LINEAR),e!==this.filter&&(o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MAG_FILTER,e),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MIN_FILTER,n||e),this.filter=e),r!==this.wrap&&(o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_S,r),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_T,r),this.wrap=r)}isSizePowerOfTwo(){return this.size[0]===this.size[1]&&Math.log(this.size[0])/Math.LN2%1===0}destroy(){let{gl:e}=this.context;e.deleteTexture(this.texture),this.texture=null}};var ii=class{constructor(e,r,n,i=1,o=1,a=1,s=0){if(this.uid=e,r.height!==r.width)throw new RangeError("DEM tiles must be square");if(n&&!["mapbox","terrarium","custom"].includes(n)){ce(`"${n}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);return}this.stride=r.height;let l=this.dim=r.height-2;switch(this.data=new Uint32Array(r.data.buffer),n){case"terrarium":this.redFactor=256,this.greenFactor=1,this.blueFactor=1/256,this.baseShift=32768;break;case"custom":this.redFactor=i,this.greenFactor=o,this.blueFactor=a,this.baseShift=s;break;case"mapbox":default:this.redFactor=6553.6,this.greenFactor=25.6,this.blueFactor=.1,this.baseShift=1e4;break}for(let u=0;u<l;u++)this.data[this._idx(-1,u)]=this.data[this._idx(0,u)],this.data[this._idx(l,u)]=this.data[this._idx(l-1,u)],this.data[this._idx(u,-1)]=this.data[this._idx(u,0)],this.data[this._idx(u,l)]=this.data[this._idx(u,l-1)];this.data[this._idx(-1,-1)]=this.data[this._idx(0,0)],this.data[this._idx(l,-1)]=this.data[this._idx(l-1,0)],this.data[this._idx(-1,l)]=this.data[this._idx(0,l-1)],this.data[this._idx(l,l)]=this.data[this._idx(l-1,l-1)],this.min=Number.MAX_SAFE_INTEGER,this.max=Number.MIN_SAFE_INTEGER;for(let u=0;u<l;u++)for(let c=0;c<l;c++){let p=this.get(u,c);p>this.max&&(this.max=p),p<this.min&&(this.min=p)}}get(e,r){let n=new Uint8Array(this.data.buffer),i=this._idx(e,r)*4;return this.unpack(n[i],n[i+1],n[i+2])}getUnpackVector(){return[this.redFactor,this.greenFactor,this.blueFactor,this.baseShift]}_idx(e,r){if(e<-1||e>=this.dim+1||r<-1||r>=this.dim+1)throw new RangeError("out of range source coordinates for DEM data");return(r+1)*this.stride+(e+1)}unpack(e,r,n){return e*this.redFactor+r*this.greenFactor+n*this.blueFactor-this.baseShift}pack(e){return pl(e,this.getUnpackVector())}getPixels(){return new fe({width:this.stride,height:this.stride},new Uint8Array(this.data.buffer))}backfillBorder(e,r,n){if(this.dim!==e.dim)throw new Error("dem dimension mismatch");let i=r*this.dim,o=r*this.dim+this.dim,a=n*this.dim,s=n*this.dim+this.dim;switch(r){case-1:i=o-1;break;case 1:o=i+1;break}switch(n){case-1:a=s-1;break;case 1:s=a+1;break}let l=-r*this.dim,u=-n*this.dim;for(let c=a;c<s;c++)for(let p=i;p<o;p++)this.data[this._idx(p,c)]=e.data[this._idx(p+l,c+u)]}};function pl(t,e){let r=e[0],n=e[1],i=e[2],o=e[3],a=Math.min(r,n,i),s=Math.round((t+o)/a);return{r:Math.floor(s*a/r)%256,g:Math.floor(s*a/n)%256,b:Math.floor(s*a/i)%256}}I("DEMData",ii);var pa=class extends oe{constructor(e){super(e,Mp)}_createColorRamp(e){let r={elevationStops:[],colorStops:[]},n=this._transitionablePaint._values["color-relief-color"].value.expression;if(n instanceof Je&&n._styleExpression.expression instanceof ke){this.colorRampExpression=n;let a=n._styleExpression.expression;r.elevationStops=a.labels,r.colorStops=[];for(let s of r.elevationStops)r.colorStops.push(a.evaluate({globals:{elevation:s}}))}if(r.elevationStops.length<1&&(r.elevationStops=[0],r.colorStops=[H.transparent]),r.elevationStops.length<2&&(r.elevationStops.push(r.elevationStops[0]+1),r.colorStops.push(r.colorStops[0])),r.elevationStops.length<=e)return r;let i={elevationStops:[],colorStops:[]},o=(r.elevationStops.length-1)/(e-1);for(let a=0;a<r.elevationStops.length-.5;a+=o)i.elevationStops.push(r.elevationStops[Math.round(a)]),i.colorStops.push(r.colorStops[Math.round(a)]);return ce(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`),i}_colorRampChanged(){return this.colorRampExpression!=this._transitionablePaint._values["color-relief-color"].value.expression}getColorRampTextures(e,r,n){if(this.colorRampTextures&&!this._colorRampChanged())return this.colorRampTextures;let i=this._createColorRamp(r),o=new fe({width:i.colorStops.length,height:1}),a=new fe({width:i.colorStops.length,height:1});for(let s=0;s<i.elevationStops.length;s++){let l=pl(i.elevationStops[s],n);a.setPixel(0,s,new H(l.r/255,l.g/255,l.b/255,1)),o.setPixel(0,s,i.colorStops[s])}return this.colorRampTextures={elevationTexture:new ni(e,a,e.gl.RGBA),colorTexture:new ni(e,o,e.gl.RGBA)},this.colorRampTextures}hasOffscreenPass(){return this.visibility!=="none"&&!!this.colorRampTextures}};var zg=Q([{name:"a_pos",components:2,type:"Int16"}],4);var{members:Lp,size:U1,alignment:$1}=zg;function Lr(t,e,r){let n=r.patternDependencies,i=!1;for(let o of e){let a=o.paint.get(`${t}-pattern`);a.isConstant()||(i=!0);let s=a.constantOr(null);s&&(i=!0,n[s.to]=!0,n[s.from]=!0)}return i}function Dr(t,e,r,n,i){let o=i.patternDependencies;for(let a of e){let l=a.paint.get(`${t}-pattern`).value;if(l.kind!=="constant"){let u=l.evaluate({zoom:n-1},r,{},i.availableImages),c=l.evaluate({zoom:n},r,{},i.availableImages),p=l.evaluate({zoom:n+1},r,{},i.availableImages);u=u&&u.name?u.name:u,c=c&&c.name?c.name:c,p=p&&p.name?p.name:p,o[u]=!0,o[c]=!0,o[p]=!0,r.patterns[a.id]={min:u,mid:c,max:p}}}return r}var ci=Y(ye(),1);function ml(t,e,r=2){let n=e&&e.length,i=n?e[0]*r:t.length,o=Bp(t,0,i,r,!0),a=[];if(!o||o.next===o.prev)return a;let s,l,u;if(n&&(o=$g(t,e,o,r)),t.length>80*r){s=1/0,l=1/0;let c=-1/0,p=-1/0;for(let f=r;f<i;f+=r){let y=t[f],m=t[f+1];y<s&&(s=y),m<l&&(l=m),y>c&&(c=y),m>p&&(p=m)}u=Math.max(c-s,p-l),u=u!==0?32767/u:0}return ai(o,a,r,s,l,u,0),a}function Bp(t,e,r,n,i){let o;if(i===eb(t,e,r,n)>0)for(let a=e;a<r;a+=n)o=Dp(a/n|0,t[a],t[a+1],o);else for(let a=r-n;a>=e;a-=n)o=Dp(a/n|0,t[a],t[a+1],o);return o&&Br(o,o.next)&&(li(o),o=o.next),o}function lr(t,e){if(!t)return t;e||(e=t);let r=t,n;do if(n=!1,!r.steiner&&(Br(r,r.next)||se(r.prev,r,r.next)===0)){if(li(r),r=e=r.prev,r===r.next)break;n=!0}else r=r.next;while(n||r!==e);return e}function ai(t,e,r,n,i,o,a){if(!t)return;!a&&o&&Hg(t,n,i,o);let s=t;for(;t.prev!==t.next;){let l=t.prev,u=t.next;if(o?Gg(t,n,i,o):Og(t)){e.push(l.i,t.i,u.i),li(t),t=u.next,s=u.next;continue}if(t=u,t===s){a?a===1?(t=Ng(lr(t),e),ai(t,e,r,n,i,o,2)):a===2&&Ug(t,e,r,n,i,o):ai(lr(t),e,r,n,i,o,1);break}}}function Og(t){let e=t.prev,r=t,n=t.next;if(se(e,r,n)>=0)return!1;let i=e.x,o=r.x,a=n.x,s=e.y,l=r.y,u=n.y,c=Math.min(i,o,a),p=Math.min(s,l,u),f=Math.max(i,o,a),y=Math.max(s,l,u),m=n.next;for(;m!==e;){if(m.x>=c&&m.x<=f&&m.y>=p&&m.y<=y&&oi(i,s,o,l,a,u,m.x,m.y)&&se(m.prev,m,m.next)>=0)return!1;m=m.next}return!0}function Gg(t,e,r,n){let i=t.prev,o=t,a=t.next;if(se(i,o,a)>=0)return!1;let s=i.x,l=o.x,u=a.x,c=i.y,p=o.y,f=a.y,y=Math.min(s,l,u),m=Math.min(c,p,f),h=Math.max(s,l,u),g=Math.max(c,p,f),d=fl(y,m,e,r,n),x=fl(h,g,e,r,n),b=t.prevZ,v=t.nextZ;for(;b&&b.z>=d&&v&&v.z<=x;){if(b.x>=y&&b.x<=h&&b.y>=m&&b.y<=g&&b!==i&&b!==a&&oi(s,c,l,p,u,f,b.x,b.y)&&se(b.prev,b,b.next)>=0||(b=b.prevZ,v.x>=y&&v.x<=h&&v.y>=m&&v.y<=g&&v!==i&&v!==a&&oi(s,c,l,p,u,f,v.x,v.y)&&se(v.prev,v,v.next)>=0))return!1;v=v.nextZ}for(;b&&b.z>=d;){if(b.x>=y&&b.x<=h&&b.y>=m&&b.y<=g&&b!==i&&b!==a&&oi(s,c,l,p,u,f,b.x,b.y)&&se(b.prev,b,b.next)>=0)return!1;b=b.prevZ}for(;v&&v.z<=x;){if(v.x>=y&&v.x<=h&&v.y>=m&&v.y<=g&&v!==i&&v!==a&&oi(s,c,l,p,u,f,v.x,v.y)&&se(v.prev,v,v.next)>=0)return!1;v=v.nextZ}return!0}function Ng(t,e){let r=t;do{let n=r.prev,i=r.next.next;!Br(n,i)&&Rp(n,r,r.next,i)&&si(n,i)&&si(i,n)&&(e.push(n.i,r.i,i.i),li(r),li(r.next),r=t=i),r=r.next}while(r!==t);return lr(r)}function Ug(t,e,r,n,i,o){let a=t;do{let s=a.next.next;for(;s!==a.prev;){if(a.i!==s.i&&Yg(a,s)){let l=zp(a,s);a=lr(a,a.next),l=lr(l,l.next),ai(a,e,r,n,i,o,0),ai(l,e,r,n,i,o,0);return}s=s.next}a=a.next}while(a!==t)}function $g(t,e,r,n){let i=[];for(let o=0,a=e.length;o<a;o++){let s=e[o]*n,l=o<a-1?e[o+1]*n:t.length,u=Bp(t,s,l,n,!1);u===u.next&&(u.steiner=!0),i.push(Jg(u))}i.sort(jg);for(let o=0;o<i.length;o++)r=qg(i[o],r);return r}function jg(t,e){let r=t.x-e.x;if(r===0&&(r=t.y-e.y,r===0)){let n=(t.next.y-t.y)/(t.next.x-t.x),i=(e.next.y-e.y)/(e.next.x-e.x);r=n-i}return r}function qg(t,e){let r=Wg(t,e);if(!r)return e;let n=zp(r,t);return lr(n,n.next),lr(r,r.next)}function Wg(t,e){let r=e,n=t.x,i=t.y,o=-1/0,a;if(Br(t,r))return r;do{if(Br(t,r.next))return r.next;if(i<=r.y&&i>=r.next.y&&r.next.y!==r.y){let p=r.x+(i-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(p<=n&&p>o&&(o=p,a=r.x<r.next.x?r:r.next,p===n))return a}r=r.next}while(r!==e);if(!a)return null;let s=a,l=a.x,u=a.y,c=1/0;r=a;do{if(n>=r.x&&r.x>=l&&n!==r.x&&Vp(i<u?n:o,i,l,u,i<u?o:n,i,r.x,r.y)){let p=Math.abs(i-r.y)/(n-r.x);si(r,t)&&(p<c||p===c&&(r.x>a.x||r.x===a.x&&Xg(a,r)))&&(a=r,c=p)}r=r.next}while(r!==s);return a}function Xg(t,e){return se(t.prev,t,e.prev)<0&&se(e.next,t,t.next)<0}function Hg(t,e,r,n){let i=t;do i.z===0&&(i.z=fl(i.x,i.y,e,r,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,Zg(i)}function Zg(t){let e,r=1;do{let n=t,i;t=null;let o=null;for(e=0;n;){e++;let a=n,s=0;for(let u=0;u<r&&(s++,a=a.nextZ,!!a);u++);let l=r;for(;s>0||l>0&&a;)s!==0&&(l===0||!a||n.z<=a.z)?(i=n,n=n.nextZ,s--):(i=a,a=a.nextZ,l--),o?o.nextZ=i:t=i,i.prevZ=o,o=i;n=a}o.nextZ=null,r*=2}while(e>1);return t}function fl(t,e,r,n,i){return t=(t-r)*i|0,e=(e-n)*i|0,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,t|e<<1}function Jg(t){let e=t,r=t;do(e.x<r.x||e.x===r.x&&e.y<r.y)&&(r=e),e=e.next;while(e!==t);return r}function Vp(t,e,r,n,i,o,a,s){return(i-a)*(e-s)>=(t-a)*(o-s)&&(t-a)*(n-s)>=(r-a)*(e-s)&&(r-a)*(o-s)>=(i-a)*(n-s)}function oi(t,e,r,n,i,o,a,s){return!(t===a&&e===s)&&Vp(t,e,r,n,i,o,a,s)}function Yg(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!Kg(t,e)&&(si(t,e)&&si(e,t)&&Qg(t,e)&&(se(t.prev,t,e.prev)||se(t,e.prev,e))||Br(t,e)&&se(t.prev,t,t.next)>0&&se(e.prev,e,e.next)>0)}function se(t,e,r){return(e.y-t.y)*(r.x-e.x)-(e.x-t.x)*(r.y-e.y)}function Br(t,e){return t.x===e.x&&t.y===e.y}function Rp(t,e,r,n){let i=ya(se(t,e,r)),o=ya(se(t,e,n)),a=ya(se(r,n,t)),s=ya(se(r,n,e));return!!(i!==o&&a!==s||i===0&&fa(t,r,e)||o===0&&fa(t,n,e)||a===0&&fa(r,t,n)||s===0&&fa(r,e,n))}function fa(t,e,r){return e.x<=Math.max(t.x,r.x)&&e.x>=Math.min(t.x,r.x)&&e.y<=Math.max(t.y,r.y)&&e.y>=Math.min(t.y,r.y)}function ya(t){return t>0?1:t<0?-1:0}function Kg(t,e){let r=t;do{if(r.i!==t.i&&r.next.i!==t.i&&r.i!==e.i&&r.next.i!==e.i&&Rp(r,r.next,t,e))return!0;r=r.next}while(r!==t);return!1}function si(t,e){return se(t.prev,t,t.next)<0?se(t,e,t.next)>=0&&se(t,t.prev,e)>=0:se(t,e,t.prev)<0||se(t,t.next,e)<0}function Qg(t,e){let r=t,n=!1,i=(t.x+e.x)/2,o=(t.y+e.y)/2;do r.y>o!=r.next.y>o&&r.next.y!==r.y&&i<(r.next.x-r.x)*(o-r.y)/(r.next.y-r.y)+r.x&&(n=!n),r=r.next;while(r!==t);return n}function zp(t,e){let r=yl(t.i,t.x,t.y),n=yl(e.i,e.x,e.y),i=t.next,o=e.prev;return t.next=e,e.prev=t,r.next=i,i.prev=r,n.next=r,r.prev=n,o.next=n,n.prev=o,n}function Dp(t,e,r,n){let i=yl(t,e,r);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function li(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function yl(t,e,r){return{i:t,x:e,y:r,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}function eb(t,e,r,n){let i=0;for(let o=e,a=r-n;o<r;o+=n)i+=(t[a]-t[o])*(t[o+1]+t[a+1]),a=o;return i}var Vt=class{constructor(e,r){if(r>e)throw new Error("Min granularity must not be greater than base granularity.");this._baseZoomGranularity=e,this._minGranularity=r}getGranularityForZoomLevel(e){let r=1<<e;return Math.max(Math.floor(this._baseZoomGranularity/r),this._minGranularity,1)}},ha=class ha{constructor(e){this.fill=e.fill,this.line=e.line,this.tile=e.tile,this.stencil=e.stencil,this.circle=e.circle}};ha.noSubdivision=new ha({fill:new Vt(0,0),line:new Vt(0,0),tile:new Vt(0,0),stencil:new Vt(0,0),circle:1});var ma=ha;I("SubdivisionGranularityExpression",Vt);I("SubdivisionGranularitySetting",ma);var Vr=-32768,ui=32767,hl=class{constructor(e,r){this._vertexBuffer=[];this._vertexDictionary=new Map;this._used=!1;this._granularity=e,this._granularityCellSize=8192/e,this._canonical=r}_getKey(e,r){return e=e+32768,r=r+32768,e<<16|r<<0}_vertexToIndex(e,r){if(e<-32768||r<-32768||e>32767||r>32767)throw new Error("Vertex coordinates are out of signed 16 bit integer range.");let n=Math.round(e)|0,i=Math.round(r)|0,o=this._getKey(n,i);if(this._vertexDictionary.has(o))return this._vertexDictionary.get(o);let a=this._vertexBuffer.length/2;return this._vertexDictionary.set(o,a),this._vertexBuffer.push(n,i),a}_subdivideTrianglesScanline(e){if(this._granularity<2)return rb(this._vertexBuffer,e);let r=[],n=e.length;for(let i=0;i<n;i+=3){let o=[e[i+0],e[i+1],e[i+2]],a=[this._vertexBuffer[e[i+0]*2+0],this._vertexBuffer[e[i+0]*2+1],this._vertexBuffer[e[i+1]*2+0],this._vertexBuffer[e[i+1]*2+1],this._vertexBuffer[e[i+2]*2+0],this._vertexBuffer[e[i+2]*2+1]],s=1/0,l=1/0,u=-1/0,c=-1/0;for(let h=0;h<3;h++){let g=a[h*2],d=a[h*2+1];s=Math.min(s,g),u=Math.max(u,g),l=Math.min(l,d),c=Math.max(c,d)}if(s===u||l===c)continue;let p=Math.floor(s/this._granularityCellSize),f=Math.ceil(u/this._granularityCellSize),y=Math.floor(l/this._granularityCellSize),m=Math.ceil(c/this._granularityCellSize);if(p===f&&y===m){r.push(...o);continue}for(let h=y;h<m;h++){let g=this._scanlineGenerateVertexRingForCellRow(h,a,o);nb(this._vertexBuffer,g,r)}}return r}_scanlineGenerateVertexRingForCellRow(e,r,n){let i=e*this._granularityCellSize,o=i+this._granularityCellSize,a=[];for(let s=0;s<3;s++){let l=r[s*2],u=r[s*2+1],c=r[(s+1)*2%6],p=r[((s+1)*2+1)%6],f=r[(s+2)*2%6],y=r[((s+2)*2+1)%6],m=c-l,h=p-u,g=m===0,d=h===0,x=(i-u)/h,b=(o-u)/h,v=Math.min(x,b),S=Math.max(x,b);if(!d&&(v>=1||S<=0)||d&&(u<i||u>o)){p>=i&&p<=o&&a.push(n[(s+1)%3]);continue}if(!d&&v>0){let T=l+m*v,E=u+h*v;a.push(this._vertexToIndex(T,E))}let A=l+m*Math.max(v,0),w=l+m*Math.min(S,1);if(g||this._generateIntraEdgeVertices(a,l,u,c,p,A,w),!d&&S<1){let T=l+m*S,E=u+h*S;a.push(this._vertexToIndex(T,E))}(d||p>=i&&p<=o)&&a.push(n[(s+1)%3]),!d&&(p<=i||p>=o)&&this._generateInterEdgeVertices(a,l,u,c,p,f,y,w,i,o)}return a}_generateIntraEdgeVertices(e,r,n,i,o,a,s){let l=i-r,u=o-n,c=u===0,p=c?Math.min(r,i):Math.min(a,s),f=c?Math.max(r,i):Math.max(a,s),y=Math.floor(p/this._granularityCellSize)+1,m=Math.ceil(f/this._granularityCellSize)-1;if(c?r<i:a<s)for(let g=y;g<=m;g++){let d=g*this._granularityCellSize,x=n+u*(d-r)/l;e.push(this._vertexToIndex(d,x))}else for(let g=m;g>=y;g--){let d=g*this._granularityCellSize,x=n+u*(d-r)/l;e.push(this._vertexToIndex(d,x))}}_generateInterEdgeVertices(e,r,n,i,o,a,s,l,u,c){let p=o-n,f=a-i,y=s-o,m=(u-o)/y,h=(c-o)/y,g=Math.min(m,h),d=Math.max(m,h),x=i+f*g,b=Math.floor(Math.min(x,l)/this._granularityCellSize)+1,v=Math.ceil(Math.max(x,l)/this._granularityCellSize)-1,S=l<x,A=y===0;if(A&&(s===u||s===c))return;if(A||g>=1||d<=0){let T=r-a,E=n-s,D=(u-s)/E,B=(c-s)/E,z=Math.min(D,B),M=a+T*z;b=Math.floor(Math.min(M,l)/this._granularityCellSize)+1,v=Math.ceil(Math.max(M,l)/this._granularityCellSize)-1,S=l<M}let w=p>0?c:u;if(S)for(let T=b;T<=v;T++){let E=T*this._granularityCellSize;e.push(this._vertexToIndex(E,w))}else for(let T=v;T>=b;T--){let E=T*this._granularityCellSize;e.push(this._vertexToIndex(E,w))}}_generateOutline(e){let r=[];for(let n of e){let i=Ke(n,this._granularity,!0),o=this._pointArrayToIndices(i),a=[];for(let s=1;s<o.length;s++)a.push(o[s-1]),a.push(o[s]);r.push(a)}return r}_handlePoles(e){let r=!1,n=!1;this._canonical&&(this._canonical.y===0&&(r=!0),this._canonical.y===(1<<this._canonical.z)-1&&(n=!0)),(r||n)&&this._fillPoles(e,r,n)}_ensureNoPoleVertices(){let e=this._vertexBuffer;for(let r=0;r<e.length;r+=2){let n=e[r+1];n===Vr&&(e[r+1]=Vr+1),n===ui&&(e[r+1]=ui-1)}}_generatePoleQuad(e,r,n,i,o,a){i>o!=(a===Vr)?(e.push(r),e.push(n),e.push(this._vertexToIndex(i,a)),e.push(n),e.push(this._vertexToIndex(o,a)),e.push(this._vertexToIndex(i,a))):(e.push(n),e.push(r),e.push(this._vertexToIndex(i,a)),e.push(this._vertexToIndex(o,a)),e.push(n),e.push(this._vertexToIndex(i,a)))}_fillPoles(e,r,n){let i=this._vertexBuffer,o=0,a=8192,s=e.length;for(let l=2;l<s;l+=3){let u=e[l-2],c=e[l-1],p=e[l],f=i[u*2],y=i[u*2+1],m=i[c*2],h=i[c*2+1],g=i[p*2],d=i[p*2+1];r&&(y===o&&h===o&&this._generatePoleQuad(e,u,c,f,m,Vr),h===o&&d===o&&this._generatePoleQuad(e,c,p,m,g,Vr),d===o&&y===o&&this._generatePoleQuad(e,p,u,g,f,Vr)),n&&(y===a&&h===a&&this._generatePoleQuad(e,u,c,f,m,ui),h===a&&d===a&&this._generatePoleQuad(e,c,p,m,g,ui),d===a&&y===a&&this._generatePoleQuad(e,p,u,g,f,ui))}}_initializeVertices(e){for(let r=0;r<e.length;r+=2)this._vertexToIndex(e[r],e[r+1])}subdividePolygonInternal(e,r){if(this._used)throw new Error("Subdivision: multiple use not allowed.");this._used=!0;let{flattened:n,holeIndices:i}=tb(e);this._initializeVertices(n);let o;try{let s=ml(n,i),l=this._convertIndices(n,s);o=this._subdivideTrianglesScanline(l)}catch(s){console.error(s)}let a=[];return r&&(a=this._generateOutline(e)),this._ensureNoPoleVertices(),this._handlePoles(o),{verticesFlattened:this._vertexBuffer,indicesTriangles:o,indicesLineList:a}}_convertIndices(e,r){let n=[];for(let i=0;i<r.length;i++){let o=e[r[i]*2],a=e[r[i]*2+1];n.push(this._vertexToIndex(o,a))}return n}_pointArrayToIndices(e){let r=[];for(let n=0;n<e.length;n++){let i=e[n];r.push(this._vertexToIndex(i.x,i.y))}return r}};function da(t,e,r,n=!0){return new hl(r,e).subdividePolygonInternal(t,n)}function Ke(t,e,r=!1){if(!t||t.length<1)return[];if(t.length<2)return[];let n=t[0],i=t[t.length-1],o=r&&(n.x!==i.x||n.y!==i.y);if(e<2)return o?[...t,t[0]]:[...t];let a=Math.floor(8192/e),s=[];s.push(new ci.default(t[0].x,t[0].y));let l=t.length,u=o?l:l-1;for(let c=0;c<u;c++){let p=t[c],f=c<l-1?t[c+1]:t[0],y=p.x,m=p.y,h=f.x,g=f.y,d=y!==h,x=m!==g;if(!d&&!x)continue;let b=h-y,v=g-m,S=Math.abs(b),A=Math.abs(v),w=y,T=m;for(;;){let D=b>0?(Math.floor(w/a)+1)*a:(Math.ceil(w/a)-1)*a,B=v>0?(Math.floor(T/a)+1)*a:(Math.ceil(T/a)-1)*a,z=Math.abs(w-D),M=Math.abs(T-B),_=Math.abs(w-h),V=Math.abs(T-g),G=d?z/S:Number.POSITIVE_INFINITY,O=x?M/A:Number.POSITIVE_INFINITY;if((_<=z||!d)&&(V<=M||!x))break;if(G<O&&d||!x){w=D,T=T+v*G;let R=new ci.default(w,Math.round(T));(s[s.length-1].x!==R.x||s[s.length-1].y!==R.y)&&s.push(R)}else{w=w+b*O,T=B;let R=new ci.default(Math.round(w),T);(s[s.length-1].x!==R.x||s[s.length-1].y!==R.y)&&s.push(R)}}let E=new ci.default(h,g);(s[s.length-1].x!==E.x||s[s.length-1].y!==E.y)&&s.push(E)}return s}function tb(t){let e=[],r=[];for(let n of t)if(n.length!==0){n!==t[0]&&e.push(r.length/2);for(let i=0;i<n.length;i++)r.push(n[i].x),r.push(n[i].y)}return{flattened:r,holeIndices:e}}function rb(t,e){let r=[];for(let n=0;n<e.length;n+=3){let i=e[n],o=e[n+1],a=e[n+2],s=t[i*2],l=t[i*2+1],u=t[o*2],c=t[o*2+1],p=t[a*2],f=t[a*2+1],y=u-s,m=c-l,h=p-s,g=f-l;y*g-m*h>0?(r.push(i),r.push(a),r.push(o)):(r.push(i),r.push(o),r.push(a))}return r}function nb(t,e,r){if(e.length===0)throw new Error("Subdivision vertex ring is empty.");let n=0,i=t[e[0]*2];for(let l=1;l<e.length;l++){let u=t[e[l]*2];u<i&&(i=u,n=l)}let o=e.length,a=n,s=(a+1)%o;for(;;){let l=a-1>=0?a-1:o-1,u=(s+1)%o,c=t[e[l]*2],p=t[e[l]*2+1],f=t[e[u]*2],y=t[e[u]*2+1],m=t[e[a]*2],h=t[e[a]*2+1],g=t[e[s]*2],d=t[e[s]*2+1],x=!1;if(c<f)x=!0;else if(c>f)x=!1;else{let b=g-m,S=d-h,A=-b,w=h<d?1:-1,T=((c-m)*S+(p-h)*A)*w,E=((f-m)*S+(y-h)*A)*w;T>E&&(x=!0)}if(x){let b=e[l],v=e[a],S=e[s];b!==v&&b!==S&&v!==S&&r.push(S,v,b),a--,a<0&&(a=o-1)}else{let b=e[u],v=e[a],S=e[s];b!==v&&b!==S&&v!==S&&r.push(S,v,b),s++,s>=o&&(s=0)}if(l===u)break}}function ga(t,e,r,n,i,o,a,s,l){let u=i.length/2,c=a&&s&&l;if(u<pe.MAX_VERTEX_ARRAY_LENGTH){let p=e.prepareSegment(u,r,n),f=p.vertexLength;for(let h=0;h<o.length;h+=3)n.emplaceBack(f+o[h],f+o[h+1],f+o[h+2]);p.vertexLength+=u,p.primitiveLength+=o.length/3;let y,m;c&&(m=a.prepareSegment(u,r,s),y=m.vertexLength,m.vertexLength+=u);for(let h=0;h<i.length;h+=2)t(i[h],i[h+1]);if(c)for(let h=0;h<l.length;h++){let g=l[h];for(let d=1;d<g.length;d+=2)s.emplaceBack(y+g[d-1],y+g[d]);m.primitiveLength+=g.length/2}}else ib(e,r,n,i,o,t),c&&ob(a,r,s,i,l,t),e.forceNewSegmentOnNextPrepare(),a?.forceNewSegmentOnNextPrepare()}function pi(t,e,r,n,i,o,a){if(o){let s=n.count;return r(e[i*2],e[i*2+1]),t[i]=n.count,n.count++,a.vertexLength++,s}else return t[i]}function ib(t,e,r,n,i,o){let a=[];for(let p=0;p<n.length/2;p++)a.push(-1);let s={count:0},l=0,u=t.getOrCreateLatestSegment(e,r),c=u.vertexLength;for(let p=2;p<i.length;p+=3){let f=i[p-2],y=i[p-1],m=i[p],h=a[f]<l,g=a[y]<l,d=a[m]<l,x=(h?1:0)+(g?1:0)+(d?1:0);u.vertexLength+x>pe.MAX_VERTEX_ARRAY_LENGTH&&(u=t.createNewSegment(e,r),l=s.count,h=!0,g=!0,d=!0,c=0);let b=pi(a,n,o,s,f,h,u),v=pi(a,n,o,s,y,g,u),S=pi(a,n,o,s,m,d,u);r.emplaceBack(c+b-l,c+v-l,c+S-l),u.primitiveLength++}}function ob(t,e,r,n,i,o){let a=[];for(let p=0;p<n.length/2;p++)a.push(-1);let s={count:0},l=0,u=t.getOrCreateLatestSegment(e,r),c=u.vertexLength;for(let p=0;p<i.length;p++){let f=i[p];for(let y=1;y<i[p].length;y+=2){let m=f[y-1],h=f[y],g=a[m]<l,d=a[h]<l,x=(g?1:0)+(d?1:0);u.vertexLength+x>pe.MAX_VERTEX_ARRAY_LENGTH&&(u=t.createNewSegment(e,r),l=s.count,g=!0,d=!0,c=0);let b=pi(a,n,o,s,m,g,u),v=pi(a,n,o,s,h,d,u);r.emplaceBack(c+b-l,c+v-l),u.primitiveLength++}}}var ab=500,ur=class{constructor(e){this.zoom=e.zoom,this.globalState=e.globalState,this.overscaling=e.overscaling,this.layers=e.layers,this.layerIds=this.layers.map(r=>r.id),this.index=e.index,this.hasPattern=!1,this.patternFeatures=[],this.layoutVertexArray=new Xo,this.indexArray=new Le,this.indexArray2=new Mt,this.programConfigurations=new Ae(e.layers,e.zoom),this.segments=new pe,this.segments2=new pe,this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(e,r,n){this.hasPattern=Lr("fill",this.layers,r);let i=this.layers[0].layout.get("fill-sort-key"),o=!i.isConstant(),a=[];for(let{feature:s,id:l,index:u,sourceLayerIndex:c}of e){let p=this.layers[0]._featureFilter.needGeometry,f=Ne(s,p);if(!this.layers[0]._featureFilter.filter(new W(this.zoom,{globalState:this.globalState}),f,n))continue;let y=o?i.evaluate(f,{},n,r.availableImages):void 0,m={id:l,properties:s.properties,type:s.type,sourceLayerIndex:c,index:u,geometry:p?f.geometry:_e(s),patterns:{},sortKey:y};a.push(m)}o&&a.sort((s,l)=>s.sortKey-l.sortKey);for(let s of a){let{geometry:l,index:u,sourceLayerIndex:c}=s;if(this.hasPattern){let f=Dr("fill",this.layers,s,this.zoom,r);this.patternFeatures.push(f)}else this.addFeature(s,l,u,n,{},r.subdivisionGranularity);let p=e[u].feature;r.featureIndex.insert(p,l,u,c,this.index)}}update(e,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(e,r,this.stateDependentLayers,n)}addFeatures(e,r,n){for(let i of this.patternFeatures)this.addFeature(i,i.geometry,i.index,r,n,e.subdivisionGranularity)}isEmpty(){return this.layoutVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(e){this.uploaded||(this.layoutVertexBuffer=e.createVertexBuffer(this.layoutVertexArray,Lp),this.indexBuffer=e.createIndexBuffer(this.indexArray),this.indexBuffer2=e.createIndexBuffer(this.indexArray2)),this.programConfigurations.upload(e),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.indexBuffer2.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.segments2.destroy())}addFeature(e,r,n,i,o,a){for(let s of Yt(r,ab)){let l=da(s,i,a.fill.getGranularityForZoomLevel(i.z)),u=this.layoutVertexArray;ga((c,p)=>{u.emplaceBack(c,p)},this.segments,this.layoutVertexArray,this.indexArray,l.verticesFlattened,l.indicesTriangles,this.segments2,this.indexArray2,l.indicesLineList)}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,e,n,o,i)}};I("FillBucket",ur,{omit:["layers","patternFeatures"]});var Op,sb=()=>Op=Op||new ee({"fill-sort-key":new L(P.layout_fill["fill-sort-key"])}),Gp,lb=()=>Gp=Gp||new ee({"fill-antialias":new F(P.paint_fill["fill-antialias"]),"fill-opacity":new L(P.paint_fill["fill-opacity"]),"fill-color":new L(P.paint_fill["fill-color"]),"fill-outline-color":new L(P.paint_fill["fill-outline-color"]),"fill-translate":new F(P.paint_fill["fill-translate"]),"fill-translate-anchor":new F(P.paint_fill["fill-translate-anchor"]),"fill-pattern":new pt(P.paint_fill["fill-pattern"])}),Np={get paint(){return lb()},get layout(){return sb()}};var ba=class extends oe{constructor(e){super(e,Np)}recalculate(e,r){super.recalculate(e,r);let n=this.paint._values["fill-outline-color"];n.value.kind==="constant"&&n.value.value===void 0&&(this.paint._values["fill-outline-color"]=this.paint._values["fill-color"])}createBucket(e){return new ur(e)}queryRadius(){return Dt(this.paint.get("fill-translate"))}queryIntersectsFeature({queryGeometry:e,geometry:r,transform:n,pixelsToTileUnits:i}){let o=Bt(e,this.paint.get("fill-translate"),this.paint.get("fill-translate-anchor"),-n.bearingInRadians,i);return aa(o,r)}isTileClipped(){return!0}};var ub=Q([{name:"a_pos",components:2,type:"Int16"},{name:"a_normal_ed",components:4,type:"Int16"}],4),Up=Q([{name:"a_centroid",components:2,type:"Int16"}],4);var{members:$p,size:kS,alignment:FS}=ub;var Jp=Y(Rt(),1);var Pb=Jp.default.VectorTileFeature.types,Sb=500,bl=Math.pow(2,13);function fi(t,e,r,n,i,o,a,s){t.emplaceBack(e,r,Math.floor(n*bl)*2+a,i*bl*2,o*bl*2,Math.round(s))}var cr=class{constructor(e){this.zoom=e.zoom,this.globalState=e.globalState,this.overscaling=e.overscaling,this.layers=e.layers,this.layerIds=this.layers.map(r=>r.id),this.index=e.index,this.hasPattern=!1,this.layoutVertexArray=new Ho,this.centroidVertexArray=new qo,this.indexArray=new Le,this.programConfigurations=new Ae(e.layers,e.zoom),this.segments=new pe,this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(e,r,n){this.features=[],this.hasPattern=Lr("fill-extrusion",this.layers,r);for(let{feature:i,id:o,index:a,sourceLayerIndex:s}of e){let l=this.layers[0]._featureFilter.needGeometry,u=Ne(i,l);if(!this.layers[0]._featureFilter.filter(new W(this.zoom,{globalState:this.globalState}),u,n))continue;let c={id:o,sourceLayerIndex:s,index:a,geometry:l?u.geometry:_e(i),properties:i.properties,type:i.type,patterns:{}};this.hasPattern?this.features.push(Dr("fill-extrusion",this.layers,c,this.zoom,r)):this.addFeature(c,c.geometry,a,n,{},r.subdivisionGranularity),r.featureIndex.insert(i,c.geometry,a,s,this.index,!0)}}addFeatures(e,r,n){for(let i of this.features){let{geometry:o}=i;this.addFeature(i,o,i.index,r,n,e.subdivisionGranularity)}}update(e,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(e,r,this.stateDependentLayers,n)}isEmpty(){return this.layoutVertexArray.length===0&&this.centroidVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(e){this.uploaded||(this.layoutVertexBuffer=e.createVertexBuffer(this.layoutVertexArray,$p),this.centroidVertexBuffer=e.createVertexBuffer(this.centroidVertexArray,Up.members,!0),this.indexBuffer=e.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(e),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.centroidVertexBuffer.destroy())}addFeature(e,r,n,i,o,a){for(let s of Yt(r,Sb)){let l={x:0,y:0,sampleCount:0},u=this.layoutVertexArray.length;this.processPolygon(l,i,e,s,a);let c=this.layoutVertexArray.length-u,p=Math.floor(l.x/l.sampleCount),f=Math.floor(l.y/l.sampleCount);for(let y=0;y<c;y++)this.centroidVertexArray.emplaceBack(p,f)}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,e,n,o,i)}processPolygon(e,r,n,i,o){if(i.length<1||Zp(i[0]))return;for(let p of i)p.length!==0&&wb(e,p);let a={segment:this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray)},s=o.fill.getGranularityForZoomLevel(r.z),l=Pb[n.type]==="Polygon";for(let p of i){if(p.length===0||Zp(p))continue;let f=Ke(p,s,l);this._generateSideFaces(f,a)}if(!l)return;let u=da(i,r,s,!1),c=this.layoutVertexArray;ga((p,f)=>{fi(c,p,f,0,0,1,1,0)},this.segments,this.layoutVertexArray,this.indexArray,u.verticesFlattened,u.indicesTriangles)}_generateSideFaces(e,r){let n=0;for(let i=1;i<e.length;i++){let o=e[i],a=e[i-1];if(Ab(o,a))continue;r.segment.vertexLength+4>pe.MAX_VERTEX_ARRAY_LENGTH&&(r.segment=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray));let s=o.sub(a)._perp()._unit(),l=a.dist(o);n+l>32768&&(n=0),fi(this.layoutVertexArray,o.x,o.y,s.x,s.y,0,0,n),fi(this.layoutVertexArray,o.x,o.y,s.x,s.y,0,1,n),n+=l,fi(this.layoutVertexArray,a.x,a.y,s.x,s.y,0,0,n),fi(this.layoutVertexArray,a.x,a.y,s.x,s.y,0,1,n);let u=r.segment.vertexLength;this.indexArray.emplaceBack(u,u+2,u+1),this.indexArray.emplaceBack(u+1,u+2,u+3),r.segment.vertexLength+=4,r.segment.primitiveLength+=2}}};function wb(t,e){for(let r=0;r<e.length;r++){let n=e[r];r===e.length-1&&e[0].x===n.x&&e[0].y===n.y||(t.x+=n.x,t.y+=n.y,t.sampleCount++)}}I("FillExtrusionBucket",cr,{omit:["layers","features"]});function Ab(t,e){return t.x===e.x&&(t.x<0||t.x>8192)||t.y===e.y&&(t.y<0||t.y>8192)}function Zp(t){return t.every(e=>e.x<0)||t.every(e=>e.x>8192)||t.every(e=>e.y<0)||t.every(e=>e.y>8192)}var Yp,_b=()=>Yp=Yp||new ee({"fill-extrusion-opacity":new F(P["paint_fill-extrusion"]["fill-extrusion-opacity"]),"fill-extrusion-color":new L(P["paint_fill-extrusion"]["fill-extrusion-color"]),"fill-extrusion-translate":new F(P["paint_fill-extrusion"]["fill-extrusion-translate"]),"fill-extrusion-translate-anchor":new F(P["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),"fill-extrusion-pattern":new pt(P["paint_fill-extrusion"]["fill-extrusion-pattern"]),"fill-extrusion-height":new L(P["paint_fill-extrusion"]["fill-extrusion-height"]),"fill-extrusion-base":new L(P["paint_fill-extrusion"]["fill-extrusion-base"]),"fill-extrusion-vertical-gradient":new F(P["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])}),Kp={get paint(){return _b()}};var va=Y(ye(),1);var Pa=class extends oe{constructor(e){super(e,Kp)}createBucket(e){return new cr(e)}queryRadius(){return Dt(this.paint.get("fill-extrusion-translate"))}is3D(){return!0}queryIntersectsFeature({queryGeometry:e,feature:r,featureState:n,geometry:i,transform:o,pixelsToTileUnits:a,pixelPosMatrix:s}){let l=Bt(e,this.paint.get("fill-extrusion-translate"),this.paint.get("fill-extrusion-translate-anchor"),-o.bearingInRadians,a),u=this.paint.get("fill-extrusion-height").evaluate(r,n),c=this.paint.get("fill-extrusion-base").evaluate(r,n),p=Cb(l,s,0),f=Tb(i,c,u,s),y=f[0],m=f[1];return Ib(y,m,p)}};function yi(t,e){return t.x*e.x+t.y*e.y}function Qp(t,e){if(t.length===1){let r=0,n=e[r++],i;for(;!i||n.equals(i);)if(i=e[r++],!i)return 1/0;for(;r<e.length;r++){let o=e[r],a=t[0],s=i.sub(n),l=o.sub(n),u=a.sub(n),c=yi(s,s),p=yi(s,l),f=yi(l,l),y=yi(u,s),m=yi(u,l),h=c*f-p*p,g=(f*y-p*m)/h,d=(c*m-p*y)/h,x=1-g-d,b=n.z*x+i.z*g+o.z*d;if(isFinite(b))return b}return 1/0}else{let r=1/0;for(let n of e)r=Math.min(r,n.z);return r}}function Ib(t,e,r){let n=1/0;aa(r,e)&&(n=Qp(r,e[0]));for(let i=0;i<e.length;i++){let o=e[i],a=t[i];for(let s=0;s<o.length-1;s++){let l=o[s],u=o[s+1],c=a[s],p=a[s+1],f=[l,u,p,c,l];mp(r,f)&&(n=Math.min(n,Qp(r,f)))}}return n===1/0?!1:n}function Tb(t,e,r,n){let i=[],o=[],a=n[8]*e,s=n[9]*e,l=n[10]*e,u=n[11]*e,c=n[8]*r,p=n[9]*r,f=n[10]*r,y=n[11]*r;for(let m of t){let h=[],g=[];for(let d of m){let x=d.x,b=d.y,v=n[0]*x+n[4]*b+n[12],S=n[1]*x+n[5]*b+n[13],A=n[2]*x+n[6]*b+n[14],w=n[3]*x+n[7]*b+n[15],T=v+a,E=S+s,D=A+l,B=w+u,z=v+c,M=S+p,_=A+f,V=w+y,G=new va.default(T/B,E/B);G.z=D/B,h.push(G);let O=new va.default(z/V,M/V);O.z=_/V,g.push(O)}i.push(h),o.push(g)}return[i,o]}function Cb(t,e,r){let n=[];for(let i of t){let o=[i.x,i.y,r,1];Wi.transformMat4(o,o,e),n.push(new va.default(o[0]/o[3],o[1]/o[3]))}return n}var kb=Q([{name:"a_pos_normal",components:2,type:"Int16"},{name:"a_data",components:4,type:"Uint8"}],4),{members:ef,size:fw,alignment:yw}=kb;var Fb=Q([{name:"a_uv_x",components:1,type:"Float32"},{name:"a_split_index",components:1,type:"Float32"}]),{members:tf,size:dw,alignment:gw}=Fb;var of=Y(Rt(),1);var Eb=of.default.VectorTileFeature.types,rf=63,Mb=Math.cos(75/2*(Math.PI/180)),Lb=15,Db=20,Bb=15,af=1/2,nf=Math.pow(2,Bb-1)/af,pr=class{constructor(e){this.zoom=e.zoom,this.globalState=e.globalState,this.overscaling=e.overscaling,this.layers=e.layers,this.layerIds=this.layers.map(r=>r.id),this.index=e.index,this.hasPattern=!1,this.patternFeatures=[],this.lineClipsArray=[],this.gradients={},this.layers.forEach(r=>{this.gradients[r.id]={}}),this.layoutVertexArray=new Zo,this.layoutVertexArray2=new Jo,this.indexArray=new Le,this.programConfigurations=new Ae(e.layers,e.zoom),this.segments=new pe,this.maxLineLength=0,this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(e,r,n){this.hasPattern=Lr("line",this.layers,r);let i=this.layers[0].layout.get("line-sort-key"),o=!i.isConstant(),a=[];for(let{feature:s,id:l,index:u,sourceLayerIndex:c}of e){let p=this.layers[0]._featureFilter.needGeometry,f=Ne(s,p);if(!this.layers[0]._featureFilter.filter(new W(this.zoom,{globalState:this.globalState}),f,n))continue;let y=o?i.evaluate(f,{},n):void 0,m={id:l,properties:s.properties,type:s.type,sourceLayerIndex:c,index:u,geometry:p?f.geometry:_e(s),patterns:{},sortKey:y};a.push(m)}o&&a.sort((s,l)=>s.sortKey-l.sortKey);for(let s of a){let{geometry:l,index:u,sourceLayerIndex:c}=s;if(this.hasPattern){let f=Dr("line",this.layers,s,this.zoom,r);this.patternFeatures.push(f)}else this.addFeature(s,l,u,n,{},r.subdivisionGranularity);let p=e[u].feature;r.featureIndex.insert(p,l,u,c,this.index)}}update(e,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(e,r,this.stateDependentLayers,n)}addFeatures(e,r,n){for(let i of this.patternFeatures)this.addFeature(i,i.geometry,i.index,r,n,e.subdivisionGranularity)}isEmpty(){return this.layoutVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(e){this.uploaded||(this.layoutVertexArray2.length!==0&&(this.layoutVertexBuffer2=e.createVertexBuffer(this.layoutVertexArray2,tf)),this.layoutVertexBuffer=e.createVertexBuffer(this.layoutVertexArray,ef),this.indexBuffer=e.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(e),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy())}lineFeatureClips(e){if(e.properties&&Object.prototype.hasOwnProperty.call(e.properties,"mapbox_clip_start")&&Object.prototype.hasOwnProperty.call(e.properties,"mapbox_clip_end")){let r=+e.properties.mapbox_clip_start,n=+e.properties.mapbox_clip_end;return{start:r,end:n}}}addFeature(e,r,n,i,o,a){let s=this.layers[0].layout,l=s.get("line-join").evaluate(e,{}),u=s.get("line-cap"),c=s.get("line-miter-limit"),p=s.get("line-round-limit");this.lineClips=this.lineFeatureClips(e);for(let f of r)this.addLine(f,e,l,u,c,p,i,a);this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,e,n,o,i)}addLine(e,r,n,i,o,a,s,l){this.distance=0,this.scaledDistance=0,this.totalDistance=0;let u=s?l.line.getGranularityForZoomLevel(s.z):1;if(e=Ke(e,u),this.lineClips){this.lineClipsArray.push(this.lineClips);for(let v=0;v<e.length-1;v++)this.totalDistance+=e[v].dist(e[v+1]);this.updateScaledDistance(),this.maxLineLength=Math.max(this.maxLineLength,this.totalDistance)}let c=Eb[r.type]==="Polygon",p=e.length;for(;p>=2&&e[p-1].equals(e[p-2]);)p--;let f=0;for(;f<p-1&&e[f].equals(e[f+1]);)f++;if(p<(c?3:2))return;n==="bevel"&&(o=1.05);let y=this.overscaling<=16?Lb*8192/(512*this.overscaling):0,m=this.segments.prepareSegment(p*10,this.layoutVertexArray,this.indexArray),h,g,d,x,b;this.e1=this.e2=-1,c&&(h=e[p-2],b=e[f].sub(h)._unit()._perp());for(let v=f;v<p;v++){if(d=v===p-1?c?e[f+1]:void 0:e[v+1],d&&e[v].equals(d))continue;b&&(x=b),h&&(g=h),h=e[v],b=d?d.sub(h)._unit()._perp():x,x=x||b;let S=x.add(b);(S.x!==0||S.y!==0)&&S._unit();let A=x.x*b.x+x.y*b.y,w=S.x*b.x+S.y*b.y,T=w!==0?1/w:1/0,E=2*Math.sqrt(2-2*w),D=w<Mb&&g&&d,B=x.x*b.y-x.y*b.x>0;if(D&&v>f){let _=h.dist(g);if(_>2*y){let V=h.sub(h.sub(g)._mult(y/_)._round());this.updateDistance(g,V),this.addCurrentVertex(V,x,0,0,m),g=V}}let z=g&&d,M=z?n:c?"butt":i;if(z&&M==="round"&&(T<a?M="miter":T<=2&&(M="fakeround")),M==="miter"&&T>o&&(M="bevel"),M==="bevel"&&(T>2&&(M="flipbevel"),T<o&&(M="miter")),g&&this.updateDistance(g,h),M==="miter")S._mult(T),this.addCurrentVertex(h,S,0,0,m);else if(M==="flipbevel"){if(T>100)S=b.mult(-1);else{let _=T*x.add(b).mag()/x.sub(b).mag();S._perp()._mult(_*(B?-1:1))}this.addCurrentVertex(h,S,0,0,m),this.addCurrentVertex(h,S.mult(-1),0,0,m)}else if(M==="bevel"||M==="fakeround"){let _=-Math.sqrt(T*T-1),V=B?_:0,G=B?0:_;if(g&&this.addCurrentVertex(h,x,V,G,m),M==="fakeround"){let O=Math.round(E*180/Math.PI/Db);for(let R=1;R<O;R++){let K=R/O;if(K!==.5){let re=K-.5,me=1.0904+A*(-3.2452+A*(3.55645-A*1.43519)),Ut=.848013+A*(-1.06021+A*.215638);K=K+K*re*(K-1)*(me*re*re+Ut)}let X=b.sub(x)._mult(K)._add(x)._unit()._mult(B?-1:1);this.addHalfVertex(h,X.x,X.y,!1,B,0,m)}}d&&this.addCurrentVertex(h,b,-V,-G,m)}else if(M==="butt")this.addCurrentVertex(h,S,0,0,m);else if(M==="square"){let _=g?1:-1;this.addCurrentVertex(h,S,_,_,m)}else M==="round"&&(g&&(this.addCurrentVertex(h,x,0,0,m),this.addCurrentVertex(h,x,1,1,m,!0)),d&&(this.addCurrentVertex(h,b,-1,-1,m,!0),this.addCurrentVertex(h,b,0,0,m)));if(D&&v<p-1){let _=h.dist(d);if(_>2*y){let V=h.add(d.sub(h)._mult(y/_)._round());this.updateDistance(h,V),this.addCurrentVertex(V,b,0,0,m),h=V}}}}addCurrentVertex(e,r,n,i,o,a=!1){let s=r.x+r.y*n,l=r.y-r.x*n,u=-r.x+r.y*i,c=-r.y-r.x*i;this.addHalfVertex(e,s,l,a,!1,n,o),this.addHalfVertex(e,u,c,a,!0,-i,o),this.distance>nf/2&&this.totalDistance===0&&(this.distance=0,this.updateScaledDistance(),this.addCurrentVertex(e,r,n,i,o,a))}addHalfVertex({x:e,y:r},n,i,o,a,s,l){let c=(this.lineClips?this.scaledDistance*(nf-1):this.scaledDistance)*af;if(this.layoutVertexArray.emplaceBack((e<<1)+(o?1:0),(r<<1)+(a?1:0),Math.round(rf*n)+128,Math.round(rf*i)+128,(s===0?0:s<0?-1:1)+1|(c&63)<<2,c>>6),this.lineClips){let f=this.scaledDistance-this.lineClips.start,y=this.lineClips.end-this.lineClips.start,m=f/y;this.layoutVertexArray2.emplaceBack(m,this.lineClipsArray.length)}let p=l.vertexLength++;this.e1>=0&&this.e2>=0&&(this.indexArray.emplaceBack(this.e1,p,this.e2),l.primitiveLength++),a?this.e2=p:this.e1=p}updateScaledDistance(){this.scaledDistance=this.lineClips?this.lineClips.start+(this.lineClips.end-this.lineClips.start)*this.distance/this.totalDistance:this.distance}updateDistance(e,r){this.distance+=e.dist(r),this.updateScaledDistance()}};I("LineBucket",pr,{omit:["layers","patternFeatures"]});var sf,Vb=()=>sf=sf||new ee({"line-cap":new F(P.layout_line["line-cap"]),"line-join":new L(P.layout_line["line-join"]),"line-miter-limit":new F(P.layout_line["line-miter-limit"]),"line-round-limit":new F(P.layout_line["line-round-limit"]),"line-sort-key":new L(P.layout_line["line-sort-key"])}),lf,Rb=()=>lf=lf||new ee({"line-opacity":new L(P.paint_line["line-opacity"]),"line-color":new L(P.paint_line["line-color"]),"line-translate":new F(P.paint_line["line-translate"]),"line-translate-anchor":new F(P.paint_line["line-translate-anchor"]),"line-width":new L(P.paint_line["line-width"]),"line-gap-width":new L(P.paint_line["line-gap-width"]),"line-offset":new L(P.paint_line["line-offset"]),"line-blur":new L(P.paint_line["line-blur"]),"line-dasharray":new tr(P.paint_line["line-dasharray"]),"line-pattern":new pt(P.paint_line["line-pattern"]),"line-gradient":new ft(P.paint_line["line-gradient"])}),xl={get paint(){return Rb()},get layout(){return Vb()}};var vl=class extends L{possiblyEvaluate(e,r){return r=new W(Math.floor(r.zoom),{now:r.now,fadeDuration:r.fadeDuration,zoomHistory:r.zoomHistory,transition:r.transition}),super.possiblyEvaluate(e,r)}evaluate(e,r,n,i){return r=de({},r,{zoom:Math.floor(r.zoom)}),super.evaluate(e,r,n,i)}},Sa;var wa=class extends oe{constructor(e){super(e,xl),this.gradientVersion=0,Sa||(Sa=new vl(xl.paint.properties["line-width"].specification),Sa.useIntegerZoom=!0)}_handleSpecialPaintPropertyUpdate(e){if(e==="line-gradient"){let r=this.gradientExpression();fc(r)?this.stepInterpolant=r._styleExpression.expression instanceof Pr:this.stepInterpolant=!1,this.gradientVersion=(this.gradientVersion+1)%Number.MAX_SAFE_INTEGER}}gradientExpression(){return this._transitionablePaint._values["line-gradient"].value.expression}recalculate(e,r){super.recalculate(e,r),this.paint._values["line-floorwidth"]=Sa.possiblyEvaluate(this._transitioningPaint._values["line-width"].value,e)}createBucket(e){return new pr(e)}queryRadius(e){let r=e,n=uf(ar("line-width",this,r),ar("line-gap-width",this,r)),i=ar("line-offset",this,r);return n/2+Math.abs(i)+Dt(this.paint.get("line-translate"))}queryIntersectsFeature({queryGeometry:e,feature:r,featureState:n,geometry:i,transform:o,pixelsToTileUnits:a}){let s=Bt(e,this.paint.get("line-translate"),this.paint.get("line-translate-anchor"),-o.bearingInRadians,a),l=a/2*uf(this.paint.get("line-width").evaluate(r,n),this.paint.get("line-gap-width").evaluate(r,n)),u=this.paint.get("line-offset").evaluate(r,n);return u&&(i=bp(i,u*a)),dp(s,i,l)}isTileClipped(){return!0}};function uf(t,e){return e>0?e+2*t:t}var cf=Q([{name:"a_pos_offset",components:4,type:"Int16"},{name:"a_data",components:4,type:"Uint16"},{name:"a_pixeloffset",components:4,type:"Int16"}],4),pf=Q([{name:"a_projected_pos",components:3,type:"Float32"}],4),Zw=Q([{name:"a_fade_opacity",components:1,type:"Uint32"}],4),ff=Q([{name:"a_placed",components:2,type:"Uint8"},{name:"a_shift",components:2,type:"Float32"},{name:"a_box_real",components:2,type:"Int16"}]),Jw=Q([{type:"Int16",name:"anchorPointX"},{type:"Int16",name:"anchorPointY"},{type:"Int16",name:"x1"},{type:"Int16",name:"y1"},{type:"Int16",name:"x2"},{type:"Int16",name:"y2"},{type:"Uint32",name:"featureIndex"},{type:"Uint16",name:"sourceLayerIndex"},{type:"Uint16",name:"bucketIndex"}]),Pl=Q([{name:"a_pos",components:2,type:"Int16"},{name:"a_anchor_pos",components:2,type:"Int16"},{name:"a_extrude",components:2,type:"Int16"}],4),Yw=Q([{name:"a_pos",components:2,type:"Float32"},{name:"a_radius",components:1,type:"Float32"},{name:"a_flags",components:2,type:"Int16"}],4),Kw=Q([{name:"triangle",components:3,type:"Uint16"}]),Qw=Q([{type:"Int16",name:"anchorX"},{type:"Int16",name:"anchorY"},{type:"Uint16",name:"glyphStartIndex"},{type:"Uint16",name:"numGlyphs"},{type:"Uint32",name:"vertexStartIndex"},{type:"Uint32",name:"lineStartIndex"},{type:"Uint32",name:"lineLength"},{type:"Uint16",name:"segment"},{type:"Uint16",name:"lowerSize"},{type:"Uint16",name:"upperSize"},{type:"Float32",name:"lineOffsetX"},{type:"Float32",name:"lineOffsetY"},{type:"Uint8",name:"writingMode"},{type:"Uint8",name:"placedOrientation"},{type:"Uint8",name:"hidden"},{type:"Uint32",name:"crossTileID"},{type:"Int16",name:"associatedIconIndex"}]),eA=Q([{type:"Int16",name:"anchorX"},{type:"Int16",name:"anchorY"},{type:"Int16",name:"rightJustifiedTextSymbolIndex"},{type:"Int16",name:"centerJustifiedTextSymbolIndex"},{type:"Int16",name:"leftJustifiedTextSymbolIndex"},{type:"Int16",name:"verticalPlacedTextSymbolIndex"},{type:"Int16",name:"placedIconSymbolIndex"},{type:"Int16",name:"verticalPlacedIconSymbolIndex"},{type:"Uint16",name:"key"},{type:"Uint16",name:"textBoxStartIndex"},{type:"Uint16",name:"textBoxEndIndex"},{type:"Uint16",name:"verticalTextBoxStartIndex"},{type:"Uint16",name:"verticalTextBoxEndIndex"},{type:"Uint16",name:"iconBoxStartIndex"},{type:"Uint16",name:"iconBoxEndIndex"},{type:"Uint16",name:"verticalIconBoxStartIndex"},{type:"Uint16",name:"verticalIconBoxEndIndex"},{type:"Uint16",name:"featureIndex"},{type:"Uint16",name:"numHorizontalGlyphVertices"},{type:"Uint16",name:"numVerticalGlyphVertices"},{type:"Uint16",name:"numIconVertices"},{type:"Uint16",name:"numVerticalIconVertices"},{type:"Uint16",name:"useRuntimeCollisionCircles"},{type:"Uint32",name:"crossTileID"},{type:"Float32",name:"textBoxScale"},{type:"Float32",name:"collisionCircleDiameter"},{type:"Uint16",name:"textAnchorOffsetStartIndex"},{type:"Uint16",name:"textAnchorOffsetEndIndex"}]),tA=Q([{type:"Float32",name:"offsetX"}]),rA=Q([{type:"Int16",name:"x"},{type:"Int16",name:"y"},{type:"Int16",name:"tileUnitDistanceFromAnchor"}]),nA=Q([{type:"Uint16",name:"textAnchor"},{type:"Float32",components:2,name:"textOffset"}]);var vi=Y(ye(),1);function zb(t,e,r){let n=e.layout.get("text-transform").evaluate(r,{});return n==="uppercase"?t=t.toLocaleUpperCase():n==="lowercase"&&(t=t.toLocaleLowerCase()),we.applyArabicShaping&&(t=we.applyArabicShaping(t)),t}function yf(t,e,r){return t.sections.forEach(n=>{n.text=zb(n.text,e,r)}),t}function mf(t){let e={},r={},n=[],i=0;function o(u){n.push(t[u]),i++}function a(u,c,p){let f=r[u];return delete r[u],r[c]=f,n[f].geometry[0].pop(),n[f].geometry[0]=n[f].geometry[0].concat(p[0]),f}function s(u,c,p){let f=e[c];return delete e[c],e[u]=f,n[f].geometry[0].shift(),n[f].geometry[0]=p[0].concat(n[f].geometry[0]),f}function l(u,c,p){let f=p?c[0][c[0].length-1]:c[0][0];return`${u}:${f.x}:${f.y}`}for(let u=0;u<t.length;u++){let c=t[u],p=c.geometry,f=c.text?c.text.toString():null;if(!f){o(u);continue}let y=l(f,p),m=l(f,p,!0);if(y in r&&m in e&&r[y]!==e[m]){let h=s(y,m,p),g=a(y,m,n[h].geometry);delete e[y],delete r[m],r[l(f,n[g].geometry,!0)]=g,n[h].geometry=null}else y in r?a(y,m,p):m in e?s(y,m,p):(o(u),e[y]=i-1,r[m]=i-1)}return n.filter(u=>u.geometry)}var zr={"!":"\\uFE15","#":"\\uFF03",$:"\\uFF04","%":"\\uFF05","&":"\\uFF06","(":"\\uFE35",")":"\\uFE36","*":"\\uFF0A","+":"\\uFF0B",",":"\\uFE10","-":"\\uFE32",".":"\\u30FB","/":"\\uFF0F",":":"\\uFE13",";":"\\uFE14","<":"\\uFE3F","=":"\\uFF1D",">":"\\uFE40","?":"\\uFE16","@":"\\uFF20","[":"\\uFE47","\\\\":"\\uFF3C","]":"\\uFE48","^":"\\uFF3E",_:"\\uFE33","`":"\\uFF40","{":"\\uFE37","|":"\\u2015","}":"\\uFE38","~":"\\uFF5E","\\xA2":"\\uFFE0","\\xA3":"\\uFFE1","\\xA5":"\\uFFE5","\\xA6":"\\uFFE4","\\xAC":"\\uFFE2","\\xAF":"\\uFFE3","\\u2013":"\\uFE32","\\u2014":"\\uFE31","\\u2018":"\\uFE43","\\u2019":"\\uFE44","\\u201C":"\\uFE41","\\u201D":"\\uFE42","\\u2026":"\\uFE19","\\u2027":"\\u30FB","\\u20A9":"\\uFFE6","\\u3001":"\\uFE11","\\u3002":"\\uFE12","\\u3008":"\\uFE3F","\\u3009":"\\uFE40","\\u300A":"\\uFE3D","\\u300B":"\\uFE3E","\\u300C":"\\uFE41","\\u300D":"\\uFE42","\\u300E":"\\uFE43","\\u300F":"\\uFE44","\\u3010":"\\uFE3B","\\u3011":"\\uFE3C","\\u3014":"\\uFE39","\\u3015":"\\uFE3A","\\u3016":"\\uFE17","\\u3017":"\\uFE18","\\uFF01":"\\uFE15","\\uFF08":"\\uFE35","\\uFF09":"\\uFE36","\\uFF0C":"\\uFE10","\\uFF0D":"\\uFE32","\\uFF0E":"\\u30FB","\\uFF1A":"\\uFE13","\\uFF1B":"\\uFE14","\\uFF1C":"\\uFE3F","\\uFF1E":"\\uFE40","\\uFF1F":"\\uFE16","\\uFF3B":"\\uFE47","\\uFF3D":"\\uFE48","\\uFF3F":"\\uFE33","\\uFF5B":"\\uFE37","\\uFF5C":"\\u2015","\\uFF5D":"\\uFE38","\\uFF5F":"\\uFE35","\\uFF60":"\\uFE36","\\uFF61":"\\uFE12","\\uFF62":"\\uFE41","\\uFF63":"\\uFE42"};function hf(t){let e="";for(let r=0;r<t.length;r++){let n=t.charCodeAt(r+1)||null,i=t.charCodeAt(r-1)||null;(!n||!Ys(n)||zr[t[r+1]])&&(!i||!Ys(i)||zr[t[r-1]])&&zr[t[r]]?e+=zr[t[r]]:e+=t[r]}return e}var ae=24;var rx=Y(mi(),1),nx=3;var Ia=nx;function hi(t){let e=0,r=0;for(let s of t)e+=s.w*s.h,r=Math.max(r,s.w);t.sort((s,l)=>l.h-s.h);let i=[{x:0,y:0,w:Math.max(Math.ceil(Math.sqrt(e/.95)),r),h:1/0}],o=0,a=0;for(let s of t)for(let l=i.length-1;l>=0;l--){let u=i[l];if(!(s.w>u.w||s.h>u.h)){if(s.x=u.x,s.y=u.y,a=Math.max(a,s.y+s.h),o=Math.max(o,s.x+s.w),s.w===u.w&&s.h===u.h){let c=i.pop();l<i.length&&(i[l]=c)}else s.h===u.h?(u.x+=s.w,u.w-=s.w):s.w===u.w?(u.y+=s.h,u.h-=s.h):(i.push({x:u.x+s.w,y:u.y,w:u.w-s.w,h:s.h}),u.y+=s.h,u.h-=s.h);break}}return{w:o,h:a,fill:e/(o*a)||0}}var he=1;var Ta=class{constructor(e,{pixelRatio:r,version:n,stretchX:i,stretchY:o,content:a,textFitWidth:s,textFitHeight:l}){this.paddedRect=e,this.pixelRatio=r,this.stretchX=i,this.stretchY=o,this.content=a,this.version=n,this.textFitWidth=s,this.textFitHeight=l}get tl(){return[this.paddedRect.x+he,this.paddedRect.y+he]}get br(){return[this.paddedRect.x+this.paddedRect.w-he,this.paddedRect.y+this.paddedRect.h-he]}get tlbr(){return this.tl.concat(this.br)}get displaySize(){return[(this.paddedRect.w-he*2)/this.pixelRatio,(this.paddedRect.h-he*2)/this.pixelRatio]}},di=class{constructor(e,r){let n={},i={};this.haveRenderCallbacks=[];let o=[];this.addImages(e,n,o),this.addImages(r,i,o);let{w:a,h:s}=hi(o),l=new fe({width:a||1,height:s||1});for(let u in e){let c=e[u],p=n[u].paddedRect;fe.copy(c.data,l,{x:0,y:0},{x:p.x+he,y:p.y+he},c.data)}for(let u in r){let c=r[u],p=i[u].paddedRect,f=p.x+he,y=p.y+he,m=c.data.width,h=c.data.height;fe.copy(c.data,l,{x:0,y:0},{x:f,y},c.data),fe.copy(c.data,l,{x:0,y:h-1},{x:f,y:y-1},{width:m,height:1}),fe.copy(c.data,l,{x:0,y:0},{x:f,y:y+h},{width:m,height:1}),fe.copy(c.data,l,{x:m-1,y:0},{x:f-1,y},{width:1,height:h}),fe.copy(c.data,l,{x:0,y:0},{x:f+m,y},{width:1,height:h})}this.image=l,this.iconPositions=n,this.patternPositions=i}addImages(e,r,n){for(let i in e){let o=e[i],a={x:0,y:0,w:o.data.width+2*he,h:o.data.height+2*he};n.push(a),r[i]=new Ta(a,o),o.hasRenderCallback&&this.haveRenderCallbacks.push(i)}}patchUpdatedImages(e,r){e.dispatchRenderCallbacks(this.haveRenderCallbacks);for(let n in e.updatedImages)this.patchUpdatedImage(this.iconPositions[n],e.getImage(n),r),this.patchUpdatedImage(this.patternPositions[n],e.getImage(n),r)}patchUpdatedImage(e,r,n){if(!e||!r||e.version===r.version)return;e.version=r.version;let[i,o]=e.tl;n.update(r.data,void 0,{x:i,y:o})}};I("ImagePosition",Ta);I("ImageAtlas",di);var Fa=(i=>(i[i.none=0]="none",i[i.horizontal=1]="horizontal",i[i.vertical=2]="vertical",i[i.horizontalOnly=3]="horizontalOnly",i))(Fa||{}),bi=-17;function ix(t){for(let e of t)if(e.positionedGlyphs.length!==0)return!1;return!0}var Sf=57344,wf=63743,Ca=class t{constructor(){this.scale=1,this.fontStack="",this.imageName=null,this.verticalAlign="bottom"}static forText(e,r,n){let i=new t;return i.scale=e||1,i.fontStack=r,i.verticalAlign=n||"bottom",i}static forImage(e,r){let n=new t;return n.imageName=e,n.verticalAlign=r||"bottom",n}},gi=class t{constructor(){this.text="",this.sectionIndex=[],this.sections=[],this.imageSectionID=null}static fromFeature(e,r){let n=new t;for(let i=0;i<e.sections.length;i++){let o=e.sections[i];o.image?n.addImageSection(o):n.addTextSection(o,r)}return n}length(){return this.text.length}getSection(e){return this.sections[this.sectionIndex[e]]}getSectionIndex(e){return this.sectionIndex[e]}getCharCode(e){return this.text.charCodeAt(e)}verticalizePunctuation(){this.text=hf(this.text)}trim(){let e=0;for(let n=0;n<this.text.length&&ka[this.text.charCodeAt(n)];n++)e++;let r=this.text.length;for(let n=this.text.length-1;n>=0&&n>=e&&ka[this.text.charCodeAt(n)];n--)r--;this.text=this.text.substring(e,r),this.sectionIndex=this.sectionIndex.slice(e,r)}substring(e,r){let n=new t;return n.text=this.text.substring(e,r),n.sectionIndex=this.sectionIndex.slice(e,r),n.sections=this.sections,n}toString(){return this.text}getMaxScale(){return this.sectionIndex.reduce((e,r)=>Math.max(e,this.sections[r].scale),0)}getMaxImageSize(e){let r=0,n=0;for(let i=0;i<this.length();i++){let o=this.getSection(i);if(o.imageName){let a=e[o.imageName];if(!a)continue;let s=a.displaySize;r=Math.max(r,s[0]),n=Math.max(n,s[1])}}return{maxImageWidth:r,maxImageHeight:n}}addTextSection(e,r){this.text+=e.text,this.sections.push(Ca.forText(e.scale,e.fontStack||r,e.verticalAlign));let n=this.sections.length-1;for(let i=0;i<e.text.length;++i)this.sectionIndex.push(n)}addImageSection(e){let r=e.image?e.image.name:"";if(r.length===0){ce("Can\'t add FormattedSection with an empty image.");return}let n=this.getNextImageSectionCharCode();if(!n){ce(`Reached maximum number of images ${wf-Sf+2}`);return}this.text+=String.fromCharCode(n),this.sections.push(Ca.forImage(r,e.verticalAlign)),this.sectionIndex.push(this.sections.length-1)}getNextImageSectionCharCode(){return this.imageSectionID?this.imageSectionID>=wf?null:++this.imageSectionID:(this.imageSectionID=Sf,this.imageSectionID)}};function ox(t,e){let r=[],n=t.text,i=0;for(let o of e)r.push(t.substring(i,o)),i=o;return i<n.length&&r.push(t.substring(i,n.length)),r}function xi(t,e,r,n,i,o,a,s,l,u,c,p,f,y,m){let h=gi.fromFeature(t,i);p===2&&h.verticalizePunctuation();let g,{processBidirectionalText:d,processStyledBidirectionalText:x}=we;if(d&&h.sections.length===1){g=[];let S=d(h.toString(),Al(h,u,o,e,n,y));for(let A of S){let w=new gi;w.text=A,w.sections=h.sections;for(let T=0;T<A.length;T++)w.sectionIndex.push(0);g.push(w)}}else if(x){g=[];let S=x(h.text,h.sectionIndex,Al(h,u,o,e,n,y));for(let A of S){let w=new gi;w.text=A[0],w.sectionIndex=A[1],w.sections=h.sections,g.push(w)}}else g=ox(h,Al(h,u,o,e,n,y));let b=[],v={positionedLines:b,text:h.toString(),top:c[1],bottom:c[1],left:c[0],right:c[0],writingMode:p,iconsInText:!1,verticalizable:!1};return yx(v,e,r,n,g,a,s,l,p,u,f,m),ix(b)?!1:v}var ka={9:!0,10:!0,11:!0,12:!0,13:!0,32:!0},ax={10:!0,32:!0,38:!0,41:!0,43:!0,45:!0,47:!0,173:!0,183:!0,8203:!0,8208:!0,8211:!0,8231:!0},sx={40:!0};function If(t,e,r,n,i,o){if(e.imageName){let a=n[e.imageName];return a?a.displaySize[0]*e.scale*ae/o+i:0}else{let a=r[e.fontStack],s=a&&a[t];return s?s.metrics.advance*e.scale+i:0}}function lx(t,e,r,n,i,o){let a=0;for(let l=0;l<t.length();l++){let u=t.getSection(l);a+=If(t.getCharCode(l),u,n,i,e,o)}let s=Math.max(1,Math.ceil(a/r));return a/s}function Af(t,e,r,n){let i=Math.pow(t-e,2);return n?t<e?i/2:i*2:i+Math.abs(r)*r}function ux(t,e,r){let n=0;return t===10&&(n-=1e4),r&&(n+=150),(t===40||t===65288)&&(n+=50),(e===41||e===65289)&&(n+=50),n}function _f(t,e,r,n,i,o){let a=null,s=Af(e,r,i,o);for(let l of n){let u=e-l.x,c=Af(u,r,i,o)+l.badness;c<=s&&(a=l,s=c)}return{index:t,x:e,priorBreak:a,badness:s}}function Tf(t){return t?Tf(t.priorBreak).concat(t.index):[]}function Al(t,e,r,n,i,o){if(!t)return[];let a=[],s=lx(t,e,r,n,i,o),l=t.text.indexOf("\\u200B")>=0,u=0;for(let c=0;c<t.length();c++){let p=t.getSection(c),f=t.getCharCode(c);if(ka[f]||(u+=If(f,p,n,i,e,o)),c<t.length()-1){let y=Yc(f);(ax[f]||y||p.imageName||c!==t.length()-2&&sx[t.getCharCode(c+1)])&&a.push(_f(c+1,u,s,a,ux(f,t.getCharCode(c+1),y&&l),!1))}}return Tf(_f(t.length(),u,s,a,0,!0))}function Cf(t){let e=.5,r=.5;switch(t){case"right":case"top-right":case"bottom-right":e=1;break;case"left":case"top-left":case"bottom-left":e=0;break}switch(t){case"bottom":case"bottom-right":case"bottom-left":r=1;break;case"top":case"top-right":case"top-left":r=0;break}return{horizontalAlign:e,verticalAlign:r}}function cx(t,e,r){let n=e.getMaxScale()*ae,{maxImageWidth:i,maxImageHeight:o}=e.getMaxImageSize(t),a=Math.max(n,o*r);return{verticalLineContentWidth:Math.max(n,i*r),horizontalLineContentHeight:a}}function kf(t){switch(t){case"top":return 0;case"center":return .5;default:return 1}}function px(t,e,r,n){if(t&&t.rect)return t;let i=e[r.fontStack],o=i&&i[n];return o?{rect:null,metrics:o.metrics}:null}function fx(t,e,r){return!(t===1||!e&&!Eo(r)||e&&(ka[r]||Kc(r)))}function yx(t,e,r,n,i,o,a,s,l,u,c,p){let f=0,y=0,m=0,h=0,g=s==="right"?1:s==="left"?0:.5,d=ae/p,x=0;for(let S of i){S.trim();let A=S.getMaxScale(),w={positionedGlyphs:[],lineOffset:0};t.positionedLines[x]=w;let T=w.positionedGlyphs,E=0;if(!S.length()){y+=o,++x;continue}let D=cx(n,S,d);for(let M=0;M<S.length();M++){let _=S.getSection(M),V=S.getSectionIndex(M),G=S.getCharCode(M),O=fx(l,c,G),R;if(_.imageName){if(t.iconsInText=!0,_.scale=_.scale*d,R=hx(_,O,A,D,n),!R)continue;E=Math.max(E,R.imageOffset)}else if(R=mx(_,G,O,D,e,r),!R)continue;let{rect:K,metrics:X,baselineOffset:re}=R;if(T.push({glyph:G,imageName:_.imageName,x:f,y:y+re+bi,vertical:O,scale:_.scale,fontStack:_.fontStack,sectionIndex:V,metrics:X,rect:K}),!O)f+=X.advance*_.scale+u;else{t.verticalizable=!0;let me=_.imageName?X.advance:ae;f+=me*_.scale+u}}if(T.length!==0){let M=f-u;m=Math.max(M,m),dx(T,0,T.length-1,g)}f=0;let B=(A-1)*ae;w.lineOffset=Math.max(E,B);let z=o*A+E;y+=z,h=Math.max(z,h),++x}let{horizontalAlign:b,verticalAlign:v}=Cf(a);gx(t.positionedLines,g,b,v,m,h,o,y,i.length),t.top+=-v*y,t.bottom=t.top+y,t.left+=-b*m,t.right=t.left+m}function mx(t,e,r,n,i,o){let a=o[t.fontStack],s=a&&a[e],l=px(s,i,t,e);if(l===null)return null;let u;if(r)u=n.verticalLineContentWidth-t.scale*ae;else{let c=kf(t.verticalAlign);u=(n.horizontalLineContentHeight-t.scale*ae)*c}return{rect:l.rect,metrics:l.metrics,baselineOffset:u}}function hx(t,e,r,n,i){let o=i[t.imageName];if(!o)return null;let a=o.paddedRect,s=o.displaySize,l={width:s[0],height:s[1],left:he,top:-Ia,advance:e?s[1]:s[0]},u;if(e)u=n.verticalLineContentWidth-s[1]*t.scale;else{let p=kf(t.verticalAlign);u=(n.horizontalLineContentHeight-s[1]*t.scale)*p}let c=(e?s[0]:s[1])*t.scale-ae*r;return{rect:a,metrics:l,baselineOffset:u,imageOffset:c}}function dx(t,e,r,n){if(n===0)return;let i=t[r],o=i.metrics.advance*i.scale,a=(t[r].x+o)*n;for(let s=e;s<=r;s++)t[s].x-=a}function gx(t,e,r,n,i,o,a,s,l){let u=(e-r)*i,c=0;o!==a?c=-s*n-bi:c=-n*l*a+.5*a;for(let p of t)for(let f of p.positionedGlyphs)f.x+=u,f.y+=c}function Ff(t,e,r){let{horizontalAlign:n,verticalAlign:i}=Cf(r),o=e[0],a=e[1],s=o-t.displaySize[0]*n,l=s+t.displaySize[0],u=a-t.displaySize[1]*i,c=u+t.displaySize[1];return{image:t,top:u,bottom:c,left:s,right:l}}function Ea(t){let e=t.left,r=t.top,n=t.right-e,i=t.bottom-r,o=t.image.content[2]-t.image.content[0],a=t.image.content[3]-t.image.content[1],s=t.image.textFitWidth??"stretchOrShrink",l=t.image.textFitHeight??"stretchOrShrink",u=o/a;if(l==="proportional"){if(s==="stretchOnly"&&n/i<u||s==="proportional"){let c=Math.ceil(i*u);e*=c/n,n=c}}else if(s==="proportional"&&l==="stretchOnly"&&u!==0&&n/i>u){let c=Math.ceil(n/u);r*=c/i,i=c}return{x1:e,y1:r,x2:e+n,y2:r+i}}function _l(t,e,r,n,i,o){let a=t.image,s;if(a.content){let g=a.content,d=a.pixelRatio||1;s=[g[0]/d,g[1]/d,a.displaySize[0]-g[2]/d,a.displaySize[1]-g[3]/d]}let l=e.left*o,u=e.right*o,c,p,f,y;r==="width"||r==="both"?(y=i[0]+l-n[3],p=i[0]+u+n[1]):(y=i[0]+(l+u-a.displaySize[0])/2,p=y+a.displaySize[0]);let m=e.top*o,h=e.bottom*o;return r==="height"||r==="both"?(c=i[1]+m-n[0],f=i[1]+h+n[2]):(c=i[1]+(m+h-a.displaySize[1])/2,f=c+a.displaySize[1]),{image:a,top:c,right:p,bottom:f,left:y,collisionPadding:s}}var Ef=Y(Rt(),1);var Nr=255,zt=128,Qe=Nr*zt;function Il(t,e){let{expression:r}=e;if(r.kind==="constant")return{kind:"constant",layoutSize:r.evaluate(new W(t+1))};if(r.kind==="source")return{kind:"source"};{let{zoomStops:n,interpolationType:i}=r,o=0;for(;o<n.length&&n[o]<=t;)o++;o=Math.max(0,o-1);let a=o;for(;a<n.length&&n[a]<t+1;)a++;a=Math.min(n.length-1,a);let s=n[o],l=n[a];if(r.kind==="composite")return{kind:"composite",minZoom:s,maxZoom:l,interpolationType:i};let u=r.evaluate(new W(s)),c=r.evaluate(new W(l));return{kind:"camera",minZoom:s,maxZoom:l,minSize:u,maxSize:c,interpolationType:i}}}function Tl(t,e,r){let n="never",i=t.get(e);return i?n=i:t.get(r)&&(n="always"),n}var bx=Ef.default.VectorTileFeature.types,xx=[{name:"a_fade_opacity",components:1,type:"Uint8",offset:0}];function Ma(t,e,r,n,i,o,a,s,l,u,c,p,f){let y=s?Math.min(Qe,Math.round(s[0])):0,m=s?Math.min(Qe,Math.round(s[1])):0;t.emplaceBack(e,r,Math.round(n*32),Math.round(i*32),o,a,(y<<1)+(l?1:0),m,u*16,c*16,p*256,f*256)}function Mf(t,e,r){t.emplaceBack(e.x,e.y,r),t.emplaceBack(e.x,e.y,r),t.emplaceBack(e.x,e.y,r),t.emplaceBack(e.x,e.y,r)}function vx(t){for(let e of t.sections)if(ep(e.text))return!0;return!1}var Pi=class{constructor(e){this.layoutVertexArray=new Yo,this.indexArray=new Le,this.programConfigurations=e,this.segments=new pe,this.dynamicLayoutVertexArray=new Ko,this.opacityVertexArray=new Qo,this.hasVisibleVertices=!1,this.placedSymbolArray=new qn}isEmpty(){return this.layoutVertexArray.length===0&&this.indexArray.length===0&&this.dynamicLayoutVertexArray.length===0&&this.opacityVertexArray.length===0}upload(e,r,n,i){this.isEmpty()||(n&&(this.layoutVertexBuffer=e.createVertexBuffer(this.layoutVertexArray,cf.members),this.indexBuffer=e.createIndexBuffer(this.indexArray,r),this.dynamicLayoutVertexBuffer=e.createVertexBuffer(this.dynamicLayoutVertexArray,pf.members,!0),this.opacityVertexBuffer=e.createVertexBuffer(this.opacityVertexArray,xx,!0),this.opacityVertexBuffer.itemSize=1),(n||i)&&this.programConfigurations.upload(e))}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.dynamicLayoutVertexBuffer.destroy(),this.opacityVertexBuffer.destroy())}};I("SymbolBuffers",Pi);var Si=class{constructor(e,r,n){this.layoutVertexArray=new e,this.layoutAttributes=r,this.indexArray=new n,this.segments=new pe,this.collisionVertexArray=new ea}upload(e){this.layoutVertexBuffer=e.createVertexBuffer(this.layoutVertexArray,this.layoutAttributes),this.indexBuffer=e.createIndexBuffer(this.indexArray),this.collisionVertexBuffer=e.createVertexBuffer(this.collisionVertexArray,ff.members,!0)}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.segments.destroy(),this.collisionVertexBuffer.destroy())}};I("CollisionBuffers",Si);var Xe=class{constructor(e){this.collisionBoxArray=e.collisionBoxArray,this.zoom=e.zoom,this.globalState=e.globalState,this.overscaling=e.overscaling,this.layers=e.layers,this.layerIds=this.layers.map(l=>l.id),this.index=e.index,this.pixelRatio=e.pixelRatio,this.sourceLayerIndex=e.sourceLayerIndex,this.hasPattern=!1,this.hasRTLText=!1,this.sortKeyRanges=[],this.collisionCircleArray=[];let n=this.layers[0]._unevaluatedLayout._values;this.textSizeData=Il(this.zoom,n["text-size"]),this.iconSizeData=Il(this.zoom,n["icon-size"]);let i=this.layers[0].layout,o=i.get("symbol-sort-key"),a=i.get("symbol-z-order");this.canOverlap=Tl(i,"text-overlap","text-allow-overlap")!=="never"||Tl(i,"icon-overlap","icon-allow-overlap")!=="never"||i.get("text-ignore-placement")||i.get("icon-ignore-placement"),this.sortFeaturesByKey=a!=="viewport-y"&&!o.isConstant();let s=a==="viewport-y"||a==="auto"&&!this.sortFeaturesByKey;this.sortFeaturesByY=s&&this.canOverlap,i.get("symbol-placement")==="point"&&(this.writingModes=i.get("text-writing-mode").map(l=>Fa[l])),this.stateDependentLayerIds=this.layers.filter(l=>l.isStateDependent()).map(l=>l.id),this.sourceID=e.sourceID}createArrays(){this.text=new Pi(new Ae(this.layers,this.zoom,e=>/^text/.test(e))),this.icon=new Pi(new Ae(this.layers,this.zoom,e=>/^icon/.test(e))),this.glyphOffsetArray=new Xn,this.lineVertexArray=new Hn,this.symbolInstances=new Wn,this.textAnchorOffsets=new Zn}calculateGlyphDependencies(e,r,n,i,o){for(let a=0;a<e.length;a++)if(r[e.charCodeAt(a)]=!0,(n||i)&&o){let s=zr[e.charAt(a)];s&&(r[s.charCodeAt(0)]=!0)}}populate(e,r,n){let i=this.layers[0],o=i.layout,a=o.get("text-font"),s=o.get("text-field"),l=o.get("icon-image"),u=(s.value.kind!=="constant"||s.value.value instanceof Fe&&!s.value.value.isEmpty()||s.value.value.toString().length>0)&&(a.value.kind!=="constant"||a.value.value.length>0),c=l.value.kind!=="constant"||!!l.value.value||Object.keys(l.parameters).length>0,p=o.get("symbol-sort-key");if(this.features=[],!u&&!c)return;let f=r.iconDependencies,y=r.glyphDependencies,m=r.availableImages,h=new W(this.zoom,{globalState:this.globalState});for(let{feature:g,id:d,index:x,sourceLayerIndex:b}of e){let v=i._featureFilter.needGeometry,S=Ne(g,v);if(!i._featureFilter.filter(h,S,n))continue;v||(S.geometry=_e(g));let A;if(u){let D=i.getValueAndResolveTokens("text-field",S,n,m),B=Fe.factory(D),z=this.hasRTLText=this.hasRTLText||vx(B);(!z||we.getRTLTextPluginStatus()==="unavailable"||z&&we.isParsed())&&(A=yf(B,i,S))}let w;if(c){let D=i.getValueAndResolveTokens("icon-image",S,n,m);D instanceof Se?w=D:w=Se.fromString(D)}if(!A&&!w)continue;let T=this.sortFeaturesByKey?p.evaluate(S,{},n):void 0,E={id:d,text:A,icon:w,index:x,sourceLayerIndex:b,geometry:S.geometry,properties:g.properties,type:bx[g.type],sortKey:T};if(this.features.push(E),w&&(f[w.name]=!0),A){let D=a.evaluate(S,{},n).join(","),B=o.get("text-rotation-alignment")!=="viewport"&&o.get("symbol-placement")!=="point";this.allowVerticalPlacement=this.writingModes&&this.writingModes.indexOf(2)>=0;for(let z of A.sections)if(z.image)f[z.image.name]=!0;else{let M=In(A.toString()),_=z.fontStack||D,V=y[_]=y[_]||{};this.calculateGlyphDependencies(z.text,V,B,this.allowVerticalPlacement,M)}}}o.get("symbol-placement")==="line"&&(this.features=mf(this.features)),this.sortFeaturesByKey&&this.features.sort((g,d)=>g.sortKey-d.sortKey)}update(e,r,n){this.stateDependentLayers.length&&(this.text.programConfigurations.updatePaintArrays(e,r,this.layers,n),this.icon.programConfigurations.updatePaintArrays(e,r,this.layers,n))}isEmpty(){return this.symbolInstances.length===0&&!this.hasRTLText}uploadPending(){return!this.uploaded||this.text.programConfigurations.needsUpload||this.icon.programConfigurations.needsUpload}upload(e){!this.uploaded&&this.hasDebugData()&&(this.textCollisionBox.upload(e),this.iconCollisionBox.upload(e)),this.text.upload(e,this.sortFeaturesByY,!this.uploaded,this.text.programConfigurations.needsUpload),this.icon.upload(e,this.sortFeaturesByY,!this.uploaded,this.icon.programConfigurations.needsUpload),this.uploaded=!0}destroyDebugData(){this.textCollisionBox.destroy(),this.iconCollisionBox.destroy()}destroy(){this.text.destroy(),this.icon.destroy(),this.hasDebugData()&&this.destroyDebugData()}addToLineVertexArray(e,r){let n=this.lineVertexArray.length;if(e.segment!==void 0){let i=e.dist(r[e.segment+1]),o=e.dist(r[e.segment]),a={};for(let s=e.segment+1;s<r.length;s++)a[s]={x:r[s].x,y:r[s].y,tileUnitDistanceFromAnchor:i},s<r.length-1&&(i+=r[s+1].dist(r[s]));for(let s=e.segment||0;s>=0;s--)a[s]={x:r[s].x,y:r[s].y,tileUnitDistanceFromAnchor:o},s>0&&(o+=r[s-1].dist(r[s]));for(let s=0;s<r.length;s++){let l=a[s];this.lineVertexArray.emplaceBack(l.x,l.y,l.tileUnitDistanceFromAnchor)}}return{lineStartIndex:n,lineLength:this.lineVertexArray.length-n}}addSymbols(e,r,n,i,o,a,s,l,u,c,p,f){let y=e.indexArray,m=e.layoutVertexArray,h=e.segments.prepareSegment(4*r.length,m,y,this.canOverlap?a.sortKey:void 0),g=this.glyphOffsetArray.length,d=h.vertexLength,x=this.allowVerticalPlacement&&s===2?Math.PI/2:0,b=a.text&&a.text.sections;for(let v=0;v<r.length;v++){let{tl:S,tr:A,bl:w,br:T,tex:E,pixelOffsetTL:D,pixelOffsetBR:B,minFontScaleX:z,minFontScaleY:M,glyphOffset:_,isSDF:V,sectionIndex:G}=r[v],O=h.vertexLength,R=_[1];Ma(m,l.x,l.y,S.x,R+S.y,E.x,E.y,n,V,D.x,D.y,z,M),Ma(m,l.x,l.y,A.x,R+A.y,E.x+E.w,E.y,n,V,B.x,D.y,z,M),Ma(m,l.x,l.y,w.x,R+w.y,E.x,E.y+E.h,n,V,D.x,B.y,z,M),Ma(m,l.x,l.y,T.x,R+T.y,E.x+E.w,E.y+E.h,n,V,B.x,B.y,z,M),Mf(e.dynamicLayoutVertexArray,l,x),y.emplaceBack(O,O+2,O+1),y.emplaceBack(O+1,O+2,O+3),h.vertexLength+=4,h.primitiveLength+=2,this.glyphOffsetArray.emplaceBack(_[0]),(v===r.length-1||G!==r[v+1].sectionIndex)&&e.programConfigurations.populatePaintArrays(m.length,a,a.index,{},f,b&&b[G])}e.placedSymbolArray.emplaceBack(l.x,l.y,g,this.glyphOffsetArray.length-g,d,u,c,l.segment,n?n[0]:0,n?n[1]:0,i[0],i[1],s,0,!1,0,p)}_addCollisionDebugVertex(e,r,n,i,o,a){return r.emplaceBack(0,0),e.emplaceBack(n.x,n.y,i,o,Math.round(a.x),Math.round(a.y))}addCollisionDebugVertices(e,r,n,i,o,a,s){let l=o.segments.prepareSegment(4,o.layoutVertexArray,o.indexArray),u=l.vertexLength,c=o.layoutVertexArray,p=o.collisionVertexArray,f=s.anchorX,y=s.anchorY;this._addCollisionDebugVertex(c,p,a,f,y,new vi.default(e,r)),this._addCollisionDebugVertex(c,p,a,f,y,new vi.default(n,r)),this._addCollisionDebugVertex(c,p,a,f,y,new vi.default(n,i)),this._addCollisionDebugVertex(c,p,a,f,y,new vi.default(e,i)),l.vertexLength+=4;let m=o.indexArray;m.emplaceBack(u,u+1),m.emplaceBack(u+1,u+2),m.emplaceBack(u+2,u+3),m.emplaceBack(u+3,u),l.primitiveLength+=4}addDebugCollisionBoxes(e,r,n,i){for(let o=e;o<r;o++){let a=this.collisionBoxArray.get(o),s=a.x1,l=a.y1,u=a.x2,c=a.y2;this.addCollisionDebugVertices(s,l,u,c,i?this.textCollisionBox:this.iconCollisionBox,a.anchorPoint,n)}}generateCollisionDebugBuffers(){this.hasDebugData()&&this.destroyDebugData(),this.textCollisionBox=new Si(Yn,Pl.members,Mt),this.iconCollisionBox=new Si(Yn,Pl.members,Mt);for(let e=0;e<this.symbolInstances.length;e++){let r=this.symbolInstances.get(e);this.addDebugCollisionBoxes(r.textBoxStartIndex,r.textBoxEndIndex,r,!0),this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex,r.verticalTextBoxEndIndex,r,!0),this.addDebugCollisionBoxes(r.iconBoxStartIndex,r.iconBoxEndIndex,r,!1),this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex,r.verticalIconBoxEndIndex,r,!1)}}_deserializeCollisionBoxesForSymbol(e,r,n,i,o,a,s,l,u){let c={};for(let p=r;p<n;p++){let f=e.get(p);c.textBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.textFeatureIndex=f.featureIndex;break}for(let p=i;p<o;p++){let f=e.get(p);c.verticalTextBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.verticalTextFeatureIndex=f.featureIndex;break}for(let p=a;p<s;p++){let f=e.get(p);c.iconBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.iconFeatureIndex=f.featureIndex;break}for(let p=l;p<u;p++){let f=e.get(p);c.verticalIconBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.verticalIconFeatureIndex=f.featureIndex;break}return c}deserializeCollisionBoxes(e){this.collisionArrays=[];for(let r=0;r<this.symbolInstances.length;r++){let n=this.symbolInstances.get(r);this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e,n.textBoxStartIndex,n.textBoxEndIndex,n.verticalTextBoxStartIndex,n.verticalTextBoxEndIndex,n.iconBoxStartIndex,n.iconBoxEndIndex,n.verticalIconBoxStartIndex,n.verticalIconBoxEndIndex))}}hasTextData(){return this.text.segments.get().length>0}hasIconData(){return this.icon.segments.get().length>0}hasDebugData(){return this.textCollisionBox&&this.iconCollisionBox}hasTextCollisionBoxData(){return this.hasDebugData()&&this.textCollisionBox.segments.get().length>0}hasIconCollisionBoxData(){return this.hasDebugData()&&this.iconCollisionBox.segments.get().length>0}addIndicesForPlacedSymbol(e,r){let n=e.placedSymbolArray.get(r),i=n.vertexStartIndex+n.numGlyphs*4;for(let o=n.vertexStartIndex;o<i;o+=4)e.indexArray.emplaceBack(o,o+2,o+1),e.indexArray.emplaceBack(o+1,o+2,o+3)}getSortedSymbolIndexes(e){if(this.sortedAngle===e&&this.symbolInstanceIndexes!==void 0)return this.symbolInstanceIndexes;let r=Math.sin(e),n=Math.cos(e),i=[],o=[],a=[];for(let s=0;s<this.symbolInstances.length;++s){a.push(s);let l=this.symbolInstances.get(s);i.push(Math.round(r*l.anchorX+n*l.anchorY)|0),o.push(l.featureIndex)}return a.sort((s,l)=>i[s]-i[l]||o[l]-o[s]),a}addToSortKeyRanges(e,r){let n=this.sortKeyRanges[this.sortKeyRanges.length-1];n&&n.sortKey===r?n.symbolInstanceEnd=e+1:this.sortKeyRanges.push({sortKey:r,symbolInstanceStart:e,symbolInstanceEnd:e+1})}sortFeatures(e){if(this.sortFeaturesByY&&this.sortedAngle!==e&&!(this.text.segments.get().length>1||this.icon.segments.get().length>1)){this.symbolInstanceIndexes=this.getSortedSymbolIndexes(e),this.sortedAngle=e,this.text.indexArray.clear(),this.icon.indexArray.clear(),this.featureSortOrder=[];for(let r of this.symbolInstanceIndexes){let n=this.symbolInstances.get(r);this.featureSortOrder.push(n.featureIndex),[n.rightJustifiedTextSymbolIndex,n.centerJustifiedTextSymbolIndex,n.leftJustifiedTextSymbolIndex].forEach((i,o,a)=>{i>=0&&a.indexOf(i)===o&&this.addIndicesForPlacedSymbol(this.text,i)}),n.verticalPlacedTextSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.text,n.verticalPlacedTextSymbolIndex),n.placedIconSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.icon,n.placedIconSymbolIndex),n.verticalPlacedIconSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.icon,n.verticalPlacedIconSymbolIndex)}this.text.indexBuffer&&this.text.indexBuffer.updateData(this.text.indexArray),this.icon.indexBuffer&&this.icon.indexBuffer.updateData(this.icon.indexArray)}}};I("SymbolBucket",Xe,{omit:["layers","collisionBoxArray","features","compareText"]});Xe.MAX_GLYPHS=65535;Xe.addDynamicAttributes=Mf;function Lf(t,e){return e.replace(/{([^{}]+)}/g,(r,n)=>t&&n in t?String(t[n]):"")}var Df,Px=()=>Df=Df||new ee({"symbol-placement":new F(P.layout_symbol["symbol-placement"]),"symbol-spacing":new F(P.layout_symbol["symbol-spacing"]),"symbol-avoid-edges":new F(P.layout_symbol["symbol-avoid-edges"]),"symbol-sort-key":new L(P.layout_symbol["symbol-sort-key"]),"symbol-z-order":new F(P.layout_symbol["symbol-z-order"]),"icon-allow-overlap":new F(P.layout_symbol["icon-allow-overlap"]),"icon-overlap":new F(P.layout_symbol["icon-overlap"]),"icon-ignore-placement":new F(P.layout_symbol["icon-ignore-placement"]),"icon-optional":new F(P.layout_symbol["icon-optional"]),"icon-rotation-alignment":new F(P.layout_symbol["icon-rotation-alignment"]),"icon-size":new L(P.layout_symbol["icon-size"]),"icon-text-fit":new F(P.layout_symbol["icon-text-fit"]),"icon-text-fit-padding":new F(P.layout_symbol["icon-text-fit-padding"]),"icon-image":new L(P.layout_symbol["icon-image"]),"icon-rotate":new L(P.layout_symbol["icon-rotate"]),"icon-padding":new L(P.layout_symbol["icon-padding"]),"icon-keep-upright":new F(P.layout_symbol["icon-keep-upright"]),"icon-offset":new L(P.layout_symbol["icon-offset"]),"icon-anchor":new L(P.layout_symbol["icon-anchor"]),"icon-pitch-alignment":new F(P.layout_symbol["icon-pitch-alignment"]),"text-pitch-alignment":new F(P.layout_symbol["text-pitch-alignment"]),"text-rotation-alignment":new F(P.layout_symbol["text-rotation-alignment"]),"text-field":new L(P.layout_symbol["text-field"]),"text-font":new L(P.layout_symbol["text-font"]),"text-size":new L(P.layout_symbol["text-size"]),"text-max-width":new L(P.layout_symbol["text-max-width"]),"text-line-height":new F(P.layout_symbol["text-line-height"]),"text-letter-spacing":new L(P.layout_symbol["text-letter-spacing"]),"text-justify":new L(P.layout_symbol["text-justify"]),"text-radial-offset":new L(P.layout_symbol["text-radial-offset"]),"text-variable-anchor":new F(P.layout_symbol["text-variable-anchor"]),"text-variable-anchor-offset":new L(P.layout_symbol["text-variable-anchor-offset"]),"text-anchor":new L(P.layout_symbol["text-anchor"]),"text-max-angle":new F(P.layout_symbol["text-max-angle"]),"text-writing-mode":new F(P.layout_symbol["text-writing-mode"]),"text-rotate":new L(P.layout_symbol["text-rotate"]),"text-padding":new F(P.layout_symbol["text-padding"]),"text-keep-upright":new F(P.layout_symbol["text-keep-upright"]),"text-transform":new L(P.layout_symbol["text-transform"]),"text-offset":new L(P.layout_symbol["text-offset"]),"text-allow-overlap":new F(P.layout_symbol["text-allow-overlap"]),"text-overlap":new F(P.layout_symbol["text-overlap"]),"text-ignore-placement":new F(P.layout_symbol["text-ignore-placement"]),"text-optional":new F(P.layout_symbol["text-optional"])}),Bf,Sx=()=>Bf=Bf||new ee({"icon-opacity":new L(P.paint_symbol["icon-opacity"]),"icon-color":new L(P.paint_symbol["icon-color"]),"icon-halo-color":new L(P.paint_symbol["icon-halo-color"]),"icon-halo-width":new L(P.paint_symbol["icon-halo-width"]),"icon-halo-blur":new L(P.paint_symbol["icon-halo-blur"]),"icon-translate":new F(P.paint_symbol["icon-translate"]),"icon-translate-anchor":new F(P.paint_symbol["icon-translate-anchor"]),"text-opacity":new L(P.paint_symbol["text-opacity"]),"text-color":new L(P.paint_symbol["text-color"],{runtimeType:ze,getOverride:t=>t.textColor,hasOverride:t=>!!t.textColor}),"text-halo-color":new L(P.paint_symbol["text-halo-color"]),"text-halo-width":new L(P.paint_symbol["text-halo-width"]),"text-halo-blur":new L(P.paint_symbol["text-halo-blur"]),"text-translate":new F(P.paint_symbol["text-translate"]),"text-translate-anchor":new F(P.paint_symbol["text-translate-anchor"])}),La={get paint(){return Sx()},get layout(){return Px()}};var wi=class{constructor(e){if(e.property.overrides===void 0)throw new Error("overrides must be provided to instantiate FormatSectionOverride class");this.type=e.property.overrides?e.property.overrides.runtimeType:wr,this.defaultValue=e}evaluate(e){if(e.formattedSection){let r=this.defaultValue.property.overrides;if(r&&r.hasOverride(e.formattedSection))return r.getOverride(e.formattedSection)}return e.feature&&e.featureState?this.defaultValue.evaluate(e.feature,e.featureState):this.defaultValue.property.specification.default}eachChild(e){if(!this.defaultValue.isConstant()){let r=this.defaultValue.value;e(r._styleExpression.expression)}}outputDefined(){return!1}serialize(){return null}};I("FormatSectionOverride",wi,{omit:["defaultValue"]});var Da=class t extends oe{constructor(e){super(e,La)}recalculate(e,r){if(super.recalculate(e,r),this.layout.get("icon-rotation-alignment")==="auto"&&(this.layout.get("symbol-placement")!=="point"?this.layout._values["icon-rotation-alignment"]="map":this.layout._values["icon-rotation-alignment"]="viewport"),this.layout.get("text-rotation-alignment")==="auto"&&(this.layout.get("symbol-placement")!=="point"?this.layout._values["text-rotation-alignment"]="map":this.layout._values["text-rotation-alignment"]="viewport"),this.layout.get("text-pitch-alignment")==="auto"&&(this.layout._values["text-pitch-alignment"]=this.layout.get("text-rotation-alignment")==="map"?"map":"viewport"),this.layout.get("icon-pitch-alignment")==="auto"&&(this.layout._values["icon-pitch-alignment"]=this.layout.get("icon-rotation-alignment")),this.layout.get("symbol-placement")==="point"){let n=this.layout.get("text-writing-mode");if(n){let i=[];for(let o of n)i.indexOf(o)<0&&i.push(o);this.layout._values["text-writing-mode"]=i}else this.layout._values["text-writing-mode"]=["horizontal"]}this._setPaintOverrides()}getValueAndResolveTokens(e,r,n,i){let o=this.layout.get(e).evaluate(r,{},n,i),a=this._unevaluatedLayout._values[e];return!a.isDataDriven()&&!wn(a.value)&&o?Lf(r.properties,o):o}createBucket(e){return new Xe(e)}queryRadius(){return 0}queryIntersectsFeature(){throw new Error("Should take a different path in FeatureIndex")}_setPaintOverrides(){for(let e of La.paint.overridableProperties){if(!t.hasPaintOverride(this.layout,e))continue;let r=this.paint.get(e),n=new wi(r),i=new Ht(n,r.property.specification),o=null;r.value.kind==="constant"||r.value.kind==="source"?o=new Je("source",i):o=new Tt("composite",i,r.value.zoomStops),this.paint._values[e]=new ge(r.property,o,r.parameters)}}_handleOverridablePaintPropertyUpdate(e,r,n){return!this.layout||r.isDataDriven()||n.isDataDriven()?!1:t.hasPaintOverride(this.layout,e)}static hasPaintOverride(e,r){let n=e.get("text-field"),i=La.paint.properties[r],o=!1,a=s=>{for(let l of s)if(i.overrides&&i.overrides.hasOverride(l)){o=!0;return}};if(n.value.kind==="constant"&&n.value.value instanceof Fe)a(n.value.value.sections);else if(n.value.kind==="source"){let s=u=>{if(!o)if(u instanceof _t&&ue(u.value)===Ar){let c=u.value;a(c.sections)}else u instanceof pn?a(u.sections):u.eachChild(s)},l=n.value;l._styleExpression&&s(l._styleExpression.expression)}return o}};function Vf(t,e,r,n=1){let i=t.get("icon-padding").evaluate(e,{},r),o=i&&i.values;return[o[0]*n,o[1]*n,o[2]*n,o[3]*n]}var Rf,wx=()=>Rf=Rf||new ee({"background-color":new F(P.paint_background["background-color"]),"background-pattern":new tr(P.paint_background["background-pattern"]),"background-opacity":new F(P.paint_background["background-opacity"])}),zf={get paint(){return wx()}};var Ba=class extends oe{constructor(e){super(e,zf)}};var Of,Ax=()=>Of=Of||new ee({"raster-opacity":new F(P.paint_raster["raster-opacity"]),"raster-hue-rotate":new F(P.paint_raster["raster-hue-rotate"]),"raster-brightness-min":new F(P.paint_raster["raster-brightness-min"]),"raster-brightness-max":new F(P.paint_raster["raster-brightness-max"]),"raster-saturation":new F(P.paint_raster["raster-saturation"]),"raster-contrast":new F(P.paint_raster["raster-contrast"]),"raster-resampling":new F(P.paint_raster["raster-resampling"]),"raster-fade-duration":new F(P.paint_raster["raster-fade-duration"])}),Gf={get paint(){return Ax()}};var Va=class extends oe{constructor(e){super(e,Gf)}};var Ra=class extends oe{constructor(r){super(r,{});this.onAdd=r=>{this.implementation.onAdd&&this.implementation.onAdd(r,r.painter.context.gl)};this.onRemove=r=>{this.implementation.onRemove&&this.implementation.onRemove(r,r.painter.context.gl)};this.implementation=r}is3D(){return this.implementation.renderingMode==="3d"}hasOffscreenPass(){return this.implementation.prerender!==void 0}recalculate(){}updateTransitions(){}hasTransition(){return!1}serialize(){throw new Error("Custom layers cannot be serialized")}};function Nf(t){if(t.type==="custom")return new Ra(t);switch(t.type){case"background":return new Ba(t);case"circle":return new la(t);case"color-relief":return new pa(t);case"fill":return new ba(t);case"fill-extrusion":return new Pa(t);case"heatmap":return new ua(t);case"hillshade":return new ca(t);case"line":return new wa(t);case"raster":return new Va(t);case"symbol":return new Da(t)}}var za=class{constructor(e){this.keyCache={},e&&this.replace(e)}replace(e){this._layerConfigs={},this._layers={},this.update(e,[])}update(e,r){for(let i of e){this._layerConfigs[i.id]=i;let o=this._layers[i.id]=Nf(i);o._featureFilter=Ct(o.filter),this.keyCache[i.id]&&delete this.keyCache[i.id]}for(let i of r)delete this.keyCache[i],delete this._layerConfigs[i],delete this._layers[i];this.familiesBySource={};let n=dc(Object.values(this._layerConfigs),this.keyCache);for(let i of n){let o=i.map(p=>this._layers[p.id]),a=o[0];if(a.visibility==="none")continue;let s=a.source||"",l=this.familiesBySource[s];l||(l=this.familiesBySource[s]={});let u=a.sourceLayer||"_geojsonTileLayer",c=l[u];c||(c=l[u]=[]),c.push(o)}}};var fy=Y(Rt(),1),yy=Y(mi(),1);var Ur=class{constructor(e){this._stringToNumber={},this._numberToString=[];for(let r=0;r<e.length;r++){let n=e[r];this._stringToNumber[n]=r,this._numberToString[r]=n}}encode(e){return this._stringToNumber[e]}decode(e){if(e>=this._numberToString.length)throw new Error(`Out of bounds. Index requested n=${e} can\'t be >= this._numberToString.length ${this._numberToString.length}`);return this._numberToString[e]}};var $f=Y(Rt(),1),jf=Y(mi(),1);var Oa=class{constructor(e,r,n,i,o){this.type="Feature",this._vectorTileFeature=e,e._z=r,e._x=n,e._y=i,this.properties=e.properties,this.id=o}get geometry(){return this._geometry===void 0&&(this._geometry=this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x,this._vectorTileFeature._y,this._vectorTileFeature._z).geometry),this._geometry}set geometry(e){this._geometry=e}toJSON(){let e={geometry:this.geometry};for(let r in this)r==="_geometry"||r==="_vectorTileFeature"||(e[r]=this[r]);return e}};var Ai=Y(ye(),1),fr=class t{constructor(){this.minX=1/0;this.maxX=-1/0;this.minY=1/0;this.maxY=-1/0}extend(e){return this.minX=Math.min(this.minX,e.x),this.minY=Math.min(this.minY,e.y),this.maxX=Math.max(this.maxX,e.x),this.maxY=Math.max(this.maxY,e.y),this}expandBy(e){return this.minX-=e,this.minY-=e,this.maxX+=e,this.maxY+=e,(this.minX>this.maxX||this.minY>this.maxY)&&(this.minX=1/0,this.maxX=-1/0,this.minY=1/0,this.maxY=-1/0),this}shrinkBy(e){return this.expandBy(-e)}map(e){let r=new t;return r.extend(e(new Ai.default(this.minX,this.minY))),r.extend(e(new Ai.default(this.maxX,this.minY))),r.extend(e(new Ai.default(this.minX,this.maxY))),r.extend(e(new Ai.default(this.maxX,this.maxY))),r}static fromPoints(e){let r=new t;for(let n of e)r.extend(n);return r}contains(e){return e.x>=this.minX&&e.x<=this.maxX&&e.y>=this.minY&&e.y<=this.maxY}empty(){return this.minX>this.maxX}width(){return this.maxX-this.minX}height(){return this.maxY-this.minY}covers(e){return!this.empty()&&!e.empty()&&e.minX>=this.minX&&e.maxX<=this.maxX&&e.minY>=this.minY&&e.maxY<=this.maxY}intersects(e){return!this.empty()&&!e.empty()&&e.minX<=this.maxX&&e.maxX>=this.minX&&e.minY<=this.maxY&&e.maxY>=this.minY}};var _i=class{constructor(e,r){this.tileID=e,this.x=e.canonical.x,this.y=e.canonical.y,this.z=e.canonical.z,this.grid=new $t(8192,16,0),this.grid3D=new $t(8192,16,0),this.featureIndexArray=new Jn,this.promoteId=r}insert(e,r,n,i,o,a){let s=this.featureIndexArray.length;this.featureIndexArray.emplaceBack(n,i,o);let l=a?this.grid3D:this.grid;for(let u=0;u<r.length;u++){let c=r[u],p=[1/0,1/0,-1/0,-1/0];for(let f=0;f<c.length;f++){let y=c[f];p[0]=Math.min(p[0],y.x),p[1]=Math.min(p[1],y.y),p[2]=Math.max(p[2],y.x),p[3]=Math.max(p[3],y.y)}p[0]<8192&&p[1]<8192&&p[2]>=0&&p[3]>=0&&l.insert(s,p[0],p[1],p[2],p[3])}}loadVTLayers(){return this.vtLayers||(this.vtLayers=new $f.default.VectorTile(new jf.default(this.rawTileData)).layers,this.sourceLayerCoder=new Ur(this.vtLayers?Object.keys(this.vtLayers).sort():["_geojsonTileLayer"])),this.vtLayers}query(e,r,n,i){this.loadVTLayers();let o=e.params,a=8192/e.tileSize/e.scale,s=Ct(o.filter),l=e.queryGeometry,u=e.queryPadding*a,c=fr.fromPoints(l),p=this.grid.query(c.minX-u,c.minY-u,c.maxX+u,c.maxY+u),f=fr.fromPoints(e.cameraQueryGeometry).expandBy(u),y=this.grid3D.query(f.minX,f.minY,f.maxX,f.maxY,(g,d,x,b)=>gp(e.cameraQueryGeometry,g-u,d-u,x+u,b+u));for(let g of y)p.push(g);p.sort(_x);let m={},h;for(let g=0;g<p.length;g++){let d=p[g];if(d===h)continue;h=d;let x=this.featureIndexArray.get(d),b=null;this.loadMatchingFeature(m,x.bucketIndex,x.sourceLayerIndex,x.featureIndex,s,o.layers,o.availableImages,r,n,i,(v,S,A)=>(b||(b=_e(v)),S.queryIntersectsFeature({queryGeometry:l,feature:v,featureState:A,geometry:b,zoom:this.z,transform:e.transform,pixelsToTileUnits:a,pixelPosMatrix:e.pixelPosMatrix,unwrappedTileID:this.tileID.toUnwrapped(),getElevation:e.getElevation})))}return m}loadMatchingFeature(e,r,n,i,o,a,s,l,u,c,p){let f=this.bucketLayerIDs[r];if(a&&!f.some(d=>a.has(d)))return;let y=this.sourceLayerCoder.decode(n),h=this.vtLayers[y].feature(i);if(o.needGeometry){let d=Ne(h,!0);if(!o.filter(new W(this.tileID.overscaledZ),d,this.tileID.canonical))return}else if(!o.filter(new W(this.tileID.overscaledZ),h))return;let g=this.getId(h,y);for(let d=0;d<f.length;d++){let x=f[d];if(a&&!a.has(x))continue;let b=l[x];if(!b)continue;let v={};g&&c&&(v=c.getState(b.sourceLayer||"_geojsonTileLayer",g));let S=de({},u[x]);S.paint=Uf(S.paint,b.paint,h,v,s),S.layout=Uf(S.layout,b.layout,h,v,s);let A=!p||p(h,b,v);if(!A)continue;let w=new Oa(h,this.z,this.x,this.y,g);w.layer=S;let T=e[x];T===void 0&&(T=e[x]=[]),T.push({featureIndex:i,feature:w,intersectionZ:A})}}lookupSymbolFeatures(e,r,n,i,o,a,s,l){let u={};this.loadVTLayers();let c=Ct(o);for(let p of e)this.loadMatchingFeature(u,n,i,p,c,a,s,l,r);return u}hasLayer(e){for(let r of this.bucketLayerIDs)for(let n of r)if(e===n)return!0;return!1}getId(e,r){let n=e.id;if(this.promoteId){let i=typeof this.promoteId=="string"?this.promoteId:this.promoteId[r];n=e.properties[i],typeof n=="boolean"&&(n=Number(n)),n===void 0&&e.properties?.cluster&&this.promoteId&&(n=Number(e.properties.cluster_id))}return n}};I("FeatureIndex",_i,{omit:["rawTileData","sourceLayerCoder"]});function Uf(t,e,r,n,i){return tn(t,(o,a)=>{let s=e instanceof kt?e.get(a):null;return s&&s.evaluate?s.evaluate(r,n,i):s})}function _x(t,e){return e-t}var qf=Y(ye(),1);var et=class t extends qf.default{constructor(e,r,n,i){super(e,r),this.angle=n,i!==void 0&&(this.segment=i)}clone(){return new t(this.x,this.y,this.angle,this.segment)}};I("Anchor",et);function Cl(t,e,r,n,i){if(e.segment===void 0||r===0)return!0;let o=e,a=e.segment+1,s=0;for(;s>-r/2;){if(a--,a<0)return!1;s-=t[a].dist(o),o=t[a]}s+=t[a].dist(t[a+1]),a++;let l=[],u=0;for(;s<r/2;){let c=t[a-1],p=t[a],f=t[a+1];if(!f)return!1;let y=c.angleTo(p)-p.angleTo(f);for(y=Math.abs((y+3*Math.PI)%(Math.PI*2)-Math.PI),l.push({distance:s,angleDelta:y}),u+=y;s-l[0].distance>n;)u-=l.shift().angleDelta;if(u>i)return!1;a++,s+=p.dist(f)}return!0}function Wf(t){let e=0;for(let r=0;r<t.length-1;r++)e+=t[r].dist(t[r+1]);return e}function Xf(t,e,r){return t?3/5*e*r:0}function Hf(t,e){return Math.max(t?t.right-t.left:0,e?e.right-e.left:0)}function Zf(t,e,r,n,i,o){let a=Xf(r,i,o),s=Hf(r,n)*o,l=0,u=Wf(t)/2;for(let c=0;c<t.length-1;c++){let p=t[c],f=t[c+1],y=p.dist(f);if(l+y>u){let m=(u-l)/y,h=lt.number(p.x,f.x,m),g=lt.number(p.y,f.y,m),d=new et(h,g,f.angleTo(p),c);return d._round(),!a||Cl(t,d,s,a,e)?d:void 0}l+=y}}function Jf(t,e,r,n,i,o,a,s,l){let u=Xf(n,o,a),c=Hf(n,i),p=c*a,f=t[0].x===0||t[0].x===l||t[0].y===0||t[0].y===l;e-p<e/4&&(e=p+e/4);let y=o*2,m=f?e/2*s%e:(c/2+y)*a*s%e;return Yf(t,m,e,u,r,p,f,!1,l)}function Yf(t,e,r,n,i,o,a,s,l){let u=o/2,c=Wf(t),p=0,f=e-r,y=[];for(let m=0;m<t.length-1;m++){let h=t[m],g=t[m+1],d=h.dist(g),x=g.angleTo(h);for(;f+r<p+d;){f+=r;let b=(f-p)/d,v=lt.number(h.x,g.x,b),S=lt.number(h.y,g.y,b);if(v>=0&&v<l&&S>=0&&S<l&&f-u>=0&&f+u<=c){let A=new et(v,S,x,m);A._round(),(!n||Cl(t,A,o,n,i))&&y.push(A)}}p+=d}return!s&&!y.length&&!a&&(y=Yf(t,p/2,r,n,i,o,a,!0,l)),y}var ht=Y(ye(),1);function Kf(t,e,r,n,i){let o=[];for(let a=0;a<t.length;a++){let s=t[a],l;for(let u=0;u<s.length-1;u++){let c=s[u],p=s[u+1];c.x<e&&p.x<e||(c.x<e?c=new ht.default(e,c.y+(p.y-c.y)*((e-c.x)/(p.x-c.x)))._round():p.x<e&&(p=new ht.default(e,c.y+(p.y-c.y)*((e-c.x)/(p.x-c.x)))._round()),!(c.y<r&&p.y<r)&&(c.y<r?c=new ht.default(c.x+(p.x-c.x)*((r-c.y)/(p.y-c.y)),r)._round():p.y<r&&(p=new ht.default(c.x+(p.x-c.x)*((r-c.y)/(p.y-c.y)),r)._round()),!(c.x>=n&&p.x>=n)&&(c.x>=n?c=new ht.default(n,c.y+(p.y-c.y)*((n-c.x)/(p.x-c.x)))._round():p.x>=n&&(p=new ht.default(n,c.y+(p.y-c.y)*((n-c.x)/(p.x-c.x)))._round()),!(c.y>=i&&p.y>=i)&&(c.y>=i?c=new ht.default(c.x+(p.x-c.x)*((i-c.y)/(p.y-c.y)),i)._round():p.y>=i&&(p=new ht.default(c.x+(p.x-c.x)*((i-c.y)/(p.y-c.y)),i)._round()),(!l||!c.equals(l[l.length-1]))&&(l=[c],o.push(l)),l.push(p)))))}}return o}var be=Y(ye(),1);var $r=he;function kl(t,e,r,n){let i=[],o=t.image,a=o.pixelRatio,s=o.paddedRect.w-2*$r,l=o.paddedRect.h-2*$r,u={x1:t.left,y1:t.top,x2:t.right,y2:t.bottom},c=o.stretchX||[[0,s]],p=o.stretchY||[[0,l]],f=(_,V)=>_+V[1]-V[0],y=c.reduce(f,0),m=p.reduce(f,0),h=s-y,g=l-m,d=0,x=y,b=0,v=m,S=0,A=h,w=0,T=g;if(o.content&&n){let _=o.content,V=_[2]-_[0],G=_[3]-_[1];(o.textFitWidth||o.textFitHeight)&&(u=Ea(t)),d=Ga(c,0,_[0]),b=Ga(p,0,_[1]),x=Ga(c,_[0],_[2]),v=Ga(p,_[1],_[3]),S=_[0]-d,w=_[1]-b,A=V-x,T=G-v}let E=u.x1,D=u.y1,B=u.x2-E,z=u.y2-D,M=(_,V,G,O)=>{let R=Na(_.stretch-d,x,B,E),K=Ua(_.fixed-S,A,_.stretch,y),X=Na(V.stretch-b,v,z,D),re=Ua(V.fixed-w,T,V.stretch,m),me=Na(G.stretch-d,x,B,E),Ut=Ua(G.fixed-S,A,G.stretch,y),tt=Na(O.stretch-b,v,z,D),gt=Ua(O.fixed-w,T,O.stretch,m),Gi=new be.default(R,X),Ni=new be.default(me,X),Ui=new be.default(me,tt),$i=new be.default(R,tt),is=new be.default(K/a,re/a),Ie=new be.default(Ut/a,gt/a),bt=e*Math.PI/180;if(bt){let xt=Math.sin(bt),Zr=Math.cos(bt),Be=[Zr,-xt,xt,Zr];Gi._matMult(Be),Ni._matMult(Be),$i._matMult(Be),Ui._matMult(Be)}let Hr=_.stretch+_.fixed,os=G.stretch+G.fixed,ji=V.stretch+V.fixed,as=O.stretch+O.fixed,Te={x:o.paddedRect.x+$r+Hr,y:o.paddedRect.y+$r+ji,w:os-Hr,h:as-ji},xe=A/a/B,rt=T/a/z;return{tl:Gi,tr:Ni,bl:$i,br:Ui,tex:Te,writingMode:void 0,glyphOffset:[0,0],sectionIndex:0,pixelOffsetTL:is,pixelOffsetBR:Ie,minFontScaleX:xe,minFontScaleY:rt,isSDF:r}};if(!n||!o.stretchX&&!o.stretchY)i.push(M({fixed:0,stretch:-1},{fixed:0,stretch:-1},{fixed:0,stretch:s+1},{fixed:0,stretch:l+1}));else{let _=Qf(c,h,y),V=Qf(p,g,m);for(let G=0;G<_.length-1;G++){let O=_[G],R=_[G+1];for(let K=0;K<V.length-1;K++){let X=V[K],re=V[K+1];i.push(M(O,X,R,re))}}}return i}function Ga(t,e,r){let n=0;for(let i of t)n+=Math.max(e,Math.min(r,i[1]))-Math.max(e,Math.min(r,i[0]));return n}function Qf(t,e,r){let n=[{fixed:-$r,stretch:0}];for(let[i,o]of t){let a=n[n.length-1];n.push({fixed:i-a.stretch,stretch:a.stretch}),n.push({fixed:i-a.stretch,stretch:a.stretch+(o-i)})}return n.push({fixed:e+$r,stretch:r}),n}function Na(t,e,r,n){return t/e*r+n}function Ua(t,e,r,n){return t-e*r/n}function ey(t,e,r,n,i,o,a,s){let l=n.layout.get("text-rotate").evaluate(o,{})*Math.PI/180,u=[];for(let c of e.positionedLines)for(let p of c.positionedGlyphs){if(!p.rect)continue;let f=p.rect||{},m=Ia+1,h=!0,g=1,d=0,x=(i||s)&&p.vertical,b=p.metrics.advance*p.scale/2;if(s&&e.verticalizable){let X=(p.scale-1)*ae,re=(ae-p.metrics.width*p.scale)/2;d=c.lineOffset/2-(p.imageName?-re:X)}if(p.imageName){let X=a[p.imageName];h=X.sdf,g=X.pixelRatio,m=he/g}let v=i?[p.x+b,p.y]:[0,0],S=i?[0,0]:[p.x+b+r[0],p.y+r[1]-d],A=[0,0];x&&(A=S,S=[0,0]);let w=p.metrics.isDoubleResolution?2:1,T=(p.metrics.left-m)*p.scale-b+S[0],E=(-p.metrics.top-m)*p.scale+S[1],D=T+f.w/w*p.scale/g,B=E+f.h/w*p.scale/g,z=new be.default(T,E),M=new be.default(D,E),_=new be.default(T,B),V=new be.default(D,B);if(x){let X=new be.default(-b,b-bi),re=-Math.PI/2,me=ae/2-b,Ut=p.imageName?me:0,tt=new be.default(5-bi-me,-Ut),gt=new be.default(...A);z._rotateAround(re,X)._add(tt)._add(gt),M._rotateAround(re,X)._add(tt)._add(gt),_._rotateAround(re,X)._add(tt)._add(gt),V._rotateAround(re,X)._add(tt)._add(gt)}if(l){let X=Math.sin(l),re=Math.cos(l),me=[re,-X,X,re];z._matMult(me),M._matMult(me),_._matMult(me),V._matMult(me)}let G=new be.default(0,0),O=new be.default(0,0);u.push({tl:z,tr:M,bl:_,br:V,tex:f,writingMode:e.writingMode,glyphOffset:v,sectionIndex:p.sectionIndex,isSDF:h,pixelOffsetTL:G,pixelOffsetBR:O,minFontScaleX:0,minFontScaleY:0})}return u}var Ii=Y(ye(),1);var yr=class{constructor(e,r,n,i,o,a,s,l,u,c){if(this.boxStartIndex=e.length,u){let p=a.top,f=a.bottom,y=a.collisionPadding;y&&(p-=y[1],f+=y[3]);let m=f-p;m>0&&(m=Math.max(10,m),this.circleDiameter=m)}else{let p=a.image?.content&&(a.image.textFitWidth||a.image.textFitHeight)?Ea(a):{x1:a.left,y1:a.top,x2:a.right,y2:a.bottom};p.y1=p.y1*s-l[0],p.y2=p.y2*s+l[2],p.x1=p.x1*s-l[3],p.x2=p.x2*s+l[1];let f=a.collisionPadding;if(f&&(p.x1-=f[0]*s,p.y1-=f[1]*s,p.x2+=f[2]*s,p.y2+=f[3]*s),c){let y=new Ii.default(p.x1,p.y1),m=new Ii.default(p.x2,p.y1),h=new Ii.default(p.x1,p.y2),g=new Ii.default(p.x2,p.y2),d=c*Math.PI/180;y._rotate(d),m._rotate(d),h._rotate(d),g._rotate(d),p.x1=Math.min(y.x,m.x,h.x,g.x),p.x2=Math.max(y.x,m.x,h.x,g.x),p.y1=Math.min(y.y,m.y,h.y,g.y),p.y2=Math.max(y.y,m.y,h.y,g.y)}e.emplaceBack(r.x,r.y,p.x1,p.y1,p.x2,p.y2,n,i,o)}this.boxEndIndex=e.length}};var Ti=class{constructor(e=[],r=(n,i)=>n<i?-1:n>i?1:0){if(this.data=e,this.length=this.data.length,this.compare=r,this.length>0)for(let n=(this.length>>1)-1;n>=0;n--)this._down(n)}push(e){this.data.push(e),this._up(this.length++)}pop(){if(this.length===0)return;let e=this.data[0],r=this.data.pop();return--this.length>0&&(this.data[0]=r,this._down(0)),e}peek(){return this.data[0]}_up(e){let{data:r,compare:n}=this,i=r[e];for(;e>0;){let o=e-1>>1,a=r[o];if(n(i,a)>=0)break;r[e]=a,e=o}r[e]=i}_down(e){let{data:r,compare:n}=this,i=this.length>>1,o=r[e];for(;e<i;){let a=(e<<1)+1,s=a+1;if(s<this.length&&n(r[s],r[a])<0&&(a=s),n(r[a],o)>=0)break;r[e]=r[a],e=a}r[e]=o}};var Fl=Y(ye(),1);function ty(t,e=1,r=!1){let n=fr.fromPoints(t[0]),i=Math.min(n.width(),n.height()),o=i/2,a=new Ti([],Ix),{minX:s,minY:l,maxX:u,maxY:c}=n;if(i===0)return new Fl.default(s,l);for(let y=s;y<u;y+=i)for(let m=l;m<c;m+=i)a.push(new jr(y+o,m+o,o,t));let p=Cx(t),f=a.length;for(;a.length;){let y=a.pop();(y.d>p.d||!p.d)&&(p=y,r&&console.log("found best %d after %d probes",Math.round(1e4*y.d)/1e4,f)),!(y.max-p.d<=e)&&(o=y.h/2,a.push(new jr(y.p.x-o,y.p.y-o,o,t)),a.push(new jr(y.p.x+o,y.p.y-o,o,t)),a.push(new jr(y.p.x-o,y.p.y+o,o,t)),a.push(new jr(y.p.x+o,y.p.y+o,o,t)),f+=4)}return r&&(console.log(`num probes: ${f}`),console.log(`best distance: ${p.d}`)),p.p}function Ix(t,e){return e.max-t.max}function jr(t,e,r,n){this.p=new Fl.default(t,e),this.h=r,this.d=Tx(this.p,n),this.max=this.d+this.h*Math.SQRT2}function Tx(t,e){let r=!1,n=1/0;for(let i=0;i<e.length;i++){let o=e[i];for(let a=0,s=o.length,l=s-1;a<s;l=a++){let u=o[a],c=o[l];u.y>t.y!=c.y>t.y&&t.x<(c.x-u.x)*(t.y-u.y)/(c.y-u.y)+u.x&&(r=!r),n=Math.min(n,ll(t,u,c))}}return(r?1:-1)*Math.sqrt(n)}function Cx(t){let e=0,r=0,n=0,i=t[0];for(let o=0,a=i.length,s=a-1;o<a;s=o++){let l=i[o],u=i[s],c=l.x*u.y-u.x*l.y;r+=(l.x+u.x)*c,n+=(l.y+u.y)*c,e+=c*3}return new jr(r/e,n/e,0,t)}var Dl=Y(rl(),1);var El=(o=>(o[o.center=1]="center",o[o.left=2]="left",o[o.right=3]="right",o[o.top=4]="top",o[o.bottom=5]="bottom",o[o["top-left"]=6]="top-left",o[o["top-right"]=7]="top-right",o[o["bottom-left"]=8]="bottom-left",o[o["bottom-right"]=9]="bottom-right",o))(El||{}),Ot=7,$a=Number.POSITIVE_INFINITY;function Ml(t,e){function r(i,o){let a=0,s=0;o<0&&(o=0);let l=o/Math.SQRT2;switch(i){case"top-right":case"top-left":s=l-Ot;break;case"bottom-right":case"bottom-left":s=-l+Ot;break;case"bottom":s=-o+Ot;break;case"top":s=o-Ot;break}switch(i){case"top-right":case"bottom-right":a=-l;break;case"top-left":case"bottom-left":a=l;break;case"left":a=o;break;case"right":a=-o;break}return[a,s]}function n(i,o,a){let s=0,l=0;switch(o=Math.abs(o),a=Math.abs(a),i){case"top-right":case"top-left":case"top":l=a-Ot;break;case"bottom-right":case"bottom-left":case"bottom":l=-a+Ot;break}switch(i){case"top-right":case"bottom-right":case"right":s=-o;break;case"top-left":case"bottom-left":case"left":s=o;break}return[s,l]}return e[1]!==$a?n(t,e[0],e[1]):r(t,e[0])}function Ll(t,e,r){let n=t.layout,i=n.get("text-variable-anchor-offset")?.evaluate(e,{},r);if(i){let a=i.values,s=[];for(let l=0;l<a.length;l+=2){let u=s[l]=a[l],c=a[l+1].map(p=>p*ae);u.startsWith("top")?c[1]-=Ot:u.startsWith("bottom")&&(c[1]+=Ot),s[l+1]=c}return new Ee(s)}let o=n.get("text-variable-anchor");if(o){let a;t._unevaluatedLayout.getValue("text-radial-offset")!==void 0?a=[n.get("text-radial-offset").evaluate(e,{},r)*ae,$a]:a=n.get("text-offset").evaluate(e,{},r).map(u=>u*ae);let l=[];for(let u of o)l.push(u,Ml(u,a));return new Ee(l)}return null}function iy(t){t.bucket.createArrays();let e=512*t.bucket.overscaling;t.bucket.tilePixelRatio=8192/e,t.bucket.compareText={},t.bucket.iconsNeedLinear=!1;let r=t.bucket.layers[0],n=r.layout,i=r._unevaluatedLayout._values,o={layoutIconSize:i["icon-size"].possiblyEvaluate(new W(t.bucket.zoom+1),t.canonical),layoutTextSize:i["text-size"].possiblyEvaluate(new W(t.bucket.zoom+1),t.canonical),textMaxSize:i["text-size"].possiblyEvaluate(new W(18))};if(t.bucket.textSizeData.kind==="composite"){let{minZoom:c,maxZoom:p}=t.bucket.textSizeData;o.compositeTextSizes=[i["text-size"].possiblyEvaluate(new W(c),t.canonical),i["text-size"].possiblyEvaluate(new W(p),t.canonical)]}if(t.bucket.iconSizeData.kind==="composite"){let{minZoom:c,maxZoom:p}=t.bucket.iconSizeData;o.compositeIconSizes=[i["icon-size"].possiblyEvaluate(new W(c),t.canonical),i["icon-size"].possiblyEvaluate(new W(p),t.canonical)]}let a=n.get("text-line-height")*ae,s=n.get("text-rotation-alignment")!=="viewport"&&n.get("symbol-placement")!=="point",l=n.get("text-keep-upright"),u=n.get("text-size");for(let c of t.bucket.features){let p=n.get("text-font").evaluate(c,{},t.canonical).join(","),f=u.evaluate(c,{},t.canonical),y=o.layoutTextSize.evaluate(c,{},t.canonical),m=o.layoutIconSize.evaluate(c,{},t.canonical),h={horizontal:{},vertical:void 0},g=c.text,d=[0,0];if(g){let S=g.toString(),A=n.get("text-letter-spacing").evaluate(c,{},t.canonical)*ae,w=Zc(S)?A:0,T=n.get("text-anchor").evaluate(c,{},t.canonical),E=Ll(r,c,t.canonical);if(!E){let _=n.get("text-radial-offset").evaluate(c,{},t.canonical);_?d=Ml(T,[_*ae,$a]):d=n.get("text-offset").evaluate(c,{},t.canonical).map(V=>V*ae)}let D=s?"center":n.get("text-justify").evaluate(c,{},t.canonical),z=n.get("symbol-placement")==="point"?n.get("text-max-width").evaluate(c,{},t.canonical)*ae:1/0,M=()=>{t.bucket.allowVerticalPlacement&&In(S)&&(h.vertical=xi(g,t.glyphMap,t.glyphPositions,t.imagePositions,p,z,a,T,"left",w,d,2,!0,y,f))};if(!s&&E){let _=new Set;if(D==="auto")for(let G=0;G<E.values.length;G+=2)_.add(ry(E.values[G]));else _.add(D);let V=!1;for(let G of _)if(!h.horizontal[G])if(V)h.horizontal[G]=h.horizontal[0];else{let O=xi(g,t.glyphMap,t.glyphPositions,t.imagePositions,p,z,a,"center",G,w,d,1,!1,y,f);O&&(h.horizontal[G]=O,V=O.positionedLines.length===1)}M()}else{D==="auto"&&(D=ry(T));let _=xi(g,t.glyphMap,t.glyphPositions,t.imagePositions,p,z,a,T,D,w,d,1,!1,y,f);_&&(h.horizontal[D]=_),M(),In(S)&&s&&l&&(h.vertical=xi(g,t.glyphMap,t.glyphPositions,t.imagePositions,p,z,a,T,D,w,d,2,!1,y,f))}}let x,b=!1;if(c.icon&&c.icon.name){let S=t.imageMap[c.icon.name];S&&(x=Ff(t.imagePositions[c.icon.name],n.get("icon-offset").evaluate(c,{},t.canonical),n.get("icon-anchor").evaluate(c,{},t.canonical)),b=!!S.sdf,t.bucket.sdfIcons===void 0?t.bucket.sdfIcons=b:t.bucket.sdfIcons!==b&&ce("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),(S.pixelRatio!==t.bucket.pixelRatio||n.get("icon-rotate").constantOr(1)!==0)&&(t.bucket.iconsNeedLinear=!0))}let v=oy(h.horizontal)||h.vertical;t.bucket.iconsInText=v?v.iconsInText:!1,(v||x)&&kx(t.bucket,c,h,x,t.imageMap,o,y,m,d,b,t.canonical,t.subdivisionGranularity)}t.showCollisionBoxes&&t.bucket.generateCollisionDebugBuffers()}function ry(t){switch(t){case"right":case"top-right":case"bottom-right":return"right";case"left":case"top-left":case"bottom-left":return"left"}return"center"}function kx(t,e,r,n,i,o,a,s,l,u,c,p){let f=o.textMaxSize.evaluate(e,{});f===void 0&&(f=a);let y=t.layers[0].layout,m=y.get("icon-offset").evaluate(e,{},c),h=oy(r.horizontal),g=24,d=a/g,x=t.tilePixelRatio*d,b=t.tilePixelRatio*f/g,v=t.tilePixelRatio*s,S=t.tilePixelRatio*y.get("symbol-spacing"),A=y.get("text-padding")*t.tilePixelRatio,w=Vf(y,e,c,t.tilePixelRatio),T=y.get("text-max-angle")/180*Math.PI,E=y.get("text-rotation-alignment")!=="viewport"&&y.get("symbol-placement")!=="point",D=y.get("icon-rotation-alignment")==="map"&&y.get("symbol-placement")!=="point",B=y.get("symbol-placement"),z=S/2,M=y.get("icon-text-fit"),_;n&&M!=="none"&&(t.allowVerticalPlacement&&r.vertical&&(_=_l(n,r.vertical,M,y.get("icon-text-fit-padding"),m,d)),h&&(n=_l(n,h,M,y.get("icon-text-fit-padding"),m,d)));let V=c?p.line.getGranularityForZoomLevel(c.z):1,G=(O,R)=>{R.x<0||R.x>=8192||R.y<0||R.y>=8192||Ex(t,R,O,r,n,i,_,t.layers[0],t.collisionBoxArray,e.index,e.sourceLayerIndex,t.index,x,[A,A,A,A],E,l,v,w,D,m,e,o,u,c,a)};if(B==="line")for(let O of Kf(e.geometry,0,0,8192,8192)){let R=Ke(O,V),K=Jf(R,S,T,r.vertical||h,n,g,b,t.overscaling,8192);for(let X of K){let re=h;(!re||!Mx(t,re.text,z,X))&&G(R,X)}}else if(B==="line-center"){for(let O of e.geometry)if(O.length>1){let R=Ke(O,V),K=Zf(R,T,r.vertical||h,n,g,b);K&&G(R,K)}}else if(e.type==="Polygon")for(let O of Yt(e.geometry,0)){let R=ty(O,16),K=Ke(O[0],V,!0);G(K,new et(R.x,R.y,0))}else if(e.type==="LineString")for(let O of e.geometry){let R=Ke(O,V);G(R,new et(R[0].x,R[0].y,0))}else if(e.type==="Point")for(let O of e.geometry)for(let R of O)G([R],new et(R.x,R.y,0))}function Fx(t,e){let r=t.length,n=e?.values;if(n?.length>0)for(let i=0;i<n.length;i+=2){let o=El[n[i]],a=n[i+1];t.emplaceBack(o,a[0],a[1])}return[r,t.length]}function ny(t,e,r,n,i,o,a,s,l,u,c,p,f,y,m){let h=ey(e,r,s,i,o,a,n,t.allowVerticalPlacement),g=t.textSizeData,d=null;g.kind==="source"?(d=[zt*i.layout.get("text-size").evaluate(a,{})],d[0]>Qe&&ce(`${t.layerIds[0]}: Value for "text-size" is >= ${Nr}. Reduce your "text-size".`)):g.kind==="composite"&&(d=[zt*y.compositeTextSizes[0].evaluate(a,{},m),zt*y.compositeTextSizes[1].evaluate(a,{},m)],(d[0]>Qe||d[1]>Qe)&&ce(`${t.layerIds[0]}: Value for "text-size" is >= ${Nr}. Reduce your "text-size".`)),t.addSymbols(t.text,h,d,s,o,a,u,e,l.lineStartIndex,l.lineLength,f,m);for(let x of c)p[x]=t.text.placedSymbolArray.length-1;return h.length*4}function oy(t){for(let e in t)return t[e];return null}function Ex(t,e,r,n,i,o,a,s,l,u,c,p,f,y,m,h,g,d,x,b,v,S,A,w,T){let E=t.addToLineVertexArray(e,r),D,B,z,M,_=0,V=0,G=0,O=0,R=-1,K=-1,X={},re=(0,Dl.default)("");if(t.allowVerticalPlacement&&n.vertical){let xe=s.layout.get("text-rotate").evaluate(v,{},w)+90,rt=n.vertical;z=new yr(l,e,u,c,p,rt,f,y,m,xe),a&&(M=new yr(l,e,u,c,p,a,g,d,m,xe))}if(i){let Te=s.layout.get("icon-rotate").evaluate(v,{}),xe=s.layout.get("icon-text-fit")!=="none",rt=kl(i,Te,A,xe),xt=a?kl(a,Te,A,xe):void 0;B=new yr(l,e,u,c,p,i,g,d,!1,Te),_=rt.length*4;let Zr=t.iconSizeData,Be=null;Zr.kind==="source"?(Be=[zt*s.layout.get("icon-size").evaluate(v,{})],Be[0]>Qe&&ce(`${t.layerIds[0]}: Value for "icon-size" is >= ${Nr}. Reduce your "icon-size".`)):Zr.kind==="composite"&&(Be=[zt*S.compositeIconSizes[0].evaluate(v,{},w),zt*S.compositeIconSizes[1].evaluate(v,{},w)],(Be[0]>Qe||Be[1]>Qe)&&ce(`${t.layerIds[0]}: Value for "icon-size" is >= ${Nr}. Reduce your "icon-size".`)),t.addSymbols(t.icon,rt,Be,b,x,v,0,e,E.lineStartIndex,E.lineLength,-1,w),R=t.icon.placedSymbolArray.length-1,xt&&(V=xt.length*4,t.addSymbols(t.icon,xt,Be,b,x,v,2,e,E.lineStartIndex,E.lineLength,-1,w),K=t.icon.placedSymbolArray.length-1)}let me=Object.keys(n.horizontal);for(let Te of me){let xe=n.horizontal[Te];if(!D){re=(0,Dl.default)(xe.text);let xt=s.layout.get("text-rotate").evaluate(v,{},w);D=new yr(l,e,u,c,p,xe,f,y,m,xt)}let rt=xe.positionedLines.length===1;if(G+=ny(t,e,xe,o,s,m,v,h,E,n.vertical?1:3,rt?me:[Te],X,R,S,w),rt)break}n.vertical&&(O+=ny(t,e,n.vertical,o,s,m,v,h,E,2,["vertical"],X,K,S,w));let Ut=D?D.boxStartIndex:t.collisionBoxArray.length,tt=D?D.boxEndIndex:t.collisionBoxArray.length,gt=z?z.boxStartIndex:t.collisionBoxArray.length,Gi=z?z.boxEndIndex:t.collisionBoxArray.length,Ni=B?B.boxStartIndex:t.collisionBoxArray.length,Ui=B?B.boxEndIndex:t.collisionBoxArray.length,$i=M?M.boxStartIndex:t.collisionBoxArray.length,is=M?M.boxEndIndex:t.collisionBoxArray.length,Ie=-1,bt=(Te,xe)=>Te&&Te.circleDiameter?Math.max(Te.circleDiameter,xe):xe;Ie=bt(D,Ie),Ie=bt(z,Ie),Ie=bt(B,Ie),Ie=bt(M,Ie);let Hr=Ie>-1?1:0;Hr&&(Ie*=T/ae),t.glyphOffsetArray.length>=Xe.MAX_GLYPHS&&ce("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"),v.sortKey!==void 0&&t.addToSortKeyRanges(t.symbolInstances.length,v.sortKey);let os=Ll(s,v,w),[ji,as]=Fx(t.textAnchorOffsets,os);t.symbolInstances.emplaceBack(e.x,e.y,X.right>=0?X.right:-1,X.center>=0?X.center:-1,X.left>=0?X.left:-1,X.vertical||-1,R,K,re,Ut,tt,gt,Gi,Ni,Ui,$i,is,u,G,O,_,V,Hr,0,f,Ie,ji,as)}function Mx(t,e,r,n){let i=t.compareText;if(!(e in i))i[e]=[];else{let o=i[e];for(let a=o.length-1;a>=0;a--)if(n.dist(o[a])<r)return!0}return i[e].push(n),!1}var ja=1,Ci=class{constructor(e){let r={},n=[];for(let s in e){let l=e[s],u=r[s]={};for(let c in l){let p=l[+c];if(!p||p.bitmap.width===0||p.bitmap.height===0)continue;let f={x:0,y:0,w:p.bitmap.width+2*ja,h:p.bitmap.height+2*ja};n.push(f),u[c]={rect:f,metrics:p.metrics}}}let{w:i,h:o}=hi(n),a=new sr({width:i||1,height:o||1});for(let s in e){let l=e[s];for(let u in l){let c=l[+u];if(!c||c.bitmap.width===0||c.bitmap.height===0)continue;let p=r[s][u].rect;sr.copy(c.bitmap,a,{x:0,y:0},{x:p.x+ja,y:p.y+ja},c.bitmap)}}this.image=a,this.positions=r}};I("GlyphAtlas",Ci);function sy(t,e,r){e=Math.pow(2,r)-e-1;var n=ay(t*256,e*256,r),i=ay((t+1)*256,(e+1)*256,r);return n[0]+","+n[1]+","+i[0]+","+i[1]}function ay(t,e,r){var n=2*Math.PI*6378137/256/Math.pow(2,r),i=t*n-2*Math.PI*6378137/2,o=e*n-2*Math.PI*6378137/2;return[i,o]}var py=Y(ye(),1);var Bl=63710088e-1,ki=class t{constructor(e,r){if(isNaN(e)||isNaN(r))throw new Error(`Invalid LngLat object: (${e}, ${r})`);if(this.lng=+e,this.lat=+r,this.lat>90||this.lat<-90)throw new Error("Invalid LngLat latitude value: must be between -90 and 90")}wrap(){return new t(wu(this.lng,-180,180),this.lat)}toArray(){return[this.lng,this.lat]}toString(){return`LngLat(${this.lng}, ${this.lat})`}distanceTo(e){let r=Math.PI/180,n=this.lat*r,i=e.lat*r,o=Math.sin(n)*Math.sin(i)+Math.cos(n)*Math.cos(i)*Math.cos((e.lng-this.lng)*r);return Bl*Math.acos(Math.min(o,1))}static convert(e){if(e instanceof t)return e;if(Array.isArray(e)&&(e.length===2||e.length===3))return new t(Number(e[0]),Number(e[1]));if(!Array.isArray(e)&&typeof e=="object"&&e!==null)return new t(Number("lng"in e?e.lng:e.lon),Number(e.lat));throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")}};var ly=2*Math.PI*Bl;function uy(t){return ly*Math.cos(t*Math.PI/180)}function Lx(t){return(180+t)/360}function Dx(t){return(180-180/Math.PI*Math.log(Math.tan(Math.PI/4+t*Math.PI/360)))/360}function Bx(t,e){return t/uy(e)}function Vx(t){return t*360-180}function Vl(t){let e=180-t*360;return 360/Math.PI*Math.atan(Math.exp(e*Math.PI/180))-90}function Rx(t,e){return t*uy(Vl(e))}function zx(t){return 1/Math.cos(t*Math.PI/180)}var Fi=class t{constructor(e,r,n=0){this.x=+e,this.y=+r,this.z=+n}static fromLngLat(e,r=0){let n=ki.convert(e);return new t(Lx(n.lng),Dx(n.lat),Bx(r,n.lat))}toLngLat(){return new ki(Vx(this.x),Vl(this.y))}toAltitude(){return Rx(this.z,this.y)}meterInMercatorCoordinateUnits(){return 1/ly*zx(Vl(this.y))}};function cy(t,e,r){return!(t<Hi||t>Xi||r<0||r>=Math.pow(2,t)||e<0||e>=Math.pow(2,t))}var qa=class{constructor(e,r,n){if(!cy(e,r,n))throw new Error(`x=${r}, y=${n}, z=${e} outside of bounds. 0<=x<${Math.pow(2,e)}, 0<=y<${Math.pow(2,e)} ${Hi}<=z<=${Xi} `);this.z=e,this.x=r,this.y=n,this.key=Ei(0,e,e,r,n)}equals(e){return this.z===e.z&&this.x===e.x&&this.y===e.y}url(e,r,n){let i=sy(this.x,this.y,this.z),o=Ox(this.z,this.x,this.y);return e[(this.x+this.y)%e.length].replace(/{prefix}/g,(this.x%16).toString(16)+(this.y%16).toString(16)).replace(/{z}/g,String(this.z)).replace(/{x}/g,String(this.x)).replace(/{y}/g,String(n==="tms"?Math.pow(2,this.z)-this.y-1:this.y)).replace(/{ratio}/g,r>1?"@2x":"").replace(/{quadkey}/g,o).replace(/{bbox-epsg-3857}/g,i)}isChildOf(e){let r=this.z-e.z;return r>0&&e.x===this.x>>r&&e.y===this.y>>r}getTilePoint(e){let r=Math.pow(2,this.z);return new py.default((e.x*r-this.x)*8192,(e.y*r-this.y)*8192)}toString(){return`${this.z}/${this.x}/${this.y}`}},Rl=class{constructor(e,r){this.wrap=e,this.canonical=r,this.key=Ei(e,r.z,r.z,r.x,r.y)}},Mi=class t{constructor(e,r,n,i,o){this.terrainRttPosMatrix32f=null;if(e<n)throw new Error(`overscaledZ should be >= z; overscaledZ = ${e}; z = ${n}`);this.overscaledZ=e,this.wrap=r,this.canonical=new qa(n,+i,+o),this.key=Ei(r,e,n,i,o)}clone(){return new t(this.overscaledZ,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)}equals(e){return this.overscaledZ===e.overscaledZ&&this.wrap===e.wrap&&this.canonical.equals(e.canonical)}scaledTo(e){if(e>this.overscaledZ)throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);let r=this.canonical.z-e;return e>this.canonical.z?new t(e,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y):new t(e,this.wrap,e,this.canonical.x>>r,this.canonical.y>>r)}calculateScaledKey(e,r){if(e>this.overscaledZ)throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);let n=this.canonical.z-e;return e>this.canonical.z?Ei(this.wrap*+r,e,this.canonical.z,this.canonical.x,this.canonical.y):Ei(this.wrap*+r,e,e,this.canonical.x>>n,this.canonical.y>>n)}isChildOf(e){if(e.wrap!==this.wrap)return!1;let r=this.canonical.z-e.canonical.z;return e.overscaledZ===0||e.overscaledZ<this.overscaledZ&&e.canonical.x===this.canonical.x>>r&&e.canonical.y===this.canonical.y>>r}children(e){if(this.overscaledZ>=e)return[new t(this.overscaledZ+1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)];let r=this.canonical.z+1,n=this.canonical.x*2,i=this.canonical.y*2;return[new t(r,this.wrap,r,n,i),new t(r,this.wrap,r,n+1,i),new t(r,this.wrap,r,n,i+1),new t(r,this.wrap,r,n+1,i+1)]}isLessThan(e){return this.wrap<e.wrap?!0:this.wrap>e.wrap?!1:this.overscaledZ<e.overscaledZ?!0:this.overscaledZ>e.overscaledZ?!1:this.canonical.x<e.canonical.x?!0:this.canonical.x>e.canonical.x?!1:this.canonical.y<e.canonical.y}wrapped(){return new t(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y)}unwrapTo(e){return new t(this.overscaledZ,e,this.canonical.z,this.canonical.x,this.canonical.y)}overscaleFactor(){return Math.pow(2,this.overscaledZ-this.canonical.z)}toUnwrapped(){return new Rl(this.wrap,this.canonical)}toString(){return`${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`}getTilePoint(e){return this.canonical.getTilePoint(new Fi(e.x-this.wrap,e.y))}};function Ei(t,e,r,n,i){t*=2,t<0&&(t=t*-1-1);let o=1<<r;return(o*o*t+o*i+n).toString(36)+r.toString(36)+e.toString(36)}function Ox(t,e,r){let n="",i;for(let o=t;o>0;o--)i=1<<o-1,n+=(e&i?1:0)+(r&i?2:0);return n}I("CanonicalTileID",qa);I("OverscaledTileID",Mi,{omit:["terrainRttPosMatrix32f"]});var Wa=class{constructor(e){this.tileID=new Mi(e.tileID.overscaledZ,e.tileID.wrap,e.tileID.canonical.z,e.tileID.canonical.x,e.tileID.canonical.y),this.uid=e.uid,this.zoom=e.zoom,this.pixelRatio=e.pixelRatio,this.tileSize=e.tileSize,this.source=e.source,this.overscaling=this.tileID.overscaleFactor(),this.showCollisionBoxes=e.showCollisionBoxes,this.collectResourceTiming=!!e.collectResourceTiming,this.returnDependencies=!!e.returnDependencies,this.promoteId=e.promoteId,this.inFlightDependencies=[],this.globalState=e.globalState}async parse(e,r,n,i,o){this.status="parsing",this.data=e,this.collisionBoxArray=new jn;let a=new Ur(Object.keys(e.layers).sort()),s=new _i(this.tileID,this.promoteId);s.bucketLayerIDs=[];let l={},u={featureIndex:s,iconDependencies:{},patternDependencies:{},glyphDependencies:{},availableImages:n,subdivisionGranularity:o},c=r.familiesBySource[this.source];for(let A in c){let w=e.layers[A];if(!w)continue;w.version===1&&ce(`Vector tile source "${this.source}" layer "${A}" does not use vector tile spec v2 and therefore may have some rendering errors.`);let T=a.encode(A),E=[];for(let D=0;D<w.length;D++){let B=w.feature(D),z=s.getId(B,A);E.push({feature:B,id:z,index:D,sourceLayerIndex:T})}for(let D of c[A]){let B=D[0];if(B.source!==this.source&&ce(`layer.source = ${B.source} does not equal this.source = ${this.source}`),B.minzoom&&this.zoom<Math.floor(B.minzoom)||B.maxzoom&&this.zoom>=B.maxzoom||B.visibility==="none")continue;zl(D,this.zoom,n),(l[B.id]=B.createBucket({index:s.bucketLayerIDs.length,layers:D,zoom:this.zoom,pixelRatio:this.pixelRatio,overscaling:this.overscaling,collisionBoxArray:this.collisionBoxArray,sourceLayerIndex:T,sourceID:this.source,globalState:this.globalState})).populate(E,u,this.tileID.canonical),s.bucketLayerIDs.push(D.map(M=>M.id))}}let p=tn(u.glyphDependencies,A=>Object.keys(A).map(Number));this.inFlightDependencies.forEach(A=>A?.abort()),this.inFlightDependencies=[];let f=Promise.resolve({});if(Object.keys(p).length){let A=new AbortController;this.inFlightDependencies.push(A),f=i.sendAsync({type:"GG",data:{stacks:p,source:this.source,tileID:this.tileID,type:"glyphs"}},A)}let y=Object.keys(u.iconDependencies),m=Promise.resolve({});if(y.length){let A=new AbortController;this.inFlightDependencies.push(A),m=i.sendAsync({type:"GI",data:{icons:y,source:this.source,tileID:this.tileID,type:"icons"}},A)}let h=Object.keys(u.patternDependencies),g=Promise.resolve({});if(h.length){let A=new AbortController;this.inFlightDependencies.push(A),g=i.sendAsync({type:"GI",data:{icons:h,source:this.source,tileID:this.tileID,type:"patterns"}},A)}let[d,x,b]=await Promise.all([f,m,g]),v=new Ci(d),S=new di(x,b);for(let A in l){let w=l[A];w instanceof Xe?(zl(w.layers,this.zoom,n),iy({bucket:w,glyphMap:d,glyphPositions:v.positions,imageMap:x,imagePositions:S.iconPositions,showCollisionBoxes:this.showCollisionBoxes,canonical:this.tileID.canonical,subdivisionGranularity:u.subdivisionGranularity})):w.hasPattern&&(w instanceof pr||w instanceof ur||w instanceof cr)&&(zl(w.layers,this.zoom,n),w.addFeatures(u,this.tileID.canonical,S.patternPositions))}return this.status="done",{buckets:Object.values(l).filter(A=>!A.isEmpty()),featureIndex:s,collisionBoxArray:this.collisionBoxArray,glyphAtlasImage:v.image,imageAtlas:S,glyphMap:this.returnDependencies?d:null,iconMap:this.returnDependencies?x:null,glyphPositions:this.returnDependencies?v.positions:null}}};function zl(t,e,r){let n=new W(e);for(let i of t)i.recalculate(n,r)}var Gx=60,XI=1e3/Gx;var qr=class{constructor(e){this._marks={start:[e.url,"start"].join("#"),end:[e.url,"end"].join("#"),measure:e.url.toString()},performance.mark(this._marks.start)}finish(){performance.mark(this._marks.end);let e=performance.getEntriesByName(this._marks.measure);return e.length===0&&(performance.measure(this._marks.measure,this._marks.start,this._marks.end),e=performance.getEntriesByName(this._marks.measure),performance.clearMarks(this._marks.start),performance.clearMarks(this._marks.end),performance.clearMeasures(this._marks.measure)),e}};var Wr=class{constructor(e,r,n){this.actor=e,this.layerIndex=r,this.availableImages=n,this.fetching={},this.loading={},this.loaded={}}async loadVectorTile(e,r){let n=await Uc(e.request,r);try{return{vectorTile:new fy.default.VectorTile(new yy.default(n.data)),rawData:n.data,cacheControl:n.cacheControl,expires:n.expires}}catch(i){let o=new Uint8Array(n.data),a=o[0]===31&&o[1]===139,s=`Unable to parse the tile at ${e.request.url}, `;throw a?s+="please make sure the data is not gzipped and that you have configured the relevant header in the server":s+=`got error: ${i.message}`,new Error(s)}}async loadTile(e){let r=e.uid,n=e&&e.request&&e.request.collectResourceTiming?new qr(e.request):!1,i=new Wa(e);this.loading[r]=i;let o=new AbortController;i.abort=o;try{let a=await this.loadVectorTile(e,o);if(delete this.loading[r],!a)return null;let s=a.rawData,l={};a.expires&&(l.expires=a.expires),a.cacheControl&&(l.cacheControl=a.cacheControl);let u={};if(n){let p=n.finish();p&&(u.resourceTiming=JSON.parse(JSON.stringify(p)))}i.vectorTile=a.vectorTile;let c=i.parse(a.vectorTile,this.layerIndex,this.availableImages,this.actor,e.subdivisionGranularity);this.loaded[r]=i,this.fetching[r]={rawTileData:s,cacheControl:l,resourceTiming:u};try{let p=await c;return de({rawTileData:s.slice(0)},p,l,u)}finally{delete this.fetching[r]}}catch(a){throw delete this.loading[r],i.status="done",this.loaded[r]=i,a}}async reloadTile(e){let r=e.uid;if(!this.loaded||!this.loaded[r])throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");let n=this.loaded[r];if(n.showCollisionBoxes=e.showCollisionBoxes,n.globalState=e.globalState,n.status==="parsing"){let i=await n.parse(n.vectorTile,this.layerIndex,this.availableImages,this.actor,e.subdivisionGranularity),o;if(this.fetching[r]){let{rawTileData:a,cacheControl:s,resourceTiming:l}=this.fetching[r];delete this.fetching[r],o=de({rawTileData:a.slice(0)},i,s,l)}else o=i;return o}if(n.status==="done"&&n.vectorTile)return n.parse(n.vectorTile,this.layerIndex,this.availableImages,this.actor,e.subdivisionGranularity)}async abortTile(e){let r=this.loading,n=e.uid;r&&r[n]&&r[n].abort&&(r[n].abort.abort(),delete r[n])}async removeTile(e){this.loaded&&this.loaded[e.uid]&&delete this.loaded[e.uid]}};var Xa=class{constructor(){this.loaded={}}async loadTile(e){let{uid:r,encoding:n,rawImageData:i,redFactor:o,greenFactor:a,blueFactor:s,baseShift:l}=e,u=i.width+2,c=i.height+2,p=vt(i)?new fe({width:u,height:c},await Iu(i,-1,-1,u,c)):i,f=new ii(r,p,n,o,a,s,l);return this.loaded=this.loaded||{},this.loaded[r]=f,f}removeTile(e){let r=this.loaded,n=e.uid;r&&r[n]&&delete r[n]}};var Gy=Y(gy(),1);var Ol=Y(ye(),1),by=Y(Rt(),1);var Nx=by.default.VectorTileFeature.prototype.toGeoJSON,Gl=class{constructor(e){this._feature=e,this.extent=8192,this.type=e.type,this.properties=e.tags,"id"in e&&!isNaN(e.id)&&(this.id=parseInt(e.id,10))}loadGeometry(){if(this._feature.type===1){let e=[];for(let r of this._feature.geometry)e.push([new Ol.default(r[0],r[1])]);return e}else{let e=[];for(let r of this._feature.geometry){let n=[];for(let i of r)n.push(new Ol.default(i[0],i[1]));e.push(n)}return e}}toGeoJSON(e,r,n){return Nx.call(this,e,r,n)}},Za=class{constructor(e){this.layers={_geojsonTileLayer:this},this.name="_geojsonTileLayer",this.extent=8192,this.length=e.length,this._features=e}feature(e){return new Gl(this._features[e])}};var Ny=Y(Ay(),1);var _y=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],$l=1,Di=8,Vi=class t{static from(e){if(!(e instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");let[r,n]=new Uint8Array(e,0,2);if(r!==219)throw new Error("Data does not appear to be in a KDBush format.");let i=n>>4;if(i!==$l)throw new Error(`Got v${i} data when expected v${$l}.`);let o=_y[n&15];if(!o)throw new Error("Unrecognized array type.");let[a]=new Uint16Array(e,2,1),[s]=new Uint32Array(e,4,1);return new t(s,a,o,e)}constructor(e,r=64,n=Float64Array,i){if(isNaN(e)||e<0)throw new Error(`Unpexpected numItems value: ${e}.`);this.numItems=+e,this.nodeSize=Math.min(Math.max(+r,2),65535),this.ArrayType=n,this.IndexArrayType=e<65536?Uint16Array:Uint32Array;let o=_y.indexOf(this.ArrayType),a=e*2*this.ArrayType.BYTES_PER_ELEMENT,s=e*this.IndexArrayType.BYTES_PER_ELEMENT,l=(8-s%8)%8;if(o<0)throw new Error(`Unexpected typed array class: ${n}.`);i&&i instanceof ArrayBuffer?(this.data=i,this.ids=new this.IndexArrayType(this.data,Di,e),this.coords=new this.ArrayType(this.data,Di+s+l,e*2),this._pos=e*2,this._finished=!0):(this.data=new ArrayBuffer(Di+a+s+l),this.ids=new this.IndexArrayType(this.data,Di,e),this.coords=new this.ArrayType(this.data,Di+s+l,e*2),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,($l<<4)+o]),new Uint16Array(this.data,2,1)[0]=r,new Uint32Array(this.data,4,1)[0]=e)}add(e,r){let n=this._pos>>1;return this.ids[n]=n,this.coords[this._pos++]=e,this.coords[this._pos++]=r,n}finish(){let e=this._pos>>1;if(e!==this.numItems)throw new Error(`Added ${e} items when expected ${this.numItems}.`);return ql(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(e,r,n,i){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");let{ids:o,coords:a,nodeSize:s}=this,l=[0,o.length-1,0],u=[];for(;l.length;){let c=l.pop()||0,p=l.pop()||0,f=l.pop()||0;if(p-f<=s){for(let g=f;g<=p;g++){let d=a[2*g],x=a[2*g+1];d>=e&&d<=n&&x>=r&&x<=i&&u.push(o[g])}continue}let y=f+p>>1,m=a[2*y],h=a[2*y+1];m>=e&&m<=n&&h>=r&&h<=i&&u.push(o[y]),(c===0?e<=m:r<=h)&&(l.push(f),l.push(y-1),l.push(1-c)),(c===0?n>=m:i>=h)&&(l.push(y+1),l.push(p),l.push(1-c))}return u}within(e,r,n){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");let{ids:i,coords:o,nodeSize:a}=this,s=[0,i.length-1,0],l=[],u=n*n;for(;s.length;){let c=s.pop()||0,p=s.pop()||0,f=s.pop()||0;if(p-f<=a){for(let g=f;g<=p;g++)Iy(o[2*g],o[2*g+1],e,r)<=u&&l.push(i[g]);continue}let y=f+p>>1,m=o[2*y],h=o[2*y+1];Iy(m,h,e,r)<=u&&l.push(i[y]),(c===0?e-n<=m:r-n<=h)&&(s.push(f),s.push(y-1),s.push(1-c)),(c===0?e+n>=m:r+n>=h)&&(s.push(y+1),s.push(p),s.push(1-c))}return l}};function ql(t,e,r,n,i,o){if(i-n<=r)return;let a=n+i>>1;Ty(t,e,a,n,i,o),ql(t,e,r,n,a-1,1-o),ql(t,e,r,a+1,i,1-o)}function Ty(t,e,r,n,i,o){for(;i>n;){if(i-n>600){let u=i-n+1,c=r-n+1,p=Math.log(u),f=.5*Math.exp(2*p/3),y=.5*Math.sqrt(p*f*(u-f)/u)*(c-u/2<0?-1:1),m=Math.max(n,Math.floor(r-c*f/u+y)),h=Math.min(i,Math.floor(r+(u-c)*f/u+y));Ty(t,e,r,m,h,o)}let a=e[2*r+o],s=n,l=i;for(Bi(t,e,n,r),e[2*i+o]>a&&Bi(t,e,n,i);s<l;){for(Bi(t,e,s,l),s++,l--;e[2*s+o]<a;)s++;for(;e[2*l+o]>a;)l--}e[2*n+o]===a?Bi(t,e,n,l):(l++,Bi(t,e,l,i)),l<=r&&(n=l+1),r<=l&&(i=l-1)}}function Bi(t,e,r,n){jl(t,r,n),jl(e,2*r,2*n),jl(e,2*r+1,2*n+1)}function jl(t,e,r){let n=t[e];t[e]=t[r],t[r]=n}function Iy(t,e,r,n){let i=t-r,o=e-n;return i*i+o*o}var Kx={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:t=>t},Cy=Math.fround||(t=>e=>(t[0]=+e,t[0]))(new Float32Array(1)),mr=2,Nt=3,Wl=4,Gt=5,Fy=6,Ri=class{constructor(e){this.options=Object.assign(Object.create(Kx),e),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(e){let{log:r,minZoom:n,maxZoom:i}=this.options;r&&console.time("total time");let o=`prepare ${e.length} points`;r&&console.time(o),this.points=e;let a=[];for(let l=0;l<e.length;l++){let u=e[l];if(!u.geometry)continue;let[c,p]=u.geometry.coordinates,f=Cy(Ya(c)),y=Cy(Ka(p));a.push(f,y,1/0,l,-1,1),this.options.reduce&&a.push(0)}let s=this.trees[i+1]=this._createTree(a);r&&console.timeEnd(o);for(let l=i;l>=n;l--){let u=+Date.now();s=this.trees[l]=this._createTree(this._cluster(s,l)),r&&console.log("z%d: %d clusters in %dms",l,s.numItems,+Date.now()-u)}return r&&console.timeEnd("total time"),this}getClusters(e,r){let n=((e[0]+180)%360+360)%360-180,i=Math.max(-90,Math.min(90,e[1])),o=e[2]===180?180:((e[2]+180)%360+360)%360-180,a=Math.max(-90,Math.min(90,e[3]));if(e[2]-e[0]>=360)n=-180,o=180;else if(n>o){let p=this.getClusters([n,i,180,a],r),f=this.getClusters([-180,i,o,a],r);return p.concat(f)}let s=this.trees[this._limitZoom(r)],l=s.range(Ya(n),Ka(a),Ya(o),Ka(i)),u=s.data,c=[];for(let p of l){let f=this.stride*p;c.push(u[f+Gt]>1?ky(u,f,this.clusterProps):this.points[u[f+Nt]])}return c}getChildren(e){let r=this._getOriginId(e),n=this._getOriginZoom(e),i="No cluster with the specified id.",o=this.trees[n];if(!o)throw new Error(i);let a=o.data;if(r*this.stride>=a.length)throw new Error(i);let s=this.options.radius/(this.options.extent*Math.pow(2,n-1)),l=a[r*this.stride],u=a[r*this.stride+1],c=o.within(l,u,s),p=[];for(let f of c){let y=f*this.stride;a[y+Wl]===e&&p.push(a[y+Gt]>1?ky(a,y,this.clusterProps):this.points[a[y+Nt]])}if(p.length===0)throw new Error(i);return p}getLeaves(e,r,n){r=r||10,n=n||0;let i=[];return this._appendLeaves(i,e,r,n,0),i}getTile(e,r,n){let i=this.trees[this._limitZoom(e)],o=Math.pow(2,e),{extent:a,radius:s}=this.options,l=s/a,u=(n-l)/o,c=(n+1+l)/o,p={features:[]};return this._addTileFeatures(i.range((r-l)/o,u,(r+1+l)/o,c),i.data,r,n,o,p),r===0&&this._addTileFeatures(i.range(1-l/o,u,1,c),i.data,o,n,o,p),r===o-1&&this._addTileFeatures(i.range(0,u,l/o,c),i.data,-1,n,o,p),p.features.length?p:null}getClusterExpansionZoom(e){let r=this._getOriginZoom(e)-1;for(;r<=this.options.maxZoom;){let n=this.getChildren(e);if(r++,n.length!==1)break;e=n[0].properties.cluster_id}return r}_appendLeaves(e,r,n,i,o){let a=this.getChildren(r);for(let s of a){let l=s.properties;if(l&&l.cluster?o+l.point_count<=i?o+=l.point_count:o=this._appendLeaves(e,l.cluster_id,n,i,o):o<i?o++:e.push(s),e.length===n)break}return o}_createTree(e){let r=new Vi(e.length/this.stride|0,this.options.nodeSize,Float32Array);for(let n=0;n<e.length;n+=this.stride)r.add(e[n],e[n+1]);return r.finish(),r.data=e,r}_addTileFeatures(e,r,n,i,o,a){for(let s of e){let l=s*this.stride,u=r[l+Gt]>1,c,p,f;if(u)c=Ey(r,l,this.clusterProps),p=r[l],f=r[l+1];else{let h=this.points[r[l+Nt]];c=h.properties;let[g,d]=h.geometry.coordinates;p=Ya(g),f=Ka(d)}let y={type:1,geometry:[[Math.round(this.options.extent*(p*o-n)),Math.round(this.options.extent*(f*o-i))]],tags:c},m;u||this.options.generateId?m=r[l+Nt]:m=this.points[r[l+Nt]].id,m!==void 0&&(y.id=m),a.features.push(y)}}_limitZoom(e){return Math.max(this.options.minZoom,Math.min(Math.floor(+e),this.options.maxZoom+1))}_cluster(e,r){let{radius:n,extent:i,reduce:o,minPoints:a}=this.options,s=n/(i*Math.pow(2,r)),l=e.data,u=[],c=this.stride;for(let p=0;p<l.length;p+=c){if(l[p+mr]<=r)continue;l[p+mr]=r;let f=l[p],y=l[p+1],m=e.within(l[p],l[p+1],s),h=l[p+Gt],g=h;for(let d of m){let x=d*c;l[x+mr]>r&&(g+=l[x+Gt])}if(g>h&&g>=a){let d=f*h,x=y*h,b,v=-1,S=((p/c|0)<<5)+(r+1)+this.points.length;for(let A of m){let w=A*c;if(l[w+mr]<=r)continue;l[w+mr]=r;let T=l[w+Gt];d+=l[w]*T,x+=l[w+1]*T,l[w+Wl]=S,o&&(b||(b=this._map(l,p,!0),v=this.clusterProps.length,this.clusterProps.push(b)),o(b,this._map(l,w)))}l[p+Wl]=S,u.push(d/g,x/g,1/0,S,-1,g),o&&u.push(v)}else{for(let d=0;d<c;d++)u.push(l[p+d]);if(g>1)for(let d of m){let x=d*c;if(!(l[x+mr]<=r)){l[x+mr]=r;for(let b=0;b<c;b++)u.push(l[x+b])}}}}return u}_getOriginId(e){return e-this.points.length>>5}_getOriginZoom(e){return(e-this.points.length)%32}_map(e,r,n){if(e[r+Gt]>1){let a=this.clusterProps[e[r+Fy]];return n?Object.assign({},a):a}let i=this.points[e[r+Nt]].properties,o=this.options.map(i);return n&&o===i?Object.assign({},o):o}};function ky(t,e,r){return{type:"Feature",id:t[e+Nt],properties:Ey(t,e,r),geometry:{type:"Point",coordinates:[Qx(t[e]),e0(t[e+1])]}}}function Ey(t,e,r){let n=t[e+Gt],i=n>=1e4?`${Math.round(n/1e3)}k`:n>=1e3?`${Math.round(n/100)/10}k`:n,o=t[e+Fy],a=o===-1?{}:Object.assign({},r[o]);return Object.assign(a,{cluster:!0,cluster_id:t[e+Nt],point_count:n,point_count_abbreviated:i})}function Ya(t){return t/360+.5}function Ka(t){let e=Math.sin(t*Math.PI/180),r=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return r<0?0:r>1?1:r}function Qx(t){return(t-.5)*360}function e0(t){let e=(180-t*360)*Math.PI/180;return 360*Math.atan(Math.exp(e))/Math.PI-90}function zi(t,e,r,n){let i=n,o=e+(r-e>>1),a=r-e,s,l=t[e],u=t[e+1],c=t[r],p=t[r+1];for(let f=e+3;f<r;f+=3){let y=t0(t[f],t[f+1],l,u,c,p);if(y>i)s=f,i=y;else if(y===i){let m=Math.abs(f-o);m<a&&(s=f,a=m)}}i>n&&(s-e>3&&zi(t,e,s,n),t[s+2]=i,r-s>3&&zi(t,s,r,n))}function t0(t,e,r,n,i,o){let a=i-r,s=o-n;if(a!==0||s!==0){let l=((t-r)*a+(e-n)*s)/(a*a+s*s);l>1?(r=i,n=o):l>0&&(r+=a*l,n+=s*l)}return a=t-r,s=e-n,a*a+s*s}function dt(t,e,r,n){let i={id:t??null,type:e,geometry:r,tags:n,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0};if(e==="Point"||e==="MultiPoint"||e==="LineString")Qa(i,r);else if(e==="Polygon")Qa(i,r[0]);else if(e==="MultiLineString")for(let o of r)Qa(i,o);else if(e==="MultiPolygon")for(let o of r)Qa(i,o[0]);return i}function Qa(t,e){for(let r=0;r<e.length;r+=3)t.minX=Math.min(t.minX,e[r]),t.minY=Math.min(t.minY,e[r+1]),t.maxX=Math.max(t.maxX,e[r]),t.maxY=Math.max(t.maxY,e[r+1])}function Zl(t,e){let r=[];if(t.type==="FeatureCollection")for(let n=0;n<t.features.length;n++)es(r,t.features[n],e,n);else t.type==="Feature"?es(r,t,e):es(r,{geometry:t},e);return r}function es(t,e,r,n){if(!e.geometry)return;let i=e.geometry.coordinates;if(i&&i.length===0)return;let o=e.geometry.type,a=Math.pow(r.tolerance/((1<<r.maxZoom)*r.extent),2),s=[],l=e.id;if(r.promoteId?l=e.properties[r.promoteId]:r.generateId&&(l=n||0),o==="Point")My(i,s);else if(o==="MultiPoint")for(let u of i)My(u,s);else if(o==="LineString")Hl(i,s,a,!1);else if(o==="MultiLineString")if(r.lineMetrics){for(let u of i)s=[],Hl(u,s,a,!1),t.push(dt(l,"LineString",s,e.properties));return}else Xl(i,s,a,!1);else if(o==="Polygon")Xl(i,s,a,!0);else if(o==="MultiPolygon")for(let u of i){let c=[];Xl(u,c,a,!0),s.push(c)}else if(o==="GeometryCollection"){for(let u of e.geometry.geometries)es(t,{id:l,geometry:u,properties:e.properties},r,n);return}else throw new Error("Input data is not a valid GeoJSON object.");t.push(dt(l,o,s,e.properties))}function My(t,e){e.push(Ly(t[0]),Dy(t[1]),0)}function Hl(t,e,r,n){let i,o,a=0;for(let l=0;l<t.length;l++){let u=Ly(t[l][0]),c=Dy(t[l][1]);e.push(u,c,0),l>0&&(n?a+=(i*c-u*o)/2:a+=Math.sqrt(Math.pow(u-i,2)+Math.pow(c-o,2))),i=u,o=c}let s=e.length-3;e[2]=1,zi(e,0,s,r),e[s+2]=1,e.size=Math.abs(a),e.start=0,e.end=e.size}function Xl(t,e,r,n){for(let i=0;i<t.length;i++){let o=[];Hl(t[i],o,r,n),e.push(o)}}function Ly(t){return t/360+.5}function Dy(t){let e=Math.sin(t*Math.PI/180),r=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return r<0?0:r>1?1:r}function Ue(t,e,r,n,i,o,a,s){if(r/=e,n/=e,o>=r&&a<n)return t;if(a<r||o>=n)return null;let l=[];for(let u of t){let c=u.geometry,p=u.type,f=i===0?u.minX:u.minY,y=i===0?u.maxX:u.maxY;if(f>=r&&y<n){l.push(u);continue}else if(y<r||f>=n)continue;let m=[];if(p==="Point"||p==="MultiPoint")r0(c,m,r,n,i);else if(p==="LineString")Vy(c,m,r,n,i,!1,s.lineMetrics);else if(p==="MultiLineString")Jl(c,m,r,n,i,!1);else if(p==="Polygon")Jl(c,m,r,n,i,!0);else if(p==="MultiPolygon")for(let h of c){let g=[];Jl(h,g,r,n,i,!0),g.length&&m.push(g)}if(m.length){if(s.lineMetrics&&p==="LineString"){for(let h of m)l.push(dt(u.id,p,h,u.tags));continue}(p==="LineString"||p==="MultiLineString")&&(m.length===1?(p="LineString",m=m[0]):p="MultiLineString"),(p==="Point"||p==="MultiPoint")&&(p=m.length===3?"Point":"MultiPoint"),l.push(dt(u.id,p,m,u.tags))}}return l.length?l:null}function r0(t,e,r,n,i){for(let o=0;o<t.length;o+=3){let a=t[o+i];a>=r&&a<=n&&Xr(e,t[o],t[o+1],t[o+2])}}function Vy(t,e,r,n,i,o,a){let s=By(t),l=i===0?n0:i0,u=t.start,c,p;for(let d=0;d<t.length-3;d+=3){let x=t[d],b=t[d+1],v=t[d+2],S=t[d+3],A=t[d+4],w=i===0?x:b,T=i===0?S:A,E=!1;a&&(c=Math.sqrt(Math.pow(x-S,2)+Math.pow(b-A,2))),w<r?T>r&&(p=l(s,x,b,S,A,r),a&&(s.start=u+c*p)):w>n?T<n&&(p=l(s,x,b,S,A,n),a&&(s.start=u+c*p)):Xr(s,x,b,v),T<r&&w>=r&&(p=l(s,x,b,S,A,r),E=!0),T>n&&w<=n&&(p=l(s,x,b,S,A,n),E=!0),!o&&E&&(a&&(s.end=u+c*p),e.push(s),s=By(t)),a&&(u+=c)}let f=t.length-3,y=t[f],m=t[f+1],h=t[f+2],g=i===0?y:m;g>=r&&g<=n&&Xr(s,y,m,h),f=s.length-3,o&&f>=3&&(s[f]!==s[0]||s[f+1]!==s[1])&&Xr(s,s[0],s[1],s[2]),s.length&&e.push(s)}function By(t){let e=[];return e.size=t.size,e.start=t.start,e.end=t.end,e}function Jl(t,e,r,n,i,o){for(let a of t)Vy(a,e,r,n,i,o,!1)}function Xr(t,e,r,n){t.push(e,r,n)}function n0(t,e,r,n,i,o){let a=(o-e)/(n-e);return Xr(t,o,r+(i-r)*a,1),a}function i0(t,e,r,n,i,o){let a=(o-r)/(i-r);return Xr(t,e+(n-e)*a,o,1),a}function Kl(t,e){let r=e.buffer/e.extent,n=t,i=Ue(t,1,-1-r,r,0,-1,2,e),o=Ue(t,1,1-r,2+r,0,-1,2,e);return(i||o)&&(n=Ue(t,1,-r,1+r,0,-1,2,e)||[],i&&(n=Ry(i,1).concat(n)),o&&(n=n.concat(Ry(o,-1)))),n}function Ry(t,e){let r=[];for(let n=0;n<t.length;n++){let i=t[n],o=i.type,a;if(o==="Point"||o==="MultiPoint"||o==="LineString")a=Yl(i.geometry,e);else if(o==="MultiLineString"||o==="Polygon"){a=[];for(let s of i.geometry)a.push(Yl(s,e))}else if(o==="MultiPolygon"){a=[];for(let s of i.geometry){let l=[];for(let u of s)l.push(Yl(u,e));a.push(l)}}r.push(dt(i.id,o,a,i.tags))}return r}function Yl(t,e){let r=[];r.size=t.size,t.start!==void 0&&(r.start=t.start,r.end=t.end);for(let n=0;n<t.length;n+=3)r.push(t[n]+e,t[n+1],t[n+2]);return r}function ts(t,e){if(t.transformed)return t;let r=1<<t.z,n=t.x,i=t.y;for(let o of t.features){let a=o.geometry,s=o.type;if(o.geometry=[],s===1)for(let l=0;l<a.length;l+=2)o.geometry.push(zy(a[l],a[l+1],e,r,n,i));else for(let l=0;l<a.length;l++){let u=[];for(let c=0;c<a[l].length;c+=2)u.push(zy(a[l][c],a[l][c+1],e,r,n,i));o.geometry.push(u)}}return t.transformed=!0,t}function zy(t,e,r,n,i,o){return[Math.round(r*(t*n-i)),Math.round(r*(e*n-o))]}function eu(t,e,r,n,i){let o=e===i.maxZoom?0:i.tolerance/((1<<e)*i.extent),a={features:[],numPoints:0,numSimplified:0,numFeatures:t.length,source:null,x:r,y:n,z:e,transformed:!1,minX:2,minY:1,maxX:-1,maxY:0};for(let s of t)o0(a,s,o,i);return a}function o0(t,e,r,n){let i=e.geometry,o=e.type,a=[];if(t.minX=Math.min(t.minX,e.minX),t.minY=Math.min(t.minY,e.minY),t.maxX=Math.max(t.maxX,e.maxX),t.maxY=Math.max(t.maxY,e.maxY),o==="Point"||o==="MultiPoint")for(let s=0;s<i.length;s+=3)a.push(i[s],i[s+1]),t.numPoints++,t.numSimplified++;else if(o==="LineString")Ql(a,i,t,r,!1,!1);else if(o==="MultiLineString"||o==="Polygon")for(let s=0;s<i.length;s++)Ql(a,i[s],t,r,o==="Polygon",s===0);else if(o==="MultiPolygon")for(let s=0;s<i.length;s++){let l=i[s];for(let u=0;u<l.length;u++)Ql(a,l[u],t,r,!0,u===0)}if(a.length){let s=e.tags||null;if(o==="LineString"&&n.lineMetrics){s={};for(let u in e.tags)s[u]=e.tags[u];s.mapbox_clip_start=i.start/i.size,s.mapbox_clip_end=i.end/i.size}let l={geometry:a,type:o==="Polygon"||o==="MultiPolygon"?3:o==="LineString"||o==="MultiLineString"?2:1,tags:s};e.id!==null&&(l.id=e.id),t.features.push(l)}}function Ql(t,e,r,n,i,o){let a=n*n;if(n>0&&e.size<(i?a:n)){r.numPoints+=e.length/3;return}let s=[];for(let l=0;l<e.length;l+=3)(n===0||e[l+2]>a)&&(r.numSimplified++,s.push(e[l],e[l+1])),r.numPoints++;i&&a0(s,o),t.push(s)}function a0(t,e){let r=0;for(let n=0,i=t.length,o=i-2;n<i;o=n,n+=2)r+=(t[n]-t[o])*(t[n+1]+t[o+1]);if(r>0===e)for(let n=0,i=t.length;n<i/2;n+=2){let o=t[n],a=t[n+1];t[n]=t[i-2-n],t[n+1]=t[i-1-n],t[i-2-n]=o,t[i-1-n]=a}}var s0={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,tolerance:3,extent:4096,buffer:64,lineMetrics:!1,promoteId:null,generateId:!1,debug:0},ru=class{constructor(e,r){r=this.options=l0(Object.create(s0),r);let n=r.debug;if(n&&console.time("preprocess data"),r.maxZoom<0||r.maxZoom>24)throw new Error("maxZoom should be in the 0-24 range");if(r.promoteId&&r.generateId)throw new Error("promoteId and generateId cannot be used together.");let i=Zl(e,r);this.tiles={},this.tileCoords=[],n&&(console.timeEnd("preprocess data"),console.log("index: maxZoom: %d, maxPoints: %d",r.indexMaxZoom,r.indexMaxPoints),console.time("generate tiles"),this.stats={},this.total=0),i=Kl(i,r),i.length&&this.splitTile(i,0,0,0),n&&(i.length&&console.log("features: %d, points: %d",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd("generate tiles"),console.log("tiles generated:",this.total,JSON.stringify(this.stats)))}splitTile(e,r,n,i,o,a,s){let l=[e,r,n,i],u=this.options,c=u.debug;for(;l.length;){i=l.pop(),n=l.pop(),r=l.pop(),e=l.pop();let p=1<<r,f=tu(r,n,i),y=this.tiles[f];if(!y&&(c>1&&console.time("creation"),y=this.tiles[f]=eu(e,r,n,i,u),this.tileCoords.push({z:r,x:n,y:i}),c)){c>1&&(console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",r,n,i,y.numFeatures,y.numPoints,y.numSimplified),console.timeEnd("creation"));let T=`z${r}`;this.stats[T]=(this.stats[T]||0)+1,this.total++}if(y.source=e,o==null){if(r===u.indexMaxZoom||y.numPoints<=u.indexMaxPoints)continue}else{if(r===u.maxZoom||r===o)continue;if(o!=null){let T=o-r;if(n!==a>>T||i!==s>>T)continue}}if(y.source=null,e.length===0)continue;c>1&&console.time("clipping");let m=.5*u.buffer/u.extent,h=.5-m,g=.5+m,d=1+m,x=null,b=null,v=null,S=null,A=Ue(e,p,n-m,n+g,0,y.minX,y.maxX,u),w=Ue(e,p,n+h,n+d,0,y.minX,y.maxX,u);e=null,A&&(x=Ue(A,p,i-m,i+g,1,y.minY,y.maxY,u),b=Ue(A,p,i+h,i+d,1,y.minY,y.maxY,u),A=null),w&&(v=Ue(w,p,i-m,i+g,1,y.minY,y.maxY,u),S=Ue(w,p,i+h,i+d,1,y.minY,y.maxY,u),w=null),c>1&&console.timeEnd("clipping"),l.push(x||[],r+1,n*2,i*2),l.push(b||[],r+1,n*2,i*2+1),l.push(v||[],r+1,n*2+1,i*2),l.push(S||[],r+1,n*2+1,i*2+1)}}getTile(e,r,n){e=+e,r=+r,n=+n;let i=this.options,{extent:o,debug:a}=i;if(e<0||e>24)return null;let s=1<<e;r=r+s&s-1;let l=tu(e,r,n);if(this.tiles[l])return ts(this.tiles[l],o);a>1&&console.log("drilling down to z%d-%d-%d",e,r,n);let u=e,c=r,p=n,f;for(;!f&&u>0;)u--,c=c>>1,p=p>>1,f=this.tiles[tu(u,c,p)];return!f||!f.source?null:(a>1&&(console.log("found parent tile z%d-%d-%d",u,c,p),console.time("drilling down")),this.splitTile(f.source,u,c,p,e,r,n),a>1&&console.timeEnd("drilling down"),this.tiles[l]?ts(this.tiles[l],o):null)}};function tu(t,e,r){return((1<<t)*r+e)*32+t}function l0(t,e){for(let r in e)t[r]=e[r];return t}function nu(t,e){return new ru(t,e)}function Oi(t,e){return e?t.properties[e]:t.id}function iu(t,e){if(t==null)return!0;if(t.type==="Feature")return Oi(t,e)!=null;if(t.type==="FeatureCollection"){let r=new Set;for(let n of t.features){let i=Oi(n,e);if(i==null||r.has(i))return!1;r.add(i)}return!0}return!1}function ou(t,e){let r=new Map;if(t!=null)if(t.type==="Feature")r.set(Oi(t,e),t);else for(let n of t.features)r.set(Oi(n,e),n);return r}function Oy(t,e,r){if(e.removeAll&&t.clear(),e.remove)for(let n of e.remove)t.delete(n);if(e.add)for(let n of e.add){let i=Oi(n,r);i!=null&&t.set(i,n)}if(e.update)for(let n of e.update){let i=t.get(n.id);if(i==null)continue;let o=n.newGeometry||n.removeAllProperties,a=!n.removeAllProperties&&(n.removeProperties?.length>0||n.addOrUpdateProperties?.length>0);if((o||a)&&(i={...i},t.set(n.id,i),a&&(i.properties={...i.properties})),n.newGeometry&&(i.geometry=n.newGeometry),n.removeAllProperties)i.properties={};else if(n.removeProperties?.length>0)for(let s of n.removeProperties)Object.prototype.hasOwnProperty.call(i.properties,s)&&delete i.properties[s];if(n.addOrUpdateProperties?.length>0)for(let{key:s,value:l}of n.addOrUpdateProperties)i.properties[s]=l}}var rs=class extends Wr{constructor(){super(...arguments);this._dataUpdateable=new Map}async loadVectorTile(r,n){let i=r.tileID.canonical;if(!this._geoJSONIndex)throw new Error("Unable to parse the data into a cluster or geojson");let o=this._geoJSONIndex.getTile(i.z,i.x,i.y);if(!o)return null;let a=new Za(o.features),s=(0,Ny.default)(a);return(s.byteOffset!==0||s.byteLength!==s.buffer.byteLength)&&(s=new Uint8Array(s)),{vectorTile:a,rawData:s.buffer}}async loadData(r){this._pendingRequest?.abort();let n=r&&r.request&&r.request.collectResourceTiming?new qr(r.request):!1;this._pendingRequest=new AbortController;try{this._pendingData=this.loadAndProcessGeoJSON(r,this._pendingRequest),this._geoJSONIndex=r.cluster?new Ri(u0(r)).load((await this._pendingData).features):nu(await this._pendingData,r.geojsonVtOptions),this.loaded={};let i={};if(n){let o=n.finish();o&&(i.resourceTiming={},i.resourceTiming[r.source]=JSON.parse(JSON.stringify(o)))}return i}catch(i){if(delete this._pendingRequest,Lc(i))return{abandoned:!0};throw i}}async getData(){return this._pendingData}reloadTile(r){let n=this.loaded,i=r.uid;return n&&n[i]?super.reloadTile(r):this.loadTile(r)}async loadAndProcessGeoJSON(r,n){let i=await this.loadGeoJSON(r,n);if(delete this._pendingRequest,typeof i!="object")throw new Error(`Input data given to \'${r.source}\' is not a valid GeoJSON object.`);if((0,Gy.default)(i,!0),r.filter){let o=Qt(r.filter,{type:"boolean","property-type":"data-driven",overridable:!1,transition:!1});if(o.result==="error")throw new Error(o.value.map(s=>`${s.key}: ${s.message}`).join(", "));i={type:"FeatureCollection",features:i.features.filter(s=>o.value.evaluate({zoom:0},s))}}return i}async loadGeoJSON(r,n){let{promoteId:i}=r;if(r.request){let o=await Nc(r.request,n);return this._dataUpdateable=iu(o.data,i)?ou(o.data,i):void 0,o.data}if(typeof r.data=="string")try{let o=JSON.parse(r.data);return this._dataUpdateable=iu(o,i)?ou(o,i):void 0,o}catch{throw new Error(`Input data given to \'${r.source}\' is not a valid GeoJSON object.`)}if(!r.dataDiff)throw new Error(`Input data given to \'${r.source}\' is not a valid GeoJSON object.`);if(!this._dataUpdateable)throw new Error(`Cannot update existing geojson data in ${r.source}`);return Oy(this._dataUpdateable,r.dataDiff,i),{type:"FeatureCollection",features:Array.from(this._dataUpdateable.values())}}async removeSource(r){this._pendingRequest&&this._pendingRequest.abort()}getClusterExpansionZoom(r){return this._geoJSONIndex.getClusterExpansionZoom(r.clusterId)}getClusterChildren(r){return this._geoJSONIndex.getChildren(r.clusterId)}getClusterLeaves(r){return this._geoJSONIndex.getLeaves(r.clusterId,r.limit,r.offset)}};function u0({superclusterOptions:t,clusterProperties:e}){if(!e||!t)return t;let r={},n={},i={accumulated:null,zoom:0},o={properties:null},a=Object.keys(e);for(let s of a){let[l,u]=e[s],c=Qt(u),p=Qt(typeof l=="string"?[l,["accumulated"],["get",s]]:l);r[s]=c.value,n[s]=p.value}return t.map=s=>{o.properties=s;let l={};for(let u of a)l[u]=r[u].evaluate(i,o);return l},t.reduce=(s,l)=>{o.properties=l;for(let u of a)i.accumulated=s[u],s[u]=n[u].evaluate(i,o)},t}var ns=class{constructor(e){this.self=e,this.actor=new Co(e),this.layerIndexes={},this.availableImages={},this.workerSources={},this.demWorkerSources={},this.externalWorkerSourceTypes={},this.self.registerWorkerSource=(r,n)=>{if(this.externalWorkerSourceTypes[r])throw new Error(`Worker source with name "${r}" already registered.`);this.externalWorkerSourceTypes[r]=n},this.self.addProtocol=Bc,this.self.removeProtocol=Vc,this.self.registerRTLTextPlugin=r=>{we.setMethods(r)},this.actor.registerMessageHandler("LDT",(r,n)=>this._getDEMWorkerSource(r,n.source).loadTile(n)),this.actor.registerMessageHandler("RDT",async(r,n)=>{this._getDEMWorkerSource(r,n.source).removeTile(n)}),this.actor.registerMessageHandler("GCEZ",async(r,n)=>this._getWorkerSource(r,n.type,n.source).getClusterExpansionZoom(n)),this.actor.registerMessageHandler("GCC",async(r,n)=>this._getWorkerSource(r,n.type,n.source).getClusterChildren(n)),this.actor.registerMessageHandler("GCL",async(r,n)=>this._getWorkerSource(r,n.type,n.source).getClusterLeaves(n)),this.actor.registerMessageHandler("LD",(r,n)=>this._getWorkerSource(r,n.type,n.source).loadData(n)),this.actor.registerMessageHandler("GD",(r,n)=>this._getWorkerSource(r,n.type,n.source).getData()),this.actor.registerMessageHandler("LT",(r,n)=>this._getWorkerSource(r,n.type,n.source).loadTile(n)),this.actor.registerMessageHandler("RT",(r,n)=>this._getWorkerSource(r,n.type,n.source).reloadTile(n)),this.actor.registerMessageHandler("AT",(r,n)=>this._getWorkerSource(r,n.type,n.source).abortTile(n)),this.actor.registerMessageHandler("RMT",(r,n)=>this._getWorkerSource(r,n.type,n.source).removeTile(n)),this.actor.registerMessageHandler("RS",async(r,n)=>{if(!this.workerSources[r]||!this.workerSources[r][n.type]||!this.workerSources[r][n.type][n.source])return;let i=this.workerSources[r][n.type][n.source];delete this.workerSources[r][n.type][n.source],i.removeSource!==void 0&&i.removeSource(n)}),this.actor.registerMessageHandler("RM",async r=>{delete this.layerIndexes[r],delete this.availableImages[r],delete this.workerSources[r],delete this.demWorkerSources[r]}),this.actor.registerMessageHandler("SR",async(r,n)=>{this.referrer=n}),this.actor.registerMessageHandler("SRPS",(r,n)=>this._syncRTLPluginState(r,n)),this.actor.registerMessageHandler("IS",async(r,n)=>{this.self.importScripts(n)}),this.actor.registerMessageHandler("SI",(r,n)=>this._setImages(r,n)),this.actor.registerMessageHandler("UL",async(r,n)=>{this._getLayerIndex(r).update(n.layers,n.removedIds)}),this.actor.registerMessageHandler("SL",async(r,n)=>{this._getLayerIndex(r).replace(n)})}async _setImages(e,r){this.availableImages[e]=r;for(let n in this.workerSources[e]){let i=this.workerSources[e][n];for(let o in i)i[o].availableImages=r}}async _syncRTLPluginState(e,r){return await we.syncState(r,this.self.importScripts)}_getAvailableImages(e){let r=this.availableImages[e];return r||(r=[]),r}_getLayerIndex(e){let r=this.layerIndexes[e];return r||(r=this.layerIndexes[e]=new za),r}_getWorkerSource(e,r,n){if(this.workerSources[e]||(this.workerSources[e]={}),this.workerSources[e][r]||(this.workerSources[e][r]={}),!this.workerSources[e][r][n]){let i={sendAsync:(o,a)=>(o.targetMapId=e,this.actor.sendAsync(o,a))};switch(r){case"vector":this.workerSources[e][r][n]=new Wr(i,this._getLayerIndex(e),this._getAvailableImages(e));break;case"geojson":this.workerSources[e][r][n]=new rs(i,this._getLayerIndex(e),this._getAvailableImages(e));break;default:this.workerSources[e][r][n]=new this.externalWorkerSourceTypes[r](i,this._getLayerIndex(e),this._getAvailableImages(e));break}}return this.workerSources[e][r][n]}_getDEMWorkerSource(e,r){return this.demWorkerSources[e]||(this.demWorkerSources[e]={}),this.demWorkerSources[e][r]||(this.demWorkerSources[e][r]=new Xa),this.demWorkerSources[e][r]}};at(self)&&(self.worker=new ns(self));})();\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n*/\n';
var $F = () => $t.WORKER_URL ? $t.WORKER_URL : URL.createObjectURL(new Blob([P1], { type: "text/javascript" }));
function w1() {
  return new Worker($F());
}
var T1 = "maplibre_preloaded_worker_pool";
var ya = class t44 {
  constructor() {
    this.active = {};
  }
  acquire(e) {
    if (!this.workers) for (this.workers = []; this.workers.length < t44.workerCount; ) this.workers.push(w1());
    return this.active[e] = true, this.workers.slice();
  }
  release(e) {
    delete this.active[e], this.numActive() === 0 && (this.workers.forEach((r3) => {
      r3.terminate();
    }), this.workers = null);
  }
  isPreloaded() {
    return !!this.active[T1];
  }
  numActive() {
    return Object.keys(this.active).length;
  }
};
var KF = Math.floor(ae.hardwareConcurrency / 2);
ya.workerCount = Nb(globalThis) ? Math.max(Math.min(KF, 3), 1) : 1;
var wy;
function Qp() {
  return wy || (wy = new ya()), wy;
}
var Ll = class {
  constructor(e, r3) {
    this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = r3;
    let n = this.workerPool.acquire(r3);
    for (let i = 0; i < n.length; i++) {
      let o = n[i], a = new Jp(o, r3);
      a.name = `Worker ${i}`, this.actors.push(a);
    }
    if (!this.actors.length) throw new Error("No actors found");
  }
  broadcast(e, r3) {
    let n = [];
    for (let i of this.actors) n.push(i.sendAsync({ type: e, data: r3 }));
    return Promise.all(n);
  }
  getActor() {
    return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
  }
  remove(e = true) {
    this.actors.forEach((r3) => {
      r3.remove();
    }), this.actors = [], e && this.workerPool.release(this.id);
  }
  registerMessageHandler(e, r3) {
    for (let n of this.actors) n.registerMessageHandler(e, r3);
  }
};
var eh;
function Ty() {
  return eh || (eh = new Ll(Qp(), cc), eh.registerMessageHandler("GR", (t63, e, r3) => Bo(e, r3))), eh;
}
$i();
function JF(t63, e) {
  let r3 = B.create();
  return B.translate(r3, r3, [1, 1, 0]), B.scale(r3, r3, [t63.width * 0.5, t63.height * 0.5, 1]), t63.calculatePosMatrix ? B.multiply(r3, r3, t63.calculatePosMatrix(e.toUnwrapped())) : r3;
}
function QF(t63, e, r3) {
  if (t63) for (let n of t63) {
    let i = e[n];
    if (i && i.source === r3 && i.type === "fill-extrusion") return true;
  }
  else for (let n in e) {
    let i = e[n];
    if (i.source === r3 && i.type === "fill-extrusion") return true;
  }
  return false;
}
function S1(t63, e, r3, n, i, o, a) {
  let s3 = QF(i?.layers ?? null, e, t63.id), l = o.maxPitchScaleFactor(), u3 = t63.tilesIn(n, l, s3);
  u3.sort(I1);
  let c = [];
  for (let h of u3) c.push({ wrappedTileID: h.tileID.wrapped().key, queryResults: h.tile.queryRenderedFeatures(e, r3, t63._state, h.queryGeometry, h.cameraQueryGeometry, h.scale, i, o, l, JF(t63.transform, h.tileID), a ? (f, d) => a(h.tileID, f, d) : void 0) });
  let p = eO(c);
  return tO(p, t63);
}
function C1(t63, e, r3, n, i, o, a) {
  let s3 = {}, l = o.queryRenderedSymbols(n), u3 = [];
  for (let c of Object.keys(l).map(Number)) u3.push(a[c]);
  u3.sort(I1);
  for (let c of u3) {
    let p = c.featureIndex.lookupSymbolFeatures(l[c.bucketInstanceId], e, c.bucketIndex, c.sourceLayerIndex, i.filter, i.layers, i.availableImages, t63);
    for (let h in p) {
      let f = s3[h] = s3[h] || [], d = p[h];
      d.sort((g, x) => {
        let b = c.featureSortOrder;
        if (b) {
          let v3 = b.indexOf(g.featureIndex);
          return b.indexOf(x.featureIndex) - v3;
        } else return x.featureIndex - g.featureIndex;
      });
      for (let g of d) f.push(g);
    }
  }
  return rO(s3, t63, r3);
}
function M1(t63, e) {
  let r3 = t63.getRenderableIds().map((o) => t63.getTileByID(o)), n = [], i = {};
  for (let o = 0; o < r3.length; o++) {
    let a = r3[o], s3 = a.tileID.canonical.key;
    i[s3] || (i[s3] = true, a.querySourceFeatures(n, e));
  }
  return n;
}
function I1(t63, e) {
  let r3 = t63.tileID, n = e.tileID;
  return r3.overscaledZ - n.overscaledZ || r3.canonical.y - n.canonical.y || r3.wrap - n.wrap || r3.canonical.x - n.canonical.x;
}
function eO(t63) {
  let e = {}, r3 = {};
  for (let n of t63) {
    let i = n.queryResults, o = n.wrappedTileID, a = r3[o] = r3[o] || {};
    for (let s3 in i) {
      let l = i[s3], u3 = a[s3] = a[s3] || {}, c = e[s3] = e[s3] || [];
      for (let p of l) u3[p.featureIndex] || (u3[p.featureIndex] = true, c.push(p));
    }
  }
  return e;
}
function tO(t63, e) {
  for (let r3 in t63) for (let n of t63[r3]) A1(n, e);
  return t63;
}
function rO(t63, e, r3) {
  for (let n in t63) for (let i of t63[n]) {
    let o = e[n], a = r3[o.source];
    A1(i, a);
  }
  return t63;
}
function A1(t63, e) {
  let r3 = t63.feature, n = e.getFeatureState(r3.layer["source-layer"], r3.id);
  r3.source = r3.layer.source, r3.layer["source-layer"] && (r3.sourceLayer = r3.layer["source-layer"]), r3.state = n;
}
$i();
$i();
$i();
$i();
async function th(t63, e, r3) {
  let n = t63;
  if (t63.url ? n = (await Kn(e.transformRequest(t63.url, "Source"), r3)).data : await ae.frameAsync(r3), !n) return null;
  let i = nn(Z(n, t63), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
  return "vector_layers" in n && n.vector_layers && (i.vectorLayerIds = n.vector_layers.map((o) => o.id)), i;
}
$i();
$i();
$i();
var nr = 63710088e-1;
var J = class t45 {
  constructor(e, r3) {
    if (isNaN(e) || isNaN(r3)) throw new Error(`Invalid LngLat object: (${e}, ${r3})`);
    if (this.lng = +e, this.lat = +r3, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
  }
  wrap() {
    return new t45(Rr(this.lng, -180, 180), this.lat);
  }
  toArray() {
    return [this.lng, this.lat];
  }
  toString() {
    return `LngLat(${this.lng}, ${this.lat})`;
  }
  distanceTo(e) {
    let r3 = Math.PI / 180, n = this.lat * r3, i = e.lat * r3, o = Math.sin(n) * Math.sin(i) + Math.cos(n) * Math.cos(i) * Math.cos((e.lng - this.lng) * r3);
    return nr * Math.acos(Math.min(o, 1));
  }
  static convert(e) {
    if (e instanceof t45) return e;
    if (Array.isArray(e) && (e.length === 2 || e.length === 3)) return new t45(Number(e[0]), Number(e[1]));
    if (!Array.isArray(e) && typeof e == "object" && e !== null) return new t45(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
    throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
  }
};
var mt = class t46 {
  constructor(e, r3) {
    e && (r3 ? this.setSouthWest(e).setNorthEast(r3) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
  }
  setNorthEast(e) {
    return this._ne = e instanceof J ? new J(e.lng, e.lat) : J.convert(e), this;
  }
  setSouthWest(e) {
    return this._sw = e instanceof J ? new J(e.lng, e.lat) : J.convert(e), this;
  }
  extend(e) {
    let r3 = this._sw, n = this._ne, i, o;
    if (e instanceof J) i = e, o = e;
    else if (e instanceof t46) {
      if (i = e._sw, o = e._ne, !i || !o) return this;
    } else {
      if (Array.isArray(e)) if (e.length === 4 || e.every(Array.isArray)) {
        let a = e;
        return this.extend(t46.convert(a));
      } else {
        let a = e;
        return this.extend(J.convert(a));
      }
      else if (e && ("lng" in e || "lon" in e) && "lat" in e) return this.extend(J.convert(e));
      return this;
    }
    return !r3 && !n ? (this._sw = new J(i.lng, i.lat), this._ne = new J(o.lng, o.lat)) : (r3.lng = Math.min(i.lng, r3.lng), r3.lat = Math.min(i.lat, r3.lat), n.lng = Math.max(o.lng, n.lng), n.lat = Math.max(o.lat, n.lat)), this;
  }
  getCenter() {
    return new J((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
  }
  getSouthWest() {
    return this._sw;
  }
  getNorthEast() {
    return this._ne;
  }
  getNorthWest() {
    return new J(this.getWest(), this.getNorth());
  }
  getSouthEast() {
    return new J(this.getEast(), this.getSouth());
  }
  getWest() {
    return this._sw.lng;
  }
  getSouth() {
    return this._sw.lat;
  }
  getEast() {
    return this._ne.lng;
  }
  getNorth() {
    return this._ne.lat;
  }
  toArray() {
    return [this._sw.toArray(), this._ne.toArray()];
  }
  toString() {
    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
  }
  isEmpty() {
    return !(this._sw && this._ne);
  }
  contains(e) {
    let { lng: r3, lat: n } = J.convert(e), i = this._sw.lat <= n && n <= this._ne.lat, o = this._sw.lng <= r3 && r3 <= this._ne.lng;
    return this._sw.lng > this._ne.lng && (o = this._sw.lng >= r3 && r3 >= this._ne.lng), i && o;
  }
  static convert(e) {
    return e instanceof t46 || !e ? e : new t46(e);
  }
  static fromLngLat(e, r3 = 0) {
    let i = 360 * r3 / 40075017, o = i / Math.cos(Math.PI / 180 * e.lat);
    return new t46(new J(e.lng - o, e.lat - i), new J(e.lng + o, e.lat + i));
  }
  adjustAntiMeridian() {
    let e = new J(this._sw.lng, this._sw.lat), r3 = new J(this._ne.lng, this._ne.lat);
    return e.lng > r3.lng ? new t46(e, new J(r3.lng + 360, r3.lat)) : new t46(e, r3);
  }
};
$i();
var E1 = 2 * Math.PI * nr;
function L1(t63) {
  return E1 * Math.cos(t63 * Math.PI / 180);
}
function Dn(t63) {
  return (180 + t63) / 360;
}
function Kr(t63) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t63 * Math.PI / 360))) / 360;
}
function dn(t63, e) {
  return t63 / L1(e);
}
function nO(t63) {
  return t63 * 360 - 180;
}
function Sy(t63) {
  let e = 180 - t63 * 360;
  return 360 / Math.PI * Math.atan(Math.exp(e * Math.PI / 180)) - 90;
}
function rh(t63, e) {
  return t63 * L1(Sy(e));
}
function iO(t63) {
  return 1 / Math.cos(t63 * Math.PI / 180);
}
var xe = class t47 {
  constructor(e, r3, n = 0) {
    this.x = +e, this.y = +r3, this.z = +n;
  }
  static fromLngLat(e, r3 = 0) {
    let n = J.convert(e);
    return new t47(Dn(n.lng), Kr(n.lat), dn(r3, n.lat));
  }
  toLngLat() {
    return new J(nO(this.x), Sy(this.y));
  }
  toAltitude() {
    return rh(this.z, this.y);
  }
  meterInMercatorCoordinateUnits() {
    return 1 / E1 * iO(Sy(this.y));
  }
};
var ga = class {
  constructor(e, r3, n) {
    this.bounds = mt.convert(this.validateBounds(e)), this.minzoom = r3 || 0, this.maxzoom = n || 24;
  }
  validateBounds(e) {
    return !Array.isArray(e) || e.length !== 4 ? [-180, -90, 180, 90] : [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])];
  }
  contains(e) {
    let r3 = Math.pow(2, e.z), n = { minX: Math.floor(Dn(this.bounds.getWest()) * r3), minY: Math.floor(Kr(this.bounds.getNorth()) * r3), maxX: Math.ceil(Dn(this.bounds.getEast()) * r3), maxY: Math.ceil(Kr(this.bounds.getSouth()) * r3) };
    return e.x >= n.minX && e.x < n.maxX && e.y >= n.minY && e.y < n.maxY;
  }
};
var Dl = class extends Ee {
  constructor(e, r3, n, i) {
    if (super(), this.id = e, this.dispatcher = n, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, Z(this, nn(r3, ["url", "scheme", "tileSize", "promoteId"])), this._options = Z({ type: "vector" }, r3), this._collectResourceTiming = r3.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
    this.setEventedParent(i);
  }
  async load() {
    this._loaded = false, this.fire(new U("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
    try {
      let e = await th(this._options, this.map._requestManager, this._tileJSONRequest);
      this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e && (Z(this, e), e.bounds && (this.tileBounds = new ga(e.bounds, this.minzoom, this.maxzoom)), this.fire(new U("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new U("data", { dataType: "source", sourceDataType: "content" })));
    } catch (e) {
      this._tileJSONRequest = null, this.fire(new Q(e));
    }
  }
  loaded() {
    return this._loaded;
  }
  hasTile(e) {
    return !this.tileBounds || this.tileBounds.contains(e.canonical);
  }
  onAdd(e) {
    this.map = e, this.load();
  }
  setSourceProperty(e) {
    this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load();
  }
  setTiles(e) {
    return this.setSourceProperty(() => {
      this._options.tiles = e;
    }), this;
  }
  setUrl(e) {
    return this.setSourceProperty(() => {
      this.url = e, this._options.url = e;
    }), this;
  }
  onRemove() {
    this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
  }
  serialize() {
    return Z({}, this._options);
  }
  async loadTile(e) {
    let r3 = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), n = { request: this.map._requestManager.transformRequest(r3, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, globalState: this.map.getGlobalState() };
    n.request.collectResourceTiming = this._collectResourceTiming;
    let i = "RT";
    if (!e.actor || e.state === "expired") e.actor = this.dispatcher.getActor(), i = "LT";
    else if (e.state === "loading") return new Promise((o, a) => {
      e.reloadPromise = { resolve: o, reject: a };
    });
    e.abortController = new AbortController();
    try {
      let o = await e.actor.sendAsync({ type: i, data: n }, e.abortController);
      if (delete e.abortController, e.aborted) return;
      this._afterTileLoadWorkerResponse(e, o);
    } catch (o) {
      if (delete e.abortController, e.aborted) return;
      if (o && o.status !== 404) throw o;
      this._afterTileLoadWorkerResponse(e, null);
    }
  }
  _afterTileLoadWorkerResponse(e, r3) {
    if (r3 && r3.resourceTiming && (e.resourceTiming = r3.resourceTiming), r3 && this.map._refreshExpiredTiles && e.setExpiryData(r3), e.loadVectorData(r3, this.map.painter), e.reloadPromise) {
      let n = e.reloadPromise;
      e.reloadPromise = null, this.loadTile(e).then(n.resolve).catch(n.reject);
    }
  }
  async abortTile(e) {
    e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && await e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } });
  }
  async unloadTile(e) {
    e.unloadVectorData(), e.actor && await e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
  }
  hasTransition() {
    return false;
  }
};
$i();
var ho = class extends Ee {
  constructor(e, r3, n, i) {
    super(), this.id = e, this.dispatcher = n, this.setEventedParent(i), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = Z({ type: "raster" }, r3), Z(this, nn(r3, ["url", "scheme", "tileSize"]));
  }
  async load(e = false) {
    this._loaded = false, this.fire(new U("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
    try {
      let r3 = await th(this._options, this.map._requestManager, this._tileJSONRequest);
      this._tileJSONRequest = null, this._loaded = true, r3 && (Z(this, r3), r3.bounds && (this.tileBounds = new ga(r3.bounds, this.minzoom, this.maxzoom)), this.fire(new U("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new U("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e })));
    } catch (r3) {
      this._tileJSONRequest = null, this.fire(new Q(r3));
    }
  }
  loaded() {
    return this._loaded;
  }
  onAdd(e) {
    this.map = e, this.load();
  }
  onRemove() {
    this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
  }
  setSourceProperty(e) {
    this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(true);
  }
  setTiles(e) {
    return this.setSourceProperty(() => {
      this._options.tiles = e;
    }), this;
  }
  setUrl(e) {
    return this.setSourceProperty(() => {
      this.url = e, this._options.url = e;
    }), this;
  }
  serialize() {
    return Z({}, this._options);
  }
  hasTile(e) {
    return !this.tileBounds || this.tileBounds.contains(e.canonical);
  }
  async loadTile(e) {
    let r3 = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
    e.abortController = new AbortController();
    try {
      let n = await Gt.getImage(this.map._requestManager.transformRequest(r3, "Tile"), e.abortController, this.map._refreshExpiredTiles);
      if (delete e.abortController, e.aborted) {
        e.state = "unloaded";
        return;
      }
      if (n && n.data) {
        this.map._refreshExpiredTiles && (n.cacheControl || n.expires) && e.setExpiryData({ cacheControl: n.cacheControl, expires: n.expires });
        let i = this.map.painter.context, o = i.gl, a = n.data;
        e.texture = this.map.painter.getTileTexture(a.width), e.texture ? e.texture.update(a, { useMipmap: true }) : (e.texture = new Se(i, a, o.RGBA, { useMipmap: true }), e.texture.bind(o.LINEAR, o.CLAMP_TO_EDGE, o.LINEAR_MIPMAP_NEAREST)), e.state = "loaded";
      }
    } catch (n) {
      if (delete e.abortController, e.aborted) e.state = "unloaded";
      else if (n) throw e.state = "errored", n;
    }
  }
  async abortTile(e) {
    e.abortController && (e.abortController.abort(), delete e.abortController);
  }
  async unloadTile(e) {
    e.texture && this.map.painter.saveTileTexture(e.texture);
  }
  hasTransition() {
    return false;
  }
};
$i();
$i();
$i();
function R1(t63, e, r3) {
  e = Math.pow(2, r3) - e - 1;
  var n = D1(t63 * 256, e * 256, r3), i = D1((t63 + 1) * 256, (e + 1) * 256, r3);
  return n[0] + "," + n[1] + "," + i[0] + "," + i[1];
}
function D1(t63, e, r3) {
  var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r3), i = t63 * n - 2 * Math.PI * 6378137 / 2, o = e * n - 2 * Math.PI * 6378137 / 2;
  return [i, o];
}
var O1 = s(fe(), 1);
$i();
function k1(t63, e, r3) {
  return !(t63 < ls || t63 > Gi || r3 < 0 || r3 >= Math.pow(2, t63) || e < 0 || e >= Math.pow(2, t63));
}
function F1(t63, e) {
  let { x: r3, y: n } = xe.fromLngLat(e);
  return !(t63 < ls || t63 > Gi || n < 0 || n >= 1 || r3 < 0 || r3 >= 1);
}
var di = class {
  constructor(e, r3, n) {
    if (!k1(e, r3, n)) throw new Error(`x=${r3}, y=${n}, z=${e} outside of bounds. 0<=x<${Math.pow(2, e)}, 0<=y<${Math.pow(2, e)} ${ls}<=z<=${Gi} `);
    this.z = e, this.x = r3, this.y = n, this.key = fo(0, e, e, r3, n);
  }
  equals(e) {
    return this.z === e.z && this.x === e.x && this.y === e.y;
  }
  url(e, r3, n) {
    let i = R1(this.x, this.y, this.z), o = oO(this.z, this.x, this.y);
    return e[(this.x + this.y) % e.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(n === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, r3 > 1 ? "@2x" : "").replace(/{quadkey}/g, o).replace(/{bbox-epsg-3857}/g, i);
  }
  isChildOf(e) {
    let r3 = this.z - e.z;
    return r3 > 0 && e.x === this.x >> r3 && e.y === this.y >> r3;
  }
  getTilePoint(e) {
    let r3 = Math.pow(2, this.z);
    return new O1.default((e.x * r3 - this.x) * 8192, (e.y * r3 - this.y) * 8192);
  }
  toString() {
    return `${this.z}/${this.x}/${this.y}`;
  }
};
var yi = class {
  constructor(e, r3) {
    this.wrap = e, this.canonical = r3, this.key = fo(e, r3.z, r3.z, r3.x, r3.y);
  }
};
var Ye2 = class t48 {
  constructor(e, r3, n, i, o) {
    this.terrainRttPosMatrix32f = null;
    if (e < n) throw new Error(`overscaledZ should be >= z; overscaledZ = ${e}; z = ${n}`);
    this.overscaledZ = e, this.wrap = r3, this.canonical = new di(n, +i, +o), this.key = fo(r3, e, n, i, o);
  }
  clone() {
    return new t48(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
  }
  equals(e) {
    return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical);
  }
  scaledTo(e) {
    if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);
    let r3 = this.canonical.z - e;
    return e > this.canonical.z ? new t48(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new t48(e, this.wrap, e, this.canonical.x >> r3, this.canonical.y >> r3);
  }
  calculateScaledKey(e, r3) {
    if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);
    let n = this.canonical.z - e;
    return e > this.canonical.z ? fo(this.wrap * +r3, e, this.canonical.z, this.canonical.x, this.canonical.y) : fo(this.wrap * +r3, e, e, this.canonical.x >> n, this.canonical.y >> n);
  }
  isChildOf(e) {
    if (e.wrap !== this.wrap) return false;
    let r3 = this.canonical.z - e.canonical.z;
    return e.overscaledZ === 0 || e.overscaledZ < this.overscaledZ && e.canonical.x === this.canonical.x >> r3 && e.canonical.y === this.canonical.y >> r3;
  }
  children(e) {
    if (this.overscaledZ >= e) return [new t48(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
    let r3 = this.canonical.z + 1, n = this.canonical.x * 2, i = this.canonical.y * 2;
    return [new t48(r3, this.wrap, r3, n, i), new t48(r3, this.wrap, r3, n + 1, i), new t48(r3, this.wrap, r3, n, i + 1), new t48(r3, this.wrap, r3, n + 1, i + 1)];
  }
  isLessThan(e) {
    return this.wrap < e.wrap ? true : this.wrap > e.wrap ? false : this.overscaledZ < e.overscaledZ ? true : this.overscaledZ > e.overscaledZ ? false : this.canonical.x < e.canonical.x ? true : this.canonical.x > e.canonical.x ? false : this.canonical.y < e.canonical.y;
  }
  wrapped() {
    return new t48(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
  }
  unwrapTo(e) {
    return new t48(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y);
  }
  overscaleFactor() {
    return Math.pow(2, this.overscaledZ - this.canonical.z);
  }
  toUnwrapped() {
    return new yi(this.wrap, this.canonical);
  }
  toString() {
    return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
  }
  getTilePoint(e) {
    return this.canonical.getTilePoint(new xe(e.x - this.wrap, e.y));
  }
};
function fo(t63, e, r3, n, i) {
  t63 *= 2, t63 < 0 && (t63 = t63 * -1 - 1);
  let o = 1 << r3;
  return (o * o * t63 + o * i + n).toString(36) + r3.toString(36) + e.toString(36);
}
function oO(t63, e, r3) {
  let n = "", i;
  for (let o = t63; o > 0; o--) i = 1 << o - 1, n += (e & i ? 1 : 0) + (r3 & i ? 2 : 0);
  return n;
}
X("CanonicalTileID", di);
X("OverscaledTileID", Ye2, { omit: ["terrainRttPosMatrix32f"] });
var Rl = class extends ho {
  constructor(e, r3, n, i) {
    super(e, r3, n, i), this.type = "raster-dem", this.maxzoom = 22, this._options = Z({ type: "raster-dem" }, r3), this.encoding = r3.encoding || "mapbox", this.redFactor = r3.redFactor, this.greenFactor = r3.greenFactor, this.blueFactor = r3.blueFactor, this.baseShift = r3.baseShift;
  }
  async loadTile(e) {
    let r3 = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), n = this.map._requestManager.transformRequest(r3, "Tile");
    e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController();
    try {
      let i = await Gt.getImage(n, e.abortController, this.map._refreshExpiredTiles);
      if (delete e.abortController, e.aborted) {
        e.state = "unloaded";
        return;
      }
      if (i && i.data) {
        let o = i.data;
        this.map._refreshExpiredTiles && (i.cacheControl || i.expires) && e.setExpiryData({ cacheControl: i.cacheControl, expires: i.expires });
        let s3 = Wt(o) && Wu() ? o : await this.readImageNow(o), l = { type: this.type, uid: e.uid, source: this.id, rawImageData: s3, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
        if (!e.actor || e.state === "expired") {
          e.actor = this.dispatcher.getActor();
          let u3 = await e.actor.sendAsync({ type: "LDT", data: l });
          e.dem = u3, e.needsHillshadePrepare = true, e.needsTerrainPrepare = true, e.state = "loaded";
        }
      }
    } catch (i) {
      if (delete e.abortController, e.aborted) e.state = "unloaded";
      else if (i) throw e.state = "errored", i;
    }
  }
  async readImageNow(e) {
    if (typeof VideoFrame < "u" && Om()) {
      let r3 = e.width + 2, n = e.height + 2;
      try {
        return new Le2({ width: r3, height: n }, await Hb(e, -1, -1, r3, n));
      } catch {
      }
    }
    return ae.getImageData(e, 1);
  }
  _getNeighboringTiles(e) {
    let r3 = e.canonical, n = Math.pow(2, r3.z), i = (r3.x - 1 + n) % n, o = r3.x === 0 ? e.wrap - 1 : e.wrap, a = (r3.x + 1 + n) % n, s3 = r3.x + 1 === n ? e.wrap + 1 : e.wrap, l = {};
    return l[new Ye2(e.overscaledZ, o, r3.z, i, r3.y).key] = { backfilled: false }, l[new Ye2(e.overscaledZ, s3, r3.z, a, r3.y).key] = { backfilled: false }, r3.y > 0 && (l[new Ye2(e.overscaledZ, o, r3.z, i, r3.y - 1).key] = { backfilled: false }, l[new Ye2(e.overscaledZ, e.wrap, r3.z, r3.x, r3.y - 1).key] = { backfilled: false }, l[new Ye2(e.overscaledZ, s3, r3.z, a, r3.y - 1).key] = { backfilled: false }), r3.y + 1 < n && (l[new Ye2(e.overscaledZ, o, r3.z, i, r3.y + 1).key] = { backfilled: false }, l[new Ye2(e.overscaledZ, e.wrap, r3.z, r3.x, r3.y + 1).key] = { backfilled: false }, l[new Ye2(e.overscaledZ, s3, r3.z, a, r3.y + 1).key] = { backfilled: false }), l;
  }
  async unloadTile(e) {
    e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && await e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } });
  }
};
$i();
var kl = class extends Ee {
  constructor(e, r3, n, i) {
    super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = n.getActor(), this.setEventedParent(i), this._data = r3.data, this._options = Z({}, r3), this._collectResourceTiming = r3.collectResourceTiming, r3.maxzoom !== void 0 && (this.maxzoom = r3.maxzoom), r3.type && (this.type = r3.type), r3.attribution && (this.attribution = r3.attribution), this.promoteId = r3.promoteId, r3.clusterMaxZoom !== void 0 && this.maxzoom <= r3.clusterMaxZoom && ve2(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${r3.clusterMaxZoom}".`), this.workerOptions = Z({ source: this.id, cluster: r3.cluster || false, geojsonVtOptions: { buffer: this._pixelsToTileUnits(r3.buffer !== void 0 ? r3.buffer : 128), tolerance: this._pixelsToTileUnits(r3.tolerance !== void 0 ? r3.tolerance : 0.375), extent: 8192, maxZoom: this.maxzoom, lineMetrics: r3.lineMetrics || false, generateId: r3.generateId || false }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(r3.clusterMaxZoom), minPoints: Math.max(2, r3.clusterMinPoints || 2), extent: 8192, radius: this._pixelsToTileUnits(r3.clusterRadius || 50), log: false, generateId: r3.generateId || false }, clusterProperties: r3.clusterProperties, filter: r3.filter }, r3.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
  }
  _pixelsToTileUnits(e) {
    return e * (8192 / this.tileSize);
  }
  _getClusterMaxZoom(e) {
    let r3 = e ? Math.round(e) : this.maxzoom - 1;
    return Number.isInteger(e) || e === void 0 || ve2(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${r3}"`), r3;
  }
  async load() {
    await this._updateWorkerData();
  }
  onAdd(e) {
    this.map = e, this.load();
  }
  setData(e) {
    return this._data = e, this._updateWorkerData(), this;
  }
  updateData(e) {
    return this._updateWorkerData(e), this;
  }
  async getData() {
    let e = Z({ type: this.type }, this.workerOptions);
    return this.actor.sendAsync({ type: "GD", data: e });
  }
  getCoordinatesFromGeometry(e) {
    return e.type === "GeometryCollection" ? e.geometries.map((r3) => r3.coordinates).flat(1 / 0) : e.coordinates.flat(1 / 0);
  }
  async getBounds() {
    let e = new mt(), r3 = await this.getData(), n;
    switch (r3.type) {
      case "FeatureCollection":
        n = r3.features.map((i) => this.getCoordinatesFromGeometry(i.geometry)).flat(1 / 0);
        break;
      case "Feature":
        n = this.getCoordinatesFromGeometry(r3.geometry);
        break;
      default:
        n = this.getCoordinatesFromGeometry(r3);
        break;
    }
    if (n.length == 0) return e;
    for (let i = 0; i < n.length - 1; i += 2) e.extend([n[i], n[i + 1]]);
    return e;
  }
  setClusterOptions(e) {
    return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom))), this._updateWorkerData(), this;
  }
  getClusterExpansionZoom(e) {
    return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } });
  }
  getClusterChildren(e) {
    return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } });
  }
  getClusterLeaves(e, r3, n) {
    return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: r3, offset: n } });
  }
  async _updateWorkerData(e) {
    let r3 = Z({ type: this.type }, this.workerOptions);
    e ? r3.dataDiff = e : typeof this._data == "string" ? (r3.request = this.map._requestManager.transformRequest(ae.resolveURL(this._data), "Source"), r3.request.collectResourceTiming = this._collectResourceTiming) : r3.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new U("dataloading", { dataType: "source" }));
    try {
      let n = await this.actor.sendAsync({ type: "LD", data: r3 });
      if (this._pendingLoads--, this._removed || n.abandoned) {
        this.fire(new U("dataabort", { dataType: "source" }));
        return;
      }
      let i = null;
      n.resourceTiming && n.resourceTiming[this.id] && (i = n.resourceTiming[this.id].slice(0));
      let o = { dataType: "source" };
      this._collectResourceTiming && i && i.length > 0 && Z(o, { resourceTiming: i }), this.fire(new U("data", { ...o, sourceDataType: "metadata" })), this.fire(new U("data", { ...o, sourceDataType: "content" }));
    } catch (n) {
      if (this._pendingLoads--, this._removed) {
        this.fire(new U("dataabort", { dataType: "source" }));
        return;
      }
      this.fire(new Q(n));
    }
  }
  loaded() {
    return this._pendingLoads === 0;
  }
  async loadTile(e) {
    let r3 = e.actor ? "RT" : "LT";
    e.actor = this.actor;
    let n = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, globalState: this.map.getGlobalState() };
    e.abortController = new AbortController();
    let i = await this.actor.sendAsync({ type: r3, data: n }, e.abortController);
    delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(i, this.map.painter, r3 === "RT");
  }
  async abortTile(e) {
    e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = true;
  }
  async unloadTile(e) {
    e.unloadVectorData(), await this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
  }
  onRemove() {
    this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
  }
  serialize() {
    return Z({}, this._options, { type: this.type, data: this._data });
  }
  hasTransition() {
    return false;
  }
};
$i();
$i();
$i();
var Fl = s(fe(), 1);
var Tt = class t49 {
  constructor() {
    this.minX = 1 / 0;
    this.maxX = -1 / 0;
    this.minY = 1 / 0;
    this.maxY = -1 / 0;
  }
  extend(e) {
    return this.minX = Math.min(this.minX, e.x), this.minY = Math.min(this.minY, e.y), this.maxX = Math.max(this.maxX, e.x), this.maxY = Math.max(this.maxY, e.y), this;
  }
  expandBy(e) {
    return this.minX -= e, this.minY -= e, this.maxX += e, this.maxY += e, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this;
  }
  shrinkBy(e) {
    return this.expandBy(-e);
  }
  map(e) {
    let r3 = new t49();
    return r3.extend(e(new Fl.default(this.minX, this.minY))), r3.extend(e(new Fl.default(this.maxX, this.minY))), r3.extend(e(new Fl.default(this.minX, this.maxY))), r3.extend(e(new Fl.default(this.maxX, this.maxY))), r3;
  }
  static fromPoints(e) {
    let r3 = new t49();
    for (let n of e) r3.extend(n);
    return r3;
  }
  contains(e) {
    return e.x >= this.minX && e.x <= this.maxX && e.y >= this.minY && e.y <= this.maxY;
  }
  empty() {
    return this.minX > this.maxX;
  }
  width() {
    return this.maxX - this.minX;
  }
  height() {
    return this.maxY - this.minY;
  }
  covers(e) {
    return !this.empty() && !e.empty() && e.minX >= this.minX && e.maxX <= this.maxX && e.minY >= this.minY && e.maxY <= this.maxY;
  }
  intersects(e) {
    return !this.empty() && !e.empty() && e.minX <= this.maxX && e.maxX >= this.minX && e.minY <= this.maxY && e.maxY >= this.minY;
  }
};
var _r = class extends Ee {
  constructor(r3, n, i, o) {
    super();
    this.flippedWindingOrder = false;
    this.id = r3, this.dispatcher = i, this.coordinates = n.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(o), this.options = n;
  }
  async load(r3) {
    this._loaded = false, this.fire(new U("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
    try {
      let n = await Gt.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
      this._request = null, this._loaded = true, n && n.data && (this.image = n.data, r3 && (this.coordinates = r3), this._finishLoading());
    } catch (n) {
      this._request = null, this._loaded = true, this.fire(new Q(n));
    }
  }
  loaded() {
    return this._loaded;
  }
  updateImage(r3) {
    return r3.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = r3.url, this.load(r3.coordinates).finally(() => {
      this.texture = null;
    }), this) : this;
  }
  _finishLoading() {
    this.map && (this.setCoordinates(this.coordinates), this.fire(new U("data", { dataType: "source", sourceDataType: "metadata" })));
  }
  onAdd(r3) {
    this.map = r3, this.load();
  }
  onRemove() {
    this._request && (this._request.abort(), this._request = null);
  }
  setCoordinates(r3) {
    this.coordinates = r3;
    let n = r3.map(xe.fromLngLat);
    return this.tileID = aO(n), this.terrainTileRanges = this._getOverlappingTileRanges(n), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = n.map((i) => this.tileID.getTilePoint(i)._round()), this.flippedWindingOrder = sO(this.tileCoords), this.fire(new U("data", { dataType: "source", sourceDataType: "content" })), this;
  }
  prepare() {
    if (Object.keys(this.tiles).length === 0 || !this.image) return;
    let r3 = this.map.painter.context, n = r3.gl;
    this.texture || (this.texture = new Se(r3, this.image, n.RGBA), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE));
    let i = false;
    for (let o in this.tiles) {
      let a = this.tiles[o];
      a.state !== "loaded" && (a.state = "loaded", a.texture = this.texture, i = true);
    }
    i && this.fire(new U("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
  }
  async loadTile(r3) {
    this.tileID && this.tileID.equals(r3.tileID.canonical) ? (this.tiles[String(r3.tileID.wrap)] = r3, r3.buckets = {}) : r3.state = "errored";
  }
  serialize() {
    return { type: "image", url: this.options.url, coordinates: this.coordinates };
  }
  hasTransition() {
    return false;
  }
  _getOverlappingTileRanges(r3) {
    let { minX: n, minY: i, maxX: o, maxY: a } = Tt.fromPoints(r3), s3 = {};
    for (let l = 0; l <= Gi; l++) {
      let u3 = Math.pow(2, l), c = Math.floor(n * u3), p = Math.floor(i * u3), h = Math.floor(o * u3), f = Math.floor(a * u3);
      s3[l] = { minTileX: c, minTileY: p, maxTileX: h, maxTileY: f };
    }
    return s3;
  }
};
function aO(t63) {
  let e = Tt.fromPoints(t63), r3 = e.width(), n = e.height(), i = Math.max(r3, n), o = Math.max(0, Math.floor(-Math.log(i) / Math.LN2)), a = Math.pow(2, o);
  return new di(o, Math.floor((e.minX + e.maxX) / 2 * a), Math.floor((e.minY + e.maxY) / 2 * a));
}
function sO(t63) {
  let e = t63[1].x - t63[0].x, r3 = t63[1].y - t63[0].y, n = t63[2].x - t63[0].x, i = t63[2].y - t63[0].y;
  return e * i - r3 * n < 0;
}
var Ol = class extends _r {
  constructor(e, r3, n, i) {
    super(e, r3, n, i), this.roundZoom = true, this.type = "video", this.options = r3;
  }
  async load() {
    this._loaded = false;
    let e = this.options;
    this.urls = [];
    for (let r3 of e.urls) this.urls.push(this.map._requestManager.transformRequest(r3, "Source").url);
    try {
      let r3 = await t_(this.urls);
      if (this._loaded = true, !r3) return;
      this.video = r3, this.video.loop = true, this.video.addEventListener("playing", () => {
        this.map.triggerRepaint();
      }), this.map && this.video.play(), this._finishLoading();
    } catch (r3) {
      this.fire(new Q(r3));
    }
  }
  pause() {
    this.video && this.video.pause();
  }
  play() {
    this.video && this.video.play();
  }
  seek(e) {
    if (this.video) {
      let r3 = this.video.seekable;
      e < r3.start(0) || e > r3.end(0) ? this.fire(new Q(new G(`sources.${this.id}`, null, `Playback for this video can be set only between the ${r3.start(0)} and ${r3.end(0)}-second mark.`))) : this.video.currentTime = e;
    }
  }
  getVideo() {
    return this.video;
  }
  onAdd(e) {
    this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
  }
  prepare() {
    if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
    let e = this.map.painter.context, r3 = e.gl;
    this.texture ? this.video.paused || (this.texture.bind(r3.LINEAR, r3.CLAMP_TO_EDGE), r3.texSubImage2D(r3.TEXTURE_2D, 0, 0, 0, r3.RGBA, r3.UNSIGNED_BYTE, this.video)) : (this.texture = new Se(e, this.video, r3.RGBA), this.texture.bind(r3.LINEAR, r3.CLAMP_TO_EDGE));
    let n = false;
    for (let i in this.tiles) {
      let o = this.tiles[i];
      o.state !== "loaded" && (o.state = "loaded", o.texture = this.texture, n = true);
    }
    n && this.fire(new U("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
  }
  serialize() {
    return { type: "video", urls: this.urls, coordinates: this.coordinates };
  }
  hasTransition() {
    return this.video && !this.video.paused;
  }
};
$i();
var Bl = class extends _r {
  constructor(e, r3, n, i) {
    super(e, r3, n, i), r3.coordinates ? (!Array.isArray(r3.coordinates) || r3.coordinates.length !== 4 || r3.coordinates.some((o) => !Array.isArray(o) || o.length !== 2 || o.some((a) => typeof a != "number"))) && this.fire(new Q(new G(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new Q(new G(`sources.${e}`, null, 'missing required property "coordinates"'))), r3.animate && typeof r3.animate != "boolean" && this.fire(new Q(new G(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), r3.canvas ? typeof r3.canvas != "string" && !(r3.canvas instanceof HTMLCanvasElement) && this.fire(new Q(new G(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new Q(new G(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = r3, this.animate = r3.animate !== void 0 ? r3.animate : true;
  }
  async load() {
    if (this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions()) {
      this.fire(new Q(new Error("Canvas dimensions cannot be less than or equal to zero.")));
      return;
    }
    this.play = function() {
      this._playing = true, this.map.triggerRepaint();
    }, this.pause = function() {
      this._playing && (this.prepare(), this._playing = false);
    }, this._finishLoading();
  }
  getCanvas() {
    return this.canvas;
  }
  onAdd(e) {
    this.map = e, this.load(), this.canvas && this.animate && this.play();
  }
  onRemove() {
    this.pause();
  }
  prepare() {
    let e = false;
    if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e = true), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
    let r3 = this.map.painter.context, n = r3.gl;
    this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new Se(r3, this.canvas, n.RGBA, { premultiply: true });
    let i = false;
    for (let o in this.tiles) {
      let a = this.tiles[o];
      a.state !== "loaded" && (a.state = "loaded", a.texture = this.texture, i = true);
    }
    i && this.fire(new U("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
  }
  serialize() {
    return { type: "canvas", coordinates: this.coordinates };
  }
  hasTransition() {
    return this._playing;
  }
  _hasInvalidDimensions() {
    for (let e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return true;
    return false;
  }
};
var lO = {};
var B1 = (t63, e, r3, n) => {
  let i = uO(e.type), o = new i(t63, e, r3, n);
  if (o.id !== t63) throw new Error(`Expected Source id to be ${t63} instead of ${o.id}`);
  return o;
};
var uO = (t63) => {
  switch (t63) {
    case "geojson":
      return kl;
    case "image":
      return _r;
    case "raster":
      return ho;
    case "raster-dem":
      return Rl;
    case "vector":
      return Dl;
    case "video":
      return Ol;
    case "canvas":
      return Bl;
  }
  return lO[t63];
};
$i();
$i();
function z1(t63, e) {
  let r3 = {};
  if (!e) return r3;
  for (let n of t63) {
    let i = n.layerIds.map((o) => e.getLayer(o)).filter(Boolean);
    if (i.length !== 0) {
      n.layers = i, n.stateDependentLayerIds && (n.stateDependentLayers = n.stateDependentLayerIds.map((o) => i.filter((a) => a.id === o)[0]));
      for (let o of i) r3[o.id] = n;
    }
  }
  return r3;
}
$i();
$i();
var nh = class {
  constructor(e) {
    this._stringToNumber = {}, this._numberToString = [];
    for (let r3 = 0; r3 < e.length; r3++) {
      let n = e[r3];
      this._stringToNumber[n] = r3, this._numberToString[r3] = n;
    }
  }
  encode(e) {
    return this._stringToNumber[e];
  }
  decode(e) {
    if (e >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${e} can't be >= this._numberToString.length ${this._numberToString.length}`);
    return this._numberToString[e];
  }
};
var U1 = s(bl(), 1);
var N1 = s(xy(), 1);
$i();
var xa = class {
  constructor(e, r3, n, i, o) {
    this.type = "Feature", this._vectorTileFeature = e, e._z = r3, e._x = n, e._y = i, this.properties = e.properties, this.id = o;
  }
  get geometry() {
    return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
  }
  set geometry(e) {
    this._geometry = e;
  }
  toJSON() {
    let e = { geometry: this.geometry };
    for (let r3 in this) r3 === "_geometry" || r3 === "_vectorTileFeature" || (e[r3] = this[r3]);
    return e;
  }
};
var Cy = class {
  constructor(e, r3) {
    this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new Qi(8192, 16, 0), this.grid3D = new Qi(8192, 16, 0), this.featureIndexArray = new nl(), this.promoteId = r3;
  }
  insert(e, r3, n, i, o, a) {
    let s3 = this.featureIndexArray.length;
    this.featureIndexArray.emplaceBack(n, i, o);
    let l = a ? this.grid3D : this.grid;
    for (let u3 = 0; u3 < r3.length; u3++) {
      let c = r3[u3], p = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      for (let h = 0; h < c.length; h++) {
        let f = c[h];
        p[0] = Math.min(p[0], f.x), p[1] = Math.min(p[1], f.y), p[2] = Math.max(p[2], f.x), p[3] = Math.max(p[3], f.y);
      }
      p[0] < 8192 && p[1] < 8192 && p[2] >= 0 && p[3] >= 0 && l.insert(s3, p[0], p[1], p[2], p[3]);
    }
  }
  loadVTLayers() {
    return this.vtLayers || (this.vtLayers = new U1.default.VectorTile(new N1.default(this.rawTileData)).layers, this.sourceLayerCoder = new nh(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
  }
  query(e, r3, n, i) {
    this.loadVTLayers();
    let o = e.params, a = 8192 / e.tileSize / e.scale, s3 = ii(o.filter), l = e.queryGeometry, u3 = e.queryPadding * a, c = Tt.fromPoints(l), p = this.grid.query(c.minX - u3, c.minY - u3, c.maxX + u3, c.maxY + u3), h = Tt.fromPoints(e.cameraQueryGeometry).expandBy(u3), f = this.grid3D.query(h.minX, h.minY, h.maxX, h.maxY, (x, b, v3, P) => Uv(e.cameraQueryGeometry, x - u3, b - u3, v3 + u3, P + u3));
    for (let x of f) p.push(x);
    p.sort(cO);
    let d = {}, g;
    for (let x = 0; x < p.length; x++) {
      let b = p[x];
      if (b === g) continue;
      g = b;
      let v3 = this.featureIndexArray.get(b), P = null;
      this.loadMatchingFeature(d, v3.bucketIndex, v3.sourceLayerIndex, v3.featureIndex, s3, o.layers, o.availableImages, r3, n, i, (w3, T, S) => (P || (P = er(w3)), T.queryIntersectsFeature({ queryGeometry: l, feature: w3, featureState: S, geometry: P, zoom: this.z, transform: e.transform, pixelsToTileUnits: a, pixelPosMatrix: e.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: e.getElevation })));
    }
    return d;
  }
  loadMatchingFeature(e, r3, n, i, o, a, s3, l, u3, c, p) {
    let h = this.bucketLayerIDs[r3];
    if (a && !h.some((b) => a.has(b))) return;
    let f = this.sourceLayerCoder.decode(n), g = this.vtLayers[f].feature(i);
    if (o.needGeometry) {
      let b = tr(g, true);
      if (!o.filter(new Te(this.tileID.overscaledZ), b, this.tileID.canonical)) return;
    } else if (!o.filter(new Te(this.tileID.overscaledZ), g)) return;
    let x = this.getId(g, f);
    for (let b = 0; b < h.length; b++) {
      let v3 = h[b];
      if (a && !a.has(v3)) continue;
      let P = l[v3];
      if (!P) continue;
      let w3 = {};
      x && c && (w3 = c.getState(P.sourceLayer || "_geojsonTileLayer", x));
      let T = Z({}, u3[v3]);
      T.paint = V1(T.paint, P.paint, g, w3, s3), T.layout = V1(T.layout, P.layout, g, w3, s3);
      let S = !p || p(g, P, w3);
      if (!S) continue;
      let C3 = new xa(g, this.z, this.x, this.y, x);
      C3.layer = T;
      let A = e[v3];
      A === void 0 && (A = e[v3] = []), A.push({ featureIndex: i, feature: C3, intersectionZ: S });
    }
  }
  lookupSymbolFeatures(e, r3, n, i, o, a, s3, l) {
    let u3 = {};
    this.loadVTLayers();
    let c = ii(o);
    for (let p of e) this.loadMatchingFeature(u3, n, i, p, c, a, s3, l, r3);
    return u3;
  }
  hasLayer(e) {
    for (let r3 of this.bucketLayerIDs) for (let n of r3) if (e === n) return true;
    return false;
  }
  getId(e, r3) {
    let n = e.id;
    if (this.promoteId) {
      let i = typeof this.promoteId == "string" ? this.promoteId : this.promoteId[r3];
      n = e.properties[i], typeof n == "boolean" && (n = Number(n)), n === void 0 && e.properties?.cluster && this.promoteId && (n = Number(e.properties.cluster_id));
    }
    return n;
  }
};
X("FeatureIndex", Cy, { omit: ["rawTileData", "sourceLayerCoder"] });
function V1(t63, e, r3, n, i) {
  return as(t63, (o, a) => {
    let s3 = e instanceof ai ? e.get(a) : null;
    return s3 && s3.evaluate ? s3.evaluate(r3, n, i) : s3;
  });
}
function cO(t63, e) {
  return e - t63;
}
$i();
$i();
var zl = "RTLPluginLoaded";
var Iy = class extends Ee {
  constructor() {
    super(...arguments);
    this.status = "unavailable";
    this.url = null;
    this.dispatcher = Ty();
  }
  _syncState(r3) {
    return this.status = r3, this.dispatcher.broadcast("SRPS", { pluginStatus: r3, pluginURL: this.url }).catch((n) => {
      throw this.status = "error", n;
    });
  }
  getRTLTextPluginStatus() {
    return this.status;
  }
  clearRTLTextPlugin() {
    this.status = "unavailable", this.url = null;
  }
  async setRTLTextPlugin(r3, n = false) {
    if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
    if (this.url = ae.resolveURL(r3), !this.url) throw new Error(`requested url ${r3} is invalid`);
    if (this.status === "unavailable") if (n) this.status = "deferred", this._syncState(this.status);
    else return this._requestImport();
    else if (this.status === "requested") return this._requestImport();
  }
  async _requestImport() {
    await this._syncState("loading"), this.status = "loaded", this.fire(new U(zl));
  }
  lazyLoad() {
    this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
  }
};
var My = null;
function ba() {
  return My || (My = new Iy()), My;
}
var pO = 3e4;
var _a = class {
  constructor(e, r3) {
    this.timeAdded = 0;
    this.fadeEndTime = 0;
    this.tileID = e, this.uid = oc(), this.uses = 0, this.tileSize = r3, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
  }
  registerFadeDuration(e) {
    let r3 = e + this.timeAdded;
    r3 < this.fadeEndTime || (this.fadeEndTime = r3);
  }
  wasRequested() {
    return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
  }
  clearTextures(e) {
    this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
  }
  loadVectorData(e, r3, n) {
    if (this.hasData() && this.unloadVectorData(), this.state = "loaded", !e) {
      this.collisionBoxArray = new Ks();
      return;
    }
    e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = z1(e.buckets, r3?.style), this.hasSymbolBuckets = false;
    for (let i in this.buckets) {
      let o = this.buckets[i];
      if (o instanceof $r) if (this.hasSymbolBuckets = true, n) o.justReloaded = true;
      else break;
    }
    if (this.hasRTLText = false, this.hasSymbolBuckets) for (let i in this.buckets) {
      let o = this.buckets[i];
      if (o instanceof $r && o.hasRTLText) {
        this.hasRTLText = true, ba().lazyLoad();
        break;
      }
    }
    this.queryPadding = 0;
    for (let i in this.buckets) {
      let o = this.buckets[i];
      this.queryPadding = Math.max(this.queryPadding, r3.style.getLayer(i).queryRadius(o));
    }
    e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage);
  }
  unloadVectorData() {
    for (let e in this.buckets) this.buckets[e].destroy();
    this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
  }
  getBucket(e) {
    return this.buckets[e.id];
  }
  upload(e) {
    for (let n in this.buckets) {
      let i = this.buckets[n];
      i.uploadPending() && i.upload(e);
    }
    let r3 = e.gl;
    this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new Se(e, this.imageAtlas.image, r3.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new Se(e, this.glyphAtlasImage, r3.ALPHA), this.glyphAtlasImage = null);
  }
  prepare(e) {
    this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
  }
  queryRenderedFeatures(e, r3, n, i, o, a, s3, l, u3, c, p) {
    return !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData ? {} : this.latestFeatureIndex.query({ queryGeometry: i, cameraQueryGeometry: o, scale: a, tileSize: this.tileSize, pixelPosMatrix: c, transform: l, params: s3, queryPadding: this.queryPadding * u3, getElevation: p }, e, r3, n);
  }
  querySourceFeatures(e, r3) {
    let n = this.latestFeatureIndex;
    if (!n || !n.rawTileData) return;
    let i = n.loadVTLayers(), o = r3 && r3.sourceLayer ? r3.sourceLayer : "", a = i._geojsonTileLayer || i[o];
    if (!a) return;
    let s3 = ii(r3 && r3.filter), { z: l, x: u3, y: c } = this.tileID.canonical, p = { z: l, x: u3, y: c };
    for (let h = 0; h < a.length; h++) {
      let f = a.feature(h);
      if (s3.needGeometry) {
        let x = tr(f, true);
        if (!s3.filter(new Te(this.tileID.overscaledZ), x, this.tileID.canonical)) continue;
      } else if (!s3.filter(new Te(this.tileID.overscaledZ), f)) continue;
      let d = n.getId(f, o), g = new xa(f, l, u3, c, d);
      g.tile = p, e.push(g);
    }
  }
  hasData() {
    return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
  }
  patternsLoaded() {
    return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
  }
  setExpiryData(e) {
    let r3 = this.expirationTime;
    if (e.cacheControl) {
      let n = Ub(e.cacheControl);
      n["max-age"] && (this.expirationTime = Date.now() + n["max-age"] * 1e3);
    } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
    if (this.expirationTime) {
      let n = Date.now(), i = false;
      if (this.expirationTime > n) i = false;
      else if (!r3) i = true;
      else if (this.expirationTime < r3) i = true;
      else {
        let o = this.expirationTime - r3;
        o ? this.expirationTime = n + Math.max(o, pO) : i = true;
      }
      i ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
    }
  }
  getExpiryTimeout() {
    if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
  }
  setFeatureState(e, r3) {
    if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
    let n = this.latestFeatureIndex.loadVTLayers();
    for (let i in this.buckets) {
      if (!r3.style.hasLayer(i)) continue;
      let o = this.buckets[i], a = o.layers[0].sourceLayer || "_geojsonTileLayer", s3 = n[a], l = e[a];
      if (!s3 || !l || Object.keys(l).length === 0) continue;
      o.update(l, s3, this.imageAtlas && this.imageAtlas.patternPositions || {});
      let u3 = r3 && r3.style && r3.style.getLayer(i);
      u3 && (this.queryPadding = Math.max(this.queryPadding, u3.queryRadius(o)));
    }
  }
  holdingForFade() {
    return this.symbolFadeHoldUntil !== void 0;
  }
  symbolFadeFinished() {
    return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < ae.now();
  }
  clearFadeHold() {
    this.symbolFadeHoldUntil = void 0;
  }
  setHoldDuration(e) {
    this.symbolFadeHoldUntil = ae.now() + e;
  }
  setDependencies(e, r3) {
    let n = {};
    for (let i of r3) n[i] = true;
    this.dependencies[e] = n;
  }
  hasDependency(e, r3) {
    for (let n of e) {
      let i = this.dependencies[n];
      if (i) {
        for (let o of r3) if (i[o]) return true;
      }
    }
    return false;
  }
};
$i();
var ih = class {
  constructor(e, r3) {
    this.max = e, this.onRemove = r3, this.reset();
  }
  reset() {
    for (let e in this.data) for (let r3 of this.data[e]) r3.timeout && clearTimeout(r3.timeout), this.onRemove(r3.value);
    return this.data = {}, this.order = [], this;
  }
  add(e, r3, n) {
    let i = e.wrapped().key;
    this.data[i] === void 0 && (this.data[i] = []);
    let o = { value: r3, timeout: void 0 };
    if (n !== void 0 && (o.timeout = setTimeout(() => {
      this.remove(e, o);
    }, n)), this.data[i].push(o), this.order.push(i), this.order.length > this.max) {
      let a = this._getAndRemoveByKey(this.order[0]);
      a && this.onRemove(a);
    }
    return this;
  }
  has(e) {
    return e.wrapped().key in this.data;
  }
  getAndRemove(e) {
    return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
  }
  _getAndRemoveByKey(e) {
    let r3 = this.data[e].shift();
    return r3.timeout && clearTimeout(r3.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), r3.value;
  }
  getByKey(e) {
    let r3 = this.data[e];
    return r3 ? r3[0].value : null;
  }
  get(e) {
    return this.has(e) ? this.data[e.wrapped().key][0].value : null;
  }
  remove(e, r3) {
    if (!this.has(e)) return this;
    let n = e.wrapped().key, i = r3 === void 0 ? 0 : this.data[n].indexOf(r3), o = this.data[n][i];
    return this.data[n].splice(i, 1), o.timeout && clearTimeout(o.timeout), this.data[n].length === 0 && delete this.data[n], this.onRemove(o.value), this.order.splice(this.order.indexOf(n), 1), this;
  }
  setMaxSize(e) {
    for (this.max = e; this.order.length > this.max; ) {
      let r3 = this._getAndRemoveByKey(this.order[0]);
      r3 && this.onRemove(r3);
    }
    return this;
  }
  filter(e) {
    let r3 = [];
    for (let n in this.data) for (let i of this.data[n]) e(i.value) || r3.push(i);
    for (let n of r3) this.remove(n.value.tileID, n);
  }
};
var Ey = s(fe(), 1);
$i();
var oh = class {
  constructor() {
    this.state = {}, this.stateChanges = {}, this.deletedStates = {};
  }
  updateState(e, r3, n) {
    let i = String(r3);
    if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][i] = this.stateChanges[e][i] || {}, Z(this.stateChanges[e][i], n), this.deletedStates[e] === null) {
      this.deletedStates[e] = {};
      for (let o in this.state[e]) o !== i && (this.deletedStates[e][o] = null);
    } else if (this.deletedStates[e] && this.deletedStates[e][i] === null) {
      this.deletedStates[e][i] = {};
      for (let a in this.state[e][i]) n[a] || (this.deletedStates[e][i][a] = null);
    } else for (let a in n) this.deletedStates[e] && this.deletedStates[e][i] && this.deletedStates[e][i][a] === null && delete this.deletedStates[e][i][a];
  }
  removeFeatureState(e, r3, n) {
    if (this.deletedStates[e] === null) return;
    let o = String(r3);
    if (this.deletedStates[e] = this.deletedStates[e] || {}, n && r3 !== void 0) this.deletedStates[e][o] !== null && (this.deletedStates[e][o] = this.deletedStates[e][o] || {}, this.deletedStates[e][o][n] = null);
    else if (r3 !== void 0) if (this.stateChanges[e] && this.stateChanges[e][o]) {
      this.deletedStates[e][o] = {};
      for (n in this.stateChanges[e][o]) this.deletedStates[e][o][n] = null;
    } else this.deletedStates[e][o] = null;
    else this.deletedStates[e] = null;
  }
  getState(e, r3) {
    let n = String(r3), i = this.state[e] || {}, o = this.stateChanges[e] || {}, a = Z({}, i[n], o[n]);
    if (this.deletedStates[e] === null) return {};
    if (this.deletedStates[e]) {
      let s3 = this.deletedStates[e][r3];
      if (s3 === null) return {};
      for (let l in s3) delete a[l];
    }
    return a;
  }
  initializeTileState(e, r3) {
    e.setFeatureState(this.state, r3);
  }
  coalesceChanges(e, r3) {
    let n = {};
    for (let i in this.stateChanges) {
      this.state[i] = this.state[i] || {};
      let o = {};
      for (let a in this.stateChanges[i]) this.state[i][a] || (this.state[i][a] = {}), Z(this.state[i][a], this.stateChanges[i][a]), o[a] = this.state[i][a];
      n[i] = o;
    }
    for (let i in this.deletedStates) {
      this.state[i] = this.state[i] || {};
      let o = {};
      if (this.deletedStates[i] === null) for (let a in this.state[i]) o[a] = {}, this.state[i][a] = {};
      else for (let a in this.deletedStates[i]) {
        if (this.deletedStates[i][a] === null) this.state[i][a] = {};
        else for (let l of Object.keys(this.deletedStates[i][a])) delete this.state[i][a][l];
        o[a] = this.state[i][a];
      }
      n[i] = n[i] || {}, Z(n[i], o);
    }
    if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(n).length !== 0) for (let i in e) e[i].setFeatureState(n, r3);
  }
};
$i();
$i();
var G1 = s(fe(), 1);
var gi = 89.25;
function j1(t63, e, r3) {
  let n = 1 / (1 << r3.z);
  return new xe(t63 / 8192 * n + r3.x * n, e / 8192 * n + r3.y * n);
}
function vr(t63, e) {
  let r3 = ce(e.lat, -Nt2, Nt2);
  return new G1.default(Dn(e.lng) * t63, Kr(r3) * t63);
}
function xi(t63, e) {
  return new xe(e.x / t63, e.y / t63).toLngLat();
}
function va(t63) {
  return t63.cameraToCenterDistance * Math.min(Math.tan(Ve(90 - t63.pitch)) * 0.85, Math.tan(Ve(gi - t63.pitch)));
}
function ah(t63, e) {
  let r3 = t63.canonical, n = e / lt(r3.z), i = r3.x + Math.pow(2, r3.z) * t63.wrap, o = B.identity(new Float64Array(16));
  return B.translate(o, o, [i * n, r3.y * n, 0]), B.scale(o, o, [n / 8192, n / 8192, 1]), o;
}
function Vl(t63, e, r3, n, i) {
  let o = xe.fromLngLat(t63, e), a = dn(1, t63.lat), s3 = i * a, l = s3 * Math.cos(Ve(r3)), u3 = Math.sqrt(s3 * s3 - l * l), c = u3 * Math.sin(Ve(-n)), p = u3 * Math.cos(Ve(-n));
  return new xe(o.x + c, o.y + p, o.z + l);
}
$i();
function hO(t63, e, r3) {
  let n = e.intersectsFrustum(t63);
  if (!r3 || n === 0) return n;
  let i = e.intersectsPlane(r3);
  return i === 0 ? 0 : n === 2 && i === 2 ? 2 : 1;
}
function H1(t63, e, r3) {
  let i = 0, o = (r3 - e) / 10;
  for (let a = 0; a < 10; a++) {
    let s3 = e + (a + 0.5) / 10 * (r3 - e);
    i += o * Math.pow(Math.cos(s3), t63);
  }
  return i;
}
function sh(t63, e) {
  return function(r3, n, i, o, a) {
    let s3 = 2 * ((t63 - 1) / rt(Math.cos(Ve(gi - a)) / Math.cos(Ve(gi))) - 1), l = Math.acos(i / o), u3 = 2 * H1(s3 - 1, 0, Ve(a / 2)), c = Math.min(Ve(gi), l + Ve(a / 2)), p = Math.min(c, l - Ve(a / 2)), h = H1(s3 - 1, p, c), f = Math.atan(n / i), d = Math.hypot(n, i), g = r3;
    return g = g + rt(o / d / Math.max(0.5, Math.cos(Ve(a / 2)))), g += s3 * rt(Math.cos(f)) / 2, g -= rt(Math.max(1, h / u3 / e)) / 2, g;
  };
}
var fO = 9.314;
var mO = 3;
var dO = sh(fO, mO);
function mo(t63, e) {
  let r3 = (e.roundZoom ? Math.round : Math.floor)(t63.zoom + rt(t63.tileSize / e.tileSize));
  return Math.max(0, r3);
}
function bi(t63, e) {
  let r3 = t63.getCameraFrustum(), n = t63.getClippingPlane(), i = t63.screenPointToMercatorCoordinate(t63.getCameraPoint()), o = xe.fromLngLat(t63.center, t63.elevation);
  i.z = o.z + Math.cos(t63.pitchInRadians) * t63.cameraToCenterDistance / t63.worldSize;
  let a = t63.getCoveringTilesDetailsProvider(), s3 = a.allowVariableZoom(t63, e), l = mo(t63, e), u3 = e.minzoom || 0, c = e.maxzoom !== void 0 ? e.maxzoom : t63.maxZoom, p = Math.min(Math.max(0, l), c), h = Math.pow(2, p), f = [h * i.x, h * i.y, 0], d = [h * o.x, h * o.y, 0], g = Math.hypot(o.x - i.x, o.y - i.y), x = Math.abs(o.z - i.z), b = Math.hypot(g, x), v3 = (T) => ({ zoom: 0, x: 0, y: 0, wrap: T, fullyVisible: false }), P = [], w3 = [];
  if (t63.renderWorldCopies && a.allowWorldCopies()) for (let T = 1; T <= 3; T++) P.push(v3(-T)), P.push(v3(T));
  for (P.push(v3(0)); P.length > 0; ) {
    let T = P.pop(), S = T.x, C3 = T.y, A = T.fullyVisible, E = { x: S, y: C3, z: T.zoom }, L = a.getTileBoundingVolume(E, T.wrap, t63.elevation, e);
    if (!A) {
      let I = hO(r3, L, n);
      if (I === 0) continue;
      A = I === 2;
    }
    let F = a.distanceToTile2d(i.x, i.y, E, L), O = l;
    s3 && (O = (e.calculateTileZoom || dO)(t63.zoom + rt(t63.tileSize / e.tileSize), F, x, b, t63.fov)), O = (e.roundZoom ? Math.round : Math.floor)(O), O = Math.max(0, O);
    let z = Math.min(O, c);
    if (T.wrap = a.getWrap(o, E, T.wrap), T.zoom >= z) {
      if (T.zoom < u3) continue;
      let I = p - T.zoom, R = f[0] - 0.5 - (S << I), H = f[1] - 0.5 - (C3 << I), W = e.reparseOverscaled ? Math.max(T.zoom, O) : T.zoom;
      w3.push({ tileID: new Ye2(T.zoom === c ? W : T.zoom, T.wrap, T.zoom, S, C3), distanceSq: wt.sqrLen([d[0] - 0.5 - S, d[1] - 0.5 - C3]), tileDistanceToCamera: Math.sqrt(R * R + H * H) });
      continue;
    }
    for (let I = 0; I < 4; I++) {
      let R = (S << 1) + I % 2, H = (C3 << 1) + (I >> 1), W = T.zoom + 1;
      P.push({ zoom: W, x: R, y: H, wrap: T.wrap, fullyVisible: A });
    }
  }
  return w3.sort((T, S) => T.distanceSq - S.distanceSq).map((T) => T.tileID);
}
$i();
var Ay = s(fe(), 1);
var Z1 = Tt.fromPoints([new Ay.default(0, 0), new Ay.default(8192, 8192)]);
var Rn = class t50 extends Ee {
  constructor(e, r3, n) {
    super(), this.id = e, this.dispatcher = n, this.on("data", (i) => this._dataHandler(i)), this.on("dataloading", () => {
      this._sourceErrored = false;
    }), this.on("error", () => {
      this._sourceErrored = this._source.loaded();
    }), this._source = B1(e, r3, n, this), this._tiles = {}, this._cache = new ih(0, (i) => this._unloadTile(i)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new oh(), this._didEmitContent = false, this._updated = false;
  }
  onAdd(e) {
    this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
  }
  onRemove(e) {
    this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
  }
  loaded() {
    if (this._sourceErrored) return true;
    if (!this._sourceLoaded || !this._source.loaded()) return false;
    if ((this.used !== void 0 || this.usedForTerrain !== void 0) && !this.used && !this.usedForTerrain) return true;
    if (!this._updated) return false;
    for (let e in this._tiles) {
      let r3 = this._tiles[e];
      if (r3.state !== "loaded" && r3.state !== "errored") return false;
    }
    return true;
  }
  getSource() {
    return this._source;
  }
  pause() {
    this._paused = true;
  }
  resume() {
    if (!this._paused) return;
    let e = this._shouldReloadOnResume;
    this._paused = false, this._shouldReloadOnResume = false, e && this.reload(), this.transform && this.update(this.transform, this.terrain);
  }
  async _loadTile(e, r3, n) {
    try {
      await this._source.loadTile(e), this._tileLoaded(e, r3, n);
    } catch (i) {
      e.state = "errored", i.status !== 404 ? this._source.fire(new Q(i, { tile: e })) : this.update(this.transform, this.terrain);
    }
  }
  _unloadTile(e) {
    this._source.unloadTile && this._source.unloadTile(e);
  }
  _abortTile(e) {
    this._source.abortTile && this._source.abortTile(e), this._source.fire(new U("dataabort", { tile: e, coord: e.tileID, dataType: "source" }));
  }
  serialize() {
    return this._source.serialize();
  }
  prepare(e) {
    this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
    for (let r3 in this._tiles) {
      let n = this._tiles[r3];
      n.upload(e), n.prepare(this.map.style.imageManager);
    }
  }
  getIds() {
    return Object.values(this._tiles).map((e) => e.tileID).sort(q1).map((e) => e.key);
  }
  getRenderableIds(e) {
    let r3 = [];
    for (let n in this._tiles) this._isIdRenderable(n, e) && r3.push(this._tiles[n]);
    return e ? r3.sort((n, i) => {
      let o = n.tileID, a = i.tileID, s3 = new Ey.default(o.canonical.x, o.canonical.y)._rotate(-this.transform.bearingInRadians), l = new Ey.default(a.canonical.x, a.canonical.y)._rotate(-this.transform.bearingInRadians);
      return o.overscaledZ - a.overscaledZ || l.y - s3.y || l.x - s3.x;
    }).map((n) => n.tileID.key) : r3.map((n) => n.tileID).sort(q1).map((n) => n.key);
  }
  hasRenderableParent(e) {
    let r3 = this.findLoadedParent(e, 0);
    return r3 ? this._isIdRenderable(r3.tileID.key) : false;
  }
  _isIdRenderable(e, r3) {
    return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (r3 || !this._tiles[e].holdingForFade());
  }
  reload(e) {
    if (this._paused) {
      this._shouldReloadOnResume = true;
      return;
    }
    this._cache.reset();
    for (let r3 in this._tiles) e ? this._reloadTile(r3, "expired") : this._tiles[r3].state !== "errored" && this._reloadTile(r3, "reloading");
  }
  async _reloadTile(e, r3) {
    let n = this._tiles[e];
    n && (n.state !== "loading" && (n.state = r3), await this._loadTile(n, e, r3));
  }
  _tileLoaded(e, r3, n) {
    e.timeAdded = ae.now(), n === "expired" && (e.refreshedUponExpiration = true), this._setTileReloadTimer(r3, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new U("data", { dataType: "source", tile: e, coord: e.tileID }));
  }
  _backfillDEM(e) {
    let r3 = this.getRenderableIds();
    for (let i = 0; i < r3.length; i++) {
      let o = r3[i];
      if (e.neighboringTiles && e.neighboringTiles[o]) {
        let a = this.getTileByID(o);
        n(e, a), n(a, e);
      }
    }
    function n(i, o) {
      i.needsHillshadePrepare = true, i.needsTerrainPrepare = true;
      let a = o.tileID.canonical.x - i.tileID.canonical.x, s3 = o.tileID.canonical.y - i.tileID.canonical.y, l = Math.pow(2, i.tileID.canonical.z), u3 = o.tileID.key;
      a === 0 && s3 === 0 || Math.abs(s3) > 1 || (Math.abs(a) > 1 && (Math.abs(a + l) === 1 ? a += l : Math.abs(a - l) === 1 && (a -= l)), !(!o.dem || !i.dem) && (i.dem.backfillBorder(o.dem, a, s3), i.neighboringTiles && i.neighboringTiles[u3] && (i.neighboringTiles[u3].backfilled = true)));
    }
  }
  getTile(e) {
    return this.getTileByID(e.key);
  }
  getTileByID(e) {
    return this._tiles[e];
  }
  _retainLoadedChildren(e, r3, n, i) {
    for (let o in this._tiles) {
      let a = this._tiles[o];
      if (i[o] || !a.hasData() || a.tileID.overscaledZ <= r3 || a.tileID.overscaledZ > n) continue;
      let s3 = a.tileID;
      for (; a && a.tileID.overscaledZ > r3 + 1; ) {
        let u3 = a.tileID.scaledTo(a.tileID.overscaledZ - 1);
        a = this._tiles[u3.key], a && a.hasData() && (s3 = u3);
      }
      let l = s3;
      for (; l.overscaledZ > r3; ) if (l = l.scaledTo(l.overscaledZ - 1), e[l.key] || e[l.canonical.key]) {
        i[s3.key] = s3;
        break;
      }
    }
  }
  findLoadedParent(e, r3) {
    if (e.key in this._loadedParentTiles) {
      let n = this._loadedParentTiles[e.key];
      return n && n.tileID.overscaledZ >= r3 ? n : null;
    }
    for (let n = e.overscaledZ - 1; n >= r3; n--) {
      let i = e.scaledTo(n), o = this._getLoadedTile(i);
      if (o) return o;
    }
  }
  findLoadedSibling(e) {
    return this._getLoadedTile(e);
  }
  _getLoadedTile(e) {
    let r3 = this._tiles[e.key];
    return r3 && r3.hasData() ? r3 : this._cache.getByKey(e.wrapped().key);
  }
  updateCacheSize(e) {
    let r3 = Math.ceil(e.width / this._source.tileSize) + 1, n = Math.ceil(e.height / this._source.tileSize) + 1, i = r3 * n, o = this._maxTileCacheZoomLevels === null ? $t.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels, a = Math.floor(i * o), s3 = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, a) : a;
    this._cache.setMaxSize(s3);
  }
  handleWrapJump(e) {
    let r3 = this._prevLng === void 0 ? e : this._prevLng, i = (e - r3) / 360, o = Math.round(i);
    if (this._prevLng = e, o) {
      let a = {};
      for (let s3 in this._tiles) {
        let l = this._tiles[s3];
        l.tileID = l.tileID.unwrapTo(l.tileID.wrap + o), a[l.tileID.key] = l;
      }
      this._tiles = a;
      for (let s3 in this._timers) clearTimeout(this._timers[s3]), delete this._timers[s3];
      for (let s3 in this._tiles) {
        let l = this._tiles[s3];
        this._setTileReloadTimer(s3, l);
      }
    }
  }
  _updateCoveredAndRetainedTiles(e, r3, n, i, o, a) {
    let s3 = {}, l = {}, u3 = Object.keys(e), c = ae.now();
    for (let p of u3) {
      let h = e[p], f = this._tiles[p];
      if (!f || f.fadeEndTime !== 0 && f.fadeEndTime <= c) continue;
      let d = this.findLoadedParent(h, r3), g = this.findLoadedSibling(h), x = d || g || null;
      x && (this._addTile(x.tileID), s3[x.tileID.key] = x.tileID), l[p] = h;
    }
    this._retainLoadedChildren(l, i, n, e);
    for (let p in s3) e[p] || (this._coveredTiles[p] = true, e[p] = s3[p]);
    if (a) {
      let p = {}, h = {};
      for (let f of o) this._tiles[f.key].hasData() ? p[f.key] = f : h[f.key] = f;
      for (let f in h) {
        let d = h[f].children(this._source.maxzoom);
        this._tiles[d[0].key] && this._tiles[d[1].key] && this._tiles[d[2].key] && this._tiles[d[3].key] && (p[d[0].key] = e[d[0].key] = d[0], p[d[1].key] = e[d[1].key] = d[1], p[d[2].key] = e[d[2].key] = d[2], p[d[3].key] = e[d[3].key] = d[3], delete h[f]);
      }
      for (let f in h) {
        let d = h[f], g = this.findLoadedParent(d, this._source.minzoom), x = this.findLoadedSibling(d), b = g || x || null;
        if (b) {
          p[b.tileID.key] = e[b.tileID.key] = b.tileID;
          for (let v3 in p) p[v3].isChildOf(b.tileID) && delete p[v3];
        }
      }
      for (let f in this._tiles) p[f] || (this._coveredTiles[f] = true);
    }
  }
  update(e, r3) {
    if (!this._sourceLoaded || this._paused) return;
    this.transform = e, this.terrain = r3, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {};
    let n;
    !this.used && !this.usedForTerrain ? n = [] : this._source.tileID ? n = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((c) => new Ye2(c.canonical.z, c.wrap, c.canonical.z, c.canonical.x, c.canonical.y)) : (n = bi(e, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this.usedForTerrain ? false : this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: r3, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (n = n.filter((c) => this._source.hasTile(c))));
    let i = mo(e, this._source), o = Math.max(i - t50.maxOverzooming, this._source.minzoom), a = Math.max(i + t50.maxUnderzooming, this._source.minzoom);
    if (this.usedForTerrain) {
      let c = {};
      for (let p of n) if (p.canonical.z > this._source.minzoom) {
        let h = p.scaledTo(p.canonical.z - 1);
        c[h.key] = h;
        let f = p.scaledTo(Math.max(this._source.minzoom, Math.min(p.canonical.z, 5)));
        c[f.key] = f;
      }
      n = n.concat(Object.values(c));
    }
    let s3 = n.length === 0 && !this._updated && this._didEmitContent;
    this._updated = true, s3 && this.fire(new U("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
    let l = this._updateRetainedTiles(n, i);
    Y1(this._source.type) && this._updateCoveredAndRetainedTiles(l, o, a, i, n, r3);
    for (let c in l) this._tiles[c].clearFadeHold();
    let u3 = Fb(this._tiles, l);
    for (let c of u3) {
      let p = this._tiles[c];
      p.hasSymbolBuckets && !p.holdingForFade() ? p.setHoldDuration(this.map._fadeDuration) : (!p.hasSymbolBuckets || p.symbolFadeFinished()) && this._removeTile(c);
    }
    this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
  }
  releaseSymbolFadeTiles() {
    for (let e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e);
  }
  _updateRetainedTiles(e, r3) {
    let n = {}, i = {}, o = Math.max(r3 - t50.maxOverzooming, this._source.minzoom), a = Math.max(r3 + t50.maxUnderzooming, this._source.minzoom), s3 = {};
    for (let l of e) {
      let u3 = this._addTile(l);
      n[l.key] = l, !u3.hasData() && r3 < this._source.maxzoom && (s3[l.key] = l);
    }
    this._retainLoadedChildren(s3, r3, a, n);
    for (let l of e) {
      let u3 = this._tiles[l.key];
      if (u3.hasData()) continue;
      if (r3 + 1 > this._source.maxzoom) {
        let p = l.children(this._source.maxzoom)[0], h = this.getTile(p);
        if (h && h.hasData()) {
          n[p.key] = p;
          continue;
        }
      } else {
        let p = l.children(this._source.maxzoom);
        if (n[p[0].key] && n[p[1].key] && n[p[2].key] && n[p[3].key]) continue;
      }
      let c = u3.wasRequested();
      for (let p = l.overscaledZ - 1; p >= o; --p) {
        let h = l.scaledTo(p);
        if (i[h.key]) break;
        if (i[h.key] = true, u3 = this.getTile(h), !u3 && c && (u3 = this._addTile(h)), u3) {
          let f = u3.hasData();
          if ((f || !this.map?.cancelPendingTileRequestsWhileZooming || c) && (n[h.key] = h), c = u3.wasRequested(), f) break;
        }
      }
    }
    return n;
  }
  _updateLoadedParentTileCache() {
    this._loadedParentTiles = {};
    for (let e in this._tiles) {
      let r3 = [], n, i = this._tiles[e].tileID;
      for (; i.overscaledZ > 0; ) {
        if (i.key in this._loadedParentTiles) {
          n = this._loadedParentTiles[i.key];
          break;
        }
        r3.push(i.key);
        let o = i.scaledTo(i.overscaledZ - 1);
        if (n = this._getLoadedTile(o), n) break;
        i = o;
      }
      for (let o of r3) this._loadedParentTiles[o] = n;
    }
  }
  _updateLoadedSiblingTileCache() {
    this._loadedSiblingTiles = {};
    for (let e in this._tiles) {
      let r3 = this._tiles[e].tileID, n = this._getLoadedTile(r3);
      this._loadedSiblingTiles[r3.key] = n;
    }
  }
  _addTile(e) {
    let r3 = this._tiles[e.key];
    if (r3) return r3;
    r3 = this._cache.getAndRemove(e), r3 && (this._setTileReloadTimer(e.key, r3), r3.tileID = e, this._state.initializeTileState(r3, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, r3)));
    let n = r3;
    return r3 || (r3 = new _a(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(r3, e.key, r3.state)), r3.uses++, this._tiles[e.key] = r3, n || this._source.fire(new U("dataloading", { tile: r3, coord: r3.tileID, dataType: "source" })), r3;
  }
  _setTileReloadTimer(e, r3) {
    e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
    let n = r3.getExpiryTimeout();
    n && (this._timers[e] = setTimeout(() => {
      this._reloadTile(e, "expired"), delete this._timers[e];
    }, n));
  }
  refreshTiles(e) {
    for (let r3 in this._tiles) !this._isIdRenderable(r3) && this._tiles[r3].state != "errored" || e.some((n) => n.equals(this._tiles[r3].tileID.canonical)) && this._reloadTile(r3, "expired");
  }
  _removeTile(e) {
    let r3 = this._tiles[e];
    r3 && (r3.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), !(r3.uses > 0) && (r3.hasData() && r3.state !== "reloading" ? this._cache.add(r3.tileID, r3, r3.getExpiryTimeout()) : (r3.aborted = true, this._abortTile(r3), this._unloadTile(r3))));
  }
  _dataHandler(e) {
    let r3 = e.sourceDataType;
    e.dataType === "source" && r3 === "metadata" && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && e.dataType === "source" && r3 === "content" && (this.reload(e.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
  }
  clearTiles() {
    this._shouldReloadOnResume = false, this._paused = false;
    for (let e in this._tiles) this._removeTile(e);
    this._cache.reset();
  }
  tilesIn(e, r3, n) {
    let i = [], o = this.transform;
    if (!o) return i;
    let a = o.getCoveringTilesDetailsProvider().allowWorldCopies(), s3 = n ? o.getCameraQueryGeometry(e) : e, l = (f) => o.screenPointToMercatorCoordinate(f, this.terrain), u3 = this.transformBbox(e, l, !a), c = this.transformBbox(s3, l, !a), p = this.getIds(), h = Tt.fromPoints(c);
    for (let f = 0; f < p.length; f++) {
      let d = this._tiles[p[f]];
      if (d.holdingForFade()) continue;
      let g = a ? [d.tileID] : [d.tileID.unwrapTo(-1), d.tileID.unwrapTo(0)], x = Math.pow(2, o.zoom - d.tileID.overscaledZ), b = r3 * d.queryPadding * 8192 / d.tileSize / x;
      for (let v3 of g) {
        let P = h.map((w3) => v3.getTilePoint(new xe(w3.x, w3.y)));
        if (P.expandBy(b), P.intersects(Z1)) {
          let w3 = u3.map((S) => v3.getTilePoint(S)), T = c.map((S) => v3.getTilePoint(S));
          i.push({ tile: d, tileID: a ? v3 : v3.unwrapTo(0), queryGeometry: w3, cameraQueryGeometry: T, scale: x });
        }
      }
    }
    return i;
  }
  transformBbox(e, r3, n) {
    let i = e.map(r3);
    if (n) {
      let o = Tt.fromPoints(e);
      o.shrinkBy(Math.min(o.width(), o.height()) * 1e-3);
      let a = o.map(r3);
      Tt.fromPoints(i).covers(a) || (i = i.map((l) => l.x > 0.5 ? new xe(l.x - 1, l.y, l.z) : l));
    }
    return i;
  }
  getVisibleCoordinates(e) {
    let r3 = this.getRenderableIds(e).map((n) => this._tiles[n].tileID);
    return this.transform && this.transform.populateCache(r3), r3;
  }
  hasTransition() {
    if (this._source.hasTransition()) return true;
    if (Y1(this._source.type)) {
      let e = ae.now();
      for (let r3 in this._tiles) if (this._tiles[r3].fadeEndTime >= e) return true;
    }
    return false;
  }
  setFeatureState(e, r3, n) {
    e = e || "_geojsonTileLayer", this._state.updateState(e, r3, n);
  }
  removeFeatureState(e, r3, n) {
    e = e || "_geojsonTileLayer", this._state.removeFeatureState(e, r3, n);
  }
  getFeatureState(e, r3) {
    return e = e || "_geojsonTileLayer", this._state.getState(e, r3);
  }
  setDependencies(e, r3, n) {
    let i = this._tiles[e];
    i && i.setDependencies(r3, n);
  }
  reloadTilesForDependencies(e, r3) {
    for (let n in this._tiles) this._tiles[n].hasDependency(e, r3) && this._reloadTile(n, "reloading");
    this._cache.filter((n) => !n.hasDependency(e, r3));
  }
};
Rn.maxOverzooming = 10;
Rn.maxUnderzooming = 3;
function q1(t63, e) {
  let r3 = Math.abs(t63.wrap * 2) - +(t63.wrap < 0), n = Math.abs(e.wrap * 2) - +(e.wrap < 0);
  return t63.overscaledZ - e.overscaledZ || n - r3 || e.canonical.y - t63.canonical.y || e.canonical.x - t63.canonical.x;
}
function Y1(t63) {
  return t63 === "raster" || t63 === "image" || t63 === "video";
}
$i();
$i();
$i();
var Jr = s(fe(), 1);
$i();
var kn = s(fe(), 1);
function Ly(t63, e, r3, n, i) {
  let o = [];
  for (let a = 0; a < t63.length; a++) {
    let s3 = t63[a], l;
    for (let u3 = 0; u3 < s3.length - 1; u3++) {
      let c = s3[u3], p = s3[u3 + 1];
      c.x < e && p.x < e || (c.x < e ? c = new kn.default(e, c.y + (p.y - c.y) * ((e - c.x) / (p.x - c.x)))._round() : p.x < e && (p = new kn.default(e, c.y + (p.y - c.y) * ((e - c.x) / (p.x - c.x)))._round()), !(c.y < r3 && p.y < r3) && (c.y < r3 ? c = new kn.default(c.x + (p.x - c.x) * ((r3 - c.y) / (p.y - c.y)), r3)._round() : p.y < r3 && (p = new kn.default(c.x + (p.x - c.x) * ((r3 - c.y) / (p.y - c.y)), r3)._round()), !(c.x >= n && p.x >= n) && (c.x >= n ? c = new kn.default(n, c.y + (p.y - c.y) * ((n - c.x) / (p.x - c.x)))._round() : p.x >= n && (p = new kn.default(n, c.y + (p.y - c.y) * ((n - c.x) / (p.x - c.x)))._round()), !(c.y >= i && p.y >= i) && (c.y >= i ? c = new kn.default(c.x + (p.x - c.x) * ((i - c.y) / (p.y - c.y)), i)._round() : p.y >= i && (p = new kn.default(c.x + (p.x - c.x) * ((i - c.y) / (p.y - c.y)), i)._round()), (!l || !c.equals(l[l.length - 1])) && (l = [c], o.push(l)), l.push(p)))));
    }
  }
  return o;
}
$i();
var lh = class {
  constructor(e, r3) {
    this.reset(e, r3);
  }
  reset(e, r3) {
    this.points = e || [], this._distances = [0];
    for (let n = 1; n < this.points.length; n++) this._distances[n] = this._distances[n - 1] + this.points[n].dist(this.points[n - 1]);
    this.length = this._distances[this._distances.length - 1], this.padding = Math.min(r3 || 0, this.length * 0.5), this.paddedLength = this.length - this.padding * 2;
  }
  lerp(e) {
    if (this.points.length === 1) return this.points[0];
    e = ce(e, 0, 1);
    let r3 = 1, n = this._distances[r3], i = e * this.paddedLength + this.padding;
    for (; n < i && r3 < this._distances.length; ) n = this._distances[++r3];
    let o = r3 - 1, a = this._distances[o], s3 = n - a, l = s3 > 0 ? (i - a) / s3 : 0;
    return this.points[o].mult(1 - l).add(this.points[r3].mult(l));
  }
};
$i();
function uh(t63, e) {
  let r3 = true;
  return t63 === "always" || (t63 === "never" || e === "never") && (r3 = false), r3;
}
var Ul = class {
  constructor(e, r3, n) {
    let i = this.boxCells = [], o = this.circleCells = [];
    this.xCellCount = Math.ceil(e / n), this.yCellCount = Math.ceil(r3 / n);
    for (let a = 0; a < this.xCellCount * this.yCellCount; a++) i.push([]), o.push([]);
    this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = r3, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / r3, this.boxUid = 0, this.circleUid = 0;
  }
  keysLength() {
    return this.boxKeys.length + this.circleKeys.length;
  }
  insert(e, r3, n, i, o) {
    this._forEachCell(r3, n, i, o, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(r3), this.bboxes.push(n), this.bboxes.push(i), this.bboxes.push(o);
  }
  insertCircle(e, r3, n, i) {
    this._forEachCell(r3 - i, n - i, r3 + i, n + i, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(r3), this.circles.push(n), this.circles.push(i);
  }
  _insertBoxCell(e, r3, n, i, o, a) {
    this.boxCells[o].push(a);
  }
  _insertCircleCell(e, r3, n, i, o, a) {
    this.circleCells[o].push(a);
  }
  _query(e, r3, n, i, o, a, s3) {
    if (n < 0 || e > this.width || i < 0 || r3 > this.height) return [];
    let l = [];
    if (e <= 0 && r3 <= 0 && this.width <= n && this.height <= i) {
      if (o) return [{ key: null, x1: e, y1: r3, x2: n, y2: i }];
      for (let u3 = 0; u3 < this.boxKeys.length; u3++) l.push({ key: this.boxKeys[u3], x1: this.bboxes[u3 * 4], y1: this.bboxes[u3 * 4 + 1], x2: this.bboxes[u3 * 4 + 2], y2: this.bboxes[u3 * 4 + 3] });
      for (let u3 = 0; u3 < this.circleKeys.length; u3++) {
        let c = this.circles[u3 * 3], p = this.circles[u3 * 3 + 1], h = this.circles[u3 * 3 + 2];
        l.push({ key: this.circleKeys[u3], x1: c - h, y1: p - h, x2: c + h, y2: p + h });
      }
    } else {
      let u3 = { hitTest: o, overlapMode: a, seenUids: { box: {}, circle: {} } };
      this._forEachCell(e, r3, n, i, this._queryCell, l, u3, s3);
    }
    return l;
  }
  query(e, r3, n, i) {
    return this._query(e, r3, n, i, false, null);
  }
  hitTest(e, r3, n, i, o, a) {
    return this._query(e, r3, n, i, true, o, a).length > 0;
  }
  hitTestCircle(e, r3, n, i, o) {
    let a = e - n, s3 = e + n, l = r3 - n, u3 = r3 + n;
    if (s3 < 0 || a > this.width || u3 < 0 || l > this.height) return false;
    let c = [], p = { hitTest: true, overlapMode: i, circle: { x: e, y: r3, radius: n }, seenUids: { box: {}, circle: {} } };
    return this._forEachCell(a, l, s3, u3, this._queryCellCircle, c, p, o), c.length > 0;
  }
  _queryCell(e, r3, n, i, o, a, s3, l) {
    let { seenUids: u3, hitTest: c, overlapMode: p } = s3, h = this.boxCells[o];
    if (h !== null) {
      let d = this.bboxes;
      for (let g of h) if (!u3.box[g]) {
        u3.box[g] = true;
        let x = g * 4, b = this.boxKeys[g];
        if (e <= d[x + 2] && r3 <= d[x + 3] && n >= d[x + 0] && i >= d[x + 1] && (!l || l(b)) && (!c || !uh(p, b.overlapMode)) && (a.push({ key: b, x1: d[x], y1: d[x + 1], x2: d[x + 2], y2: d[x + 3] }), c)) return true;
      }
    }
    let f = this.circleCells[o];
    if (f !== null) {
      let d = this.circles;
      for (let g of f) if (!u3.circle[g]) {
        u3.circle[g] = true;
        let x = g * 3, b = this.circleKeys[g];
        if (this._circleAndRectCollide(d[x], d[x + 1], d[x + 2], e, r3, n, i) && (!l || l(b)) && (!c || !uh(p, b.overlapMode))) {
          let v3 = d[x], P = d[x + 1], w3 = d[x + 2];
          if (a.push({ key: b, x1: v3 - w3, y1: P - w3, x2: v3 + w3, y2: P + w3 }), c) return true;
        }
      }
    }
    return false;
  }
  _queryCellCircle(e, r3, n, i, o, a, s3, l) {
    let { circle: u3, seenUids: c, overlapMode: p } = s3, h = this.boxCells[o];
    if (h !== null) {
      let d = this.bboxes;
      for (let g of h) if (!c.box[g]) {
        c.box[g] = true;
        let x = g * 4, b = this.boxKeys[g];
        if (this._circleAndRectCollide(u3.x, u3.y, u3.radius, d[x + 0], d[x + 1], d[x + 2], d[x + 3]) && (!l || l(b)) && !uh(p, b.overlapMode)) return a.push(true), true;
      }
    }
    let f = this.circleCells[o];
    if (f !== null) {
      let d = this.circles;
      for (let g of f) if (!c.circle[g]) {
        c.circle[g] = true;
        let x = g * 3, b = this.circleKeys[g];
        if (this._circlesCollide(d[x], d[x + 1], d[x + 2], u3.x, u3.y, u3.radius) && (!l || l(b)) && !uh(p, b.overlapMode)) return a.push(true), true;
      }
    }
  }
  _forEachCell(e, r3, n, i, o, a, s3, l) {
    let u3 = this._convertToXCellCoord(e), c = this._convertToYCellCoord(r3), p = this._convertToXCellCoord(n), h = this._convertToYCellCoord(i);
    for (let f = u3; f <= p; f++) for (let d = c; d <= h; d++) {
      let g = this.xCellCount * d + f;
      if (o.call(this, e, r3, n, i, g, a, s3, l)) return;
    }
  }
  _convertToXCellCoord(e) {
    return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
  }
  _convertToYCellCoord(e) {
    return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
  }
  _circlesCollide(e, r3, n, i, o, a) {
    let s3 = i - e, l = o - r3, u3 = n + a;
    return u3 * u3 > s3 * s3 + l * l;
  }
  _circleAndRectCollide(e, r3, n, i, o, a, s3) {
    let l = (a - i) / 2, u3 = Math.abs(e - (i + l));
    if (u3 > l + n) return false;
    let c = (s3 - o) / 2, p = Math.abs(r3 - (o + c));
    if (p > c + n) return false;
    if (u3 <= l || p <= c) return true;
    let h = u3 - l, f = p - c;
    return h * h + f * f <= n * n;
  }
};
$i();
var Pa = s(fe(), 1);
function Nl(t63, e, r3) {
  let n = B.create();
  if (!t63) {
    let { vecSouth: i, vecEast: o } = hh(e), a = qn.create();
    a[0] = o[0], a[1] = o[1], a[2] = i[0], a[3] = i[1], qn.invert(a, a), n[0] = a[0], n[1] = a[1], n[4] = a[2], n[5] = a[3];
  }
  return B.scale(n, n, [1 / r3, 1 / r3, 1]), n;
}
function K1(t63, e, r3, n) {
  if (t63) {
    let i = B.create();
    if (!e) {
      let { vecSouth: o, vecEast: a } = hh(r3);
      i[0] = a[0], i[1] = a[1], i[4] = o[0], i[5] = o[1];
    }
    return B.scale(i, i, [n, n, 1]), i;
  } else return r3.pixelsToClipSpaceMatrix;
}
function hh(t63) {
  let e = Math.cos(t63.rollInRadians), r3 = Math.sin(t63.rollInRadians), n = Math.cos(t63.pitchInRadians), i = Math.cos(t63.bearingInRadians), o = Math.sin(t63.bearingInRadians), a = wt.create();
  a[0] = -i * n * r3 - o * e, a[1] = -o * n * r3 + i * e;
  let s3 = wt.length(a);
  s3 < 1e-9 ? wt.zero(a) : wt.scale(a, a, 1 / s3);
  let l = wt.create();
  l[0] = i * n * e - o * r3, l[1] = o * n * e + i * r3;
  let u3 = wt.length(l);
  return u3 < 1e-9 ? wt.zero(l) : wt.scale(l, l, 1 / u3), { vecEast: l, vecSouth: a };
}
function fh(t63, e, r3, n) {
  let i;
  n ? (i = [t63, e, n(t63, e), 1], Ne.transformMat4(i, i, r3)) : (i = [t63, e, 0, 1], Gl(i, i, r3));
  let o = i[3];
  return { point: new Pa.default(i[0] / o, i[1] / o), signedDistanceFromCamera: o, isOccluded: false };
}
function ky(t63, e) {
  return 0.5 + 0.5 * (t63 / e);
}
function yO(t63, e) {
  return t63.x >= -e[0] && t63.x <= e[0] && t63.y >= -e[1] && t63.y <= e[1];
}
function J1(t63, e, r3, n, i, o, a, s3, l, u3, c, p, h) {
  let f = r3 ? t63.textSizeData : t63.iconSizeData, d = co(f, e.transform.zoom), g = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1], x = r3 ? t63.text.dynamicLayoutVertexArray : t63.icon.dynamicLayoutVertexArray;
  x.clear();
  let b = t63.lineVertexArray, v3 = r3 ? t63.text.placedSymbolArray : t63.icon.placedSymbolArray, P = e.transform.width / e.transform.height, w3 = false;
  for (let T = 0; T < v3.length; T++) {
    let S = v3.get(T);
    if (S.hidden || S.writingMode === 2 && !w3) {
      yo(S.numGlyphs, x);
      continue;
    }
    w3 = false;
    let C3 = new Pa.default(S.anchorX, S.anchorY), E = { getElevation: h, pitchedLabelPlaneMatrix: n, lineVertexArray: b, pitchWithMap: o, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: e.transform, tileAnchorPoint: C3, unwrappedTileID: l, width: u3, height: c, translation: p }, L = Oy(S.anchorX, S.anchorY, E);
    if (!yO(L.point, g)) {
      yo(S.numGlyphs, x);
      continue;
    }
    let F = L.signedDistanceFromCamera, O = ky(e.transform.cameraToCenterDistance, F), z = ha(f, d, S), I = o ? z * e.transform.getPitchedTextCorrection(S.anchorX, S.anchorY, l) / O : z * O, R = $1({ projectionContext: E, pitchedLabelPlaneMatrixInverse: i, symbol: S, fontSize: I, flip: false, keepUpright: a, glyphOffsetArray: t63.glyphOffsetArray, dynamicLayoutVertexArray: x, aspectRatio: P, rotateToLine: s3 });
    w3 = R.useVertical, (R.notEnoughRoom || w3 || R.needsFlipping && $1({ projectionContext: E, pitchedLabelPlaneMatrixInverse: i, symbol: S, fontSize: I, flip: true, keepUpright: a, glyphOffsetArray: t63.glyphOffsetArray, dynamicLayoutVertexArray: x, aspectRatio: P, rotateToLine: s3 }).notEnoughRoom) && yo(S.numGlyphs, x);
  }
  r3 ? t63.text.dynamicLayoutVertexBuffer.updateData(x) : t63.icon.dynamicLayoutVertexBuffer.updateData(x);
}
function Fy(t63, e, r3, n, i, o, a, s3) {
  let l = o.glyphStartIndex + o.numGlyphs, u3 = o.lineStartIndex, c = o.lineStartIndex + o.lineLength, p = e.getoffsetX(o.glyphStartIndex), h = e.getoffsetX(l - 1), f = ph(t63 * p, r3, n, i, o.segment, u3, c, s3, a);
  if (!f) return null;
  let d = ph(t63 * h, r3, n, i, o.segment, u3, c, s3, a);
  return !d || s3.projectionCache.anyProjectionOccluded ? null : { first: f, last: d };
}
function W1(t63, e, r3, n) {
  if (t63 === 1) {
    let i = Math.abs(r3.y - e.y), o = Math.abs(r3.x - e.x) * n;
    if (i > o) return { useVertical: true };
  }
  return (t63 === 2 ? e.y < r3.y : e.x > r3.x) ? { needsFlipping: true } : null;
}
function $1(t63) {
  let { projectionContext: e, pitchedLabelPlaneMatrixInverse: r3, symbol: n, fontSize: i, flip: o, keepUpright: a, glyphOffsetArray: s3, dynamicLayoutVertexArray: l, aspectRatio: u3, rotateToLine: c } = t63, p = i / 24, h = n.lineOffsetX * p, f = n.lineOffsetY * p, d;
  if (n.numGlyphs > 1) {
    let g = n.glyphStartIndex + n.numGlyphs, x = n.lineStartIndex, b = n.lineStartIndex + n.lineLength, v3 = Fy(p, s3, h, f, o, n, c, e);
    if (!v3) return { notEnoughRoom: true };
    let P = ch(v3.first.point.x, v3.first.point.y, e, r3), w3 = ch(v3.last.point.x, v3.last.point.y, e, r3);
    if (a && !o) {
      let T = W1(n.writingMode, P, w3, u3);
      if (T) return T;
    }
    d = [v3.first];
    for (let T = n.glyphStartIndex + 1; T < g - 1; T++) {
      let S = ph(p * s3.getoffsetX(T), h, f, o, n.segment, x, b, e, c);
      if (!S) return { notEnoughRoom: true };
      d.push(S);
    }
    d.push(v3.last);
  } else {
    if (a && !o) {
      let x = _i(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point, b = n.lineStartIndex + n.segment + 1, v3 = new Pa.default(e.lineVertexArray.getx(b), e.lineVertexArray.gety(b)), P = _i(v3.x, v3.y, e), w3 = P.signedDistanceFromCamera > 0 ? P.point : Q1(e.tileAnchorPoint, v3, x, 1, e), T = ch(x.x, x.y, e, r3), S = ch(w3.x, w3.y, e, r3), C3 = W1(n.writingMode, T, S, u3);
      if (C3) return C3;
    }
    let g = ph(p * s3.getoffsetX(n.glyphStartIndex), h, f, o, n.segment, n.lineStartIndex, n.lineStartIndex + n.lineLength, e, c);
    if (!g || e.projectionCache.anyProjectionOccluded) return { notEnoughRoom: true };
    d = [g];
  }
  for (let g of d) po(l, g.point, g.angle);
  return {};
}
function Q1(t63, e, r3, n, i) {
  let o = t63.add(t63.sub(e)._unit()), a = _i(o.x, o.y, i).point, s3 = r3.sub(a);
  return r3.add(s3._mult(n / s3.mag()));
}
function Dy(t63, e, r3) {
  let n = e.projectionCache;
  if (n.projections[t63]) return n.projections[t63];
  let i = new Pa.default(e.lineVertexArray.getx(t63), e.lineVertexArray.gety(t63)), o = _i(i.x, i.y, e);
  if (o.signedDistanceFromCamera > 0) return n.projections[t63] = o.point, n.anyProjectionOccluded = n.anyProjectionOccluded || o.isOccluded, o.point;
  let a = t63 - r3.direction, s3 = r3.distanceFromAnchor === 0 ? e.tileAnchorPoint : new Pa.default(e.lineVertexArray.getx(a), e.lineVertexArray.gety(a)), l = r3.absOffsetX - r3.distanceFromAnchor + 1;
  return Q1(s3, i, r3.previousVertex, l, e);
}
function _i(t63, e, r3) {
  let n = t63 + r3.translation[0], i = e + r3.translation[1], o;
  return r3.pitchWithMap ? (o = fh(n, i, r3.pitchedLabelPlaneMatrix, r3.getElevation), o.isOccluded = false) : (o = r3.transform.projectTileCoordinates(n, i, r3.unwrappedTileID, r3.getElevation), o.point.x = (o.point.x * 0.5 + 0.5) * r3.width, o.point.y = (-o.point.y * 0.5 + 0.5) * r3.height), o;
}
function ch(t63, e, r3, n) {
  if (r3.pitchWithMap) {
    let i = [t63, e, 0, 1];
    return Ne.transformMat4(i, i, n), r3.transform.projectTileCoordinates(i[0] / i[3], i[1] / i[3], r3.unwrappedTileID, r3.getElevation).point;
  } else return { x: t63 / r3.width * 2 - 1, y: e / r3.height * 2 - 1 };
}
function Oy(t63, e, r3) {
  return r3.transform.projectTileCoordinates(t63, e, r3.unwrappedTileID, r3.getElevation);
}
function Ry(t63, e, r3) {
  return t63._unit()._perp()._mult(e * r3);
}
function gO(t63, e, r3, n, i, o, a, s3, l) {
  if (s3.projectionCache.offsets[t63]) return s3.projectionCache.offsets[t63];
  let u3 = r3.add(e);
  if (t63 + l.direction < n || t63 + l.direction >= i) return s3.projectionCache.offsets[t63] = u3, u3;
  let c = Dy(t63 + l.direction, s3, l), p = Ry(c.sub(r3), a, l.direction), h = r3.add(p), f = c.add(p);
  return s3.projectionCache.offsets[t63] = zb(o, u3, h, f) || u3, s3.projectionCache.offsets[t63];
}
function ph(t63, e, r3, n, i, o, a, s3, l) {
  let u3 = n ? t63 - e : t63 + e, c = u3 > 0 ? 1 : -1, p = 0;
  n && (c *= -1, p = Math.PI), c < 0 && (p += Math.PI);
  let h = c > 0 ? o + i : o + i + 1, f;
  s3.projectionCache.cachedAnchorPoint ? f = s3.projectionCache.cachedAnchorPoint : (f = _i(s3.tileAnchorPoint.x, s3.tileAnchorPoint.y, s3).point, s3.projectionCache.cachedAnchorPoint = f);
  let d = f, g = f, x, b, v3 = 0, P = 0, w3 = Math.abs(u3), T = [], S;
  do {
    if (h += c, h < o || h >= a) return null;
    v3 += P, g = d, b = x;
    let L = { absOffsetX: w3, direction: c, distanceFromAnchor: v3, previousVertex: g };
    if (d = Dy(h, s3, L), r3 === 0) T.push(g), S = d.sub(g);
    else {
      let F, O = d.sub(g);
      if (O.mag() === 0) {
        let z = Dy(h + c, s3, L);
        F = Ry(z.sub(d), r3, c);
      } else F = Ry(O, r3, c);
      b || (b = g.add(F)), x = gO(h, F, d, o, a, b, r3, s3, L), T.push(b), S = x.sub(b);
    }
    P = S.mag();
  } while (v3 + P <= w3);
  let C3 = (w3 - v3) / P, A = S._mult(C3)._add(b || g), E = p + Math.atan2(d.y - g.y, d.x - g.x);
  return T.push(A), { point: A, angle: l ? E : 0, path: T };
}
var xO = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
function yo(t63, e) {
  for (let r3 = 0; r3 < t63; r3++) {
    let n = e.length;
    e.resize(n + 4), e.float32.set(xO, n * 3);
  }
}
function Gl(t63, e, r3) {
  let n = e[0], i = e[1];
  return t63[0] = r3[0] * n + r3[4] * i + r3[12], t63[1] = r3[1] * n + r3[5] * i + r3[13], t63[3] = r3[3] * n + r3[7] * i + r3[15], t63;
}
function eP(t63, e) {
  let r3 = B.create();
  return B.invert(r3, e.pitchedLabelPlaneMatrix), t63.map((n) => {
    let i = fh(n.x, n.y, r3, e.getElevation), o = e.transform.projectTileCoordinates(i.point.x, i.point.y, e.unwrappedTileID, e.getElevation);
    return o.point.x = (o.point.x * 0.5 + 0.5) * e.width, o.point.y = (-o.point.y * 0.5 + 0.5) * e.height, o;
  });
}
function tP(t63) {
  let e = 0, r3 = 0, n = 0, i = 0;
  for (let o = 0; o < t63.length; o++) t63[o].isOccluded ? (n = o + 1, i = 0) : (i++, i > r3 && (r3 = i, e = n));
  return t63.slice(e, e + r3);
}
var He = 100;
var mh = class {
  constructor(e, r3 = new Ul(e.width + 2 * He, e.height + 2 * He, 25), n = new Ul(e.width + 2 * He, e.height + 2 * He, 25)) {
    this.transform = e, this.grid = r3, this.ignoredGrid = n, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + He, this.screenBottomBoundary = e.height + He, this.gridRightBoundary = e.width + 2 * He, this.gridBottomBoundary = e.height + 2 * He, this.perspectiveRatioCutoff = 0.6;
  }
  placeCollisionBox(e, r3, n, i, o, a, s3, l, u3, c, p, h) {
    let f = e.anchorPointX + l[0], d = e.anchorPointY + l[1], g = this.projectAndGetPerspectiveRatio(f, d, o, c, h), x = n * g.perspectiveRatio, b;
    if (!a && !s3) {
      let A = g.x + (p ? p.x * x : 0), E = g.y + (p ? p.y * x : 0);
      b = { allPointsOccluded: false, box: [A + e.x1 * x, E + e.y1 * x, A + e.x2 * x, E + e.y2 * x] };
    } else b = this._projectCollisionBox(e, x, i, o, a, s3, l, g, c, p, h);
    let [v3, P, w3, T] = b.box, S = a ? b.allPointsOccluded : g.isOccluded, C3 = S;
    return C3 || (C3 = g.perspectiveRatio < this.perspectiveRatioCutoff), C3 || (C3 = !this.isInsideGrid(v3, P, w3, T)), C3 || r3 !== "always" && this.grid.hitTest(v3, P, w3, T, r3, u3) ? { box: [v3, P, w3, T], placeable: false, offscreen: false, occluded: S } : { box: [v3, P, w3, T], placeable: true, offscreen: this.isOffscreen(v3, P, w3, T), occluded: S };
  }
  placeCollisionCircles(e, r3, n, i, o, a, s3, l, u3, c, p, h, f, d) {
    let g = [], x = new Jr.default(r3.anchorX, r3.anchorY), b = this.getPerspectiveRatio(x.x, x.y, a, d), P = (u3 ? o * this.transform.getPitchedTextCorrection(r3.anchorX, r3.anchorY, a) / b : o * b) / mi, w3 = { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, T = r3.lineOffsetX * P, S = r3.lineOffsetY * P, C3 = { getElevation: d, pitchedLabelPlaneMatrix: s3, lineVertexArray: n, pitchWithMap: u3, projectionCache: w3, transform: this.transform, tileAnchorPoint: x, unwrappedTileID: a, width: this.transform.width, height: this.transform.height, translation: f }, A = Fy(P, i, T, S, false, r3, false, C3), E = false, L = false, F = true;
    if (A) {
      let O = p * 0.5 * b + h, z = new Jr.default(-He, -He), I = new Jr.default(this.screenRightBoundary, this.screenBottomBoundary), R = new lh(), H = A.first, W = A.last, $ = [];
      for (let be = H.path.length - 1; be >= 1; be--) $.push(H.path[be]);
      for (let be = 1; be < W.path.length; be++) $.push(W.path[be]);
      let he = O * 2.5;
      if (u3) {
        let be = this.projectPathToScreenSpace($, C3);
        be.some((ye) => ye.signedDistanceFromCamera <= 0) ? $ = [] : $ = be.map((ye) => ye.point);
      }
      let Xe = [];
      if ($.length > 0) {
        let be = $[0].clone(), ye = $[0].clone();
        for (let Ze = 1; Ze < $.length; Ze++) be.x = Math.min(be.x, $[Ze].x), be.y = Math.min(be.y, $[Ze].y), ye.x = Math.max(ye.x, $[Ze].x), ye.y = Math.max(ye.y, $[Ze].y);
        be.x >= z.x && ye.x <= I.x && be.y >= z.y && ye.y <= I.y ? Xe = [$] : ye.x < z.x || be.x > I.x || ye.y < z.y || be.y > I.y ? Xe = [] : Xe = Ly([$], z.x, z.y, I.x, I.y);
      }
      for (let be of Xe) {
        R.reset(be, O * 0.25);
        let ye = 0;
        R.length <= 0.5 * O ? ye = 1 : ye = Math.ceil(R.paddedLength / he) + 1;
        for (let Ze = 0; Ze < ye; Ze++) {
          let st = Ze / Math.max(ye - 1, 1), vt = R.lerp(st), dt = vt.x + He, zt = vt.y + He;
          g.push(dt, zt, O, 0);
          let cr = dt - O, rn = zt - O, pr = dt + O, Ct = zt + O;
          if (F = F && this.isOffscreen(cr, rn, pr, Ct), L = L || this.isInsideGrid(cr, rn, pr, Ct), e !== "always" && this.grid.hitTestCircle(dt, zt, O, e, c) && (E = true, !l)) return { circles: [], offscreen: false, collisionDetected: E };
        }
      }
    }
    return { circles: !l && E || !L || b < this.perspectiveRatioCutoff ? [] : g, offscreen: F, collisionDetected: E };
  }
  projectPathToScreenSpace(e, r3) {
    let n = eP(e, r3);
    return tP(n);
  }
  queryRenderedSymbols(e) {
    if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
    let r3 = [], n = new Tt();
    for (let p of e) {
      let h = new Jr.default(p.x + He, p.y + He);
      n.extend(h), r3.push(h);
    }
    let { minX: i, minY: o, maxX: a, maxY: s3 } = n, l = this.grid.query(i, o, a, s3).concat(this.ignoredGrid.query(i, o, a, s3)), u3 = {}, c = {};
    for (let p of l) {
      let h = p.key;
      if (u3[h.bucketInstanceId] === void 0 && (u3[h.bucketInstanceId] = {}), u3[h.bucketInstanceId][h.featureIndex]) continue;
      let f = [new Jr.default(p.x1, p.y1), new Jr.default(p.x2, p.y1), new Jr.default(p.x2, p.y2), new Jr.default(p.x1, p.y2)];
      dp(r3, f) && (u3[h.bucketInstanceId][h.featureIndex] = true, c[h.bucketInstanceId] === void 0 && (c[h.bucketInstanceId] = []), c[h.bucketInstanceId].push(h.featureIndex));
    }
    return c;
  }
  insertCollisionBox(e, r3, n, i, o, a) {
    let s3 = n ? this.ignoredGrid : this.grid, l = { bucketInstanceId: i, featureIndex: o, collisionGroupID: a, overlapMode: r3 };
    s3.insert(l, e[0], e[1], e[2], e[3]);
  }
  insertCollisionCircles(e, r3, n, i, o, a) {
    let s3 = n ? this.ignoredGrid : this.grid, l = { bucketInstanceId: i, featureIndex: o, collisionGroupID: a, overlapMode: r3 };
    for (let u3 = 0; u3 < e.length; u3 += 4) s3.insertCircle(l, e[u3], e[u3 + 1], e[u3 + 2]);
  }
  projectAndGetPerspectiveRatio(e, r3, n, i, o) {
    if (o) {
      let a;
      i ? (a = [e, r3, i(e, r3), 1], Ne.transformMat4(a, a, o)) : (a = [e, r3, 0, 1], Gl(a, a, o));
      let s3 = a[3];
      return { x: (a[0] / s3 + 1) / 2 * this.transform.width + He, y: (-a[1] / s3 + 1) / 2 * this.transform.height + He, perspectiveRatio: 0.5 + 0.5 * (this.transform.cameraToCenterDistance / s3), isOccluded: false, signedDistanceFromCamera: s3 };
    } else {
      let a = this.transform.projectTileCoordinates(e, r3, n, i);
      return { x: (a.point.x + 1) / 2 * this.transform.width + He, y: (-a.point.y + 1) / 2 * this.transform.height + He, perspectiveRatio: 0.5 + 0.5 * (this.transform.cameraToCenterDistance / a.signedDistanceFromCamera), isOccluded: a.isOccluded, signedDistanceFromCamera: a.signedDistanceFromCamera };
    }
  }
  getPerspectiveRatio(e, r3, n, i) {
    let o = this.transform.projectTileCoordinates(e, r3, n, i);
    return 0.5 + 0.5 * (this.transform.cameraToCenterDistance / o.signedDistanceFromCamera);
  }
  isOffscreen(e, r3, n, i) {
    return n < He || e >= this.screenRightBoundary || i < He || r3 > this.screenBottomBoundary;
  }
  isInsideGrid(e, r3, n, i) {
    return n >= 0 && e < this.gridRightBoundary && i >= 0 && r3 < this.gridBottomBoundary;
  }
  getViewportMatrix() {
    let e = B.identity([]);
    return B.translate(e, e, [-He, -He, 0]), e;
  }
  _projectCollisionBox(e, r3, n, i, o, a, s3, l, u3, c, p) {
    let h = 1, f = 0, d = 0, g = 1, x = e.anchorPointX + s3[0], b = e.anchorPointY + s3[1];
    if (a && !o) {
      let I = this.projectAndGetPerspectiveRatio(x + 1, b, i, u3, p), R = I.x - l.x, H = I.y - l.y, W = Math.atan(H / R) + (R < 0 ? Math.PI : 0), $ = Math.sin(W), he = Math.cos(W);
      h = he, f = $, d = -$, g = he;
    } else if (!a && o) {
      let I = hh(this.transform);
      h = I.vecEast[0], f = I.vecEast[1], d = I.vecSouth[0], g = I.vecSouth[1];
    }
    let v3 = l.x, P = l.y, w3 = r3;
    if (o) {
      v3 = x, P = b;
      let I = this.transform.zoom - n.overscaledZ;
      if (w3 = Math.pow(2, -I), w3 *= this.transform.getPitchedTextCorrection(x, b, i), !c) {
        let R = l.signedDistanceFromCamera / this.transform.cameraToCenterDistance, H = ce(0.5 + 0.5 * R, 0, 4);
        w3 *= H;
      }
    }
    c && (v3 += h * c.x * w3 + d * c.y * w3, P += f * c.x * w3 + g * c.y * w3);
    let T = e.x1 * w3, S = e.x2 * w3, C3 = (T + S) / 2, A = e.y1 * w3, E = e.y2 * w3, L = (A + E) / 2, F = [{ offsetX: T, offsetY: A }, { offsetX: C3, offsetY: A }, { offsetX: S, offsetY: A }, { offsetX: S, offsetY: L }, { offsetX: S, offsetY: E }, { offsetX: C3, offsetY: E }, { offsetX: T, offsetY: E }, { offsetX: T, offsetY: L }], O = [];
    for (let { offsetX: I, offsetY: R } of F) O.push(new Jr.default(v3 + h * I + d * R, P + f * I + g * R));
    let z = false;
    if (o) {
      let I = O.map((R) => this.projectAndGetPerspectiveRatio(R.x, R.y, i, u3, p));
      z = I.some((R) => !R.isOccluded), O = I.map((R) => new Jr.default(R.x, R.y));
    } else z = true;
    return { box: kb(O), allPointsOccluded: !z };
  }
};
$i();
$i();
var rP = s(fe(), 1);
var jl = class t51 extends rP.default {
  constructor(e, r3, n, i) {
    super(e, r3), this.angle = n, i !== void 0 && (this.segment = i);
  }
  clone() {
    return new t51(this.x, this.y, this.angle, this.segment);
  }
};
X("Anchor", jl);
$i();
$i();
$i();
var vO = s(fe(), 1);
$i();
var PO = s(fe(), 1);
$i();
$i();
var wO = s(fe(), 1);
var SO = s($d(), 1);
$i();
var Hl = ((o) => (o[o.center = 1] = "center", o[o.left = 2] = "left", o[o.right = 3] = "right", o[o.top = 4] = "top", o[o.bottom = 5] = "bottom", o[o["top-left"] = 6] = "top-left", o[o["top-right"] = 7] = "top-right", o[o["bottom-left"] = 8] = "bottom-left", o[o["bottom-right"] = 9] = "bottom-right", o))(Hl || {});
var TO = Number.POSITIVE_INFINITY;
function nP(t63) {
  switch (t63) {
    case "right":
    case "top-right":
    case "bottom-right":
      return "right";
    case "left":
    case "top-left":
    case "bottom-left":
      return "left";
  }
  return "center";
}
var Vy = s(fe(), 1);
var dh = class {
  constructor(e, r3, n, i) {
    e ? this.opacity = Math.max(0, Math.min(1, e.opacity + (e.placed ? r3 : -r3))) : this.opacity = i && n ? 1 : 0, this.placed = n;
  }
  isHidden() {
    return this.opacity === 0 && !this.placed;
  }
};
var go = class {
  constructor(e, r3, n, i, o) {
    this.text = new dh(e ? e.text : null, r3, n, o), this.icon = new dh(e ? e.icon : null, r3, i, o);
  }
  isHidden() {
    return this.text.isHidden() && this.icon.isHidden();
  }
};
var yh = class {
  constructor(e, r3, n) {
    this.text = e, this.icon = r3, this.skipFade = n;
  }
};
var By = class {
  constructor(e, r3, n, i, o) {
    this.bucketInstanceId = e, this.featureIndex = r3, this.sourceLayerIndex = n, this.bucketIndex = i, this.tileID = o;
  }
};
var zy = class {
  constructor(e) {
    this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
  }
  get(e) {
    if (this.crossSourceCollisions) return { ID: 0, predicate: null };
    if (!this.collisionGroups[e]) {
      let r3 = ++this.maxGroupID;
      this.collisionGroups[e] = { ID: r3, predicate: (n) => n.collisionGroupID === r3 };
    }
    return this.collisionGroups[e];
  }
};
function iP(t63, e, r3, n, i) {
  let { horizontalAlign: o, verticalAlign: a } = Op(t63), s3 = -(o - 0.5) * e, l = -(a - 0.5) * r3;
  return new Vy.default(s3 + n[0] * i, l + n[1] * i);
}
var gh = class {
  constructor(e, r3, n, i, o) {
    this.transform = e.clone(), this.terrain = r3, this.collisionIndex = new mh(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = n, this.retainedQueryData = {}, this.collisionGroups = new zy(i), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};
  }
  _getTerrainElevationFunc(e) {
    let r3 = this.terrain;
    return r3 ? (n, i) => r3.getElevation(e, n, i) : null;
  }
  getBucketParts(e, r3, n, i) {
    let o = n.getBucket(r3), a = n.latestFeatureIndex;
    if (!o || !a || r3.id !== o.layerIds[0]) return;
    let s3 = n.collisionBoxArray, l = o.layers[0].layout, u3 = o.layers[0].paint, c = Math.pow(2, this.transform.zoom - n.tileID.overscaledZ), p = n.tileSize / 8192, h = n.tileID.toUnwrapped(), f = l.get("text-rotation-alignment") === "map", d = yt(n, 1, this.transform.zoom), g = Yt(this.collisionIndex.transform, n, u3.get("text-translate"), u3.get("text-translate-anchor")), x = Yt(this.collisionIndex.transform, n, u3.get("icon-translate"), u3.get("icon-translate-anchor")), b = Nl(f, this.transform, d);
    this.retainedQueryData[o.bucketInstanceId] = new By(o.bucketInstanceId, a, o.sourceLayerIndex, o.index, n.tileID);
    let v3 = { bucket: o, layout: l, translationText: g, translationIcon: x, unwrappedTileID: h, pitchedLabelPlaneMatrix: b, scale: c, textPixelRatio: p, holdingForFade: n.holdingForFade(), collisionBoxArray: s3, partiallyEvaluatedTextSize: co(o.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(o.sourceID) };
    if (i) for (let P of o.sortKeyRanges) {
      let { sortKey: w3, symbolInstanceStart: T, symbolInstanceEnd: S } = P;
      e.push({ sortKey: w3, symbolInstanceStart: T, symbolInstanceEnd: S, parameters: v3 });
    }
    else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: o.symbolInstances.length, parameters: v3 });
  }
  attemptAnchorPlacement(e, r3, n, i, o, a, s3, l, u3, c, p, h, f, d, g, x, b, v3, P, w3) {
    let T = Hl[e.textAnchor], S = [e.textOffset0, e.textOffset1], C3 = iP(T, n, i, S, o), A = this.collisionIndex.placeCollisionBox(r3, h, l, u3, c, s3, a, x, p.predicate, P, C3, w3);
    if (!(v3 && !this.collisionIndex.placeCollisionBox(v3, h, l, u3, c, s3, a, b, p.predicate, P, C3, w3).placeable) && A.placeable) {
      let E;
      if (this.prevPlacement && this.prevPlacement.variableOffsets[f.crossTileID] && this.prevPlacement.placements[f.crossTileID] && this.prevPlacement.placements[f.crossTileID].text && (E = this.prevPlacement.variableOffsets[f.crossTileID].anchor), f.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
      return this.variableOffsets[f.crossTileID] = { textOffset: S, width: n, height: i, anchor: T, textBoxScale: o, prevAnchor: E }, this.markUsedJustification(d, T, f, g), d.allowVerticalPlacement && (this.markUsedOrientation(d, g, f), this.placedOrientations[f.crossTileID] = g), { shift: C3, placedGlyphBoxes: A };
    }
  }
  placeLayerBucketPart(e, r3, n) {
    let { bucket: i, layout: o, translationText: a, translationIcon: s3, unwrappedTileID: l, pitchedLabelPlaneMatrix: u3, textPixelRatio: c, holdingForFade: p, collisionBoxArray: h, partiallyEvaluatedTextSize: f, collisionGroup: d } = e.parameters, g = o.get("text-optional"), x = o.get("icon-optional"), b = fa(o, "text-overlap", "text-allow-overlap"), v3 = b === "always", P = fa(o, "icon-overlap", "icon-allow-overlap"), w3 = P === "always", T = o.get("text-rotation-alignment") === "map", S = o.get("text-pitch-alignment") === "map", C3 = o.get("icon-text-fit") !== "none", A = o.get("symbol-z-order") === "viewport-y", E = v3 && (w3 || !i.hasIconData() || x), L = w3 && (v3 || !i.hasTextData() || g);
    !i.collisionArrays && h && i.deserializeCollisionBoxes(h);
    let F = this.retainedQueryData[i.bucketInstanceId].tileID, O = this._getTerrainElevationFunc(F), z = this.transform.getFastPathSimpleProjectionMatrix(F), I = (R, H, W) => {
      if (r3[R.crossTileID]) return;
      if (p) {
        this.placements[R.crossTileID] = new yh(false, false, false);
        return;
      }
      let $ = false, he = false, Xe = true, be = null, ye = { box: null, placeable: false, offscreen: null, occluded: false }, Ze = { box: null, placeable: false, offscreen: null }, st = null, vt = null, dt = null, zt = 0, cr = 0, rn = 0;
      H.textFeatureIndex ? zt = H.textFeatureIndex : R.useRuntimeCollisionCircles && (zt = R.featureIndex), H.verticalTextFeatureIndex && (cr = H.verticalTextFeatureIndex);
      let pr = H.textBox;
      if (pr) {
        let Mr = (Dt) => {
          let At = 1;
          if (i.allowVerticalPlacement && !Dt && this.prevPlacement) {
            let Ar = this.prevPlacement.placedOrientations[R.crossTileID];
            Ar && (this.placedOrientations[R.crossTileID] = Ar, At = Ar, this.markUsedOrientation(i, At, R));
          }
          return At;
        }, Ir = (Dt, At) => {
          if (i.allowVerticalPlacement && R.numVerticalGlyphVertices > 0 && H.verticalTextBox) {
            for (let Ar of i.writingModes) if (Ar === 2 ? (ye = At(), Ze = ye) : ye = Dt(), ye && ye.placeable) break;
          } else ye = Dt();
        }, Hn = R.textAnchorOffsetStartIndex, bn2 = R.textAnchorOffsetEndIndex;
        if (bn2 === Hn) {
          let Dt = (Di, Ro) => {
            let Rt = this.collisionIndex.placeCollisionBox(Di, b, c, F, l, S, T, a, d.predicate, O, void 0, z);
            return Rt && Rt.placeable && (this.markUsedOrientation(i, Ro, R), this.placedOrientations[R.crossTileID] = Ro), Rt;
          };
          Ir(() => Dt(pr, 1), () => {
            let Di = H.verticalTextBox;
            return i.allowVerticalPlacement && R.numVerticalGlyphVertices > 0 && Di ? Dt(Di, 2) : { box: null, offscreen: null };
          }), Mr(ye && ye.placeable);
        } else {
          let Dt = Hl[this.prevPlacement?.variableOffsets[R.crossTileID]?.anchor], At = (Rt, wm, OM) => {
            let BM = Rt.x2 - Rt.x1, zM = Rt.y2 - Rt.y1, VM = R.textBoxScale, UM = C3 && P === "never" ? wm : null, Ri = null, cx = b === "never" ? 1 : 2, px = "never";
            Dt && cx++;
            for (let Tm = 0; Tm < cx; Tm++) {
              for (let Sm = Hn; Sm < bn2; Sm++) {
                let hx = i.textAnchorOffsets.get(Sm);
                if (Dt && hx.textAnchor !== Dt) continue;
                let Cm = this.attemptAnchorPlacement(hx, Rt, BM, zM, VM, T, S, c, F, l, d, px, R, i, OM, a, s3, UM, O);
                if (Cm && (Ri = Cm.placedGlyphBoxes, Ri && Ri.placeable)) return $ = true, be = Cm.shift, Ri;
              }
              Dt ? Dt = null : px = b;
            }
            return n && !Ri && (Ri = { box: this.collisionIndex.placeCollisionBox(pr, "always", c, F, l, S, T, a, d.predicate, O, void 0, z).box, offscreen: false, placeable: false, occluded: false }), Ri;
          };
          Ir(() => At(pr, H.iconBox, 1), () => {
            let Rt = H.verticalTextBox, wm = ye && ye.placeable;
            return i.allowVerticalPlacement && !wm && R.numVerticalGlyphVertices > 0 && Rt ? At(Rt, H.verticalIconBox, 2) : { box: null, occluded: true, offscreen: null };
          }), ye && ($ = ye.placeable, Xe = ye.offscreen);
          let Ro = Mr(ye && ye.placeable);
          if (!$ && this.prevPlacement) {
            let Rt = this.prevPlacement.variableOffsets[R.crossTileID];
            Rt && (this.variableOffsets[R.crossTileID] = Rt, this.markUsedJustification(i, Rt.anchor, R, Ro));
          }
        }
      }
      if (st = ye, $ = st && st.placeable, Xe = st && st.offscreen, R.useRuntimeCollisionCircles) {
        let Mr = i.text.placedSymbolArray.get(R.centerJustifiedTextSymbolIndex), Ir = ha(i.textSizeData, f, Mr), Hn = o.get("text-padding"), bn2 = R.collisionCircleDiameter;
        vt = this.collisionIndex.placeCollisionCircles(b, Mr, i.lineVertexArray, i.glyphOffsetArray, Ir, l, u3, n, S, d.predicate, bn2, Hn, a, O), vt.circles.length && vt.collisionDetected && !n && ve2("Collisions detected, but collision boxes are not shown"), $ = v3 || vt.circles.length > 0 && !vt.collisionDetected, Xe = Xe && vt.offscreen;
      }
      if (H.iconFeatureIndex && (rn = H.iconFeatureIndex), H.iconBox) {
        let Mr = (Ir) => this.collisionIndex.placeCollisionBox(Ir, P, c, F, l, S, T, s3, d.predicate, O, C3 && be ? be : void 0, z);
        Ze && Ze.placeable && H.verticalIconBox ? (dt = Mr(H.verticalIconBox), he = dt.placeable) : (dt = Mr(H.iconBox), he = dt.placeable), Xe = Xe && dt.offscreen;
      }
      let Ct = g || R.numHorizontalGlyphVertices === 0 && R.numVerticalGlyphVertices === 0, Ya = x || R.numIconVertices === 0;
      !Ct && !Ya ? he = $ = he && $ : Ya ? Ct || (he = he && $) : $ = he && $;
      let Lo = $ && st.placeable, Li = he && dt.placeable;
      if (Lo && (Ze && Ze.placeable && cr ? this.collisionIndex.insertCollisionBox(st.box, b, o.get("text-ignore-placement"), i.bucketInstanceId, cr, d.ID) : this.collisionIndex.insertCollisionBox(st.box, b, o.get("text-ignore-placement"), i.bucketInstanceId, zt, d.ID)), Li && this.collisionIndex.insertCollisionBox(dt.box, P, o.get("icon-ignore-placement"), i.bucketInstanceId, rn, d.ID), vt && $ && this.collisionIndex.insertCollisionCircles(vt.circles, b, o.get("text-ignore-placement"), i.bucketInstanceId, zt, d.ID), n && this.storeCollisionData(i.bucketInstanceId, W, H, st, dt, vt), R.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
      if (i.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
      let xn = ($ || E) && !st?.occluded, Do = (he || L) && !dt?.occluded;
      this.placements[R.crossTileID] = new yh(xn, Do, Xe || i.justReloaded), r3[R.crossTileID] = true;
    };
    if (A) {
      if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
      let R = i.getSortedSymbolIndexes(-this.transform.bearingInRadians);
      for (let H = R.length - 1; H >= 0; --H) {
        let W = R[H];
        I(i.symbolInstances.get(W), i.collisionArrays[W], W);
      }
    } else for (let R = e.symbolInstanceStart; R < e.symbolInstanceEnd; R++) I(i.symbolInstances.get(R), i.collisionArrays[R], R);
    i.justReloaded = false;
  }
  storeCollisionData(e, r3, n, i, o, a) {
    if (n.textBox || n.iconBox) {
      let s3;
      this.collisionBoxArrays.has(e) ? s3 = this.collisionBoxArrays.get(e) : (s3 = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e, s3));
      let l;
      s3.has(r3) ? l = s3.get(r3) : (l = { text: null, icon: null }, s3.set(r3, l)), n.textBox && (l.text = i.box), n.iconBox && (l.icon = o.box);
    }
    if (a) {
      let s3 = this.collisionCircleArrays[e];
      s3 === void 0 && (s3 = this.collisionCircleArrays[e] = []);
      for (let l = 0; l < a.circles.length; l += 4) s3.push(a.circles[l + 0] - He), s3.push(a.circles[l + 1] - He), s3.push(a.circles[l + 2]), s3.push(a.collisionDetected ? 1 : 0);
    }
  }
  markUsedJustification(e, r3, n, i) {
    let o = { left: n.leftJustifiedTextSymbolIndex, center: n.centerJustifiedTextSymbolIndex, right: n.rightJustifiedTextSymbolIndex }, a;
    i === 2 ? a = n.verticalPlacedTextSymbolIndex : a = o[nP(r3)];
    let s3 = [n.leftJustifiedTextSymbolIndex, n.centerJustifiedTextSymbolIndex, n.rightJustifiedTextSymbolIndex, n.verticalPlacedTextSymbolIndex];
    for (let l of s3) l >= 0 && (a >= 0 && l !== a ? e.text.placedSymbolArray.get(l).crossTileID = 0 : e.text.placedSymbolArray.get(l).crossTileID = n.crossTileID);
  }
  markUsedOrientation(e, r3, n) {
    let i = r3 === 1 || r3 === 3 ? r3 : 0, o = r3 === 2 ? r3 : 0, a = [n.leftJustifiedTextSymbolIndex, n.centerJustifiedTextSymbolIndex, n.rightJustifiedTextSymbolIndex];
    for (let s3 of a) e.text.placedSymbolArray.get(s3).placedOrientation = i;
    n.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(n.verticalPlacedTextSymbolIndex).placedOrientation = o);
  }
  commit(e) {
    this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
    let r3 = this.prevPlacement, n = false;
    this.prevZoomAdjustment = r3 ? r3.zoomAdjustment(this.transform.zoom) : 0;
    let i = r3 ? r3.symbolFadeChange(e) : 1, o = r3 ? r3.opacities : {}, a = r3 ? r3.variableOffsets : {}, s3 = r3 ? r3.placedOrientations : {};
    for (let l in this.placements) {
      let u3 = this.placements[l], c = o[l];
      c ? (this.opacities[l] = new go(c, i, u3.text, u3.icon), n = n || u3.text !== c.text.placed || u3.icon !== c.icon.placed) : (this.opacities[l] = new go(null, i, u3.text, u3.icon, u3.skipFade), n = n || u3.text || u3.icon);
    }
    for (let l in o) {
      let u3 = o[l];
      if (!this.opacities[l]) {
        let c = new go(u3, i, false, false);
        c.isHidden() || (this.opacities[l] = c, n = n || u3.text.placed || u3.icon.placed);
      }
    }
    for (let l in a) !this.variableOffsets[l] && this.opacities[l] && !this.opacities[l].isHidden() && (this.variableOffsets[l] = a[l]);
    for (let l in s3) !this.placedOrientations[l] && this.opacities[l] && !this.opacities[l].isHidden() && (this.placedOrientations[l] = s3[l]);
    if (r3 && r3.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
    n ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = r3 ? r3.lastPlacementChangeTime : e);
  }
  updateLayerOpacities(e, r3) {
    let n = {};
    for (let i of r3) {
      let o = i.getBucket(e);
      o && i.latestFeatureIndex && e.id === o.layerIds[0] && this.updateBucketOpacities(o, i.tileID, n, i.collisionBoxArray);
    }
  }
  updateBucketOpacities(e, r3, n, i) {
    e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = false), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = false), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
    let o = e.layers[0], a = o.layout, s3 = new go(null, 0, false, false, true), l = a.get("text-allow-overlap"), u3 = a.get("icon-allow-overlap"), c = o._unevaluatedLayout.hasValue("text-variable-anchor") || o._unevaluatedLayout.hasValue("text-variable-anchor-offset"), p = a.get("text-rotation-alignment") === "map", h = a.get("text-pitch-alignment") === "map", f = a.get("icon-text-fit") !== "none", d = new go(null, 0, l && (u3 || !e.hasIconData() || a.get("icon-optional")), u3 && (l || !e.hasTextData() || a.get("text-optional")), true);
    !e.collisionArrays && i && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(i);
    let g = (b, v3, P) => {
      for (let w3 = 0; w3 < v3 / 4; w3++) b.opacityVertexArray.emplaceBack(P);
      b.hasVisibleVertices = b.hasVisibleVertices || P !== Xl;
    }, x = this.collisionBoxArrays.get(e.bucketInstanceId);
    for (let b = 0; b < e.symbolInstances.length; b++) {
      let v3 = e.symbolInstances.get(b), { numHorizontalGlyphVertices: P, numVerticalGlyphVertices: w3, crossTileID: T } = v3, S = n[T], C3 = this.opacities[T];
      S ? C3 = s3 : C3 || (C3 = d, this.opacities[T] = C3), n[T] = true;
      let A = P > 0 || w3 > 0, E = v3.numIconVertices > 0, L = this.placedOrientations[v3.crossTileID], F = L === 2, O = L === 1 || L === 3;
      if (A) {
        let I = aP(C3.text), R = F ? Xl : I;
        g(e.text, P, R);
        let H = O ? Xl : I;
        g(e.text, w3, H);
        let W = C3.text.isHidden();
        [v3.rightJustifiedTextSymbolIndex, v3.centerJustifiedTextSymbolIndex, v3.leftJustifiedTextSymbolIndex].forEach((Xe) => {
          Xe >= 0 && (e.text.placedSymbolArray.get(Xe).hidden = W || F ? 1 : 0);
        }), v3.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(v3.verticalPlacedTextSymbolIndex).hidden = W || O ? 1 : 0);
        let $ = this.variableOffsets[v3.crossTileID];
        $ && this.markUsedJustification(e, $.anchor, v3, L);
        let he = this.placedOrientations[v3.crossTileID];
        he && (this.markUsedJustification(e, "left", v3, he), this.markUsedOrientation(e, he, v3));
      }
      if (E) {
        let I = aP(C3.icon), R = !(f && v3.verticalPlacedIconSymbolIndex && F);
        if (v3.placedIconSymbolIndex >= 0) {
          let H = R ? I : Xl;
          g(e.icon, v3.numIconVertices, H), e.icon.placedSymbolArray.get(v3.placedIconSymbolIndex).hidden = C3.icon.isHidden();
        }
        if (v3.verticalPlacedIconSymbolIndex >= 0) {
          let H = R ? Xl : I;
          g(e.icon, v3.numVerticalIconVertices, H), e.icon.placedSymbolArray.get(v3.verticalPlacedIconSymbolIndex).hidden = C3.icon.isHidden();
        }
      }
      let z = x && x.has(b) ? x.get(b) : { text: null, icon: null };
      if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
        let I = e.collisionArrays[b];
        if (I) {
          let R = new Vy.default(0, 0);
          if (I.textBox || I.verticalTextBox) {
            let H = true;
            if (c) {
              let W = this.variableOffsets[T];
              W ? (R = iP(W.anchor, W.width, W.height, W.textOffset, W.textBoxScale), p && R._rotate(h ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : H = false;
            }
            if (I.textBox || I.verticalTextBox) {
              let W;
              I.textBox && (W = F), I.verticalTextBox && (W = O), oP(e.textCollisionBox.collisionVertexArray, C3.text.placed, !H || W, z.text, R.x, R.y);
            }
          }
          if (I.iconBox || I.verticalIconBox) {
            let H = !!(!O && I.verticalIconBox), W;
            I.iconBox && (W = H), I.verticalIconBox && (W = !H), oP(e.iconCollisionBox.collisionVertexArray, C3.icon.placed, W, z.icon, f ? R.x : 0, f ? R.y : 0);
          }
        }
      }
    }
    if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
    if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
    e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId]);
  }
  symbolFadeChange(e) {
    return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
  }
  zoomAdjustment(e) {
    return Math.max(0, (this.transform.zoom - e) / 1.5);
  }
  hasTransitions(e) {
    return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
  }
  stillRecent(e, r3) {
    let n = this.zoomAtLastRecencyCheck === r3 ? 1 - this.zoomAdjustment(r3) : 1;
    return this.zoomAtLastRecencyCheck = r3, this.commitTime + this.fadeDuration * n > e;
  }
  setStale() {
    this.stale = true;
  }
};
function oP(t63, e, r3, n, i, o) {
  (!n || n.length === 0) && (n = [0, 0, 0, 0]);
  let a = n[0] - He, s3 = n[1] - He, l = n[2] - He, u3 = n[3] - He;
  t63.emplaceBack(e ? 1 : 0, r3 ? 1 : 0, i || 0, o || 0, a, s3), t63.emplaceBack(e ? 1 : 0, r3 ? 1 : 0, i || 0, o || 0, l, s3), t63.emplaceBack(e ? 1 : 0, r3 ? 1 : 0, i || 0, o || 0, l, u3), t63.emplaceBack(e ? 1 : 0, r3 ? 1 : 0, i || 0, o || 0, a, u3);
}
var CO = Math.pow(2, 25);
var MO = Math.pow(2, 24);
var IO = Math.pow(2, 17);
var AO = Math.pow(2, 16);
var EO = Math.pow(2, 9);
var LO = Math.pow(2, 8);
var DO = Math.pow(2, 1);
function aP(t63) {
  if (t63.opacity === 0 && !t63.placed) return 0;
  if (t63.opacity === 1 && t63.placed) return 4294967295;
  let e = t63.placed ? 1 : 0, r3 = Math.floor(t63.opacity * 127);
  return r3 * CO + e * MO + r3 * IO + e * AO + r3 * EO + e * LO + r3 * DO + e;
}
var Xl = 0;
var Uy = class {
  constructor(e) {
    this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
  }
  continuePlacement(e, r3, n, i, o) {
    let a = this._bucketParts;
    for (; this._currentTileIndex < e.length; ) {
      let s3 = e[this._currentTileIndex];
      if (r3.getBucketParts(a, i, s3, this._sortAcrossTiles), this._currentTileIndex++, o()) return true;
    }
    for (this._sortAcrossTiles && (this._sortAcrossTiles = false, a.sort((s3, l) => s3.sortKey - l.sortKey)); this._currentPartIndex < a.length; ) {
      let s3 = a[this._currentPartIndex];
      if (r3.placeLayerBucketPart(s3, this._seenCrossTileIDs, n), this._currentPartIndex++, o()) return true;
    }
    return false;
  }
};
var xh = class {
  constructor(e, r3, n, i, o, a, s3, l) {
    this.placement = new gh(e, r3, a, s3, l), this._currentPlacementIndex = n.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = o, this._done = false;
  }
  isDone() {
    return this._done;
  }
  continuePlacement(e, r3, n) {
    let i = ae.now(), o = () => this._forceFullPlacement ? false : ae.now() - i > 2;
    for (; this._currentPlacementIndex >= 0; ) {
      let a = e[this._currentPlacementIndex], s3 = r3[a], l = this.placement.collisionIndex.transform.zoom;
      if (s3.type === "symbol" && (!s3.minzoom || s3.minzoom <= l) && (!s3.maxzoom || s3.maxzoom > l)) {
        if (this._inProgressLayer || (this._inProgressLayer = new Uy(s3)), this._inProgressLayer.continuePlacement(n[s3.source], this.placement, this._showCollisionBoxes, s3, o)) return;
        delete this._inProgressLayer;
      }
      this._currentPlacementIndex--;
    }
    this._done = true;
  }
  commit(e) {
    return this.placement.commit(e), this.placement;
  }
};
$i();
$i();
var sP = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
var Ny = 1;
var Zl = 8;
var Yl = class t52 {
  static from(e) {
    if (!(e instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
    let [r3, n] = new Uint8Array(e, 0, 2);
    if (r3 !== 219) throw new Error("Data does not appear to be in a KDBush format.");
    let i = n >> 4;
    if (i !== Ny) throw new Error(`Got v${i} data when expected v${Ny}.`);
    let o = sP[n & 15];
    if (!o) throw new Error("Unrecognized array type.");
    let [a] = new Uint16Array(e, 2, 1), [s3] = new Uint32Array(e, 4, 1);
    return new t52(s3, a, o, e);
  }
  constructor(e, r3 = 64, n = Float64Array, i) {
    if (isNaN(e) || e < 0) throw new Error(`Unpexpected numItems value: ${e}.`);
    this.numItems = +e, this.nodeSize = Math.min(Math.max(+r3, 2), 65535), this.ArrayType = n, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
    let o = sP.indexOf(this.ArrayType), a = e * 2 * this.ArrayType.BYTES_PER_ELEMENT, s3 = e * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s3 % 8) % 8;
    if (o < 0) throw new Error(`Unexpected typed array class: ${n}.`);
    i && i instanceof ArrayBuffer ? (this.data = i, this.ids = new this.IndexArrayType(this.data, Zl, e), this.coords = new this.ArrayType(this.data, Zl + s3 + l, e * 2), this._pos = e * 2, this._finished = true) : (this.data = new ArrayBuffer(Zl + a + s3 + l), this.ids = new this.IndexArrayType(this.data, Zl, e), this.coords = new this.ArrayType(this.data, Zl + s3 + l, e * 2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, (Ny << 4) + o]), new Uint16Array(this.data, 2, 1)[0] = r3, new Uint32Array(this.data, 4, 1)[0] = e);
  }
  add(e, r3) {
    let n = this._pos >> 1;
    return this.ids[n] = n, this.coords[this._pos++] = e, this.coords[this._pos++] = r3, n;
  }
  finish() {
    let e = this._pos >> 1;
    if (e !== this.numItems) throw new Error(`Added ${e} items when expected ${this.numItems}.`);
    return jy(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
  }
  range(e, r3, n, i) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    let { ids: o, coords: a, nodeSize: s3 } = this, l = [0, o.length - 1, 0], u3 = [];
    for (; l.length; ) {
      let c = l.pop() || 0, p = l.pop() || 0, h = l.pop() || 0;
      if (p - h <= s3) {
        for (let x = h; x <= p; x++) {
          let b = a[2 * x], v3 = a[2 * x + 1];
          b >= e && b <= n && v3 >= r3 && v3 <= i && u3.push(o[x]);
        }
        continue;
      }
      let f = h + p >> 1, d = a[2 * f], g = a[2 * f + 1];
      d >= e && d <= n && g >= r3 && g <= i && u3.push(o[f]), (c === 0 ? e <= d : r3 <= g) && (l.push(h), l.push(f - 1), l.push(1 - c)), (c === 0 ? n >= d : i >= g) && (l.push(f + 1), l.push(p), l.push(1 - c));
    }
    return u3;
  }
  within(e, r3, n) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    let { ids: i, coords: o, nodeSize: a } = this, s3 = [0, i.length - 1, 0], l = [], u3 = n * n;
    for (; s3.length; ) {
      let c = s3.pop() || 0, p = s3.pop() || 0, h = s3.pop() || 0;
      if (p - h <= a) {
        for (let x = h; x <= p; x++) lP(o[2 * x], o[2 * x + 1], e, r3) <= u3 && l.push(i[x]);
        continue;
      }
      let f = h + p >> 1, d = o[2 * f], g = o[2 * f + 1];
      lP(d, g, e, r3) <= u3 && l.push(i[f]), (c === 0 ? e - n <= d : r3 - n <= g) && (s3.push(h), s3.push(f - 1), s3.push(1 - c)), (c === 0 ? e + n >= d : r3 + n >= g) && (s3.push(f + 1), s3.push(p), s3.push(1 - c));
    }
    return l;
  }
};
function jy(t63, e, r3, n, i, o) {
  if (i - n <= r3) return;
  let a = n + i >> 1;
  uP(t63, e, a, n, i, o), jy(t63, e, r3, n, a - 1, 1 - o), jy(t63, e, r3, a + 1, i, 1 - o);
}
function uP(t63, e, r3, n, i, o) {
  for (; i > n; ) {
    if (i - n > 600) {
      let u3 = i - n + 1, c = r3 - n + 1, p = Math.log(u3), h = 0.5 * Math.exp(2 * p / 3), f = 0.5 * Math.sqrt(p * h * (u3 - h) / u3) * (c - u3 / 2 < 0 ? -1 : 1), d = Math.max(n, Math.floor(r3 - c * h / u3 + f)), g = Math.min(i, Math.floor(r3 + (u3 - c) * h / u3 + f));
      uP(t63, e, r3, d, g, o);
    }
    let a = e[2 * r3 + o], s3 = n, l = i;
    for (ql(t63, e, n, r3), e[2 * i + o] > a && ql(t63, e, n, i); s3 < l; ) {
      for (ql(t63, e, s3, l), s3++, l--; e[2 * s3 + o] < a; ) s3++;
      for (; e[2 * l + o] > a; ) l--;
    }
    e[2 * n + o] === a ? ql(t63, e, n, l) : (l++, ql(t63, e, l, i)), l <= r3 && (n = l + 1), r3 <= l && (i = l - 1);
  }
}
function ql(t63, e, r3, n) {
  Gy(t63, r3, n), Gy(e, 2 * r3, 2 * n), Gy(e, 2 * r3 + 1, 2 * n + 1);
}
function Gy(t63, e, r3) {
  let n = t63[e];
  t63[e] = t63[r3], t63[r3] = n;
}
function lP(t63, e, r3, n) {
  let i = t63 - r3, o = e - n;
  return i * i + o * o;
}
var Wl = 512 / 8192 / 2;
var RO = 128;
var Hy = class {
  constructor(e, r3, n) {
    this.tileID = e;
    this.bucketInstanceId = n;
    this._symbolsByKey = {};
    let i = /* @__PURE__ */ new Map();
    for (let o = 0; o < r3.length; o++) {
      let a = r3.get(o), s3 = a.key, l = i.get(s3);
      l ? l.push(a) : i.set(s3, [a]);
    }
    for (let [o, a] of i) {
      let s3 = a.map((c) => ({ x: Math.floor(c.anchorX * Wl), y: Math.floor(c.anchorY * Wl) })), l = a.map((c) => c.crossTileID), u3 = { positions: s3, crossTileIDs: l };
      if (u3.positions.length > RO) {
        let c = new Yl(u3.positions.length, 16, Uint16Array);
        for (let { x: p, y: h } of u3.positions) c.add(p, h);
        c.finish(), delete u3.positions, u3.index = c;
      }
      this._symbolsByKey[o] = u3;
    }
  }
  getScaledCoordinates(e, r3) {
    let { x: n, y: i, z: o } = this.tileID.canonical, { x: a, y: s3, z: l } = r3.canonical, u3 = l - o, c = Wl / Math.pow(2, u3), p = (a * 8192 + e.anchorX) * c, h = (s3 * 8192 + e.anchorY) * c, f = n * 8192 * Wl, d = i * 8192 * Wl;
    return { x: Math.floor(p - f), y: Math.floor(h - d) };
  }
  findMatches(e, r3, n) {
    let i = this.tileID.canonical.z < r3.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - r3.canonical.z);
    for (let o = 0; o < e.length; o++) {
      let a = e.get(o);
      if (a.crossTileID) continue;
      let s3 = this._symbolsByKey[a.key];
      if (!s3) continue;
      let l = this.getScaledCoordinates(a, r3);
      if (s3.index) {
        let u3 = s3.index.range(l.x - i, l.y - i, l.x + i, l.y + i).sort();
        for (let c of u3) {
          let p = s3.crossTileIDs[c];
          if (!n[p]) {
            n[p] = true, a.crossTileID = p;
            break;
          }
        }
      } else if (s3.positions) for (let u3 = 0; u3 < s3.positions.length; u3++) {
        let c = s3.positions[u3], p = s3.crossTileIDs[u3];
        if (Math.abs(c.x - l.x) <= i && Math.abs(c.y - l.y) <= i && !n[p]) {
          n[p] = true, a.crossTileID = p;
          break;
        }
      }
    }
  }
  getCrossTileIDsLists() {
    return Object.values(this._symbolsByKey).map(({ crossTileIDs: e }) => e);
  }
};
var Xy = class {
  constructor() {
    this.maxCrossTileID = 0;
  }
  generate() {
    return ++this.maxCrossTileID;
  }
};
var Zy = class {
  constructor() {
    this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
  }
  handleWrapJump(e) {
    let r3 = Math.round((e - this.lng) / 360);
    if (r3 !== 0) for (let n in this.indexes) {
      let i = this.indexes[n], o = {};
      for (let a in i) {
        let s3 = i[a];
        s3.tileID = s3.tileID.unwrapTo(s3.tileID.wrap + r3), o[s3.tileID.key] = s3;
      }
      this.indexes[n] = o;
    }
    this.lng = e;
  }
  addBucket(e, r3, n) {
    if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
      if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === r3.bucketInstanceId) return false;
      this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
    }
    for (let o = 0; o < r3.symbolInstances.length; o++) {
      let a = r3.symbolInstances.get(o);
      a.crossTileID = 0;
    }
    this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
    let i = this.usedCrossTileIDs[e.overscaledZ];
    for (let o in this.indexes) {
      let a = this.indexes[o];
      if (Number(o) > e.overscaledZ) for (let s3 in a) {
        let l = a[s3];
        l.tileID.isChildOf(e) && l.findMatches(r3.symbolInstances, e, i);
      }
      else {
        let s3 = e.scaledTo(Number(o)), l = a[s3.key];
        l && l.findMatches(r3.symbolInstances, e, i);
      }
    }
    for (let o = 0; o < r3.symbolInstances.length; o++) {
      let a = r3.symbolInstances.get(o);
      a.crossTileID || (a.crossTileID = n.generate(), i[a.crossTileID] = true);
    }
    return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Hy(e, r3.symbolInstances, r3.bucketInstanceId), true;
  }
  removeBucketCrossTileIDs(e, r3) {
    for (let n of r3.getCrossTileIDsLists()) for (let i of n) delete this.usedCrossTileIDs[e][i];
  }
  removeStaleBuckets(e) {
    let r3 = false;
    for (let n in this.indexes) {
      let i = this.indexes[n];
      for (let o in i) e[i[o].bucketInstanceId] || (this.removeBucketCrossTileIDs(n, i[o]), delete i[o], r3 = true);
    }
    return r3;
  }
};
var wa = class {
  constructor() {
    this.layerIndexes = {}, this.crossTileIDs = new Xy(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
  }
  addLayer(e, r3, n) {
    let i = this.layerIndexes[e.id];
    i === void 0 && (i = this.layerIndexes[e.id] = new Zy());
    let o = false, a = {};
    i.handleWrapJump(n);
    for (let s3 of r3) {
      let l = s3.getBucket(e);
      !l || e.id !== l.layerIds[0] || (l.bucketInstanceId || (l.bucketInstanceId = ++this.maxBucketInstanceId), i.addBucket(s3.tileID, l, this.crossTileIDs) && (o = true), a[l.bucketInstanceId] = true);
    }
    return i.removeStaleBuckets(a) && (o = true), o;
  }
  pruneUnusedLayers(e) {
    let r3 = {};
    e.forEach((n) => {
      r3[n] = true;
    });
    for (let n in this.layerIndexes) r3[n] || delete this.layerIndexes[n];
  }
};
$i();
$i();
$i();
$i();
var cP = `#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`;
$i();
var pP = `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`;
$i();
var hP = `uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var fP = "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}";
$i();
var mP = `uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var dP = "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}";
$i();
var yP = `in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var gP = `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`;
$i();
var qy = "void main() {fragColor=vec4(1.0);}";
$i();
var xP = "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}";
$i();
var bP = `uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var _P = `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`;
$i();
var vP = `uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`;
$i();
var PP = "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}";
$i();
var wP = "in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}";
$i();
var TP = "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}";
$i();
var SP = "in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}";
$i();
var CP = "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}";
$i();
var MP = `#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(textureSize(u_elevation_stops,0)[0]);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int num_elevation_stops=textureSize(u_elevation_stops,0)[0];int r=(num_elevation_stops-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(textureSize(u_color_stops,0)[0]);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var IP = "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}";
$i();
var AP = "uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}";
$i();
var EP = "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}";
$i();
var LP = `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`;
$i();
var DP = `#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var RP = `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`;
$i();
var kP = `in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var FP = `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`;
$i();
var OP = `uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var BP = `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`;
$i();
var zP = `#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var VP = `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`;
$i();
var UP = `in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var NP = `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`;
$i();
var GP = `uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var jP = `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`;
$i();
var HP = `#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var XP = "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}";
$i();
var ZP = `uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;switch(u_method){case BASIC:
basic_hillshade(deriv);break;case COMBINED:
combined_hillshade(deriv);break;case IGOR:
igor_hillshade(deriv);break;case MULTIDIRECTIONAL:
multidirectional_hillshade(deriv);break;case STANDARD:
default:
standard_hillshade(deriv);break;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var qP = "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}";
$i();
var YP = `uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var WP = `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`;
$i();
var $P = `uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var KP = `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`;
$i();
var JP = `#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var QP = `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`;
$i();
var ew = `uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var tw = `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`;
$i();
var rw = `uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var nw = `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`;
$i();
var iw = `uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var ow = `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`;
$i();
var aw = `#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var sw = `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`;
$i();
var lw = `#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`;
$i();
var uw = `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`;
$i();
var cw = "in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}";
$i();
var pw = "precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}";
$i();
var hw = "uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}";
$i();
var fw = "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}";
$i();
var mw = "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}";
$i();
var dw = "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}";
$i();
var yw = "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}";
$i();
var gw = "in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}";
$i();
var xw = "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}";
$i();
var bw = `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`;
$i();
var _w = `in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`;
$i();
var vw = "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}";
$i();
var Pw = "uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}";
$i();
var ww = "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}";
var or = { prelude: Ie2(cP, pP), projectionMercator: Ie2("", xw), projectionGlobe: Ie2("", bw), background: Ie2(hP, fP), backgroundPattern: Ie2(mP, dP), circle: Ie2(yP, gP), clippingMask: Ie2(qy, xP), heatmap: Ie2(bP, _P), heatmapTexture: Ie2(vP, PP), collisionBox: Ie2(wP, TP), collisionCircle: Ie2(SP, CP), colorRelief: Ie2(MP, IP), debug: Ie2(AP, EP), depth: Ie2(qy, LP), fill: Ie2(DP, RP), fillOutline: Ie2(kP, FP), fillOutlinePattern: Ie2(OP, BP), fillPattern: Ie2(zP, VP), fillExtrusion: Ie2(UP, NP), fillExtrusionPattern: Ie2(GP, jP), hillshadePrepare: Ie2(HP, XP), hillshade: Ie2(ZP, qP), line: Ie2(YP, WP), lineGradient: Ie2($P, KP), linePattern: Ie2(JP, QP), lineSDF: Ie2(ew, tw), raster: Ie2(rw, nw), symbolIcon: Ie2(iw, ow), symbolSDF: Ie2(aw, sw), symbolTextAndIcon: Ie2(lw, uw), terrain: Ie2(hw, fw), terrainDepth: Ie2(cw, mw), terrainCoords: Ie2(pw, dw), projectionErrorMeasurement: Ie2(gw, yw), atmosphere: Ie2(_w, vw), sky: Ie2(Pw, ww) };
function Ie2(t63, e) {
  let r3 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, n = e.match(/in ([\w]+) ([\w]+)/g), i = t63.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), a = o ? o.concat(i) : i, s3 = {};
  return t63 = t63.replace(r3, (l, u3, c, p, h) => (s3[h] = true, u3 === "define" ? `
#ifndef HAS_UNIFORM_u_${h}
in ${c} ${p} ${h};
#else
uniform ${c} ${p} u_${h};
#endif
` : `
#ifdef HAS_UNIFORM_u_${h}
    ${c} ${p} ${h} = u_${h};
#endif
`)), e = e.replace(r3, (l, u3, c, p, h) => {
    let f = p === "float" ? "vec2" : "vec4", d = h.match(/color/) ? "color" : f;
    return s3[h] ? u3 === "define" ? `
#ifndef HAS_UNIFORM_u_${h}
uniform lowp float u_${h}_t;
in ${c} ${f} a_${h};
out ${c} ${p} ${h};
#else
uniform ${c} ${p} u_${h};
#endif
` : d === "vec4" ? `
#ifndef HAS_UNIFORM_u_${h}
    ${h} = a_${h};
#else
    ${c} ${p} ${h} = u_${h};
#endif
` : `
#ifndef HAS_UNIFORM_u_${h}
    ${h} = unpack_mix_${d}(a_${h}, u_${h}_t);
#else
    ${c} ${p} ${h} = u_${h};
#endif
` : u3 === "define" ? `
#ifndef HAS_UNIFORM_u_${h}
uniform lowp float u_${h}_t;
in ${c} ${f} a_${h};
#else
uniform ${c} ${p} u_${h};
#endif
` : d === "vec4" ? `
#ifndef HAS_UNIFORM_u_${h}
    ${c} ${p} ${h} = a_${h};
#else
    ${c} ${p} ${h} = u_${h};
#endif
` : `
#ifndef HAS_UNIFORM_u_${h}
    ${c} ${p} ${h} = unpack_mix_${d}(a_${h}, u_${h}_t);
#else
    ${c} ${p} ${h} = u_${h};
#endif
`;
  }), { fragmentSource: t63, vertexSource: e, staticAttributes: n, staticUniforms: a };
}
function Tw(t63) {
  return t63.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
}
function Sw(t63) {
  return t63.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
}
$i();
var ar = class {
  constructor(e, r3, n) {
    this.vertexBuffer = e, this.indexBuffer = r3, this.segments = n;
  }
  destroy() {
    this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
  }
};
$i();
var Pr = ze([{ name: "a_pos", type: "Int16", components: 2 }]);
var Yy = "#define PROJECTION_MERCATOR";
var Wy = "mercator";
var xo = class {
  constructor() {
    this._cachedMesh = null;
  }
  get name() {
    return "mercator";
  }
  get useSubdivision() {
    return false;
  }
  get shaderVariantName() {
    return Wy;
  }
  get shaderDefine() {
    return Yy;
  }
  get shaderPreludeCode() {
    return or.projectionMercator;
  }
  get vertexShaderPreludeCode() {
    return or.projectionMercator.vertexSource;
  }
  get subdivisionGranularity() {
    return fi.noSubdivision;
  }
  get useGlobeControls() {
    return false;
  }
  get transitionState() {
    return 0;
  }
  get latitudeErrorCorrectionRadians() {
    return 0;
  }
  destroy() {
  }
  updateGPUdependent(e) {
  }
  getMeshFromTileID(e, r3, n, i, o) {
    if (this._cachedMesh) return this._cachedMesh;
    let a = new Et();
    a.emplaceBack(0, 0), a.emplaceBack(8192, 0), a.emplaceBack(0, 8192), a.emplaceBack(8192, 8192);
    let s3 = e.createVertexBuffer(a, Pr.members), l = de2.simpleSegment(0, 0, 4, 2), u3 = new Qe();
    u3.emplaceBack(1, 0, 2), u3.emplaceBack(1, 2, 3);
    let c = e.createIndexBuffer(u3);
    return this._cachedMesh = new ar(s3, c, l), this._cachedMesh;
  }
  recalculate() {
  }
  hasTransition() {
    return false;
  }
  setErrorQueryLatitudeDegrees(e) {
  }
};
$i();
var sr = s(fe(), 1);
$i();
var vi = s(fe(), 1);
$i();
var Cw = s(fe(), 1);
var Ta = class t53 {
  constructor(e = 0, r3 = 0, n = 0, i = 0) {
    if (isNaN(e) || e < 0 || isNaN(r3) || r3 < 0 || isNaN(n) || n < 0 || isNaN(i) || i < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
    this.top = e, this.bottom = r3, this.left = n, this.right = i;
  }
  interpolate(e, r3, n) {
    return r3.top != null && e.top != null && (this.top = Fe.number(e.top, r3.top, n)), r3.bottom != null && e.bottom != null && (this.bottom = Fe.number(e.bottom, r3.bottom, n)), r3.left != null && e.left != null && (this.left = Fe.number(e.left, r3.left, n)), r3.right != null && e.right != null && (this.right = Fe.number(e.right, r3.right, n)), this;
  }
  getCenter(e, r3) {
    let n = ce((this.left + e - this.right) / 2, 0, e), i = ce((this.top + r3 - this.bottom) / 2, 0, r3);
    return new Cw.default(n, i);
  }
  equals(e) {
    return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
  }
  clone() {
    return new t53(this.top, this.bottom, this.left, this.right);
  }
  toJSON() {
    return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
  }
};
function Sa(t63, e) {
  if (!t63.renderWorldCopies || t63.lngRange) return;
  let r3 = e.lng - t63.center.lng;
  e.lng += r3 > 180 ? -360 : r3 < -180 ? 360 : 0;
}
function Mw(t63) {
  return Math.max(0, Math.floor(t63));
}
var Pi = class {
  constructor(e, r3, n, i, o, a) {
    this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = a === void 0 ? true : !!a, this._minZoom = r3 || 0, this._maxZoom = n || 22, this._minPitch = i ?? 0, this._maxPitch = o ?? 60, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new J(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Mw(this._zoom), this._scale = lt(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = true, this._edgeInsets = new Ta(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = true;
  }
  apply(e, r3, n) {
    this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = Mw(this._zoom), this._scale = lt(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new Ta(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !n && e.autoCalculateNearFarZ, r3 && this._constrain(), this._calcMatrices();
  }
  get pixelsToClipSpaceMatrix() {
    return this._pixelsToClipSpaceMatrix;
  }
  get clipSpaceToPixelsMatrix() {
    return this._clipSpaceToPixelsMatrix;
  }
  get minElevationForCurrentTile() {
    return this._minElevationForCurrentTile;
  }
  setMinElevationForCurrentTile(e) {
    this._minElevationForCurrentTile = e;
  }
  get tileSize() {
    return this._tileSize;
  }
  get tileZoom() {
    return this._tileZoom;
  }
  get scale() {
    return this._scale;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get bearingInRadians() {
    return this._bearingInRadians;
  }
  get lngRange() {
    return this._lngRange;
  }
  get latRange() {
    return this._latRange;
  }
  get pixelsToGLUnits() {
    return this._pixelsToGLUnits;
  }
  get minZoom() {
    return this._minZoom;
  }
  setMinZoom(e) {
    this._minZoom !== e && (this._minZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
  }
  get maxZoom() {
    return this._maxZoom;
  }
  setMaxZoom(e) {
    this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
  }
  get minPitch() {
    return this._minPitch;
  }
  setMinPitch(e) {
    this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)));
  }
  get maxPitch() {
    return this._maxPitch;
  }
  setMaxPitch(e) {
    this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)));
  }
  get renderWorldCopies() {
    return this._renderWorldCopies;
  }
  setRenderWorldCopies(e) {
    e === void 0 ? e = true : e === null && (e = false), this._renderWorldCopies = e;
  }
  get worldSize() {
    return this._tileSize * this._scale;
  }
  get centerOffset() {
    return this.centerPoint._sub(this.size._div(2));
  }
  get size() {
    return new vi.default(this._width, this._height);
  }
  get bearing() {
    return this._bearingInRadians / Math.PI * 180;
  }
  setBearing(e) {
    let r3 = Rr(e, -180, 180) * Math.PI / 180;
    this._bearingInRadians !== r3 && (this._unmodified = false, this._bearingInRadians = r3, this._calcMatrices(), this._rotationMatrix = qn.create(), qn.rotate(this._rotationMatrix, this._rotationMatrix, -this._bearingInRadians));
  }
  get rotationMatrix() {
    return this._rotationMatrix;
  }
  get pitchInRadians() {
    return this._pitchInRadians;
  }
  get pitch() {
    return this._pitchInRadians / Math.PI * 180;
  }
  setPitch(e) {
    let r3 = ce(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
    this._pitchInRadians !== r3 && (this._unmodified = false, this._pitchInRadians = r3, this._calcMatrices());
  }
  get rollInRadians() {
    return this._rollInRadians;
  }
  get roll() {
    return this._rollInRadians / Math.PI * 180;
  }
  setRoll(e) {
    let r3 = e / 180 * Math.PI;
    this._rollInRadians !== r3 && (this._unmodified = false, this._rollInRadians = r3, this._calcMatrices());
  }
  get fovInRadians() {
    return this._fovInRadians;
  }
  get fov() {
    return Ui(this._fovInRadians);
  }
  setFov(e) {
    e = ce(e, 0.1, 150), this.fov !== e && (this._unmodified = false, this._fovInRadians = Ve(e), this._calcMatrices());
  }
  get zoom() {
    return this._zoom;
  }
  setZoom(e) {
    let r3 = this.getConstrained(this._center, e).zoom;
    this._zoom !== r3 && (this._unmodified = false, this._zoom = r3, this._tileZoom = Math.max(0, Math.floor(r3)), this._scale = lt(r3), this._constrain(), this._calcMatrices());
  }
  get center() {
    return this._center;
  }
  setCenter(e) {
    e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = false, this._center = e, this._constrain(), this._calcMatrices());
  }
  get elevation() {
    return this._elevation;
  }
  setElevation(e) {
    e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices());
  }
  get padding() {
    return this._edgeInsets.toJSON();
  }
  setPadding(e) {
    this._edgeInsets.equals(e) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
  }
  get centerPoint() {
    return this._edgeInsets.getCenter(this._width, this._height);
  }
  get pixelsPerMeter() {
    return this._pixelPerMeter;
  }
  get unmodified() {
    return this._unmodified;
  }
  get cameraToCenterDistance() {
    return this._cameraToCenterDistance;
  }
  get nearZ() {
    return this._nearZ;
  }
  get farZ() {
    return this._farZ;
  }
  get autoCalculateNearFarZ() {
    return this._autoCalculateNearFarZ;
  }
  overrideNearFarZ(e, r3) {
    this._autoCalculateNearFarZ = false, this._nearZ = e, this._farZ = r3, this._calcMatrices();
  }
  clearNearFarZOverride() {
    this._autoCalculateNearFarZ = true, this._calcMatrices();
  }
  isPaddingEqual(e) {
    return this._edgeInsets.equals(e);
  }
  interpolatePadding(e, r3, n) {
    this._unmodified = false, this._edgeInsets.interpolate(e, r3, n), this._constrain(), this._calcMatrices();
  }
  resize(e, r3, n = true) {
    this._width = e, this._height = r3, n && this._constrain(), this._calcMatrices();
  }
  getMaxBounds() {
    return !this._latRange || this._latRange.length !== 2 || !this._lngRange || this._lngRange.length !== 2 ? null : new mt([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]);
  }
  setMaxBounds(e) {
    e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-Nt2, Nt2]);
  }
  getConstrained(e, r3) {
    return this._callbacks.getConstrained(e, r3);
  }
  getCameraQueryGeometry(e, r3) {
    if (r3.length === 1) return [r3[0], e];
    {
      let { minX: n, minY: i, maxX: o, maxY: a } = Tt.fromPoints(r3).extend(e);
      return [new vi.default(n, i), new vi.default(o, i), new vi.default(o, a), new vi.default(n, a), new vi.default(n, i)];
    }
  }
  _constrain() {
    if (!this.center || !this._width || !this._height || this._constraining) return;
    this._constraining = true;
    let e = this._unmodified, { center: r3, zoom: n } = this.getConstrained(this.center, this.zoom);
    this.setCenter(r3), this.setZoom(n), this._unmodified = e, this._constraining = false;
  }
  _calcMatrices() {
    if (this._width && this._height) {
      this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
      let e = B.identity(new Float64Array(16));
      B.scale(e, e, [this._width / 2, -this._height / 2, 1]), B.translate(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = B.identity(new Float64Array(16)), B.scale(e, e, [1, -1, 1]), B.translate(e, e, [-1, -1, 0]), B.scale(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e;
      let r3 = this.fovInRadians / 2;
      this._cameraToCenterDistance = 0.5 / Math.tan(r3) * this._height;
    }
    this._callbacks.calcMatrices();
  }
  calculateCenterFromCameraLngLatAlt(e, r3, n, i) {
    let o = n !== void 0 ? n : this.bearing, a = i = i !== void 0 ? i : this.pitch, s3 = xe.fromLngLat(e, r3), l = -Math.cos(Ve(a)), u3 = Math.sin(Ve(a)), c = u3 * Math.sin(Ve(o)), p = -u3 * Math.cos(Ve(o)), h = this.elevation, f = r3 - h, d;
    l * f >= 0 || Math.abs(l) < 0.1 ? (d = 1e4, h = r3 + d * l) : d = -f / l;
    let g = rh(1, s3.y), x, b, v3 = 0, P = 10;
    do {
      if (v3 += 1, v3 > P) break;
      b = d / g;
      let S = c * b, C3 = p * b;
      x = new xe(s3.x + S, s3.y + C3), g = 1 / x.meterInMercatorCoordinateUnits();
    } while (Math.abs(d - b * g) > 1e-12);
    let w3 = x.toLngLat(), T = rt(this.height / 2 / Math.tan(this.fovInRadians / 2) / b / this.tileSize);
    return { center: w3, elevation: h, zoom: T };
  }
  recalculateZoomAndCenter(e) {
    if (this.elevation - e === 0) return;
    let r3 = dn(1, this.center.lat) * this.worldSize, n = this.cameraToCenterDistance / r3, i = xe.fromLngLat(this.center, this.elevation), o = Vl(this.center, this.elevation, this.pitch, this.bearing, n);
    this._elevation = e;
    let a = this.calculateCenterFromCameraLngLatAlt(o.toLngLat(), rh(o.z, i.y), this.bearing, this.pitch);
    this._elevation = a.elevation, this._center = a.center, this.setZoom(a.zoom);
  }
  getCameraPoint() {
    let e = this.pitchInRadians, r3 = Math.tan(e) * (this.cameraToCenterDistance || 1);
    return this.centerPoint.add(new vi.default(r3 * Math.sin(this.rollInRadians), r3 * Math.cos(this.rollInRadians)));
  }
  getCameraAltitude() {
    return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
  }
  getCameraLngLat() {
    let e = dn(1, this.center.lat) * this.worldSize, r3 = this.cameraToCenterDistance / e;
    return Vl(this.center, this.elevation, this.pitch, this.bearing, r3).toLngLat();
  }
  getMercatorTileCoordinates(e) {
    if (!e) return [0, 0, 1, 1];
    let r3 = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
    return [e.canonical.x / r3, e.canonical.y / r3, 1 / r3 / 8192, 1 / r3 / 8192];
  }
};
$i();
$i();
var Ca = class t54 {
  constructor(e, r3) {
    this.min = e, this.max = r3, this.center = V.scale([], V.add([], this.min, this.max), 0.5);
  }
  quadrant(e) {
    let r3 = [e % 2 === 0, e < 2], n = V.clone(this.min), i = V.clone(this.max);
    for (let o = 0; o < r3.length; o++) n[o] = r3[o] ? this.min[o] : this.center[o], i[o] = r3[o] ? this.center[o] : this.max[o];
    return i[2] = this.max[2], new t54(n, i);
  }
  distanceX(e) {
    return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
  }
  distanceY(e) {
    return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
  }
  intersectsFrustum(e) {
    let r3 = true;
    for (let n = 0; n < e.planes.length; n++) {
      let i = this.intersectsPlane(e.planes[n]);
      if (i === 0) return 0;
      i === 1 && (r3 = false);
    }
    return r3 ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1;
  }
  intersectsPlane(e) {
    let r3 = e[3], n = e[3];
    for (let i = 0; i < 3; i++) e[i] > 0 ? (r3 += e[i] * this.min[i], n += e[i] * this.max[i]) : (n += e[i] * this.min[i], r3 += e[i] * this.max[i]);
    return r3 >= 0 ? 2 : n < 0 ? 0 : 1;
  }
};
var bh = class {
  distanceToTile2d(e, r3, n, i) {
    let o = i.distanceX([e, r3]), a = i.distanceY([e, r3]);
    return Math.hypot(o, a);
  }
  getWrap(e, r3, n) {
    return n;
  }
  getTileBoundingVolume(e, r3, n, i) {
    let o = 0, a = 0;
    if (i?.terrain) {
      let l = new Ye2(e.z, r3, e.z, e.x, e.y), u3 = i.terrain.getMinMaxElevation(l);
      o = u3.minElevation ?? Math.min(0, n), a = u3.maxElevation ?? Math.max(0, n);
    }
    let s3 = 1 << e.z;
    return new Ca([r3 + e.x / s3, e.y / s3, o], [r3 + (e.x + 1) / s3, (e.y + 1) / s3, a]);
  }
  allowVariableZoom(e, r3) {
    let n = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height, i = ce(78.5 - n / 2, 0, 60);
    return !!r3.terrain || e.pitch > i;
  }
  allowWorldCopies() {
    return true;
  }
  prepareNextFrame() {
  }
};
$i();
var Ma = class t55 {
  constructor(e, r3, n) {
    this.points = e;
    this.planes = r3;
    this.aabb = n;
  }
  static fromInvProjectionMatrix(e, r3 = 1, n = 0, i, o) {
    let a = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]], s3 = o ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], l = Math.pow(2, n), u3 = a.map((f) => kO(f, e, r3, l));
    i && FO(u3, s3[0], i, o);
    let c = s3.map((f) => {
      let d = V.sub([], u3[f[0]], u3[f[1]]), g = V.sub([], u3[f[2]], u3[f[1]]), x = V.normalize([], V.cross([], d, g)), b = -V.dot(x, u3[f[1]]);
      return x.concat(b);
    }), p = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], h = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
    for (let f of u3) for (let d = 0; d < 3; d++) p[d] = Math.min(p[d], f[d]), h[d] = Math.max(h[d], f[d]);
    return new t55(u3, c, new Ca(p, h));
  }
};
function kO(t63, e, r3, n) {
  let i = Ne.transformMat4([], t63, e), o = 1 / i[3] / r3 * n;
  return Ne.mul(i, i, [o, o, 1 / i[3], o]);
}
function FO(t63, e, r3, n) {
  let i = n ? 4 : 0, o = n ? 0 : 4, a = 0, s3 = [], l = [];
  for (let p = 0; p < 4; p++) {
    let h = V.sub([], t63[p + o], t63[p + i]), f = V.length(h);
    V.scale(h, h, 1 / f), s3.push(f), l.push(h);
  }
  for (let p = 0; p < 4; p++) {
    let h = Rb(t63[p + i], l[p], r3);
    h !== null && h >= 0 ? a = Math.max(a, h) : a = Math.max(a, s3[p]);
  }
  let u3 = OO(t63, e), c = BO(r3, u3);
  if (c !== null) {
    let p = c / V.dot(l[0], u3);
    a = Math.min(a, p);
  }
  for (let p = 0; p < 4; p++) {
    let h = Math.min(a, s3[p]), f = [t63[p + i][0] + l[p][0] * h, t63[p + i][1] + l[p][1] * h, t63[p + i][2] + l[p][2] * h, 1];
    t63[p + o] = f;
  }
}
function OO(t63, e) {
  let r3 = V.sub([], t63[e[0]], t63[e[1]]), n = V.sub([], t63[e[2]], t63[e[1]]), i = [0, 0, 0, 0];
  return V.normalize(i, V.cross([], r3, n)), i[3] = -V.dot(i, t63[e[0]]), i;
}
function BO(t63, e) {
  let r3 = V.len(t63), n = Ne.scale([], t63, 1 / r3), i = V.sub([], e, V.scale([], n, V.dot(e, n))), o = V.len(i);
  if (o > 0) {
    let a = Math.sqrt(1 - n[3] * n[3]), s3 = V.scale([], n, -n[3]), l = V.add([], s3, V.scale([], i, a / o));
    return ts(e, l);
  } else return null;
}
var Fn = class t56 {
  constructor(e, r3, n, i, o) {
    this._posMatrixCache = /* @__PURE__ */ new Map();
    this._alignedPosMatrixCache = /* @__PURE__ */ new Map();
    this._fogMatrixCacheF32 = /* @__PURE__ */ new Map();
    this._helper = new Pi({ calcMatrices: () => {
      this._calcMatrices();
    }, getConstrained: (a, s3) => this.getConstrained(a, s3) }, e, r3, n, i, o), this._coveringTilesDetailsProvider = new bh();
  }
  get pixelsToClipSpaceMatrix() {
    return this._helper.pixelsToClipSpaceMatrix;
  }
  get clipSpaceToPixelsMatrix() {
    return this._helper.clipSpaceToPixelsMatrix;
  }
  get pixelsToGLUnits() {
    return this._helper.pixelsToGLUnits;
  }
  get centerOffset() {
    return this._helper.centerOffset;
  }
  get size() {
    return this._helper.size;
  }
  get rotationMatrix() {
    return this._helper.rotationMatrix;
  }
  get centerPoint() {
    return this._helper.centerPoint;
  }
  get pixelsPerMeter() {
    return this._helper.pixelsPerMeter;
  }
  setMinZoom(e) {
    this._helper.setMinZoom(e);
  }
  setMaxZoom(e) {
    this._helper.setMaxZoom(e);
  }
  setMinPitch(e) {
    this._helper.setMinPitch(e);
  }
  setMaxPitch(e) {
    this._helper.setMaxPitch(e);
  }
  setRenderWorldCopies(e) {
    this._helper.setRenderWorldCopies(e);
  }
  setBearing(e) {
    this._helper.setBearing(e);
  }
  setPitch(e) {
    this._helper.setPitch(e);
  }
  setRoll(e) {
    this._helper.setRoll(e);
  }
  setFov(e) {
    this._helper.setFov(e);
  }
  setZoom(e) {
    this._helper.setZoom(e);
  }
  setCenter(e) {
    this._helper.setCenter(e);
  }
  setElevation(e) {
    this._helper.setElevation(e);
  }
  setMinElevationForCurrentTile(e) {
    this._helper.setMinElevationForCurrentTile(e);
  }
  setPadding(e) {
    this._helper.setPadding(e);
  }
  interpolatePadding(e, r3, n) {
    return this._helper.interpolatePadding(e, r3, n);
  }
  isPaddingEqual(e) {
    return this._helper.isPaddingEqual(e);
  }
  resize(e, r3, n = true) {
    this._helper.resize(e, r3, n);
  }
  getMaxBounds() {
    return this._helper.getMaxBounds();
  }
  setMaxBounds(e) {
    this._helper.setMaxBounds(e);
  }
  overrideNearFarZ(e, r3) {
    this._helper.overrideNearFarZ(e, r3);
  }
  clearNearFarZOverride() {
    this._helper.clearNearFarZOverride();
  }
  getCameraQueryGeometry(e) {
    return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
  }
  get tileSize() {
    return this._helper.tileSize;
  }
  get tileZoom() {
    return this._helper.tileZoom;
  }
  get scale() {
    return this._helper.scale;
  }
  get worldSize() {
    return this._helper.worldSize;
  }
  get width() {
    return this._helper.width;
  }
  get height() {
    return this._helper.height;
  }
  get lngRange() {
    return this._helper.lngRange;
  }
  get latRange() {
    return this._helper.latRange;
  }
  get minZoom() {
    return this._helper.minZoom;
  }
  get maxZoom() {
    return this._helper.maxZoom;
  }
  get zoom() {
    return this._helper.zoom;
  }
  get center() {
    return this._helper.center;
  }
  get minPitch() {
    return this._helper.minPitch;
  }
  get maxPitch() {
    return this._helper.maxPitch;
  }
  get pitch() {
    return this._helper.pitch;
  }
  get pitchInRadians() {
    return this._helper.pitchInRadians;
  }
  get roll() {
    return this._helper.roll;
  }
  get rollInRadians() {
    return this._helper.rollInRadians;
  }
  get bearing() {
    return this._helper.bearing;
  }
  get bearingInRadians() {
    return this._helper.bearingInRadians;
  }
  get fov() {
    return this._helper.fov;
  }
  get fovInRadians() {
    return this._helper.fovInRadians;
  }
  get elevation() {
    return this._helper.elevation;
  }
  get minElevationForCurrentTile() {
    return this._helper.minElevationForCurrentTile;
  }
  get padding() {
    return this._helper.padding;
  }
  get unmodified() {
    return this._helper.unmodified;
  }
  get renderWorldCopies() {
    return this._helper.renderWorldCopies;
  }
  get cameraToCenterDistance() {
    return this._helper.cameraToCenterDistance;
  }
  get nearZ() {
    return this._helper.nearZ;
  }
  get farZ() {
    return this._helper.farZ;
  }
  get autoCalculateNearFarZ() {
    return this._helper.autoCalculateNearFarZ;
  }
  setTransitionState(e, r3) {
  }
  clone() {
    let e = new t56();
    return e.apply(this), e;
  }
  apply(e, r3, n) {
    this._helper.apply(e, r3, n);
  }
  get cameraPosition() {
    return this._cameraPosition;
  }
  get projectionMatrix() {
    return this._projectionMatrix;
  }
  get modelViewProjectionMatrix() {
    return this._viewProjMatrix;
  }
  get inverseProjectionMatrix() {
    return this._invProjMatrix;
  }
  get mercatorMatrix() {
    return this._mercatorMatrix;
  }
  getVisibleUnwrappedCoordinates(e) {
    let r3 = [new yi(0, e)];
    if (this._helper._renderWorldCopies) {
      let n = this.screenPointToMercatorCoordinate(new sr.default(0, 0)), i = this.screenPointToMercatorCoordinate(new sr.default(this._helper._width, 0)), o = this.screenPointToMercatorCoordinate(new sr.default(this._helper._width, this._helper._height)), a = this.screenPointToMercatorCoordinate(new sr.default(0, this._helper._height)), s3 = Math.floor(Math.min(n.x, i.x, o.x, a.x)), l = Math.floor(Math.max(n.x, i.x, o.x, a.x)), u3 = 1;
      for (let c = s3 - u3; c <= l + u3; c++) c !== 0 && r3.push(new yi(c, e));
    }
    return r3;
  }
  getCameraFrustum() {
    return Ma.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
  }
  getClippingPlane() {
    return null;
  }
  getCoveringTilesDetailsProvider() {
    return this._coveringTilesDetailsProvider;
  }
  recalculateZoomAndCenter(e) {
    let r3 = this.screenPointToLocation(this.centerPoint, e), n = e ? e.getElevationForLngLatZoom(r3, this._helper._tileZoom) : 0;
    this._helper.recalculateZoomAndCenter(n);
  }
  setLocationAtPoint(e, r3) {
    let n = dn(this.elevation, this.center.lat), i = this.screenPointToMercatorCoordinateAtZ(r3, n), o = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, n), a = xe.fromLngLat(e), s3 = new xe(a.x - (i.x - o.x), a.y - (i.y - o.y));
    this.setCenter(s3?.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
  }
  locationToScreenPoint(e, r3) {
    return r3 ? this.coordinatePoint(xe.fromLngLat(e), r3.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(xe.fromLngLat(e));
  }
  screenPointToLocation(e, r3) {
    return this.screenPointToMercatorCoordinate(e, r3)?.toLngLat();
  }
  screenPointToMercatorCoordinate(e, r3) {
    if (r3) {
      let n = r3.pointCoordinate(e);
      if (n != null) return n;
    }
    return this.screenPointToMercatorCoordinateAtZ(e);
  }
  screenPointToMercatorCoordinateAtZ(e, r3) {
    let n = r3 || 0, i = [e.x, e.y, 0, 1], o = [e.x, e.y, 1, 1];
    Ne.transformMat4(i, i, this._pixelMatrixInverse), Ne.transformMat4(o, o, this._pixelMatrixInverse);
    let a = i[3], s3 = o[3], l = i[0] / a, u3 = o[0] / s3, c = i[1] / a, p = o[1] / s3, h = i[2] / a, f = o[2] / s3, d = h === f ? 0 : (n - h) / (f - h);
    return new xe(Fe.number(l, u3, d) / this.worldSize, Fe.number(c, p, d) / this.worldSize, n);
  }
  coordinatePoint(e, r3 = 0, n = this._pixelMatrix) {
    let i = [e.x * this.worldSize, e.y * this.worldSize, r3, 1];
    return Ne.transformMat4(i, i, n), new sr.default(i[0] / i[3], i[1] / i[3]);
  }
  getBounds() {
    let e = Math.max(0, this._helper._height / 2 - va(this));
    return new mt().extend(this.screenPointToLocation(new sr.default(0, e))).extend(this.screenPointToLocation(new sr.default(this._helper._width, e))).extend(this.screenPointToLocation(new sr.default(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new sr.default(0, this._helper._height)));
  }
  isPointOnMapSurface(e, r3) {
    return r3 ? r3.pointCoordinate(e) != null : e.y > this.height / 2 - va(this);
  }
  calculatePosMatrix(e, r3 = false, n) {
    let i = e.key ?? fo(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y), o = r3 ? this._alignedPosMatrixCache : this._posMatrixCache;
    if (o.has(i)) {
      let l = o.get(i);
      return n ? l.f32 : l.f64;
    }
    let a = ah(e, this.worldSize);
    B.multiply(a, r3 ? this._alignedProjMatrix : this._viewProjMatrix, a);
    let s3 = { f64: a, f32: new Float32Array(a) };
    return o.set(i, s3), n ? s3.f32 : s3.f64;
  }
  calculateFogMatrix(e) {
    let r3 = e.key, n = this._fogMatrixCacheF32;
    if (n.has(r3)) return n.get(r3);
    let i = ah(e, this.worldSize);
    return B.multiply(i, this._fogMatrix, i), n.set(r3, new Float32Array(i)), n.get(r3);
  }
  getConstrained(e, r3) {
    r3 = ce(+r3, this.minZoom, this.maxZoom);
    let n = { center: new J(e.lng, e.lat), zoom: r3 }, i = this._helper._lngRange;
    if (!this._helper._renderWorldCopies && i === null) {
      let P = 179.9999999999;
      i = [-P, P];
    }
    let o = this.tileSize * lt(n.zoom), a = 0, s3 = o, l = 0, u3 = o, c = 0, p = 0, { x: h, y: f } = this.size;
    if (this._helper._latRange) {
      let P = this._helper._latRange;
      a = Kr(P[1]) * o, s3 = Kr(P[0]) * o, s3 - a < f && (c = f / (s3 - a));
    }
    i && (l = Rr(Dn(i[0]) * o, 0, o), u3 = Rr(Dn(i[1]) * o, 0, o), u3 < l && (u3 += o), u3 - l < h && (p = h / (u3 - l)));
    let { x: d, y: g } = vr(o, e), x, b, v3 = Math.max(p || 0, c || 0);
    if (v3) {
      let P = new sr.default(p ? (u3 + l) / 2 : d, c ? (s3 + a) / 2 : g);
      return n.center = xi(o, P).wrap(), n.zoom += rt(v3), n;
    }
    if (this._helper._latRange) {
      let P = f / 2;
      g - P < a && (b = a + P), g + P > s3 && (b = s3 - P);
    }
    if (i) {
      let P = (l + u3) / 2, w3 = d;
      this._helper._renderWorldCopies && (w3 = Rr(d, P - o / 2, P + o / 2));
      let T = h / 2;
      w3 - T < l && (x = l + T), w3 + T > u3 && (x = u3 - T);
    }
    if (x !== void 0 || b !== void 0) {
      let P = new sr.default(x ?? d, b ?? g);
      n.center = xi(o, P).wrap();
    }
    return n;
  }
  calculateCenterFromCameraLngLatAlt(e, r3, n, i) {
    return this._helper.calculateCenterFromCameraLngLatAlt(e, r3, n, i);
  }
  _calculateNearFarZIfNeeded(e, r3, n) {
    if (!this._helper.autoCalculateNearFarZ) return;
    let o = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), a = e - o * this._helper._pixelPerMeter / Math.cos(r3), s3 = o < 0 ? a : e, l = Math.PI / 2 + this.pitchInRadians, c = Ve(this.fov) * (Math.abs(Math.cos(Ve(this.roll))) * this.height + Math.abs(Math.sin(Ve(this.roll))) * this.width) / this.height * (0.5 + n.y / this.height), p = Math.sin(c) * s3 / Math.sin(ce(Math.PI - l - c, 0.01, Math.PI - 0.01)), h = va(this), f = Math.atan(h / this._helper.cameraToCenterDistance), d = Ve(90 - gi), g = f > d ? 2 * f * (0.5 + n.y / (h * 2)) : d, x = Math.sin(g) * s3 / Math.sin(ce(Math.PI - l - g, 0.01, Math.PI - 0.01)), b = Math.min(p, x);
    this._helper._farZ = (Math.cos(Math.PI / 2 - r3) * b + s3) * 1.01, this._helper._nearZ = this._helper._height / 50;
  }
  _calcMatrices() {
    if (!this._helper._height) return;
    let e = this.centerOffset, r3 = vr(this.worldSize, this.center), n = r3.x, i = r3.y;
    this._helper._pixelPerMeter = dn(1, this.center.lat) * this.worldSize;
    let o = Ve(Math.min(this.pitch, gi)), a = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(o));
    this._calculateNearFarZIfNeeded(a, o, e);
    let s3;
    s3 = new Float64Array(16), B.perspective(s3, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), B.invert(this._invProjMatrix, s3), s3[8] = -e.x * 2 / this._helper._width, s3[9] = e.y * 2 / this._helper._height, this._projectionMatrix = B.clone(s3), B.scale(s3, s3, [1, -1, 1]), B.translate(s3, s3, [0, 0, -this._helper.cameraToCenterDistance]), B.rotateZ(s3, s3, -this.rollInRadians), B.rotateX(s3, s3, this.pitchInRadians), B.rotateZ(s3, s3, -this.bearingInRadians), B.translate(s3, s3, [-n, -i, 0]), this._mercatorMatrix = B.scale([], s3, [this.worldSize, this.worldSize, this.worldSize]), B.scale(s3, s3, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = B.multiply(new Float64Array(16), this.clipSpaceToPixelsMatrix, s3), B.translate(s3, s3, [0, 0, -this.elevation]), this._viewProjMatrix = s3, this._invViewProjMatrix = B.invert([], s3);
    let l = [0, 0, -1, 1];
    Ne.transformMat4(l, l, this._invViewProjMatrix), this._cameraPosition = [l[0] / l[3], l[1] / l[3], l[2] / l[3]], this._fogMatrix = new Float64Array(16), B.perspective(this._fogMatrix, this.fovInRadians, this.width / this.height, a, this._helper._farZ), this._fogMatrix[8] = -e.x * 2 / this.width, this._fogMatrix[9] = e.y * 2 / this.height, B.scale(this._fogMatrix, this._fogMatrix, [1, -1, 1]), B.translate(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), B.rotateZ(this._fogMatrix, this._fogMatrix, -this.rollInRadians), B.rotateX(this._fogMatrix, this._fogMatrix, this.pitchInRadians), B.rotateZ(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), B.translate(this._fogMatrix, this._fogMatrix, [-n, -i, 0]), B.scale(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), B.translate(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = B.multiply(new Float64Array(16), this.clipSpaceToPixelsMatrix, s3);
    let u3 = this._helper._width % 2 / 2, c = this._helper._height % 2 / 2, p = Math.cos(this.bearingInRadians), h = Math.sin(-this.bearingInRadians), f = n - Math.round(n) + p * u3 + h * c, d = i - Math.round(i) + p * c + h * u3, g = new Float64Array(s3);
    if (B.translate(g, g, [f > 0.5 ? f - 1 : f, d > 0.5 ? d - 1 : d, 0]), this._alignedProjMatrix = g, s3 = B.invert(new Float64Array(16), this._pixelMatrix), !s3) throw new Error("failed to invert matrix");
    this._pixelMatrixInverse = s3, this._clearMatrixCaches();
  }
  _clearMatrixCaches() {
    this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
  }
  maxPitchScaleFactor() {
    if (!this._pixelMatrixInverse) return 1;
    let e = this.screenPointToMercatorCoordinate(new sr.default(0, 0)), r3 = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
    return Ne.transformMat4(r3, r3, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
  }
  getCameraPoint() {
    return this._helper.getCameraPoint();
  }
  getCameraAltitude() {
    return this._helper.getCameraAltitude();
  }
  getCameraLngLat() {
    let e = dn(1, this.center.lat) * this.worldSize, r3 = this._helper.cameraToCenterDistance / e;
    return Vl(this.center, this.elevation, this.pitch, this.bearing, r3).toLngLat();
  }
  lngLatToCameraDepth(e, r3) {
    let n = xe.fromLngLat(e), i = [n.x * this.worldSize, n.y * this.worldSize, r3, 1];
    return Ne.transformMat4(i, i, this._viewProjMatrix), i[2] / i[3];
  }
  getProjectionData(e) {
    let { overscaledTileID: r3, aligned: n, applyTerrainMatrix: i } = e, o = this._helper.getMercatorTileCoordinates(r3), a = r3 ? this.calculatePosMatrix(r3, n, true) : null, s3;
    return r3 && r3.terrainRttPosMatrix32f && i ? s3 = r3.terrainRttPosMatrix32f : a ? s3 = a : s3 = nc(), { mainMatrix: s3, tileMercatorCoords: o, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: s3 };
  }
  isLocationOccluded(e) {
    return false;
  }
  getPixelScale() {
    return 1;
  }
  getCircleRadiusCorrection() {
    return 1;
  }
  getPitchedTextCorrection(e, r3, n) {
    return 1;
  }
  transformLightDirection(e) {
    return V.clone(e);
  }
  getRayDirectionFromPixel(e) {
    throw new Error("Not implemented.");
  }
  projectTileCoordinates(e, r3, n, i) {
    let o = this.calculatePosMatrix(n), a;
    i ? (a = [e, r3, i(e, r3), 1], Ne.transformMat4(a, a, o)) : (a = [e, r3, 0, 1], Gl(a, a, o));
    let s3 = a[3];
    return { point: new sr.default(a[0] / s3, a[1] / s3), signedDistanceFromCamera: s3, isOccluded: false };
  }
  populateCache(e) {
    for (let r3 of e) this.calculatePosMatrix(r3);
  }
  getMatrixForModel(e, r3) {
    let n = xe.fromLngLat(e, r3), i = n.meterInMercatorCoordinateUnits(), o = Wn();
    return B.translate(o, o, [n.x, n.y, n.z]), B.rotateZ(o, o, Math.PI), B.rotateX(o, o, Math.PI / 2), B.scale(o, o, [-i, i, i]), o;
  }
  getProjectionDataForCustomLayer(e = true) {
    let r3 = new Ye2(0, 0, 0, 0, 0), n = this.getProjectionData({ overscaledTileID: r3, applyGlobeMatrix: e }), i = ah(r3, this.worldSize);
    B.multiply(i, this._viewProjMatrix, i), n.tileMercatorCoords = [0, 0, 1, 1];
    let o = [8192, 8192, this.worldSize / this._helper.pixelsPerMeter], a = Hr();
    return B.scale(a, i, o), n.fallbackMatrix = a, n.mainMatrix = a, n;
  }
  getFastPathSimpleProjectionMatrix(e) {
    return this.calculatePosMatrix(e);
  }
};
$i();
$i();
var $l = s(fe(), 1);
function $y() {
  ve2("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
}
function _h(t63) {
  if (t63.useSlerp) if (t63.k < 1) {
    let e = td(t63.startEulerAngles.roll, t63.startEulerAngles.pitch, t63.startEulerAngles.bearing), r3 = td(t63.endEulerAngles.roll, t63.endEulerAngles.pitch, t63.endEulerAngles.bearing), n = new Float64Array(4);
    Yn.slerp(n, e, r3, t63.k);
    let i = Xb(n);
    t63.tr.setRoll(i.roll), t63.tr.setPitch(i.pitch), t63.tr.setBearing(i.bearing);
  } else t63.tr.setRoll(t63.endEulerAngles.roll), t63.tr.setPitch(t63.endEulerAngles.pitch), t63.tr.setBearing(t63.endEulerAngles.bearing);
  else t63.tr.setRoll(Fe.number(t63.startEulerAngles.roll, t63.endEulerAngles.roll, t63.k)), t63.tr.setPitch(Fe.number(t63.startEulerAngles.pitch, t63.endEulerAngles.pitch, t63.k)), t63.tr.setBearing(Fe.number(t63.startEulerAngles.bearing, t63.endEulerAngles.bearing, t63.k));
}
function vh(t63, e, r3, n, i) {
  let o = i.padding, a = vr(i.worldSize, r3.getNorthWest()), s3 = vr(i.worldSize, r3.getNorthEast()), l = vr(i.worldSize, r3.getSouthEast()), u3 = vr(i.worldSize, r3.getSouthWest()), c = Ve(-n), p = a.rotate(c), h = s3.rotate(c), f = l.rotate(c), d = u3.rotate(c), g = new $l.default(Math.max(p.x, h.x, d.x, f.x), Math.max(p.y, h.y, d.y, f.y)), x = new $l.default(Math.min(p.x, h.x, d.x, f.x), Math.min(p.y, h.y, d.y, f.y)), b = g.sub(x), v3 = i.width - (o.left + o.right + e.left + e.right), P = i.height - (o.top + o.bottom + e.top + e.bottom), w3 = v3 / b.x, T = P / b.y;
  if (T < 0 || w3 < 0) {
    $y();
    return;
  }
  let S = Math.min(rt(i.scale * Math.min(w3, T)), t63.maxZoom), C3 = $l.default.convert(t63.offset), A = (e.left - e.right) / 2, E = (e.top - e.bottom) / 2, F = new $l.default(A, E).rotate(Ve(n)), z = C3.add(F).mult(i.scale / lt(S));
  return { center: xi(i.worldSize, a.add(l).div(2).sub(z)), zoom: S, bearing: n };
}
var On2 = class {
  get useGlobeControls() {
    return false;
  }
  handlePanInertia(e, r3) {
    return { easingOffset: e, easingCenter: r3.center };
  }
  handleMapControlsRollPitchBearingZoom(e, r3) {
    e.bearingDelta && r3.setBearing(r3.bearing + e.bearingDelta), e.pitchDelta && r3.setPitch(r3.pitch + e.pitchDelta), e.rollDelta && r3.setRoll(r3.roll + e.rollDelta), e.zoomDelta && r3.setZoom(r3.zoom + e.zoomDelta);
  }
  handleMapControlsPan(e, r3, n) {
    e.around.distSqr(r3.centerPoint) < 0.01 || r3.setLocationAtPoint(n, e.around);
  }
  cameraForBoxAndBearing(e, r3, n, i, o) {
    return vh(e, r3, n, i, o);
  }
  handleJumpToCenterZoom(e, r3) {
    let i = typeof r3.zoom < "u" ? +r3.zoom : e.zoom;
    e.zoom !== i && e.setZoom(+r3.zoom), r3.center !== void 0 && e.setCenter(J.convert(r3.center));
  }
  handleEaseTo(e, r3) {
    let n = e.zoom, i = e.padding, o = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, a = r3.roll === void 0 ? e.roll : r3.roll, s3 = r3.pitch === void 0 ? e.pitch : r3.pitch, l = r3.bearing === void 0 ? e.bearing : r3.bearing, u3 = { roll: a, pitch: s3, bearing: l }, c = typeof r3.zoom < "u", p = !e.isPaddingEqual(r3.padding), h = false, f = c ? +r3.zoom : e.zoom, d = e.centerPoint.add(r3.offsetAsPoint), g = e.screenPointToLocation(d), { center: x, zoom: b } = e.getConstrained(J.convert(r3.center || g), f ?? n);
    Sa(e, x);
    let v3 = vr(e.worldSize, g), P = vr(e.worldSize, x).sub(v3), w3 = lt(b - n);
    return h = b !== n, { easeFunc: (S) => {
      if (h && e.setZoom(Fe.number(n, b, S)), sc(o, u3) || _h({ startEulerAngles: o, endEulerAngles: u3, tr: e, k: S, useSlerp: o.roll != u3.roll }), p && (e.interpolatePadding(i, r3.padding, S), d = e.centerPoint.add(r3.offsetAsPoint)), r3.around) e.setLocationAtPoint(r3.around, r3.aroundPoint);
      else {
        let C3 = lt(e.zoom - n), A = b > n ? Math.min(2, w3) : Math.max(0.5, w3), E = Math.pow(A, 1 - S), L = xi(e.worldSize, v3.add(P.mult(S * E)).mult(C3));
        e.setLocationAtPoint(e.renderWorldCopies ? L.wrap() : L, d);
      }
    }, isZooming: h, elevationCenter: x };
  }
  handleFlyTo(e, r3) {
    let n = typeof r3.zoom < "u", i = e.zoom, o = e.getConstrained(J.convert(r3.center || r3.locationAtOffset), n ? +r3.zoom : i), a = o.center, s3 = o.zoom;
    Sa(e, a);
    let l = vr(e.worldSize, r3.locationAtOffset), u3 = vr(e.worldSize, a).sub(l), c = u3.mag(), p = lt(s3 - i), h = typeof r3.minZoom < "u", f;
    if (h) {
      let g = Math.min(+r3.minZoom, i, s3), x = e.getConstrained(a, g).zoom;
      f = lt(x - i);
    }
    return { easeFunc: (g, x, b, v3) => {
      e.setZoom(g === 1 ? s3 : i + rt(x));
      let P = g === 1 ? a : xi(e.worldSize, l.add(u3.mult(b)).mult(x));
      e.setLocationAtPoint(e.renderWorldCopies ? P.wrap() : P, v3);
    }, scaleOfZoom: p, targetCenter: a, scaleOfMinZoom: f, pixelPathLength: c };
  }
};
$i();
$i();
$i();
$i();
var zO = 0;
var Iw = 1;
var VO = 771;
var De = class {
  constructor(e, r3, n) {
    this.blendFunction = e, this.blendColor = r3, this.mask = n;
  }
};
De.Replace = [Iw, zO];
De.disabled = new De(De.Replace, K.transparent, [false, false, false, false]);
De.unblended = new De(De.Replace, K.transparent, [true, true, true, true]);
De.alphaBlended = new De([Iw, VO], K.transparent, [true, true, true, true]);
$i();
var le = class {
  constructor(e, r3, n) {
    this.enable = e, this.mode = r3, this.frontFace = n;
  }
};
le.disabled = new le(false, 1029, 2305);
le.backCCW = new le(true, 1029, 2305);
le.frontCCW = new le(true, 1028, 2305);
$i();
var ne = class {
  constructor(e, r3, n) {
    this.func = e, this.mask = r3, this.range = n;
  }
};
ne.ReadOnly = false;
ne.ReadWrite = true;
ne.disabled = new ne(519, ne.ReadOnly, [0, 1]);
$i();
var pe = class {
  constructor(e, r3, n, i, o, a) {
    this.test = e, this.ref = r3, this.mask = n, this.fail = i, this.depthFail = o, this.pass = a;
  }
};
pe.disabled = new pe({ func: 519, mask: 0 }, 0, 0, 7680, 7680, 7680);
$i();
var Aw = (t63, e) => ({ u_input: new N(t63, e.u_input), u_output_expected: new N(t63, e.u_output_expected) });
var Ew = (t63, e) => ({ u_input: t63, u_output_expected: e });
$i();
var Ky = /* @__PURE__ */ new WeakMap();
function wr(t63) {
  if (Ky.has(t63)) return Ky.get(t63);
  {
    let e = t63.getParameter(t63.VERSION)?.startsWith("WebGL 2.0");
    return Ky.set(t63, e), e;
  }
}
var Ph = class t57 {
  constructor(e) {
    this._readbackWaitFrames = 4;
    this._measureWaitFrames = 6;
    this._texWidth = 1;
    this._texHeight = 1;
    this._measuredError = 0;
    this._updateCount = 0;
    this._lastReadbackFrame = -1e3;
    this._readbackQueue = null;
    this._cachedRenderContext = e;
    let r3 = e.context, n = r3.gl;
    this._texFormat = n.RGBA, this._texType = n.UNSIGNED_BYTE;
    let i = new Et();
    i.emplaceBack(-1, -1), i.emplaceBack(2, -1), i.emplaceBack(-1, 2);
    let o = new Qe();
    o.emplaceBack(0, 1, 2), this._fullscreenTriangle = new ar(r3.createVertexBuffer(i, Pr.members), r3.createIndexBuffer(o), de2.simpleSegment(0, 0, i.length, o.length)), this._resultBuffer = new Uint8Array(4), r3.activeTexture.set(n.TEXTURE1);
    let a = n.createTexture();
    n.bindTexture(n.TEXTURE_2D, a), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST), n.texImage2D(n.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = r3.createFramebuffer(this._texWidth, this._texHeight, false, false), this._fbo.colorAttachment.set(a), wr(n) && (this._pbo = n.createBuffer(), n.bindBuffer(n.PIXEL_PACK_BUFFER, this._pbo), n.bufferData(n.PIXEL_PACK_BUFFER, 4, n.STREAM_READ), n.bindBuffer(n.PIXEL_PACK_BUFFER, null));
  }
  get awaitingQuery() {
    return !!this._readbackQueue;
  }
  destroy() {
    let e = this._cachedRenderContext.context.gl;
    this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
  }
  updateErrorLoop(e, r3) {
    let n = this._updateCount;
    return this._readbackQueue ? n >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : n >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, r3), this._updateCount++, this._measuredError;
  }
  _bindFramebuffer() {
    let e = this._cachedRenderContext.context, r3 = e.gl;
    e.activeTexture.set(r3.TEXTURE1), r3.bindTexture(r3.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer);
  }
  _renderErrorTexture(e, r3) {
    let n = this._cachedRenderContext.context, i = n.gl;
    if (this._bindFramebuffer(), n.viewport.set([0, 0, this._texWidth, this._texHeight]), n.clear({ color: K.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(n, i.TRIANGLES, ne.disabled, pe.disabled, De.unblended, le.disabled, Ew(e, r3), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && wr(i)) {
      i.bindBuffer(i.PIXEL_PACK_BUFFER, this._pbo), i.readBuffer(i.COLOR_ATTACHMENT0), i.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), i.bindBuffer(i.PIXEL_PACK_BUFFER, null);
      let a = i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE, 0);
      i.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: a };
    } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
  }
  _tryReadback() {
    let e = this._cachedRenderContext.context.gl;
    if (this._pbo && this._readbackQueue && wr(e)) {
      let r3 = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
      if (r3 === e.WAIT_FAILED) {
        ve2("WebGL2 clientWaitSync failed."), this._readbackQueue = null, this._lastReadbackFrame = this._updateCount;
        return;
      }
      if (r3 === e.TIMEOUT_EXPIRED) return;
      e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null);
    } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
    this._readbackQueue = null, this._measuredError = t57._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
  }
  static _parseRGBA8float(e) {
    let r3 = 0;
    return r3 += e[0] / 256, r3 += e[1] / 65536, r3 += e[2] / 16777216, e[3] < 127 && (r3 = -r3), r3 / 128;
  }
};
$i();
var wh = 8192 / 128;
function Lw(t63, e) {
  let r3 = Dw(e, "16bit"), n = Et.deserialize({ arrayBuffer: r3.vertices, length: r3.vertices.byteLength / 2 / 2 }), i = Qe.deserialize({ arrayBuffer: r3.indices, length: r3.indices.byteLength / 2 / 3 });
  return new ar(t63.createVertexBuffer(n, Pr.members), t63.createIndexBuffer(i), de2.simpleSegment(0, 0, n.length, i.length));
}
function Dw(t63, e) {
  let r3 = t63.granularity !== void 0 ? Math.max(t63.granularity, 1) : 1, n = r3 + (t63.generateBorders ? 2 : 0), i = r3 + (t63.extendToNorthPole || t63.generateBorders ? 1 : 0) + (t63.extendToSouthPole || t63.generateBorders ? 1 : 0), o = n + 1, a = i + 1, s3 = t63.generateBorders ? -1 : 0, l = t63.generateBorders || t63.extendToNorthPole ? -1 : 0, u3 = r3 + (t63.generateBorders ? 1 : 0), c = r3 + (t63.generateBorders || t63.extendToSouthPole ? 1 : 0), p = o * a, h = n * i * 6, f = o * a > 65536;
  if (f && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
  let d = f || e === "32bit", g = new Int16Array(p * 2), x = 0;
  for (let P = l; P <= c; P++) for (let w3 = s3; w3 <= u3; w3++) {
    let T = w3 / r3 * 8192;
    w3 === -1 && (T = -wh), w3 === r3 + 1 && (T = 8192 + wh);
    let S = P / r3 * 8192;
    P === -1 && (S = t63.extendToNorthPole ? fn : -wh), P === r3 + 1 && (S = t63.extendToSouthPole ? En : 8192 + wh), g[x++] = T, g[x++] = S;
  }
  let b = d ? new Uint32Array(h) : new Uint16Array(h), v3 = 0;
  for (let P = 0; P < i; P++) for (let w3 = 0; w3 < n; w3++) {
    let T = w3 + P * o, S = w3 + 1 + P * o, C3 = w3 + (P + 1) * o, A = w3 + 1 + (P + 1) * o;
    b[v3++] = T, b[v3++] = C3, b[v3++] = S, b[v3++] = S, b[v3++] = C3, b[v3++] = A;
  }
  return { vertices: g.buffer.slice(0), indices: b.buffer.slice(0), uses32bitIndices: d };
}
var UO = "#define GLOBE";
var NO = "globe";
var Rw = { errorTransitionTimeSeconds: 0.5 };
var Jy = new fi({ fill: new br(128, 2), line: new br(512, 0), tile: new br(128, 32), stencil: new br(128, 1), circle: 3 });
var Ia = class {
  constructor() {
    this._tileMeshCache = {};
    this._errorCorrectionUsable = 0;
    this._errorMeasurementLastValue = 0;
    this._errorCorrectionPreviousValue = 0;
    this._errorMeasurementLastChangeTime = -1e3;
  }
  get name() {
    return "vertical-perspective";
  }
  get transitionState() {
    return 1;
  }
  get useSubdivision() {
    return true;
  }
  get shaderVariantName() {
    return NO;
  }
  get shaderDefine() {
    return UO;
  }
  get shaderPreludeCode() {
    return or.projectionGlobe;
  }
  get vertexShaderPreludeCode() {
    return or.projectionMercator.vertexSource;
  }
  get subdivisionGranularity() {
    return Jy;
  }
  get useGlobeControls() {
    return true;
  }
  get latitudeErrorCorrectionRadians() {
    return this._errorCorrectionUsable;
  }
  destroy() {
    this._errorMeasurement && this._errorMeasurement.destroy();
  }
  updateGPUdependent(e) {
    this._errorMeasurement || (this._errorMeasurement = new Ph(e));
    let r3 = Kr(this._errorQueryLatitudeDegrees), n = 2 * Math.atan(Math.exp(Math.PI - r3 * Math.PI * 2)) - Math.PI * 0.5, i = this._errorMeasurement.updateErrorLoop(r3, n), o = ae.now();
    i !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = i, this._errorMeasurementLastChangeTime = o);
    let a = (o - this._errorMeasurementLastChangeTime) / 1e3, s3 = Math.min(Math.max(a / Rw.errorTransitionTimeSeconds, 0), 1), l = -this._errorMeasurementLastValue;
    this._errorCorrectionUsable = Pn(this._errorCorrectionPreviousValue, l, ic(s3));
  }
  _getMeshKey(e) {
    return `${e.granularity.toString(36)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}`;
  }
  getMeshFromTileID(e, r3, n, i, o) {
    let s3 = (o === "stencil" ? Jy.stencil : Jy.tile).getGranularityForZoomLevel(r3.z), l = r3.y === 0 && i, u3 = r3.y === (1 << r3.z) - 1 && i;
    return this._getMesh(e, { granularity: s3, generateBorders: n, extendToNorthPole: l, extendToSouthPole: u3 });
  }
  _getMesh(e, r3) {
    let n = this._getMeshKey(r3);
    if (n in this._tileMeshCache) return this._tileMeshCache[n];
    let i = Lw(e, r3);
    return this._tileMeshCache[n] = i, i;
  }
  recalculate(e) {
  }
  hasTransition() {
    let e = ae.now(), r3 = false;
    return r3 = r3 || (e - this._errorMeasurementLastChangeTime) / 1e3 < Rw.errorTransitionTimeSeconds + 0.2, r3 = r3 || this._errorMeasurement && this._errorMeasurement.awaitingQuery, r3;
  }
  setErrorQueryLatitudeDegrees(e) {
    this._errorQueryLatitudeDegrees = e;
  }
};
var GO = new Ue({ type: new q3(D.projection.type) });
var Kl = class extends Ee {
  constructor(e) {
    super(), this._transitionable = new pn(GO), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new Te(0)), this._mercatorProjection = new xo(), this._verticalPerspectiveProjection = new Ia();
  }
  get transitionState() {
    let e = this.properties.get("type");
    if (typeof e == "string" && e === "mercator") return 0;
    if (typeof e == "string" && e === "vertical-perspective") return 1;
    if (e instanceof sn) {
      if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
      if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition;
    }
    return 1;
  }
  get useGlobeRendering() {
    return this.transitionState > 0;
  }
  get latitudeErrorCorrectionRadians() {
    return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
  }
  get currentProjection() {
    return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
  }
  get name() {
    return "globe";
  }
  get useSubdivision() {
    return this.currentProjection.useSubdivision;
  }
  get shaderVariantName() {
    return this.currentProjection.shaderVariantName;
  }
  get shaderDefine() {
    return this.currentProjection.shaderDefine;
  }
  get shaderPreludeCode() {
    return this.currentProjection.shaderPreludeCode;
  }
  get vertexShaderPreludeCode() {
    return this.currentProjection.vertexShaderPreludeCode;
  }
  get subdivisionGranularity() {
    return this.currentProjection.subdivisionGranularity;
  }
  get useGlobeControls() {
    return this.transitionState > 0;
  }
  destroy() {
    this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
  }
  updateGPUdependent(e) {
    this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e);
  }
  getMeshFromTileID(e, r3, n, i, o) {
    return this.currentProjection.getMeshFromTileID(e, r3, n, i, o);
  }
  setProjection(e) {
    this._transitionable.setValue("type", e?.type || "mercator");
  }
  updateTransitions(e) {
    this._transitioning = this._transitionable.transitioned(e, this._transitioning);
  }
  hasTransition() {
    return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
  }
  recalculate(e) {
    this.properties = this._transitioning.possiblyEvaluate(e);
  }
  setErrorQueryLatitudeDegrees(e) {
    this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e);
  }
};
$i();
$i();
var Qr = s(fe(), 1);
$i();
function kw(t63) {
  let e = bo(t63.worldSize, t63.center.lat);
  return 2 * Math.PI * e;
}
function Fw(t63, e, r3) {
  let n = It(e), i = It(r3), o = V.dot(n, i), a = Math.acos(o), s3 = kw(t63);
  return a / (2 * Math.PI) * s3;
}
function Ow(t63, e) {
  let r3 = Ni(t63 * Math.PI * 2 + Math.PI, Math.PI * 2), n = 2 * Math.atan(Math.exp(Math.PI - e * Math.PI * 2)) - Math.PI * 0.5;
  return [r3, n];
}
function jO(t63, e) {
  let r3 = Math.cos(e), n = new Float64Array(3);
  return n[0] = Math.sin(t63) * r3, n[1] = Math.sin(e), n[2] = Math.cos(t63) * r3, n;
}
function yn(t63, e, r3, n, i) {
  let o = 1 / (1 << i), a = t63 / 8192 * o + r3 * o, s3 = e / 8192 * o + n * o, l = Ni(a * Math.PI * 2 + Math.PI, Math.PI * 2), u3 = 2 * Math.atan(Math.exp(Math.PI - s3 * Math.PI * 2)) - Math.PI * 0.5, c = Math.cos(u3), p = new Float64Array(3);
  return p[0] = Math.sin(l) * c, p[1] = Math.sin(u3), p[2] = Math.cos(l) * c, p;
}
function It(t63) {
  return jO(t63.lng * Math.PI / 180, t63.lat * Math.PI / 180);
}
function bo(t63, e) {
  return t63 / (2 * Math.PI) / Math.cos(e * Math.PI / 180);
}
function eg(t63) {
  let r3 = Math.asin(t63[1]) / Math.PI * 180, n = Math.sqrt(t63[0] * t63[0] + t63[2] * t63[2]);
  if (n > 1e-6) {
    let i = t63[0] / n, o = t63[2] / n, a = Math.acos(o), l = (i > 0 ? a : -a) / Math.PI * 180;
    return new J(Rr(l, -180, 180), r3);
  } else return new J(0, r3);
}
function Bw(t63) {
  let e = tt();
  e[0] = t63[0] * -t63[3], e[1] = t63[1] * -t63[3], e[2] = t63[2] * -t63[3];
  let r3 = Math.sqrt(1 - t63[3] * t63[3]);
  return { center: e, radius: r3 };
}
function zw(t63, e, r3) {
  let n = tt();
  V.sub(n, r3, t63);
  let i = tt();
  return V.scaleAndAdd(i, t63, n, e / V.len(n)), i;
}
function Th(t63) {
  return Math.cos(t63 * Math.PI / 180);
}
function xt(t63, e) {
  let r3 = Th(t63), n = Th(e);
  return rt(n / r3);
}
function HO(t63, e) {
  return 360 / kw({ worldSize: t63, center: { lat: e } });
}
function tg(t63, e) {
  let r3 = t63.rotate(e.bearingInRadians), n = e.zoom + xt(e.center.lat, 0), i = Pn(1 / Th(e.center.lat), 1 / Th(Math.min(Math.abs(e.center.lat), 60)), Oo(n, 7, 3, 0, 1)), o = HO(e.worldSize, e.center.lat);
  return new J(e.center.lng - r3.x * o * i, ce(e.center.lat + r3.y * o, -Nt2, Nt2));
}
function Qy(t63) {
  let e = 0.5 * t63, r3 = Math.sin(e), n = Math.cos(e);
  return Math.log(r3 + n) - Math.log(n - r3);
}
function rg(t63, e, r3, n) {
  let i = t63.lat + r3 * n;
  if (Math.abs(r3) > 1) {
    let o = t63.lat + r3, s3 = (Math.sign(o) !== Math.sign(t63.lat) ? -Math.abs(t63.lat) : Math.abs(t63.lat)) * Math.PI / 180, l = Math.abs(t63.lat + r3) * Math.PI / 180, u3 = Qy(s3 + n * (l - s3)), c = Qy(s3), p = Qy(l), h = (u3 - c) / (p - c), f = t63.lng + e * h;
    return new J(f, i);
  } else {
    let o = t63.lng + e * n;
    return new J(o, i);
  }
}
$i();
$i();
var Sh = class {
  constructor(e) {
    this._cachePrevious = /* @__PURE__ */ new Map();
    this._cache = /* @__PURE__ */ new Map();
    this._hadAnyChanges = false;
    this._boundingVolumeFactory = e;
  }
  swapBuffers() {
    if (!this._hadAnyChanges) return;
    let e = this._cachePrevious;
    this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = false;
  }
  getTileBoundingVolume(e, r3, n, i) {
    let o = `${e.z}_${e.x}_${e.y}_${i?.terrain ? "t" : ""}`, a = this._cache.get(o);
    if (a) return a;
    let s3 = this._cachePrevious.get(o);
    if (s3) return this._cache.set(o, s3), s3;
    let l = this._boundingVolumeFactory(e, r3, n, i);
    return this._cache.set(o, l), this._hadAnyChanges = true, l;
  }
};
$i();
var Aa = class t58 {
  constructor(e, r3, n, i) {
    this.min = n, this.max = i, this.points = e, this.planes = r3;
  }
  static fromAabb(e, r3) {
    let n = [];
    for (let i = 0; i < 8; i++) n.push([(i >> 0 & 1) === 1 ? r3[0] : e[0], (i >> 1 & 1) === 1 ? r3[1] : e[1], (i >> 2 & 1) === 1 ? r3[2] : e[2]]);
    return new t58(n, [[-1, 0, 0, r3[0]], [1, 0, 0, -e[0]], [0, -1, 0, r3[1]], [0, 1, 0, -e[1]], [0, 0, -1, r3[2]], [0, 0, 1, -e[2]]], e, r3);
  }
  static fromCenterSizeAngles(e, r3, n) {
    let i = Yn.fromEuler([], n[0], n[1], n[2]), o = V.transformQuat([], [r3[0], 0, 0], i), a = V.transformQuat([], [0, r3[1], 0], i), s3 = V.transformQuat([], [0, 0, r3[2]], i), l = [...e], u3 = [...e];
    for (let p = 0; p < 8; p++) for (let h = 0; h < 3; h++) {
      let f = e[h] + o[h] * ((p >> 0 & 1) === 1 ? 1 : -1) + a[h] * ((p >> 1 & 1) === 1 ? 1 : -1) + s3[h] * ((p >> 2 & 1) === 1 ? 1 : -1);
      l[h] = Math.min(l[h], f), u3[h] = Math.max(u3[h], f);
    }
    let c = [];
    for (let p = 0; p < 8; p++) {
      let h = [...e];
      V.add(h, h, V.scale([], o, (p >> 0 & 1) === 1 ? 1 : -1)), V.add(h, h, V.scale([], a, (p >> 1 & 1) === 1 ? 1 : -1)), V.add(h, h, V.scale([], s3, (p >> 2 & 1) === 1 ? 1 : -1)), c.push(h);
    }
    return new t58(c, [[...o, -V.dot(o, c[0])], [...a, -V.dot(a, c[0])], [...s3, -V.dot(s3, c[0])], [-o[0], -o[1], -o[2], -V.dot(o, c[7])], [-a[0], -a[1], -a[2], -V.dot(a, c[7])], [-s3[0], -s3[1], -s3[2], -V.dot(s3, c[7])]], l, u3);
  }
  intersectsFrustum(e) {
    let r3 = true, n = this.points.length, i = this.planes.length, o = e.planes.length, a = e.points.length;
    for (let s3 = 0; s3 < o; s3++) {
      let l = e.planes[s3], u3 = 0;
      for (let c = 0; c < n; c++) {
        let p = this.points[c];
        l[0] * p[0] + l[1] * p[1] + l[2] * p[2] + l[3] >= 0 && u3++;
      }
      if (u3 === 0) return 0;
      u3 < n && (r3 = false);
    }
    if (r3) return 2;
    for (let s3 = 0; s3 < i; s3++) {
      let l = this.planes[s3], u3 = 0;
      for (let c = 0; c < a; c++) {
        let p = e.points[c];
        l[0] * p[0] + l[1] * p[1] + l[2] * p[2] + l[3] >= 0 && u3++;
      }
      if (u3 === 0) return 0;
    }
    return 1;
  }
  intersectsPlane(e) {
    let r3 = this.points.length, n = 0;
    for (let i = 0; i < r3; i++) {
      let o = this.points[i];
      e[0] * o[0] + e[1] * o[1] + e[2] * o[2] + e[3] >= 0 && n++;
    }
    return n === r3 ? 2 : n === 0 ? 0 : 1;
  }
};
function Ch(t63, e, r3) {
  let n = t63 - e;
  return n < 0 ? -n : Math.max(0, n - r3);
}
function ng(t63, e, r3, n, i) {
  let o = t63 - r3, a;
  return o < 0 ? a = Math.min(-o, 1 + o - i) : o > 1 ? a = Math.min(Math.max(o - i, 0), 1 - o) : a = 0, Math.max(a, Ch(e, n, i));
}
var Mh = class {
  constructor() {
    this._boundingVolumeCache = new Sh(this._computeTileBoundingVolume);
  }
  prepareNextFrame() {
    this._boundingVolumeCache.swapBuffers();
  }
  distanceToTile2d(e, r3, n, i) {
    let o = 1 << n.z, a = 1 / o, s3 = n.x / o, l = n.y / o, u3 = 1, c = 0.5 * u3, p = 2 * u3;
    return p = Math.min(p, ng(e, r3, s3, l, a)), p = Math.min(p, ng(e, r3, s3 + c, -l - a, a)), p = Math.min(p, ng(e, r3, s3 + c, u3 + u3 - l - a, a)), p;
  }
  getWrap(e, r3, n) {
    let i = 1 << r3.z, o = 1 / i, a = r3.x / i, s3 = Ch(e.x, a, o), l = Ch(e.x, a - 1, o), u3 = Ch(e.x, a + 1, o), c = Math.min(s3, l, u3);
    return c === u3 ? 1 : c === l ? -1 : 0;
  }
  allowVariableZoom(e, r3) {
    return mo(e, r3) > 4;
  }
  allowWorldCopies() {
    return false;
  }
  getTileBoundingVolume(e, r3, n, i) {
    return this._boundingVolumeCache.getTileBoundingVolume(e, r3, n, i);
  }
  _computeTileBoundingVolume(e, r3, n, i) {
    let o = 0, a = 0;
    if (i?.terrain) {
      let s3 = new Ye2(e.z, r3, e.z, e.x, e.y), l = i.terrain.getMinMaxElevation(s3);
      o = l.minElevation ?? Math.min(0, n), a = l.maxElevation ?? Math.max(0, n);
    }
    if (o /= nr, a /= nr, o += 1, a += 1, e.z <= 0) return Aa.fromAabb([-a, -a, -a], [a, a, a]);
    if (e.z === 1) return Aa.fromAabb([e.x === 0 ? -a : 0, e.y === 0 ? 0 : -a, -a], [e.x === 0 ? 0 : a, e.y === 0 ? a : 0, a]);
    {
      let s3 = [yn(0, 0, e.x, e.y, e.z), yn(8192, 0, e.x, e.y, e.z), yn(8192, 8192, e.x, e.y, e.z), yn(0, 8192, e.x, e.y, e.z)], l = [];
      for (let E of s3) l.push(V.scale([], E, a));
      if (a !== o) for (let E of s3) l.push(V.scale([], E, o));
      e.y === 0 && l.push([0, 1, 0]), e.y === (1 << e.z) - 1 && l.push([0, -1, 0]);
      let u3 = [1, 1, 1], c = [-1, -1, -1];
      for (let E of l) for (let L = 0; L < 3; L++) u3[L] = Math.min(u3[L], E[L]), c[L] = Math.max(c[L], E[L]);
      let p = yn(8192 / 2, 8192 / 2, e.x, e.y, e.z), h = V.cross([], [0, 1, 0], p);
      V.normalize(h, h);
      let f = V.cross([], p, h);
      V.normalize(f, f);
      let d = V.cross([], s3[2], s3[1]);
      V.normalize(d, d);
      let g = V.cross([], s3[0], s3[3]);
      V.normalize(g, g), l.push(V.scale([], p, a)), e.y >= (1 << e.z) / 2 && l.push(V.scale([], yn(8192 / 2, 0, e.x, e.y, e.z), a)), e.y < (1 << e.z) / 2 && l.push(V.scale([], yn(8192 / 2, 8192, e.x, e.y, e.z), a));
      let x = Vw(p, l), b = Vw(f, l), v3 = [-p[0], -p[1], -p[2], x.max], P = [p[0], p[1], p[2], -x.min], w3 = [-f[0], -f[1], -f[2], b.max], T = [f[0], f[1], f[2], -b.min], S = [...d, 0], C3 = [...g, 0], A = [];
      return e.y === 0 ? A.push(mr(C3, S, v3), mr(C3, S, P)) : A.push(mr(w3, S, v3), mr(w3, S, P), mr(w3, C3, v3), mr(w3, C3, P)), e.y === (1 << e.z) - 1 ? A.push(mr(C3, S, v3), mr(C3, S, P)) : A.push(mr(T, S, v3), mr(T, S, P), mr(T, C3, v3), mr(T, C3, P)), new Aa(A, [v3, P, w3, T, S, C3], u3, c);
    }
  }
};
function Vw(t63, e) {
  let r3 = 1 / 0, n = -1 / 0;
  for (let i of e) {
    let o = V.dot(t63, i);
    r3 = Math.min(r3, o), n = Math.max(n, o);
  }
  return { min: r3, max: n };
}
var Ea = class t59 {
  constructor() {
    this._cachedClippingPlane = Fo();
    this._projectionMatrix = Wn();
    this._globeViewProjMatrix32f = nc();
    this._globeViewProjMatrixNoCorrection = Wn();
    this._globeViewProjMatrixNoCorrectionInverted = Wn();
    this._globeProjMatrixInverted = Wn();
    this._cameraPosition = tt();
    this._globeLatitudeErrorCorrectionRadians = 0;
    this._helper = new Pi({ calcMatrices: () => {
      this._calcMatrices();
    }, getConstrained: (e, r3) => this.getConstrained(e, r3) }), this._coveringTilesDetailsProvider = new Mh();
  }
  get pixelsToClipSpaceMatrix() {
    return this._helper.pixelsToClipSpaceMatrix;
  }
  get clipSpaceToPixelsMatrix() {
    return this._helper.clipSpaceToPixelsMatrix;
  }
  get pixelsToGLUnits() {
    return this._helper.pixelsToGLUnits;
  }
  get centerOffset() {
    return this._helper.centerOffset;
  }
  get size() {
    return this._helper.size;
  }
  get rotationMatrix() {
    return this._helper.rotationMatrix;
  }
  get centerPoint() {
    return this._helper.centerPoint;
  }
  get pixelsPerMeter() {
    return this._helper.pixelsPerMeter;
  }
  setMinZoom(e) {
    this._helper.setMinZoom(e);
  }
  setMaxZoom(e) {
    this._helper.setMaxZoom(e);
  }
  setMinPitch(e) {
    this._helper.setMinPitch(e);
  }
  setMaxPitch(e) {
    this._helper.setMaxPitch(e);
  }
  setRenderWorldCopies(e) {
    this._helper.setRenderWorldCopies(e);
  }
  setBearing(e) {
    this._helper.setBearing(e);
  }
  setPitch(e) {
    this._helper.setPitch(e);
  }
  setRoll(e) {
    this._helper.setRoll(e);
  }
  setFov(e) {
    this._helper.setFov(e);
  }
  setZoom(e) {
    this._helper.setZoom(e);
  }
  setCenter(e) {
    this._helper.setCenter(e);
  }
  setElevation(e) {
    this._helper.setElevation(e);
  }
  setMinElevationForCurrentTile(e) {
    this._helper.setMinElevationForCurrentTile(e);
  }
  setPadding(e) {
    this._helper.setPadding(e);
  }
  interpolatePadding(e, r3, n) {
    return this._helper.interpolatePadding(e, r3, n);
  }
  isPaddingEqual(e) {
    return this._helper.isPaddingEqual(e);
  }
  resize(e, r3) {
    this._helper.resize(e, r3);
  }
  getMaxBounds() {
    return this._helper.getMaxBounds();
  }
  setMaxBounds(e) {
    this._helper.setMaxBounds(e);
  }
  overrideNearFarZ(e, r3) {
    this._helper.overrideNearFarZ(e, r3);
  }
  clearNearFarZOverride() {
    this._helper.clearNearFarZOverride();
  }
  getCameraQueryGeometry(e) {
    return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
  }
  get tileSize() {
    return this._helper.tileSize;
  }
  get tileZoom() {
    return this._helper.tileZoom;
  }
  get scale() {
    return this._helper.scale;
  }
  get worldSize() {
    return this._helper.worldSize;
  }
  get width() {
    return this._helper.width;
  }
  get height() {
    return this._helper.height;
  }
  get lngRange() {
    return this._helper.lngRange;
  }
  get latRange() {
    return this._helper.latRange;
  }
  get minZoom() {
    return this._helper.minZoom;
  }
  get maxZoom() {
    return this._helper.maxZoom;
  }
  get zoom() {
    return this._helper.zoom;
  }
  get center() {
    return this._helper.center;
  }
  get minPitch() {
    return this._helper.minPitch;
  }
  get maxPitch() {
    return this._helper.maxPitch;
  }
  get pitch() {
    return this._helper.pitch;
  }
  get pitchInRadians() {
    return this._helper.pitchInRadians;
  }
  get roll() {
    return this._helper.roll;
  }
  get rollInRadians() {
    return this._helper.rollInRadians;
  }
  get bearing() {
    return this._helper.bearing;
  }
  get bearingInRadians() {
    return this._helper.bearingInRadians;
  }
  get fov() {
    return this._helper.fov;
  }
  get fovInRadians() {
    return this._helper.fovInRadians;
  }
  get elevation() {
    return this._helper.elevation;
  }
  get minElevationForCurrentTile() {
    return this._helper.minElevationForCurrentTile;
  }
  get padding() {
    return this._helper.padding;
  }
  get unmodified() {
    return this._helper.unmodified;
  }
  get renderWorldCopies() {
    return this._helper.renderWorldCopies;
  }
  get nearZ() {
    return this._helper.nearZ;
  }
  get farZ() {
    return this._helper.farZ;
  }
  get autoCalculateNearFarZ() {
    return this._helper.autoCalculateNearFarZ;
  }
  setTransitionState(e) {
  }
  clone() {
    let e = new t59();
    return e.apply(this), e;
  }
  apply(e, r3) {
    this._globeLatitudeErrorCorrectionRadians = r3 || 0, this._helper.apply(e);
  }
  get projectionMatrix() {
    return this._projectionMatrix;
  }
  get modelViewProjectionMatrix() {
    return this._globeViewProjMatrixNoCorrection;
  }
  get inverseProjectionMatrix() {
    return this._globeProjMatrixInverted;
  }
  get cameraPosition() {
    let e = tt();
    return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e;
  }
  get cameraToCenterDistance() {
    return this._helper.cameraToCenterDistance;
  }
  getProjectionData(e) {
    let { overscaledTileID: r3, applyGlobeMatrix: n } = e, i = this._helper.getMercatorTileCoordinates(r3);
    return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: i, clippingPlane: this._cachedClippingPlane, projectionTransition: n ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
  }
  _computeClippingPlane(e) {
    let r3 = this.pitchInRadians, n = this.cameraToCenterDistance / e, i = 1, o = Math.sin(r3) * n, a = Math.cos(r3) * n + i, s3 = Math.sqrt(o * o + a * a), u3 = i / s3 * i, c = -o, p = a, h = Math.sqrt(c * c + p * p);
    c /= h, p /= h;
    let f = [0, c, p];
    V.rotateZ(f, f, [0, 0, 0], -this.bearingInRadians), V.rotateX(f, f, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), V.rotateY(f, f, [0, 0, 0], this.center.lng * Math.PI / 180);
    let d = 1 / V.length(f);
    return V.scale(f, f, d), [...f, -u3 * d];
  }
  isLocationOccluded(e) {
    return !this.isSurfacePointVisible(It(e));
  }
  transformLightDirection(e) {
    let r3 = this._helper._center.lng * Math.PI / 180, n = this._helper._center.lat * Math.PI / 180, i = Math.cos(n), o = [Math.sin(r3) * i, Math.sin(n), Math.cos(r3) * i], a = [o[2], 0, -o[0]], s3 = [0, 0, 0];
    V.cross(s3, a, o), V.normalize(a, a), V.normalize(s3, s3);
    let l = [a[0] * e[0] + s3[0] * e[1] + o[0] * e[2], a[1] * e[0] + s3[1] * e[1] + o[1] * e[2], a[2] * e[0] + s3[2] * e[1] + o[2] * e[2]], u3 = [0, 0, 0];
    return V.normalize(u3, l), u3;
  }
  getPixelScale() {
    return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
  }
  getCircleRadiusCorrection() {
    return Math.cos(this._helper._center.lat * Math.PI / 180);
  }
  getPitchedTextCorrection(e, r3, n) {
    let i = j1(e, r3, n.canonical), o = Ow(i.x, i.y);
    return this.getCircleRadiusCorrection() / Math.cos(o[1]);
  }
  projectTileCoordinates(e, r3, n, i) {
    let o = n.canonical, a = yn(e, r3, o.x, o.y, o.z), l = 1 + (i ? i(e, r3) : 0) / nr, u3 = [a[0] * l, a[1] * l, a[2] * l, 1];
    Ne.transformMat4(u3, u3, this._globeViewProjMatrixNoCorrection);
    let c = this._cachedClippingPlane, h = c[0] * a[0] + c[1] * a[1] + c[2] * a[2] + c[3] < 0;
    return { point: new Qr.default(u3[0] / u3[3], u3[1] / u3[3]), signedDistanceFromCamera: u3[3], isOccluded: h };
  }
  _calcMatrices() {
    if (!this._helper._width || !this._helper._height) return;
    let e = bo(this.worldSize, this.center.lat), r3 = Hr(), n = Hr();
    this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + e * 2), B.perspective(r3, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
    let i = this.centerOffset;
    r3[8] = -i.x * 2 / this._helper._width, r3[9] = i.y * 2 / this._helper._height, this._projectionMatrix = B.clone(r3), this._globeProjMatrixInverted = Hr(), B.invert(this._globeProjMatrixInverted, r3), B.translate(r3, r3, [0, 0, -this.cameraToCenterDistance]), B.rotateZ(r3, r3, this.rollInRadians), B.rotateX(r3, r3, -this.pitchInRadians), B.rotateZ(r3, r3, this.bearingInRadians), B.translate(r3, r3, [0, 0, -e]);
    let o = tt();
    o[0] = e, o[1] = e, o[2] = e, B.rotateX(n, r3, this.center.lat * Math.PI / 180), B.rotateY(n, n, -this.center.lng * Math.PI / 180), B.scale(n, n, o), this._globeViewProjMatrixNoCorrection = n, B.rotateX(r3, r3, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), B.rotateY(r3, r3, -this.center.lng * Math.PI / 180), B.scale(r3, r3, o), this._globeViewProjMatrix32f = new Float32Array(r3), this._globeViewProjMatrixNoCorrectionInverted = Hr(), B.invert(this._globeViewProjMatrixNoCorrectionInverted, n);
    let a = tt();
    this._cameraPosition = tt(), this._cameraPosition[2] = this.cameraToCenterDistance / e, V.rotateZ(this._cameraPosition, this._cameraPosition, a, -this.rollInRadians), V.rotateX(this._cameraPosition, this._cameraPosition, a, this.pitchInRadians), V.rotateZ(this._cameraPosition, this._cameraPosition, a, -this.bearingInRadians), V.add(this._cameraPosition, this._cameraPosition, [0, 0, 1]), V.rotateX(this._cameraPosition, this._cameraPosition, a, -this.center.lat * Math.PI / 180), V.rotateY(this._cameraPosition, this._cameraPosition, a, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
    let s3 = B.clone(this._globeViewProjMatrixNoCorrectionInverted);
    B.scale(s3, s3, [1, 1, -1]), this._cachedFrustum = Ma.fromInvProjectionMatrix(s3, 1, 0, this._cachedClippingPlane, true);
  }
  calculateFogMatrix(e) {
    ve2("calculateFogMatrix is not supported on globe projection.");
    let r3 = Hr();
    return B.identity(r3), r3;
  }
  getVisibleUnwrappedCoordinates(e) {
    return [new yi(0, e)];
  }
  getCameraFrustum() {
    return this._cachedFrustum;
  }
  getClippingPlane() {
    return this._cachedClippingPlane;
  }
  getCoveringTilesDetailsProvider() {
    return this._coveringTilesDetailsProvider;
  }
  recalculateZoomAndCenter(e) {
    e && ve2("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
  }
  maxPitchScaleFactor() {
    return 1;
  }
  getCameraPoint() {
    return this._helper.getCameraPoint();
  }
  getCameraAltitude() {
    return this._helper.getCameraAltitude();
  }
  getCameraLngLat() {
    return this._helper.getCameraLngLat();
  }
  lngLatToCameraDepth(e, r3) {
    if (!this._globeViewProjMatrixNoCorrection) return 1;
    let n = It(e);
    V.scale(n, n, 1 + r3 / nr);
    let i = Fo();
    return Ne.transformMat4(i, [n[0], n[1], n[2], 1], this._globeViewProjMatrixNoCorrection), i[2] / i[3];
  }
  populateCache(e) {
  }
  getBounds() {
    let e = this.width * 0.5, r3 = this.height * 0.5, n = [new Qr.default(0, 0), new Qr.default(e, 0), new Qr.default(this.width, 0), new Qr.default(this.width, r3), new Qr.default(this.width, this.height), new Qr.default(e, this.height), new Qr.default(0, this.height), new Qr.default(0, r3)], i = [];
    for (let p of n) i.push(this.unprojectScreenPoint(p));
    let o = 0, a = 0, s3 = 0, l = 0, u3 = this.center;
    for (let p of i) {
      let h = Ut(u3.lng, p.lng), f = Ut(u3.lat, p.lat);
      h < a && (a = h), h > o && (o = h), f < l && (l = f), f > s3 && (s3 = f);
    }
    let c = [u3.lng + a, u3.lat + l, u3.lng + o, u3.lat + s3];
    return this.isSurfacePointOnScreen([0, 1, 0]) && (c[3] = 90, c[0] = -180, c[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (c[1] = -90, c[0] = -180, c[2] = 180), new mt(c);
  }
  getConstrained(e, r3) {
    let n = ce(e.lat, -Nt2, Nt2), i = ce(+r3, this.minZoom + xt(0, n), this.maxZoom);
    return { center: new J(e.lng, n), zoom: i };
  }
  calculateCenterFromCameraLngLatAlt(e, r3, n, i) {
    return this._helper.calculateCenterFromCameraLngLatAlt(e, r3, n, i);
  }
  setLocationAtPoint(e, r3) {
    let n = this.unprojectScreenPoint(r3), i = It(n), o = It(e), a = tt();
    V.zero(a);
    let s3 = tt();
    V.rotateY(s3, i, a, -this.center.lng * Math.PI / 180), V.rotateX(s3, s3, a, this.center.lat * Math.PI / 180);
    let l = o[0] * o[0] + o[2] * o[2], u3 = s3[0] * s3[0];
    if (l < u3) return;
    let c = Math.sqrt(l - u3), p = -c, h = rs(o[0], o[2], s3[0], c), f = rs(o[0], o[2], s3[0], p), d = tt();
    V.rotateY(d, o, a, -h);
    let g = rs(d[1], d[2], s3[1], s3[2]), x = tt();
    V.rotateY(x, o, a, -f);
    let b = rs(x[1], x[2], s3[1], s3[2]), v3 = Math.PI * 0.5, P = g >= -v3 && g <= v3, w3 = b >= -v3 && b <= v3, T, S;
    if (P && w3) {
      let L = this.center.lng * Math.PI / 180, F = this.center.lat * Math.PI / 180, O = ns(h, L), z = ns(g, F), I = ns(f, L), R = ns(b, F);
      O + z < I + R ? (T = h, S = g) : (T = f, S = b);
    } else if (P) T = h, S = g;
    else if (w3) T = f, S = b;
    else return;
    let C3 = T / Math.PI * 180, A = S / Math.PI * 180, E = this.center.lat;
    this.setCenter(new J(C3, ce(A, -90, 90))), this.setZoom(this.zoom + xt(E, this.center.lat));
  }
  locationToScreenPoint(e, r3) {
    let n = It(e);
    if (r3) {
      let i = r3.getElevationForLngLatZoom(e, this._helper._tileZoom);
      V.scale(n, n, 1 + i / nr);
    }
    return this._projectSurfacePointToScreen(n);
  }
  _projectSurfacePointToScreen(e) {
    let r3 = Fo();
    return Ne.transformMat4(r3, [...e, 1], this._globeViewProjMatrixNoCorrection), r3[0] /= r3[3], r3[1] /= r3[3], new Qr.default((r3[0] * 0.5 + 0.5) * this.width, (-r3[1] * 0.5 + 0.5) * this.height);
  }
  screenPointToMercatorCoordinate(e, r3) {
    if (r3) {
      let n = r3.pointCoordinate(e);
      if (n) return n;
    }
    return xe.fromLngLat(this.unprojectScreenPoint(e));
  }
  screenPointToLocation(e, r3) {
    return this.screenPointToMercatorCoordinate(e, r3)?.toLngLat();
  }
  isPointOnMapSurface(e, r3) {
    let n = this._cameraPosition, i = this.getRayDirectionFromPixel(e);
    return !!this.rayPlanetIntersection(n, i);
  }
  getRayDirectionFromPixel(e) {
    let r3 = Fo();
    r3[0] = e.x / this.width * 2 - 1, r3[1] = (e.y / this.height * 2 - 1) * -1, r3[2] = 1, r3[3] = 1, Ne.transformMat4(r3, r3, this._globeViewProjMatrixNoCorrectionInverted), r3[0] /= r3[3], r3[1] /= r3[3], r3[2] /= r3[3];
    let n = tt();
    n[0] = r3[0] - this._cameraPosition[0], n[1] = r3[1] - this._cameraPosition[1], n[2] = r3[2] - this._cameraPosition[2];
    let i = tt();
    return V.normalize(i, n), i;
  }
  isSurfacePointVisible(e) {
    let r3 = this._cachedClippingPlane;
    return r3[0] * e[0] + r3[1] * e[1] + r3[2] * e[2] + r3[3] >= 0;
  }
  isSurfacePointOnScreen(e) {
    if (!this.isSurfacePointVisible(e)) return false;
    let r3 = Fo();
    return Ne.transformMat4(r3, [...e, 1], this._globeViewProjMatrixNoCorrection), r3[0] /= r3[3], r3[1] /= r3[3], r3[2] /= r3[3], r3[0] > -1 && r3[0] < 1 && r3[1] > -1 && r3[1] < 1 && r3[2] > -1 && r3[2] < 1;
  }
  rayPlanetIntersection(e, r3) {
    let n = V.dot(e, r3), i = 1, o = tt(), a = tt();
    V.scale(a, r3, n), V.sub(o, e, a);
    let s3 = i - V.dot(o, o);
    if (s3 < 0) return null;
    let l = V.dot(e, e) - i, u3 = -n + (n < 0 ? 1 : -1) * Math.sqrt(s3), c = l / u3, p = u3, h = Math.min(c, p), f = Math.max(c, p);
    return { tMin: h, tMax: f };
  }
  unprojectScreenPoint(e) {
    let r3 = this._cameraPosition, n = this.getRayDirectionFromPixel(e), i = this.rayPlanetIntersection(r3, n);
    if (i) {
      let f = tt();
      V.add(f, r3, [n[0] * i.tMin, n[1] * i.tMin, n[2] * i.tMin]);
      let d = tt();
      return V.normalize(d, f), eg(d);
    }
    let o = this._cachedClippingPlane, a = o[0] * n[0] + o[1] * n[1] + o[2] * n[2], l = -ts(o, r3) / a, u3 = 2, c = tt();
    if (l > 0) V.add(c, r3, [n[0] * l, n[1] * l, n[2] * l]);
    else {
      let f = tt();
      V.add(f, r3, [n[0] * u3, n[1] * u3, n[2] * u3]);
      let d = ts(this._cachedClippingPlane, f);
      V.sub(c, f, [this._cachedClippingPlane[0] * d, this._cachedClippingPlane[1] * d, this._cachedClippingPlane[2] * d]);
    }
    let p = Bw(o), h = zw(p.center, p.radius, c);
    return eg(h);
  }
  getMatrixForModel(e, r3) {
    let n = J.convert(e), i = 1 / nr, o = Wn();
    return B.rotateY(o, o, n.lng / 180 * Math.PI), B.rotateX(o, o, -n.lat / 180 * Math.PI), B.translate(o, o, [0, 0, 1 + r3 / nr]), B.rotateX(o, o, Math.PI * 0.5), B.scale(o, o, [i, i, i]), o;
  }
  getProjectionDataForCustomLayer(e = true) {
    let r3 = this.getProjectionData({ overscaledTileID: new Ye2(0, 0, 0, 0, 0), applyGlobeMatrix: e });
    return r3.tileMercatorCoords = [0, 0, 1, 1], r3;
  }
  getFastPathSimpleProjectionMatrix(e) {
  }
};
var Jl = class t60 {
  constructor() {
    this._globeLatitudeErrorCorrectionRadians = 0;
    this._globeness = 1;
    this._helper = new Pi({ calcMatrices: () => {
      this._calcMatrices();
    }, getConstrained: (e, r3) => this.getConstrained(e, r3) }), this._globeness = 1, this._mercatorTransform = new Fn(), this._verticalPerspectiveTransform = new Ea();
  }
  get pixelsToClipSpaceMatrix() {
    return this._helper.pixelsToClipSpaceMatrix;
  }
  get clipSpaceToPixelsMatrix() {
    return this._helper.clipSpaceToPixelsMatrix;
  }
  get pixelsToGLUnits() {
    return this._helper.pixelsToGLUnits;
  }
  get centerOffset() {
    return this._helper.centerOffset;
  }
  get size() {
    return this._helper.size;
  }
  get rotationMatrix() {
    return this._helper.rotationMatrix;
  }
  get centerPoint() {
    return this._helper.centerPoint;
  }
  get pixelsPerMeter() {
    return this._helper.pixelsPerMeter;
  }
  setMinZoom(e) {
    this._helper.setMinZoom(e);
  }
  setMaxZoom(e) {
    this._helper.setMaxZoom(e);
  }
  setMinPitch(e) {
    this._helper.setMinPitch(e);
  }
  setMaxPitch(e) {
    this._helper.setMaxPitch(e);
  }
  setRenderWorldCopies(e) {
    this._helper.setRenderWorldCopies(e);
  }
  setBearing(e) {
    this._helper.setBearing(e);
  }
  setPitch(e) {
    this._helper.setPitch(e);
  }
  setRoll(e) {
    this._helper.setRoll(e);
  }
  setFov(e) {
    this._helper.setFov(e);
  }
  setZoom(e) {
    this._helper.setZoom(e);
  }
  setCenter(e) {
    this._helper.setCenter(e);
  }
  setElevation(e) {
    this._helper.setElevation(e);
  }
  setMinElevationForCurrentTile(e) {
    this._helper.setMinElevationForCurrentTile(e);
  }
  setPadding(e) {
    this._helper.setPadding(e);
  }
  interpolatePadding(e, r3, n) {
    return this._helper.interpolatePadding(e, r3, n);
  }
  isPaddingEqual(e) {
    return this._helper.isPaddingEqual(e);
  }
  resize(e, r3, n = true) {
    this._helper.resize(e, r3, n);
  }
  getMaxBounds() {
    return this._helper.getMaxBounds();
  }
  setMaxBounds(e) {
    this._helper.setMaxBounds(e);
  }
  overrideNearFarZ(e, r3) {
    this._helper.overrideNearFarZ(e, r3);
  }
  clearNearFarZOverride() {
    this._helper.clearNearFarZOverride();
  }
  getCameraQueryGeometry(e) {
    return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
  }
  get tileSize() {
    return this._helper.tileSize;
  }
  get tileZoom() {
    return this._helper.tileZoom;
  }
  get scale() {
    return this._helper.scale;
  }
  get worldSize() {
    return this._helper.worldSize;
  }
  get width() {
    return this._helper.width;
  }
  get height() {
    return this._helper.height;
  }
  get lngRange() {
    return this._helper.lngRange;
  }
  get latRange() {
    return this._helper.latRange;
  }
  get minZoom() {
    return this._helper.minZoom;
  }
  get maxZoom() {
    return this._helper.maxZoom;
  }
  get zoom() {
    return this._helper.zoom;
  }
  get center() {
    return this._helper.center;
  }
  get minPitch() {
    return this._helper.minPitch;
  }
  get maxPitch() {
    return this._helper.maxPitch;
  }
  get pitch() {
    return this._helper.pitch;
  }
  get pitchInRadians() {
    return this._helper.pitchInRadians;
  }
  get roll() {
    return this._helper.roll;
  }
  get rollInRadians() {
    return this._helper.rollInRadians;
  }
  get bearing() {
    return this._helper.bearing;
  }
  get bearingInRadians() {
    return this._helper.bearingInRadians;
  }
  get fov() {
    return this._helper.fov;
  }
  get fovInRadians() {
    return this._helper.fovInRadians;
  }
  get elevation() {
    return this._helper.elevation;
  }
  get minElevationForCurrentTile() {
    return this._helper.minElevationForCurrentTile;
  }
  get padding() {
    return this._helper.padding;
  }
  get unmodified() {
    return this._helper.unmodified;
  }
  get renderWorldCopies() {
    return this._helper.renderWorldCopies;
  }
  get cameraToCenterDistance() {
    return this._helper.cameraToCenterDistance;
  }
  get nearZ() {
    return this._helper.nearZ;
  }
  get farZ() {
    return this._helper.farZ;
  }
  get autoCalculateNearFarZ() {
    return this._helper.autoCalculateNearFarZ;
  }
  get isGlobeRendering() {
    return this._globeness > 0;
  }
  setTransitionState(e, r3) {
    this._globeness = e, this._globeLatitudeErrorCorrectionRadians = r3, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
  }
  get currentTransform() {
    return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
  }
  clone() {
    let e = new t60();
    return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e;
  }
  apply(e) {
    this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
  }
  get projectionMatrix() {
    return this.currentTransform.projectionMatrix;
  }
  get modelViewProjectionMatrix() {
    return this.currentTransform.modelViewProjectionMatrix;
  }
  get inverseProjectionMatrix() {
    return this.currentTransform.inverseProjectionMatrix;
  }
  get cameraPosition() {
    return this.currentTransform.cameraPosition;
  }
  getProjectionData(e) {
    let r3 = this._mercatorTransform.getProjectionData(e), n = this._verticalPerspectiveTransform.getProjectionData(e);
    return { mainMatrix: this.isGlobeRendering ? n.mainMatrix : r3.mainMatrix, clippingPlane: n.clippingPlane, tileMercatorCoords: n.tileMercatorCoords, projectionTransition: e.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: r3.fallbackMatrix };
  }
  isLocationOccluded(e) {
    return this.currentTransform.isLocationOccluded(e);
  }
  transformLightDirection(e) {
    return this.currentTransform.transformLightDirection(e);
  }
  getPixelScale() {
    return Pn(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
  }
  getCircleRadiusCorrection() {
    return Pn(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
  }
  getPitchedTextCorrection(e, r3, n) {
    let i = this._mercatorTransform.getPitchedTextCorrection(e, r3, n), o = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, r3, n);
    return Pn(i, o, this._globeness);
  }
  projectTileCoordinates(e, r3, n, i) {
    return this.currentTransform.projectTileCoordinates(e, r3, n, i);
  }
  _calcMatrices() {
    !this._helper._width || !this._helper._height || (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, true, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
  }
  calculateFogMatrix(e) {
    return this.currentTransform.calculateFogMatrix(e);
  }
  getVisibleUnwrappedCoordinates(e) {
    return this.currentTransform.getVisibleUnwrappedCoordinates(e);
  }
  getCameraFrustum() {
    return this.currentTransform.getCameraFrustum();
  }
  getClippingPlane() {
    return this.currentTransform.getClippingPlane();
  }
  getCoveringTilesDetailsProvider() {
    return this.currentTransform.getCoveringTilesDetailsProvider();
  }
  recalculateZoomAndCenter(e) {
    this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e);
  }
  maxPitchScaleFactor() {
    return this._mercatorTransform.maxPitchScaleFactor();
  }
  getCameraPoint() {
    return this._helper.getCameraPoint();
  }
  getCameraAltitude() {
    return this._helper.getCameraAltitude();
  }
  getCameraLngLat() {
    return this._helper.getCameraLngLat();
  }
  lngLatToCameraDepth(e, r3) {
    return this.currentTransform.lngLatToCameraDepth(e, r3);
  }
  populateCache(e) {
    this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e);
  }
  getBounds() {
    return this.currentTransform.getBounds();
  }
  getConstrained(e, r3) {
    return this.currentTransform.getConstrained(e, r3);
  }
  calculateCenterFromCameraLngLatAlt(e, r3, n, i) {
    return this._helper.calculateCenterFromCameraLngLatAlt(e, r3, n, i);
  }
  setLocationAtPoint(e, r3) {
    if (!this.isGlobeRendering) {
      this._mercatorTransform.setLocationAtPoint(e, r3), this.apply(this._mercatorTransform);
      return;
    }
    this._verticalPerspectiveTransform.setLocationAtPoint(e, r3), this.apply(this._verticalPerspectiveTransform);
  }
  locationToScreenPoint(e, r3) {
    return this.currentTransform.locationToScreenPoint(e, r3);
  }
  screenPointToMercatorCoordinate(e, r3) {
    return this.currentTransform.screenPointToMercatorCoordinate(e, r3);
  }
  screenPointToLocation(e, r3) {
    return this.currentTransform.screenPointToLocation(e, r3);
  }
  isPointOnMapSurface(e, r3) {
    return this.currentTransform.isPointOnMapSurface(e, r3);
  }
  getRayDirectionFromPixel(e) {
    return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e);
  }
  getMatrixForModel(e, r3) {
    return this.currentTransform.getMatrixForModel(e, r3);
  }
  getProjectionDataForCustomLayer(e = true) {
    let r3 = this._mercatorTransform.getProjectionDataForCustomLayer(e);
    if (!this.isGlobeRendering) return r3;
    let n = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
    return n.fallbackMatrix = r3.mainMatrix, n;
  }
  getFastPathSimpleProjectionMatrix(e) {
    return this.currentTransform.getFastPathSimpleProjectionMatrix(e);
  }
};
$i();
$i();
var Ih = s(fe(), 1);
var La = class t61 {
  get useGlobeControls() {
    return true;
  }
  handlePanInertia(e, r3) {
    let n = tg(e, r3);
    return Math.abs(n.lng - r3.center.lng) > 180 && (n.lng = r3.center.lng + 179.5 * Math.sign(n.lng - r3.center.lng)), { easingCenter: n, easingOffset: new Ih.default(0, 0) };
  }
  handleMapControlsRollPitchBearingZoom(e, r3) {
    let n = e.around, i = r3.screenPointToLocation(n);
    e.bearingDelta && r3.setBearing(r3.bearing + e.bearingDelta), e.pitchDelta && r3.setPitch(r3.pitch + e.pitchDelta), e.rollDelta && r3.setRoll(r3.roll + e.rollDelta);
    let o = r3.zoom;
    e.zoomDelta && r3.setZoom(r3.zoom + e.zoomDelta);
    let a = r3.zoom - o;
    if (a === 0) return;
    let s3 = 0.3, l = 0.5, u3 = 45, c = 85, p = 0.25, h = 0.75, f = 0.35, d = 0.9, g = 0.5, x = 0.25, b = Ut(r3.center.lng, i.lng), v3 = b / (Math.abs(b / 180) + 1), P = Ut(r3.center.lat, i.lat), w3 = r3.getRayDirectionFromPixel(n), T = r3.cameraPosition, S = V.dot(T, w3) * -1, C3 = tt();
    V.add(C3, T, [w3[0] * S, w3[1] * S, w3[2] * S]);
    let A = V.length(C3) - 1, E = Math.exp(-Math.max(A - s3, 0) * l), L = bo(r3.worldSize, r3.center.lat) / Math.min(r3.width, r3.height), F = Oo(L, d, g, 1, x), O = (1 - lt(-a)) * Math.min(E, F), z = r3.center.lat, I = r3.zoom, R = new J(r3.center.lng + v3 * O, ce(r3.center.lat + P * O, -Nt2, Nt2));
    r3.setLocationAtPoint(i, n);
    let H = r3.center, W = Oo(Math.abs(b), u3, c, 0, 1), $ = Oo(L, h, f, 0, 1), he = Math.pow(Math.max(W, $), p), Xe = Ut(H.lng, R.lng), be = Ut(H.lat, R.lat);
    r3.setCenter(new J(H.lng + Xe * he, H.lat + be * he).wrap()), r3.setZoom(I + xt(z, r3.center.lat));
  }
  handleMapControlsPan(e, r3, n) {
    if (!e.panDelta) return;
    let i = r3.center.lat, o = r3.zoom;
    r3.setCenter(tg(e.panDelta, r3).wrap()), r3.setZoom(o + xt(i, r3.center.lat));
  }
  cameraForBoxAndBearing(e, r3, n, i, o) {
    let a = vh(e, r3, n, i, o), s3 = r3.left / o.width * 2 - 1, l = (o.width - r3.right) / o.width * 2 - 1, u3 = r3.top / o.height * -2 + 1, c = (o.height - r3.bottom) / o.height * -2 + 1, p = Ut(n.getWest(), n.getEast()) < 0, h = p ? n.getEast() : n.getWest(), f = p ? n.getWest() : n.getEast(), d = Math.max(n.getNorth(), n.getSouth()), g = Math.min(n.getNorth(), n.getSouth()), x = h + Ut(h, f) * 0.5, b = d + Ut(d, g) * 0.5, v3 = o.clone();
    v3.setCenter(a.center), v3.setBearing(a.bearing), v3.setPitch(0), v3.setRoll(0), v3.setZoom(a.zoom);
    let P = v3.modelViewProjectionMatrix, w3 = [It(n.getNorthWest()), It(n.getNorthEast()), It(n.getSouthWest()), It(n.getSouthEast()), It(new J(f, b)), It(new J(h, b)), It(new J(x, d)), It(new J(x, g))], T = It(a.center), S = Number.POSITIVE_INFINITY;
    for (let C3 of w3) s3 < 0 && (S = t61.getLesserNonNegativeNonNull(S, t61.solveVectorScale(C3, T, P, "x", s3))), l > 0 && (S = t61.getLesserNonNegativeNonNull(S, t61.solveVectorScale(C3, T, P, "x", l))), u3 > 0 && (S = t61.getLesserNonNegativeNonNull(S, t61.solveVectorScale(C3, T, P, "y", u3))), c < 0 && (S = t61.getLesserNonNegativeNonNull(S, t61.solveVectorScale(C3, T, P, "y", c)));
    if (!Number.isFinite(S) || S === 0) {
      $y();
      return;
    }
    return a.zoom = v3.zoom + rt(S), a;
  }
  handleJumpToCenterZoom(e, r3) {
    let n = e.center.lat, i = e.getConstrained(r3.center ? J.convert(r3.center) : e.center, e.zoom).center;
    e.setCenter(i.wrap());
    let o = typeof r3.zoom < "u" ? +r3.zoom : e.zoom + xt(n, i.lat);
    e.zoom !== o && e.setZoom(o);
  }
  handleEaseTo(e, r3) {
    let n = e.zoom, i = e.center, o = e.padding, a = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, s3 = r3.roll === void 0 ? e.roll : r3.roll, l = r3.pitch === void 0 ? e.pitch : r3.pitch, u3 = r3.bearing === void 0 ? e.bearing : r3.bearing, c = { roll: s3, pitch: l, bearing: u3 }, p = typeof r3.zoom < "u", h = !e.isPaddingEqual(r3.padding), f = false, d = r3.center ? J.convert(r3.center) : i, g = e.getConstrained(d, n).center;
    Sa(e, g);
    let x = e.clone();
    x.setCenter(g), x.setZoom(p ? +r3.zoom : n + xt(i.lat, d.lat)), x.setBearing(r3.bearing);
    let b = new Ih.default(ce(e.centerPoint.x + r3.offsetAsPoint.x, 0, e.width), ce(e.centerPoint.y + r3.offsetAsPoint.y, 0, e.height));
    x.setLocationAtPoint(g, b);
    let v3 = (r3.offset && r3.offsetAsPoint.mag()) > 0 ? x.center : g, P = p ? +r3.zoom : n + xt(i.lat, v3.lat), w3 = n + xt(i.lat, 0), T = P + xt(v3.lat, 0), S = Ut(i.lng, v3.lng), C3 = Ut(i.lat, v3.lat), A = lt(T - w3);
    return f = P !== n, { easeFunc: (L) => {
      if (sc(a, c) || _h({ startEulerAngles: a, endEulerAngles: c, tr: e, k: L, useSlerp: a.roll != c.roll }), h && e.interpolatePadding(o, r3.padding, L), r3.around) ve2("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(r3.around, r3.aroundPoint);
      else {
        let F = T > w3 ? Math.min(2, A) : Math.max(0.5, A), O = Math.pow(F, 1 - L), z = L * O, I = rg(i, S, C3, z);
        e.setCenter(I.wrap());
      }
      if (f) {
        let O = Fe.number(w3, T, L) + xt(0, e.center.lat);
        e.setZoom(O);
      }
    }, isZooming: f, elevationCenter: v3 };
  }
  handleFlyTo(e, r3) {
    let n = typeof r3.zoom < "u", i = e.center, o = e.zoom, a = e.padding, s3 = !e.isPaddingEqual(r3.padding), l = e.getConstrained(J.convert(r3.center || r3.locationAtOffset), o).center, u3 = n ? +r3.zoom : e.zoom + xt(e.center.lat, l.lat), c = e.clone();
    c.setCenter(l), c.setZoom(u3), c.setBearing(r3.bearing);
    let p = new Ih.default(ce(e.centerPoint.x + r3.offsetAsPoint.x, 0, e.width), ce(e.centerPoint.y + r3.offsetAsPoint.y, 0, e.height));
    c.setLocationAtPoint(l, p);
    let h = c.center;
    Sa(e, h);
    let f = Fw(e, i, h), d = o + xt(i.lat, 0), g = u3 + xt(h.lat, 0), x = lt(g - d), b = typeof r3.minZoom == "number", v3;
    if (b) {
      let S = +r3.minZoom + xt(h.lat, 0), A = Math.min(S, d, g) + xt(0, h.lat), L = e.getConstrained(h, A).zoom + xt(h.lat, 0);
      v3 = lt(L - d);
    }
    let P = Ut(i.lng, h.lng), w3 = Ut(i.lat, h.lat);
    return { easeFunc: (S, C3, A, E) => {
      let L = rg(i, P, w3, A);
      s3 && e.interpolatePadding(a, r3.padding, S);
      let F = S === 1 ? h : L;
      e.setCenter(F.wrap());
      let O = d + rt(C3);
      e.setZoom(S === 1 ? u3 : O + xt(0, F.lat));
    }, scaleOfZoom: x, targetCenter: h, scaleOfMinZoom: v3, pixelPathLength: f };
  }
  static solveVectorScale(e, r3, n, i, o) {
    let a = o, s3 = i === "x" ? [n[0], n[4], n[8], n[12]] : [n[1], n[5], n[9], n[13]], l = [n[3], n[7], n[11], n[15]], u3 = e[0] * s3[0] + e[1] * s3[1] + e[2] * s3[2], c = e[0] * l[0] + e[1] * l[1] + e[2] * l[2], p = r3[0] * s3[0] + r3[1] * s3[1] + r3[2] * s3[2], h = r3[0] * l[0] + r3[1] * l[1] + r3[2] * l[2], f = (p + s3[3] - a * h - a * l[3]) / (p - u3 - a * h + a * c);
    return p + a * c === u3 + a * h || l[3] * (u3 - p) + s3[3] * (h - c) + u3 * h === p * c ? null : f;
  }
  static getLesserNonNegativeNonNull(e, r3) {
    return r3 !== null && r3 >= 0 && r3 < e ? r3 : e;
  }
};
var Ql = class {
  constructor(e) {
    this._globe = e, this._mercatorCameraHelper = new On2(), this._verticalPerspectiveCameraHelper = new La();
  }
  get useGlobeControls() {
    return this._globe.useGlobeRendering;
  }
  get currentHelper() {
    return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
  }
  handlePanInertia(e, r3) {
    return this.currentHelper.handlePanInertia(e, r3);
  }
  handleMapControlsRollPitchBearingZoom(e, r3) {
    return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, r3);
  }
  handleMapControlsPan(e, r3, n) {
    this.currentHelper.handleMapControlsPan(e, r3, n);
  }
  cameraForBoxAndBearing(e, r3, n, i, o) {
    return this.currentHelper.cameraForBoxAndBearing(e, r3, n, i, o);
  }
  handleJumpToCenterZoom(e, r3) {
    this.currentHelper.handleJumpToCenterZoom(e, r3);
  }
  handleEaseTo(e, r3) {
    return this.currentHelper.handleEaseTo(e, r3);
  }
  handleFlyTo(e, r3) {
    return this.currentHelper.handleFlyTo(e, r3);
  }
};
function Uw(t63) {
  if (Array.isArray(t63)) {
    let e = new Kl({ type: t63 });
    return { projection: e, transform: new Jl(), cameraHelper: new Ql(e) };
  }
  switch (t63) {
    case "mercator":
      return { projection: new xo(), transform: new Fn(), cameraHelper: new On2() };
    case "globe": {
      let e = new Kl({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
      return { projection: e, transform: new Jl(), cameraHelper: new Ql(e) };
    }
    case "vertical-perspective":
      return { projection: new Ia(), transform: new Ea(), cameraHelper: new La() };
    default:
      return ve2(`Unknown projection name: ${t63}. Falling back to mercator projection.`), { projection: new xo(), transform: new Fn(), cameraHelper: new On2() };
  }
}
var Ah = (t63, e) => oi(t63, e && e.filter((r3) => r3.identifier !== "source.canvas"));
var XO = Q_();
var Da = class extends Ee {
  constructor(r3, n = {}) {
    super();
    this._rtlPluginLoaded = () => {
      for (let r4 in this.sourceCaches) {
        let n3 = this.sourceCaches[r4].getSource().type;
        (n3 === "vector" || n3 === "geojson") && this.sourceCaches[r4].reload();
      }
    };
    this.map = r3, this.dispatcher = new Ll(Qp(), r3._getMapId()), this.dispatcher.registerMessageHandler("GG", (i, o) => this.getGlyphs(i, o)), this.dispatcher.registerMessageHandler("GI", (i, o) => this.getImages(i, o)), this.imageManager = new Zp(), this.imageManager.setEventedParent(this), this.glyphManager = new qp(r3._requestManager, n.localIdeographFontFamily), this.lineAtlas = new $p(256, 512), this.crossTileSymbolIndex = new wa(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new eo(), this._loaded = false, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", pc()), ba().on(zl, this._rtlPluginLoaded), this.on("data", (i) => {
      if (i.dataType !== "source" || i.sourceDataType !== "metadata") return;
      let o = this.sourceCaches[i.sourceId];
      if (!o) return;
      let a = o.getSource();
      if (!(!a || !a.vectorLayerIds)) for (let s3 in this._layers) {
        let l = this._layers[s3];
        l.source === a.id && this._validateLayer(l);
      }
    });
  }
  setGlobalStateProperty(r3, n) {
    this._checkLoaded();
    let i = n === null ? this.stylesheet.state?.[r3]?.default ?? null : n;
    if (Dr(i, this._globalState[r3])) return this;
    this._globalState[r3] = i;
    let o = this._findGlobalStateAffectedSources([r3]);
    for (let a in this.sourceCaches) o.has(a) && (this._reloadSource(a), this._changed = true);
  }
  getGlobalState() {
    return this._globalState;
  }
  setGlobalState(r3) {
    this._checkLoaded();
    let n = [];
    for (let o in r3) !Dr(this._globalState[o], r3[o].default) && (n.push(o), this._globalState[o] = r3[o].default);
    let i = this._findGlobalStateAffectedSources(n);
    for (let o in this.sourceCaches) i.has(o) && (this._reloadSource(o), this._changed = true);
  }
  _findGlobalStateAffectedSources(r3) {
    if (r3.length === 0) return /* @__PURE__ */ new Set();
    let n = /* @__PURE__ */ new Set();
    for (let i in this._layers) {
      let o = this._layers[i], a = o.getLayoutAffectingGlobalStateRefs();
      for (let s3 of r3) a.has(s3) && n.add(o.source);
    }
    return n;
  }
  loadURL(r3, n = {}, i) {
    this.fire(new U("dataloading", { dataType: "style" })), n.validate = typeof n.validate == "boolean" ? n.validate : true;
    let o = this.map._requestManager.transformRequest(r3, "Style");
    this._loadStyleRequest = new AbortController();
    let a = this._loadStyleRequest;
    Kn(o, this._loadStyleRequest).then((s3) => {
      this._loadStyleRequest = null, this._load(s3.data, n, i);
    }).catch((s3) => {
      this._loadStyleRequest = null, s3 && !a.signal.aborted && this.fire(new Q(s3));
    });
  }
  loadJSON(r3, n = {}, i) {
    this.fire(new U("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), ae.frameAsync(this._frameRequest).then(() => {
      this._frameRequest = null, n.validate = n.validate !== false, this._load(r3, n, i);
    }).catch(() => {
    });
  }
  loadEmpty() {
    this.fire(new U("dataloading", { dataType: "style" })), this._load(XO, { validate: false });
  }
  _load(r3, n, i) {
    let o = n.transformStyle ? n.transformStyle(i, r3) : r3;
    if (!(n.validate && Ah(this, Je(o)))) {
      this._loaded = true, this.stylesheet = o;
      for (let a in o.sources) this.addSource(a, o.sources[a], { validate: false });
      o.sprite ? this._loadSprite(o.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(o.glyphs), this._createLayers(), this.light = new Yp(this.stylesheet.light), this._setProjectionInternal(this.stylesheet.projection?.type || "mercator"), this.sky = new Wp(this.stylesheet.sky), this.map.setTerrain(this.stylesheet.terrain ?? null), this.setGlobalState(this.stylesheet.state ?? null), this.fire(new U("data", { dataType: "style" })), this.fire(new U("style.load"));
    }
  }
  _createLayers() {
    let r3 = Dd(this.stylesheet.layers);
    this.dispatcher.broadcast("SL", r3), this._order = r3.map((n) => n.id), this._layers = {}, this._serializedLayers = null;
    for (let n of r3) {
      let i = Hp(n);
      i.setEventedParent(this, { layer: { id: n.id } }), this._layers[n.id] = i;
    }
  }
  _loadSprite(r3, n = false, i = void 0) {
    this.imageManager.setLoaded(false), this._spriteRequest = new AbortController();
    let o;
    y1(r3, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((a) => {
      if (this._spriteRequest = null, a) for (let s3 in a) {
        this._spritesImagesIds[s3] = [];
        let l = this._spritesImagesIds[s3] ? this._spritesImagesIds[s3].filter((u3) => !(u3 in a)) : [];
        for (let u3 of l) this.imageManager.removeImage(u3), this._changedImages[u3] = true;
        for (let u3 in a[s3]) {
          let c = s3 === "default" ? u3 : `${s3}:${u3}`;
          this._spritesImagesIds[s3].push(c), c in this.imageManager.images ? this.imageManager.updateImage(c, a[s3][u3], false) : this.imageManager.addImage(c, a[s3][u3]), n && (this._changedImages[c] = true);
        }
      }
    }).catch((a) => {
      this._spriteRequest = null, o = a, this.fire(new Q(o));
    }).finally(() => {
      this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), n && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new U("data", { dataType: "style" })), i && i(o);
    });
  }
  _unloadSprite() {
    for (let r3 of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(r3), this._changedImages[r3] = true;
    this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new U("data", { dataType: "style" }));
  }
  _validateLayer(r3) {
    let n = this.sourceCaches[r3.source];
    if (!n) return;
    let i = r3.sourceLayer;
    if (!i) return;
    let o = n.getSource();
    (o.type === "geojson" || o.vectorLayerIds && o.vectorLayerIds.indexOf(i) === -1) && this.fire(new Q(new Error(`Source layer "${i}" does not exist on source "${o.id}" as specified by style layer "${r3.id}".`)));
  }
  loaded() {
    if (!this._loaded || Object.keys(this._updatedSources).length) return false;
    for (let r3 in this.sourceCaches) if (!this.sourceCaches[r3].loaded()) return false;
    return !!this.imageManager.isLoaded();
  }
  _serializeByIds(r3, n = false) {
    let i = this._serializedAllLayers();
    if (!r3 || r3.length === 0) return Object.values(n ? kt2(i) : i);
    let o = [];
    for (let a of r3) if (i[a]) {
      let s3 = n ? kt2(i[a]) : i[a];
      o.push(s3);
    }
    return o;
  }
  _serializedAllLayers() {
    let r3 = this._serializedLayers;
    if (r3) return r3;
    r3 = this._serializedLayers = {};
    let n = Object.keys(this._layers);
    for (let i of n) {
      let o = this._layers[i];
      o.type !== "custom" && (r3[i] = o.serialize());
    }
    return r3;
  }
  hasTransitions() {
    if (this.light?.hasTransition() || this.sky?.hasTransition() || this.projection?.hasTransition()) return true;
    for (let r3 in this.sourceCaches) if (this.sourceCaches[r3].hasTransition()) return true;
    for (let r3 in this._layers) if (this._layers[r3].hasTransition()) return true;
    return false;
  }
  _checkLoaded() {
    if (!this._loaded) throw new Error("Style is not done loading.");
  }
  update(r3) {
    if (!this._loaded) return;
    let n = this._changed;
    if (n) {
      let o = Object.keys(this._updatedLayers), a = Object.keys(this._removedLayers);
      (o.length || a.length) && this._updateWorkerLayers(o, a);
      for (let s3 in this._updatedSources) {
        let l = this._updatedSources[s3];
        if (l === "reload") this._reloadSource(s3);
        else if (l === "clear") this._clearSource(s3);
        else throw new Error(`Invalid action ${l}`);
      }
      this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
      for (let s3 in this._updatedPaintProps) this._layers[s3].updateTransitions(r3);
      this.light.updateTransitions(r3), this.sky.updateTransitions(r3), this._resetUpdates();
    }
    let i = {};
    for (let o in this.sourceCaches) {
      let a = this.sourceCaches[o];
      i[o] = a.used, a.used = false;
    }
    for (let o of this._order) {
      let a = this._layers[o];
      a.recalculate(r3, this._availableImages), !a.isHidden(r3.zoom) && a.source && (this.sourceCaches[a.source].used = true);
    }
    for (let o in i) {
      let a = this.sourceCaches[o];
      !!i[o] != !!a.used && a.fire(new U("data", { sourceDataType: "visibility", dataType: "source", sourceId: o }));
    }
    this.light.recalculate(r3), this.sky.recalculate(r3), this.projection.recalculate(r3), this.z = r3.zoom, n && this.fire(new U("data", { dataType: "style" }));
  }
  _updateTilesForChangedImages() {
    let r3 = Object.keys(this._changedImages);
    if (r3.length) {
      for (let n in this.sourceCaches) this.sourceCaches[n].reloadTilesForDependencies(["icons", "patterns"], r3);
      this._changedImages = {};
    }
  }
  _updateTilesForChangedGlyphs() {
    if (this._glyphsDidChange) {
      for (let r3 in this.sourceCaches) this.sourceCaches[r3].reloadTilesForDependencies(["glyphs"], [""]);
      this._glyphsDidChange = false;
    }
  }
  _updateWorkerLayers(r3, n) {
    this.dispatcher.broadcast("UL", { layers: this._serializeByIds(r3, false), removedIds: n });
  }
  _resetUpdates() {
    this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
  }
  setState(r3, n = {}) {
    this._checkLoaded();
    let i = this.serialize();
    if (r3 = n.transformStyle ? n.transformStyle(i, r3) : r3, (n.validate ?? true) && Ah(this, Je(r3))) return false;
    r3 = kt2(r3), r3.layers = Dd(r3.layers);
    let a = A_(i, r3), s3 = this._getOperationsToPerform(a);
    if (s3.unimplemented.length > 0) throw new Error(`Unimplemented: ${s3.unimplemented.join(", ")}.`);
    if (s3.operations.length === 0) return false;
    for (let l of s3.operations) l();
    return this.stylesheet = r3, this._serializedLayers = null, true;
  }
  _getOperationsToPerform(r3) {
    let n = [], i = [];
    for (let o of r3) switch (o.command) {
      case "setCenter":
      case "setZoom":
      case "setBearing":
      case "setPitch":
      case "setRoll":
        continue;
      case "addLayer":
        n.push(() => this.addLayer.apply(this, o.args));
        break;
      case "removeLayer":
        n.push(() => this.removeLayer.apply(this, o.args));
        break;
      case "setPaintProperty":
        n.push(() => this.setPaintProperty.apply(this, o.args));
        break;
      case "setLayoutProperty":
        n.push(() => this.setLayoutProperty.apply(this, o.args));
        break;
      case "setFilter":
        n.push(() => this.setFilter.apply(this, o.args));
        break;
      case "addSource":
        n.push(() => this.addSource.apply(this, o.args));
        break;
      case "removeSource":
        n.push(() => this.removeSource.apply(this, o.args));
        break;
      case "setLayerZoomRange":
        n.push(() => this.setLayerZoomRange.apply(this, o.args));
        break;
      case "setLight":
        n.push(() => this.setLight.apply(this, o.args));
        break;
      case "setGeoJSONSourceData":
        n.push(() => this.setGeoJSONSourceData.apply(this, o.args));
        break;
      case "setGlyphs":
        n.push(() => this.setGlyphs.apply(this, o.args));
        break;
      case "setSprite":
        n.push(() => this.setSprite.apply(this, o.args));
        break;
      case "setTerrain":
        n.push(() => this.map.setTerrain.apply(this, o.args));
        break;
      case "setSky":
        n.push(() => this.setSky.apply(this, o.args));
        break;
      case "setProjection":
        this.setProjection.apply(this, o.args);
        break;
      case "setGlobalState":
        n.push(() => this.setGlobalState.apply(this, o.args));
        break;
      case "setTransition":
        n.push(() => {
        });
        break;
      default:
        i.push(o.command);
        break;
    }
    return { operations: n, unimplemented: i };
  }
  addImage(r3, n) {
    if (this.getImage(r3)) return this.fire(new Q(new Error(`An image named "${r3}" already exists.`)));
    this.imageManager.addImage(r3, n), this._afterImageUpdated(r3);
  }
  updateImage(r3, n) {
    this.imageManager.updateImage(r3, n);
  }
  getImage(r3) {
    return this.imageManager.getImage(r3);
  }
  removeImage(r3) {
    if (!this.getImage(r3)) return this.fire(new Q(new Error(`An image named "${r3}" does not exist.`)));
    this.imageManager.removeImage(r3), this._afterImageUpdated(r3);
  }
  _afterImageUpdated(r3) {
    this._availableImages = this.imageManager.listImages(), this._changedImages[r3] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new U("data", { dataType: "style" }));
  }
  listImages() {
    return this._checkLoaded(), this.imageManager.listImages();
  }
  addSource(r3, n, i = {}) {
    if (this._checkLoaded(), this.sourceCaches[r3] !== void 0) throw new Error(`Source "${r3}" already exists.`);
    if (!n.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(n).join(", ")}.`);
    if (["vector", "raster", "geojson", "video", "image"].indexOf(n.type) >= 0 && this._validate(Je.source, `sources.${r3}`, n, null, i)) return;
    this.map && this.map._collectResourceTiming && (n.collectResourceTiming = true);
    let s3 = this.sourceCaches[r3] = new Rn(r3, n, this.dispatcher);
    s3.style = this, s3.setEventedParent(this, () => ({ isSourceLoaded: s3.loaded(), source: s3.serialize(), sourceId: r3 })), s3.onAdd(this.map), this._changed = true;
  }
  removeSource(r3) {
    if (this._checkLoaded(), this.sourceCaches[r3] === void 0) throw new Error("There is no source with this ID");
    for (let i in this._layers) if (this._layers[i].source === r3) return this.fire(new Q(new Error(`Source "${r3}" cannot be removed while layer "${i}" is using it.`)));
    let n = this.sourceCaches[r3];
    delete this.sourceCaches[r3], delete this._updatedSources[r3], n.fire(new U("data", { sourceDataType: "metadata", dataType: "source", sourceId: r3 })), n.setEventedParent(null), n.onRemove(this.map), this._changed = true;
  }
  setGeoJSONSourceData(r3, n) {
    if (this._checkLoaded(), this.sourceCaches[r3] === void 0) throw new Error(`There is no source with this ID=${r3}`);
    let i = this.sourceCaches[r3].getSource();
    if (i.type !== "geojson") throw new Error(`geojsonSource.type is ${i.type}, which is !== 'geojson`);
    i.setData(n), this._changed = true;
  }
  getSource(r3) {
    return this.sourceCaches[r3] && this.sourceCaches[r3].getSource();
  }
  addLayer(r3, n, i = {}) {
    this._checkLoaded();
    let o = r3.id;
    if (this.getLayer(o)) {
      this.fire(new Q(new Error(`Layer "${o}" already exists on this map.`)));
      return;
    }
    let a;
    if (r3.type === "custom") {
      if (Ah(this, f1(r3))) return;
      a = Hp(r3);
    } else {
      if ("source" in r3 && typeof r3.source == "object" && (this.addSource(o, r3.source), r3 = kt2(r3), r3 = Z(r3, { source: o })), this._validate(Je.layer, `layers.${o}`, r3, { arrayIndex: -1 }, i)) return;
      a = Hp(r3), this._validateLayer(a), a.setEventedParent(this, { layer: { id: o } });
    }
    let s3 = n ? this._order.indexOf(n) : this._order.length;
    if (n && s3 === -1) {
      this.fire(new Q(new Error(`Cannot add layer "${o}" before non-existing layer "${n}".`)));
      return;
    }
    if (this._order.splice(s3, 0, o), this._layerOrderChanged = true, this._layers[o] = a, this._removedLayers[o] && a.source && a.type !== "custom") {
      let l = this._removedLayers[o];
      delete this._removedLayers[o], l.type !== a.type ? this._updatedSources[a.source] = "clear" : (this._updatedSources[a.source] = "reload", this.sourceCaches[a.source].pause());
    }
    this._updateLayer(a), a.onAdd && a.onAdd(this.map);
  }
  moveLayer(r3, n) {
    if (this._checkLoaded(), this._changed = true, !this._layers[r3]) {
      this.fire(new Q(new Error(`The layer '${r3}' does not exist in the map's style and cannot be moved.`)));
      return;
    }
    if (r3 === n) return;
    let o = this._order.indexOf(r3);
    this._order.splice(o, 1);
    let a = n ? this._order.indexOf(n) : this._order.length;
    if (n && a === -1) {
      this.fire(new Q(new Error(`Cannot move layer "${r3}" before non-existing layer "${n}".`)));
      return;
    }
    this._order.splice(a, 0, r3), this._layerOrderChanged = true;
  }
  removeLayer(r3) {
    this._checkLoaded();
    let n = this._layers[r3];
    if (!n) {
      this.fire(new Q(new Error(`Cannot remove non-existing layer "${r3}".`)));
      return;
    }
    n.setEventedParent(null);
    let i = this._order.indexOf(r3);
    this._order.splice(i, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[r3] = n, delete this._layers[r3], this._serializedLayers && delete this._serializedLayers[r3], delete this._updatedLayers[r3], delete this._updatedPaintProps[r3], n.onRemove && n.onRemove(this.map);
  }
  getLayer(r3) {
    return this._layers[r3];
  }
  getLayersOrder() {
    return [...this._order];
  }
  hasLayer(r3) {
    return r3 in this._layers;
  }
  setLayerZoomRange(r3, n, i) {
    this._checkLoaded();
    let o = this.getLayer(r3);
    if (!o) {
      this.fire(new Q(new Error(`Cannot set the zoom range of non-existing layer "${r3}".`)));
      return;
    }
    o.minzoom === n && o.maxzoom === i || (n != null && (o.minzoom = n), i != null && (o.maxzoom = i), this._updateLayer(o));
  }
  setFilter(r3, n, i = {}) {
    this._checkLoaded();
    let o = this.getLayer(r3);
    if (!o) {
      this.fire(new Q(new Error(`Cannot filter non-existing layer "${r3}".`)));
      return;
    }
    if (!Dr(o.filter, n)) {
      if (n == null) {
        o.setFilter(void 0), this._updateLayer(o);
        return;
      }
      this._validate(Je.filter, `layers.${o.id}.filter`, n, null, i) || (o.setFilter(kt2(n)), this._updateLayer(o));
    }
  }
  getFilter(r3) {
    return kt2(this.getLayer(r3).filter);
  }
  setLayoutProperty(r3, n, i, o = {}) {
    this._checkLoaded();
    let a = this.getLayer(r3);
    if (!a) {
      this.fire(new Q(new Error(`Cannot style non-existing layer "${r3}".`)));
      return;
    }
    Dr(a.getLayoutProperty(n), i) || (a.setLayoutProperty(n, i, o), this._updateLayer(a));
  }
  getLayoutProperty(r3, n) {
    let i = this.getLayer(r3);
    if (!i) {
      this.fire(new Q(new Error(`Cannot get style of non-existing layer "${r3}".`)));
      return;
    }
    return i.getLayoutProperty(n);
  }
  setPaintProperty(r3, n, i, o = {}) {
    this._checkLoaded();
    let a = this.getLayer(r3);
    if (!a) {
      this.fire(new Q(new Error(`Cannot style non-existing layer "${r3}".`)));
      return;
    }
    if (Dr(a.getPaintProperty(n), i)) return;
    a.setPaintProperty(n, i, o) && this._updateLayer(a), this._changed = true, this._updatedPaintProps[r3] = true, this._serializedLayers = null;
  }
  getPaintProperty(r3, n) {
    return this.getLayer(r3).getPaintProperty(n);
  }
  setFeatureState(r3, n) {
    this._checkLoaded();
    let i = r3.source, o = r3.sourceLayer, a = this.sourceCaches[i];
    if (a === void 0) {
      this.fire(new Q(new Error(`The source '${i}' does not exist in the map's style.`)));
      return;
    }
    let s3 = a.getSource().type;
    if (s3 === "geojson" && o) {
      this.fire(new Q(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
      return;
    }
    if (s3 === "vector" && !o) {
      this.fire(new Q(new Error("The sourceLayer parameter must be provided for vector source types.")));
      return;
    }
    r3.id === void 0 && this.fire(new Q(new Error("The feature id parameter must be provided."))), a.setFeatureState(o, r3.id, n);
  }
  removeFeatureState(r3, n) {
    this._checkLoaded();
    let i = r3.source, o = this.sourceCaches[i];
    if (o === void 0) {
      this.fire(new Q(new Error(`The source '${i}' does not exist in the map's style.`)));
      return;
    }
    let a = o.getSource().type, s3 = a === "vector" ? r3.sourceLayer : void 0;
    if (a === "vector" && !s3) {
      this.fire(new Q(new Error("The sourceLayer parameter must be provided for vector source types.")));
      return;
    }
    if (n && typeof r3.id != "string" && typeof r3.id != "number") {
      this.fire(new Q(new Error("A feature id is required to remove its specific state property.")));
      return;
    }
    o.removeFeatureState(s3, r3.id, n);
  }
  getFeatureState(r3) {
    this._checkLoaded();
    let n = r3.source, i = r3.sourceLayer, o = this.sourceCaches[n];
    if (o === void 0) {
      this.fire(new Q(new Error(`The source '${n}' does not exist in the map's style.`)));
      return;
    }
    if (o.getSource().type === "vector" && !i) {
      this.fire(new Q(new Error("The sourceLayer parameter must be provided for vector source types.")));
      return;
    }
    return r3.id === void 0 && this.fire(new Q(new Error("The feature id parameter must be provided."))), o.getFeatureState(i, r3.id);
  }
  getTransition() {
    return Z({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
  }
  serialize() {
    if (!this._loaded) return;
    let r3 = as(this.sourceCaches, (a) => a.serialize()), n = this._serializeByIds(this._order, true), i = this.map.getTerrain() || void 0, o = this.stylesheet;
    return ac({ version: o.version, name: o.name, metadata: o.metadata, light: o.light, sky: o.sky, center: o.center, zoom: o.zoom, bearing: o.bearing, pitch: o.pitch, sprite: o.sprite, glyphs: o.glyphs, transition: o.transition, projection: o.projection, sources: r3, layers: n, terrain: i }, (a) => a !== void 0);
  }
  _updateLayer(r3) {
    this._updatedLayers[r3.id] = true, r3.source && !this._updatedSources[r3.source] && this.sourceCaches[r3.source].getSource().type !== "raster" && (this._updatedSources[r3.source] = "reload", this.sourceCaches[r3.source].pause()), this._serializedLayers = null, this._changed = true;
  }
  _flattenAndSortRenderedFeatures(r3) {
    let n = (s3) => this._layers[s3].type === "fill-extrusion", i = {}, o = [];
    for (let s3 = this._order.length - 1; s3 >= 0; s3--) {
      let l = this._order[s3];
      if (n(l)) {
        i[l] = s3;
        for (let u3 of r3) {
          let c = u3[l];
          if (c) for (let p of c) o.push(p);
        }
      }
    }
    o.sort((s3, l) => l.intersectionZ - s3.intersectionZ);
    let a = [];
    for (let s3 = this._order.length - 1; s3 >= 0; s3--) {
      let l = this._order[s3];
      if (n(l)) for (let u3 = o.length - 1; u3 >= 0; u3--) {
        let c = o[u3].feature;
        if (i[c.layer.id] < s3) break;
        a.push(c), o.pop();
      }
      else for (let u3 of r3) {
        let c = u3[l];
        if (c) for (let p of c) a.push(p.feature);
      }
    }
    return a;
  }
  queryRenderedFeatures(r3, n, i) {
    n && n.filter && this._validate(Je.filter, "queryRenderedFeatures.filter", n.filter, null, n);
    let o = {};
    if (n && n.layers) {
      if (!(Array.isArray(n.layers) || n.layers instanceof Set)) return this.fire(new Q(new Error("parameters.layers must be an Array or a Set of strings"))), [];
      for (let p of n.layers) {
        let h = this._layers[p];
        if (!h) return this.fire(new Q(new Error(`The layer '${p}' does not exist in the map's style and cannot be queried for features.`))), [];
        o[h.source] = true;
      }
    }
    let a = [];
    n.availableImages = this._availableImages;
    let s3 = this._serializedAllLayers(), l = n.layers instanceof Set ? n.layers : Array.isArray(n.layers) ? new Set(n.layers) : null, u3 = { ...n, layers: l };
    for (let c in this.sourceCaches) n.layers && !o[c] || a.push(S1(this.sourceCaches[c], this._layers, s3, r3, u3, i, this.map.terrain ? (p, h, f) => this.map.terrain.getElevation(p, h, f) : void 0));
    return this.placement && a.push(C1(this._layers, s3, this.sourceCaches, r3, u3, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(a);
  }
  querySourceFeatures(r3, n) {
    n && n.filter && this._validate(Je.filter, "querySourceFeatures.filter", n.filter, null, n);
    let i = this.sourceCaches[r3];
    return i ? M1(i, n) : [];
  }
  getLight() {
    return this.light.getLight();
  }
  setLight(r3, n = {}) {
    this._checkLoaded();
    let i = this.light.getLight(), o = false;
    for (let s3 in r3) if (!Dr(r3[s3], i[s3])) {
      o = true;
      break;
    }
    if (!o) return;
    let a = { now: ae.now(), transition: Z({ duration: 300, delay: 0 }, this.stylesheet.transition) };
    this.light.setLight(r3, n), this.light.updateTransitions(a);
  }
  getProjection() {
    return this.stylesheet?.projection;
  }
  setProjection(r3) {
    if (this._checkLoaded(), this.projection) {
      if (this.projection.name === r3.type) return;
      this.projection.destroy(), delete this.projection;
    }
    this.stylesheet.projection = r3, this._setProjectionInternal(r3.type);
  }
  getSky() {
    return this.stylesheet?.sky;
  }
  setSky(r3, n = {}) {
    this._checkLoaded();
    let i = this.getSky(), o = false;
    if (!r3 && !i) return;
    if (r3 && !i) o = true;
    else if (!r3 && i) o = true;
    else for (let s3 in r3) if (!Dr(r3[s3], i[s3])) {
      o = true;
      break;
    }
    if (!o) return;
    let a = { now: ae.now(), transition: Z({ duration: 300, delay: 0 }, this.stylesheet.transition) };
    this.stylesheet.sky = r3, this.sky.setSky(r3, n), this.sky.updateTransitions(a);
  }
  _setProjectionInternal(r3) {
    let n = Uw(r3);
    this.projection = n.projection, this.map.migrateProjection(n.transform, n.cameraHelper);
    for (let i in this.sourceCaches) this.sourceCaches[i].reload();
  }
  _validate(r3, n, i, o, a = {}) {
    return a && a.validate === false ? false : Ah(this, r3.call(Je, Z({ key: n, style: this.serialize(), value: i, styleSpec: D }, o)));
  }
  _remove(r3 = true) {
    this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), ba().off(zl, this._rtlPluginLoaded);
    for (let n in this._layers) this._layers[n].setEventedParent(null);
    for (let n in this.sourceCaches) {
      let i = this.sourceCaches[n];
      i.setEventedParent(null), i.onRemove(this.map);
    }
    this.imageManager.setEventedParent(null), this.setEventedParent(null), r3 && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(r3);
  }
  _clearSource(r3) {
    this.sourceCaches[r3].clearTiles();
  }
  _reloadSource(r3) {
    this.sourceCaches[r3].resume(), this.sourceCaches[r3].reload();
  }
  _updateSources(r3) {
    for (let n in this.sourceCaches) this.sourceCaches[n].update(r3, this.map.terrain);
  }
  _generateCollisionBoxes() {
    for (let r3 in this.sourceCaches) this._reloadSource(r3);
  }
  _updatePlacement(r3, n, i, o, a = false) {
    let s3 = false, l = false, u3 = {};
    for (let p of this._order) {
      let h = this._layers[p];
      if (h.type !== "symbol") continue;
      if (!u3[h.source]) {
        let d = this.sourceCaches[h.source];
        u3[h.source] = d.getRenderableIds(true).map((g) => d.getTileByID(g)).sort((g, x) => x.tileID.overscaledZ - g.tileID.overscaledZ || (g.tileID.isLessThan(x.tileID) ? -1 : 1));
      }
      let f = this.crossTileSymbolIndex.addLayer(h, u3[h.source], r3.center.lng);
      s3 = s3 || f;
    }
    if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), a = a || this._layerOrderChanged || i === 0, (a || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(ae.now(), r3.zoom)) && (this.pauseablePlacement = new xh(r3, this.map.terrain, this._order, a, n, i, o, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, u3), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(ae.now()), l = true), s3 && this.pauseablePlacement.placement.setStale()), l || s3) for (let p of this._order) {
      let h = this._layers[p];
      h.type === "symbol" && this.placement.updateLayerOpacities(h, u3[h.source]);
    }
    return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(ae.now());
  }
  _releaseSymbolFadeTiles() {
    for (let r3 in this.sourceCaches) this.sourceCaches[r3].releaseSymbolFadeTiles();
  }
  async getImages(r3, n) {
    let i = await this.imageManager.getImages(n.icons);
    this._updateTilesForChangedImages();
    let o = this.sourceCaches[n.source];
    return o && o.setDependencies(n.tileID.key, n.type, n.icons), i;
  }
  async getGlyphs(r3, n) {
    let i = await this.glyphManager.getGlyphs(n.stacks), o = this.sourceCaches[n.source];
    return o && o.setDependencies(n.tileID.key, n.type, [""]), i;
  }
  getGlyphsUrl() {
    return this.stylesheet.glyphs || null;
  }
  setGlyphs(r3, n = {}) {
    this._checkLoaded(), !(r3 && this._validate(Je.glyphs, "glyphs", r3, null, n)) && (this._glyphsDidChange = true, this.stylesheet.glyphs = r3, this.glyphManager.entries = {}, this.glyphManager.setURL(r3));
  }
  addSprite(r3, n, i = {}, o) {
    this._checkLoaded();
    let a = [{ id: r3, url: n }], s3 = [...ma(this.stylesheet.sprite), ...a];
    this._validate(Je.sprite, "sprite", s3, null, i) || (this.stylesheet.sprite = s3, this._loadSprite(a, true, o));
  }
  removeSprite(r3) {
    this._checkLoaded();
    let n = ma(this.stylesheet.sprite);
    if (!n.find((i) => i.id === r3)) {
      this.fire(new Q(new Error(`Sprite "${r3}" doesn't exists on this map.`)));
      return;
    }
    if (this._spritesImagesIds[r3]) for (let i of this._spritesImagesIds[r3]) this.imageManager.removeImage(i), this._changedImages[i] = true;
    n.splice(n.findIndex((i) => i.id === r3), 1), this.stylesheet.sprite = n.length > 0 ? n : void 0, delete this._spritesImagesIds[r3], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new U("data", { dataType: "style" }));
  }
  getSprite() {
    return ma(this.stylesheet.sprite);
  }
  setSprite(r3, n = {}, i) {
    this._checkLoaded(), !(r3 && this._validate(Je.sprite, "sprite", r3, null, n)) && (this.stylesheet.sprite = r3, r3 ? this._loadSprite(r3, true, i) : (this._unloadSprite(), i && i(null)));
  }
};
$i();
$i();
var Nw = ze([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
$i();
$i();
var Eh = class {
  constructor() {
    this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
  }
  bind(e, r3, n, i, o, a, s3, l, u3) {
    this.context = e;
    let c = this.boundPaintVertexBuffers.length !== i.length;
    for (let h = 0; !c && h < i.length; h++) this.boundPaintVertexBuffers[h] !== i[h] && (c = true);
    !this.vao || this.boundProgram !== r3 || this.boundLayoutVertexBuffer !== n || c || this.boundIndexBuffer !== o || this.boundVertexOffset !== a || this.boundDynamicVertexBuffer !== s3 || this.boundDynamicVertexBuffer2 !== l || this.boundDynamicVertexBuffer3 !== u3 ? this.freshBind(r3, n, i, o, a, s3, l, u3) : (e.bindVertexArray.set(this.vao), s3 && s3.bind(), o && o.dynamicDraw && o.bind(), l && l.bind(), u3 && u3.bind());
  }
  freshBind(e, r3, n, i, o, a, s3, l) {
    let u3 = e.numAttributes, c = this.context, p = c.gl;
    this.vao && this.destroy(), this.vao = c.createVertexArray(), c.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = r3, this.boundPaintVertexBuffers = n, this.boundIndexBuffer = i, this.boundVertexOffset = o, this.boundDynamicVertexBuffer = a, this.boundDynamicVertexBuffer2 = s3, this.boundDynamicVertexBuffer3 = l, r3.enableAttributes(p, e);
    for (let h of n) h.enableAttributes(p, e);
    a && a.enableAttributes(p, e), s3 && s3.enableAttributes(p, e), l && l.enableAttributes(p, e), r3.bind(), r3.setVertexAttribPointers(p, e, o);
    for (let h of n) h.bind(), h.setVertexAttribPointers(p, e, o);
    a && (a.bind(), a.setVertexAttribPointers(p, e, o)), i && i.bind(), s3 && (s3.bind(), s3.setVertexAttribPointers(p, e, o)), l && (l.bind(), l.setVertexAttribPointers(p, e, o)), c.currentNumAttributes = u3;
  }
  destroy() {
    this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
  }
};
$i();
var Gw = (t63, e) => ({ u_depth: new re(t63, e.u_depth), u_terrain: new re(t63, e.u_terrain), u_terrain_dim: new N(t63, e.u_terrain_dim), u_terrain_matrix: new ft(t63, e.u_terrain_matrix), u_terrain_unpack: new Ot(t63, e.u_terrain_unpack), u_terrain_exaggeration: new N(t63, e.u_terrain_exaggeration) });
var jw = (t63, e) => ({ u_texture: new re(t63, e.u_texture), u_ele_delta: new N(t63, e.u_ele_delta), u_fog_matrix: new ft(t63, e.u_fog_matrix), u_fog_color: new Bt(t63, e.u_fog_color), u_fog_ground_blend: new N(t63, e.u_fog_ground_blend), u_fog_ground_blend_opacity: new N(t63, e.u_fog_ground_blend_opacity), u_horizon_color: new Bt(t63, e.u_horizon_color), u_horizon_fog_blend: new N(t63, e.u_horizon_fog_blend), u_is_globe_mode: new N(t63, e.u_is_globe_mode) });
var Hw = (t63, e) => ({ u_ele_delta: new N(t63, e.u_ele_delta) });
var Xw = (t63, e) => ({ u_texture: new re(t63, e.u_texture), u_terrain_coords_id: new N(t63, e.u_terrain_coords_id), u_ele_delta: new N(t63, e.u_ele_delta) });
var Zw = (t63, e, r3, n, i) => ({ u_texture: 0, u_ele_delta: t63, u_fog_matrix: e, u_fog_color: r3 ? r3.properties.get("fog-color") : K.white, u_fog_ground_blend: r3 ? r3.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: i ? 0 : r3 ? r3.calculateFogBlendOpacity(n) : 0, u_horizon_color: r3 ? r3.properties.get("horizon-color") : K.white, u_horizon_fog_blend: r3 ? r3.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: i ? 1 : 0 });
var qw = (t63) => ({ u_ele_delta: t63 });
var Yw = (t63, e) => ({ u_terrain_coords_id: t63 / 255, u_texture: 0, u_ele_delta: e });
$i();
var Ww = (t63, e) => ({ u_projection_matrix: new ft(t63, e.u_projection_matrix), u_projection_tile_mercator_coords: new Ot(t63, e.u_projection_tile_mercator_coords), u_projection_clipping_plane: new Ot(t63, e.u_projection_clipping_plane), u_projection_transition: new N(t63, e.u_projection_transition), u_projection_fallback_matrix: new ft(t63, e.u_projection_fallback_matrix) });
var $w = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
function Lh(t63) {
  let e = [];
  for (let r3 = 0; r3 < t63.length; r3++) {
    if (t63[r3] === null) continue;
    let n = t63[r3].split(" ");
    e.push(n.pop());
  }
  return e;
}
var Dh = class {
  constructor(e, r3, n, i, o, a, s3, l, u3 = []) {
    let c = e.gl;
    this.program = c.createProgram();
    let p = Lh(r3.staticAttributes), h = n ? n.getBinderAttributes() : [], f = p.concat(h), d = or.prelude.staticUniforms ? Lh(or.prelude.staticUniforms) : [], g = s3.staticUniforms ? Lh(s3.staticUniforms) : [], x = r3.staticUniforms ? Lh(r3.staticUniforms) : [], b = n ? n.getBinderUniforms() : [], v3 = d.concat(g).concat(x).concat(b), P = [];
    for (let L of v3) P.indexOf(L) < 0 && P.push(L);
    let w3 = n ? n.defines() : [];
    wr(c) && w3.unshift("#version 300 es"), o && w3.push("#define OVERDRAW_INSPECTOR;"), a && w3.push("#define TERRAIN3D;"), l && w3.push(l), u3 && w3.push(...u3);
    let T = w3.concat(or.prelude.fragmentSource, s3.fragmentSource, r3.fragmentSource).join(`
`), S = w3.concat(or.prelude.vertexSource, s3.vertexSource, r3.vertexSource).join(`
`);
    wr(c) || (T = Sw(T), S = Tw(S));
    let C3 = c.createShader(c.FRAGMENT_SHADER);
    if (c.isContextLost()) {
      this.failedToCreate = true;
      return;
    }
    if (c.shaderSource(C3, T), c.compileShader(C3), !c.getShaderParameter(C3, c.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${c.getShaderInfoLog(C3)}`);
    c.attachShader(this.program, C3);
    let A = c.createShader(c.VERTEX_SHADER);
    if (c.isContextLost()) {
      this.failedToCreate = true;
      return;
    }
    if (c.shaderSource(A, S), c.compileShader(A), !c.getShaderParameter(A, c.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${c.getShaderInfoLog(A)}`);
    c.attachShader(this.program, A), this.attributes = {};
    let E = {};
    this.numAttributes = f.length;
    for (let L = 0; L < this.numAttributes; L++) f[L] && (c.bindAttribLocation(this.program, L, f[L]), this.attributes[f[L]] = L);
    if (c.linkProgram(this.program), !c.getProgramParameter(this.program, c.LINK_STATUS)) throw new Error(`Program failed to link: ${c.getProgramInfoLog(this.program)}`);
    c.deleteShader(A), c.deleteShader(C3);
    for (let L = 0; L < P.length; L++) {
      let F = P[L];
      if (F && !E[F]) {
        let O = c.getUniformLocation(this.program, F);
        O && (E[F] = O);
      }
    }
    this.fixedUniforms = i(e, E), this.terrainUniforms = Gw(e, E), this.projectionUniforms = Ww(e, E), this.binderUniforms = n ? n.getUniforms(e, E) : [];
  }
  draw(e, r3, n, i, o, a, s3, l, u3, c, p, h, f, d, g, x, b, v3, P) {
    let w3 = e.gl;
    if (this.failedToCreate) return;
    if (e.program.set(this.program), e.setDepthMode(n), e.setStencilMode(i), e.setColorMode(o), e.setCullFace(a), l) {
      e.activeTexture.set(w3.TEXTURE2), w3.bindTexture(w3.TEXTURE_2D, l.depthTexture), e.activeTexture.set(w3.TEXTURE3), w3.bindTexture(w3.TEXTURE_2D, l.texture);
      for (let S in this.terrainUniforms) this.terrainUniforms[S].set(l[S]);
    }
    if (u3) for (let S in u3) {
      let C3 = $w[S];
      this.projectionUniforms[C3].set(u3[S]);
    }
    if (s3) for (let S in this.fixedUniforms) this.fixedUniforms[S].set(s3[S]);
    x && x.setUniforms(e, this.binderUniforms, d, { zoom: g });
    let T = 0;
    switch (r3) {
      case w3.LINES:
        T = 2;
        break;
      case w3.TRIANGLES:
        T = 3;
        break;
      case w3.LINE_STRIP:
        T = 1;
        break;
    }
    for (let S of f.get()) {
      let C3 = S.vaos || (S.vaos = {});
      (C3[c] || (C3[c] = new Eh())).bind(e, this, p, x ? x.getPaintVertexBuffers() : [], h, S.vertexOffset, b, v3, P), w3.drawElements(r3, S.primitiveLength * T, w3.UNSIGNED_SHORT, S.primitiveOffset * T * 2);
    }
  }
};
$i();
$i();
$i();
function Rh(t63, e, r3) {
  let n = 1 / yt(r3, 1, e.transform.tileZoom), i = Math.pow(2, r3.tileID.overscaledZ), o = r3.tileSize * Math.pow(2, e.transform.tileZoom) / i, a = o * (r3.tileID.canonical.x + r3.tileID.wrap * i), s3 = o * r3.tileID.canonical.y;
  return { u_image: 0, u_texsize: r3.imageAtlasTexture.size, u_scale: [n, t63.fromScale, t63.toScale], u_fade: t63.t, u_pixel_coord_upper: [a >> 16, s3 >> 16], u_pixel_coord_lower: [a & 65535, s3 & 65535] };
}
function Kw(t63, e, r3, n) {
  let i = r3.imageManager.getPattern(t63.from.toString()), o = r3.imageManager.getPattern(t63.to.toString()), { width: a, height: s3 } = r3.imageManager.getPixelSize(), l = Math.pow(2, n.tileID.overscaledZ), u3 = n.tileSize * Math.pow(2, r3.transform.tileZoom) / l, c = u3 * (n.tileID.canonical.x + n.tileID.wrap * l), p = u3 * n.tileID.canonical.y;
  return { u_image: 0, u_pattern_tl_a: i.tl, u_pattern_br_a: i.br, u_pattern_tl_b: o.tl, u_pattern_br_b: o.br, u_texsize: [a, s3], u_mix: e.t, u_pattern_size_a: i.displaySize, u_pattern_size_b: o.displaySize, u_scale_a: e.fromScale, u_scale_b: e.toScale, u_tile_units_to_pixels: 1 / yt(n, 1, r3.transform.tileZoom), u_pixel_coord_upper: [c >> 16, p >> 16], u_pixel_coord_lower: [c & 65535, p & 65535] };
}
var Jw = (t63, e) => ({ u_lightpos: new gt(t63, e.u_lightpos), u_lightpos_globe: new gt(t63, e.u_lightpos_globe), u_lightintensity: new N(t63, e.u_lightintensity), u_lightcolor: new gt(t63, e.u_lightcolor), u_vertical_gradient: new N(t63, e.u_vertical_gradient), u_opacity: new N(t63, e.u_opacity), u_fill_translate: new ee(t63, e.u_fill_translate) });
var Qw = (t63, e) => ({ u_lightpos: new gt(t63, e.u_lightpos), u_lightpos_globe: new gt(t63, e.u_lightpos_globe), u_lightintensity: new N(t63, e.u_lightintensity), u_lightcolor: new gt(t63, e.u_lightcolor), u_vertical_gradient: new N(t63, e.u_vertical_gradient), u_height_factor: new N(t63, e.u_height_factor), u_opacity: new N(t63, e.u_opacity), u_fill_translate: new ee(t63, e.u_fill_translate), u_image: new re(t63, e.u_image), u_texsize: new ee(t63, e.u_texsize), u_pixel_coord_upper: new ee(t63, e.u_pixel_coord_upper), u_pixel_coord_lower: new ee(t63, e.u_pixel_coord_lower), u_scale: new gt(t63, e.u_scale), u_fade: new N(t63, e.u_fade) });
var ig = (t63, e, r3, n) => {
  let i = t63.style.light, o = i.properties.get("position"), a = [o.x, o.y, o.z], s3 = vn.create();
  i.properties.get("anchor") === "viewport" && vn.fromRotation(s3, t63.transform.bearingInRadians), V.transformMat3(a, a, s3);
  let l = t63.transform.transformLightDirection(a), u3 = i.properties.get("color");
  return { u_lightpos: a, u_lightpos_globe: l, u_lightintensity: i.properties.get("intensity"), u_lightcolor: [u3.r, u3.g, u3.b], u_vertical_gradient: +e, u_opacity: r3, u_fill_translate: n };
};
var eT = (t63, e, r3, n, i, o, a) => Z(ig(t63, e, r3, n), Rh(o, t63, a), { u_height_factor: -Math.pow(2, i.overscaledZ) / a.tileSize / 8 });
$i();
var tT = (t63, e) => ({ u_fill_translate: new ee(t63, e.u_fill_translate) });
var rT = (t63, e) => ({ u_image: new re(t63, e.u_image), u_texsize: new ee(t63, e.u_texsize), u_pixel_coord_upper: new ee(t63, e.u_pixel_coord_upper), u_pixel_coord_lower: new ee(t63, e.u_pixel_coord_lower), u_scale: new gt(t63, e.u_scale), u_fade: new N(t63, e.u_fade), u_fill_translate: new ee(t63, e.u_fill_translate) });
var nT = (t63, e) => ({ u_world: new ee(t63, e.u_world), u_fill_translate: new ee(t63, e.u_fill_translate) });
var iT = (t63, e) => ({ u_world: new ee(t63, e.u_world), u_image: new re(t63, e.u_image), u_texsize: new ee(t63, e.u_texsize), u_pixel_coord_upper: new ee(t63, e.u_pixel_coord_upper), u_pixel_coord_lower: new ee(t63, e.u_pixel_coord_lower), u_scale: new gt(t63, e.u_scale), u_fade: new N(t63, e.u_fade), u_fill_translate: new ee(t63, e.u_fill_translate) });
var og = (t63, e, r3, n) => Z(Rh(e, t63, r3), { u_fill_translate: n });
var oT = (t63) => ({ u_fill_translate: t63 });
var aT = (t63, e) => ({ u_world: t63, u_fill_translate: e });
var sT = (t63, e, r3, n, i) => Z(og(t63, e, r3, i), { u_world: n });
$i();
var lT = (t63, e) => ({ u_camera_to_center_distance: new N(t63, e.u_camera_to_center_distance), u_scale_with_map: new re(t63, e.u_scale_with_map), u_pitch_with_map: new re(t63, e.u_pitch_with_map), u_extrude_scale: new ee(t63, e.u_extrude_scale), u_device_pixel_ratio: new N(t63, e.u_device_pixel_ratio), u_globe_extrude_scale: new N(t63, e.u_globe_extrude_scale), u_translate: new ee(t63, e.u_translate) });
var uT = (t63, e, r3, n, i) => {
  let o = t63.transform, a, s3, l = 0;
  if (r3.paint.get("circle-pitch-alignment") === "map") {
    let u3 = yt(e, 1, o.zoom);
    a = true, s3 = [u3, u3], l = u3 / (8192 * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * i;
  } else a = false, s3 = o.pixelsToGLUnits;
  return { u_camera_to_center_distance: o.cameraToCenterDistance, u_scale_with_map: +(r3.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +a, u_device_pixel_ratio: t63.pixelRatio, u_extrude_scale: s3, u_globe_extrude_scale: l, u_translate: n };
};
$i();
var cT = (t63, e) => ({ u_pixel_extrude_scale: new ee(t63, e.u_pixel_extrude_scale) });
var pT = (t63, e) => ({ u_viewport_size: new ee(t63, e.u_viewport_size) });
var hT = (t63) => ({ u_pixel_extrude_scale: [1 / t63.width, 1 / t63.height] });
var fT = (t63) => ({ u_viewport_size: [t63.width, t63.height] });
$i();
var mT = (t63, e) => ({ u_color: new Bt(t63, e.u_color), u_overlay: new re(t63, e.u_overlay), u_overlay_scale: new N(t63, e.u_overlay_scale) });
var ag = (t63, e = 1) => ({ u_color: t63, u_overlay: 0, u_overlay_scale: e });
$i();
var dT = (t63, e) => ({ u_extrude_scale: new N(t63, e.u_extrude_scale), u_intensity: new N(t63, e.u_intensity), u_globe_extrude_scale: new N(t63, e.u_globe_extrude_scale) });
var yT = (t63, e) => ({ u_matrix: new ft(t63, e.u_matrix), u_world: new ee(t63, e.u_world), u_image: new re(t63, e.u_image), u_color_ramp: new re(t63, e.u_color_ramp), u_opacity: new N(t63, e.u_opacity) });
var sg = (t63, e, r3, n) => {
  let o = yt(t63, 1, e) / (8192 * Math.pow(2, t63.tileID.overscaledZ)) * 2 * Math.PI * n;
  return { u_extrude_scale: yt(t63, 1, e), u_intensity: r3, u_globe_extrude_scale: o };
};
var lg = (t63, e, r3, n) => {
  let i = B.create();
  B.ortho(i, 0, t63.width, t63.height, 0, 0, 1);
  let o = t63.context.gl;
  return { u_matrix: i, u_world: [o.drawingBufferWidth, o.drawingBufferHeight], u_image: r3, u_color_ramp: n, u_opacity: e.paint.get("heatmap-opacity") };
};
$i();
var gT = (t63, e) => ({ u_image: new re(t63, e.u_image), u_latrange: new ee(t63, e.u_latrange), u_exaggeration: new N(t63, e.u_exaggeration), u_altitudes: new ul(t63, e.u_altitudes), u_azimuths: new ul(t63, e.u_azimuths), u_accent: new Bt(t63, e.u_accent), u_method: new re(t63, e.u_method), u_shadows: new ll(t63, e.u_shadows), u_highlights: new ll(t63, e.u_highlights) });
var xT = (t63, e) => ({ u_matrix: new ft(t63, e.u_matrix), u_image: new re(t63, e.u_image), u_dimension: new ee(t63, e.u_dimension), u_zoom: new N(t63, e.u_zoom), u_unpack: new Ot(t63, e.u_unpack) });
var bT = (t63, e, r3) => {
  let n = r3.paint.get("hillshade-accent-color"), i;
  switch (r3.paint.get("hillshade-method")) {
    case "basic":
      i = 4;
      break;
    case "combined":
      i = 1;
      break;
    case "igor":
      i = 2;
      break;
    case "multidirectional":
      i = 3;
      break;
    case "standard":
    default:
      i = 0;
      break;
  }
  let o = r3.getIlluminationProperties();
  for (let a = 0; a < o.directionRadians.length; a++) r3.paint.get("hillshade-illumination-anchor") === "viewport" && (o.directionRadians[a] += t63.transform.bearingInRadians);
  return { u_image: 0, u_latrange: ZO(t63, e.tileID), u_exaggeration: r3.paint.get("hillshade-exaggeration"), u_altitudes: o.altitudeRadians, u_azimuths: o.directionRadians, u_accent: n, u_method: i, u_highlights: o.highlightColor, u_shadows: o.shadowColor };
};
var _T = (t63, e) => {
  let r3 = e.stride, n = B.create();
  return B.ortho(n, 0, 8192, -8192, 0, 0, 1), B.translate(n, n, [0, -8192, 0]), { u_matrix: n, u_image: 1, u_dimension: [r3, r3], u_zoom: t63.overscaledZ, u_unpack: e.getUnpackVector() };
};
function ZO(t63, e) {
  let r3 = Math.pow(2, e.canonical.z), n = e.canonical.y;
  return [new xe(0, n / r3).toLngLat().lat, new xe(0, (n + 1) / r3).toLngLat().lat];
}
$i();
var vT = (t63, e) => ({ u_image: new re(t63, e.u_image), u_unpack: new Ot(t63, e.u_unpack), u_dimension: new ee(t63, e.u_dimension), u_elevation_stops: new re(t63, e.u_elevation_stops), u_color_stops: new re(t63, e.u_color_stops), u_opacity: new N(t63, e.u_opacity) });
var PT = (t63, e) => ({ u_image: 0, u_unpack: e.getUnpackVector(), u_dimension: [e.stride, e.stride], u_elevation_stops: 1, u_color_stops: 4, u_opacity: t63.paint.get("color-relief-opacity") });
$i();
var wT = (t63, e) => ({ u_translation: new ee(t63, e.u_translation), u_ratio: new N(t63, e.u_ratio), u_device_pixel_ratio: new N(t63, e.u_device_pixel_ratio), u_units_to_pixels: new ee(t63, e.u_units_to_pixels) });
var TT = (t63, e) => ({ u_translation: new ee(t63, e.u_translation), u_ratio: new N(t63, e.u_ratio), u_device_pixel_ratio: new N(t63, e.u_device_pixel_ratio), u_units_to_pixels: new ee(t63, e.u_units_to_pixels), u_image: new re(t63, e.u_image), u_image_height: new N(t63, e.u_image_height) });
var ST = (t63, e) => ({ u_translation: new ee(t63, e.u_translation), u_texsize: new ee(t63, e.u_texsize), u_ratio: new N(t63, e.u_ratio), u_device_pixel_ratio: new N(t63, e.u_device_pixel_ratio), u_image: new re(t63, e.u_image), u_units_to_pixels: new ee(t63, e.u_units_to_pixels), u_scale: new gt(t63, e.u_scale), u_fade: new N(t63, e.u_fade) });
var CT = (t63, e) => ({ u_translation: new ee(t63, e.u_translation), u_ratio: new N(t63, e.u_ratio), u_device_pixel_ratio: new N(t63, e.u_device_pixel_ratio), u_units_to_pixels: new ee(t63, e.u_units_to_pixels), u_patternscale_a: new ee(t63, e.u_patternscale_a), u_patternscale_b: new ee(t63, e.u_patternscale_b), u_sdfgamma: new N(t63, e.u_sdfgamma), u_image: new re(t63, e.u_image), u_tex_y_a: new N(t63, e.u_tex_y_a), u_tex_y_b: new N(t63, e.u_tex_y_b), u_mix: new N(t63, e.u_mix) });
var kh = (t63, e, r3, n) => {
  let i = t63.transform;
  return { u_translation: LT(t63, e, r3), u_ratio: n / yt(e, 1, i.zoom), u_device_pixel_ratio: t63.pixelRatio, u_units_to_pixels: [1 / i.pixelsToGLUnits[0], 1 / i.pixelsToGLUnits[1]] };
};
var MT = (t63, e, r3, n, i) => Z(kh(t63, e, r3, n), { u_image: 0, u_image_height: i });
var IT = (t63, e, r3, n, i) => {
  let o = t63.transform, a = ET(e, o);
  return { u_translation: LT(t63, e, r3), u_texsize: e.imageAtlasTexture.size, u_ratio: n / yt(e, 1, o.zoom), u_device_pixel_ratio: t63.pixelRatio, u_image: 0, u_scale: [a, i.fromScale, i.toScale], u_fade: i.t, u_units_to_pixels: [1 / o.pixelsToGLUnits[0], 1 / o.pixelsToGLUnits[1]] };
};
var AT = (t63, e, r3, n, i, o) => {
  let a = t63.transform, s3 = t63.lineAtlas, l = ET(e, a), u3 = r3.layout.get("line-cap") === "round", c = s3.getDash(i.from, u3), p = s3.getDash(i.to, u3), h = c.width * o.fromScale, f = p.width * o.toScale;
  return Z(kh(t63, e, r3, n), { u_patternscale_a: [l / h, -c.height / 2], u_patternscale_b: [l / f, -p.height / 2], u_sdfgamma: s3.width / (Math.min(h, f) * 256 * t63.pixelRatio) / 2, u_image: 0, u_tex_y_a: c.y, u_tex_y_b: p.y, u_mix: o.t });
};
function ET(t63, e) {
  return 1 / yt(t63, 1, e.tileZoom);
}
function LT(t63, e, r3) {
  return Yt(t63.transform, e, r3.paint.get("line-translate"), r3.paint.get("line-translate-anchor"));
}
$i();
var DT = (t63, e) => ({ u_tl_parent: new ee(t63, e.u_tl_parent), u_scale_parent: new N(t63, e.u_scale_parent), u_buffer_scale: new N(t63, e.u_buffer_scale), u_fade_t: new N(t63, e.u_fade_t), u_opacity: new N(t63, e.u_opacity), u_image0: new re(t63, e.u_image0), u_image1: new re(t63, e.u_image1), u_brightness_low: new N(t63, e.u_brightness_low), u_brightness_high: new N(t63, e.u_brightness_high), u_saturation_factor: new N(t63, e.u_saturation_factor), u_contrast_factor: new N(t63, e.u_contrast_factor), u_spin_weights: new gt(t63, e.u_spin_weights), u_coords_top: new Ot(t63, e.u_coords_top), u_coords_bottom: new Ot(t63, e.u_coords_bottom) });
var RT = (t63, e, r3, n, i) => ({ u_tl_parent: t63, u_scale_parent: e, u_buffer_scale: 1, u_fade_t: r3.mix, u_opacity: r3.opacity * n.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: n.paint.get("raster-brightness-min"), u_brightness_high: n.paint.get("raster-brightness-max"), u_saturation_factor: WO(n.paint.get("raster-saturation")), u_contrast_factor: YO(n.paint.get("raster-contrast")), u_spin_weights: qO(n.paint.get("raster-hue-rotate")), u_coords_top: [i[0].x, i[0].y, i[1].x, i[1].y], u_coords_bottom: [i[3].x, i[3].y, i[2].x, i[2].y] });
function qO(t63) {
  t63 *= Math.PI / 180;
  let e = Math.sin(t63), r3 = Math.cos(t63);
  return [(2 * r3 + 1) / 3, (-Math.sqrt(3) * e - r3 + 1) / 3, (Math.sqrt(3) * e - r3 + 1) / 3];
}
function YO(t63) {
  return t63 > 0 ? 1 / (1 - t63) : 1 + t63;
}
function WO(t63) {
  return t63 > 0 ? 1 - 1 / (1.001 - t63) : -t63;
}
$i();
var kT = (t63, e) => ({ u_is_size_zoom_constant: new re(t63, e.u_is_size_zoom_constant), u_is_size_feature_constant: new re(t63, e.u_is_size_feature_constant), u_size_t: new N(t63, e.u_size_t), u_size: new N(t63, e.u_size), u_camera_to_center_distance: new N(t63, e.u_camera_to_center_distance), u_pitch: new N(t63, e.u_pitch), u_rotate_symbol: new re(t63, e.u_rotate_symbol), u_aspect_ratio: new N(t63, e.u_aspect_ratio), u_fade_change: new N(t63, e.u_fade_change), u_label_plane_matrix: new ft(t63, e.u_label_plane_matrix), u_coord_matrix: new ft(t63, e.u_coord_matrix), u_is_text: new re(t63, e.u_is_text), u_pitch_with_map: new re(t63, e.u_pitch_with_map), u_is_along_line: new re(t63, e.u_is_along_line), u_is_variable_anchor: new re(t63, e.u_is_variable_anchor), u_texsize: new ee(t63, e.u_texsize), u_texture: new re(t63, e.u_texture), u_translation: new ee(t63, e.u_translation), u_pitched_scale: new N(t63, e.u_pitched_scale) });
var FT = (t63, e) => ({ u_is_size_zoom_constant: new re(t63, e.u_is_size_zoom_constant), u_is_size_feature_constant: new re(t63, e.u_is_size_feature_constant), u_size_t: new N(t63, e.u_size_t), u_size: new N(t63, e.u_size), u_camera_to_center_distance: new N(t63, e.u_camera_to_center_distance), u_pitch: new N(t63, e.u_pitch), u_rotate_symbol: new re(t63, e.u_rotate_symbol), u_aspect_ratio: new N(t63, e.u_aspect_ratio), u_fade_change: new N(t63, e.u_fade_change), u_label_plane_matrix: new ft(t63, e.u_label_plane_matrix), u_coord_matrix: new ft(t63, e.u_coord_matrix), u_is_text: new re(t63, e.u_is_text), u_pitch_with_map: new re(t63, e.u_pitch_with_map), u_is_along_line: new re(t63, e.u_is_along_line), u_is_variable_anchor: new re(t63, e.u_is_variable_anchor), u_texsize: new ee(t63, e.u_texsize), u_texture: new re(t63, e.u_texture), u_gamma_scale: new N(t63, e.u_gamma_scale), u_device_pixel_ratio: new N(t63, e.u_device_pixel_ratio), u_is_halo: new re(t63, e.u_is_halo), u_translation: new ee(t63, e.u_translation), u_pitched_scale: new N(t63, e.u_pitched_scale) });
var OT = (t63, e) => ({ u_is_size_zoom_constant: new re(t63, e.u_is_size_zoom_constant), u_is_size_feature_constant: new re(t63, e.u_is_size_feature_constant), u_size_t: new N(t63, e.u_size_t), u_size: new N(t63, e.u_size), u_camera_to_center_distance: new N(t63, e.u_camera_to_center_distance), u_pitch: new N(t63, e.u_pitch), u_rotate_symbol: new re(t63, e.u_rotate_symbol), u_aspect_ratio: new N(t63, e.u_aspect_ratio), u_fade_change: new N(t63, e.u_fade_change), u_label_plane_matrix: new ft(t63, e.u_label_plane_matrix), u_coord_matrix: new ft(t63, e.u_coord_matrix), u_is_text: new re(t63, e.u_is_text), u_pitch_with_map: new re(t63, e.u_pitch_with_map), u_is_along_line: new re(t63, e.u_is_along_line), u_is_variable_anchor: new re(t63, e.u_is_variable_anchor), u_texsize: new ee(t63, e.u_texsize), u_texsize_icon: new ee(t63, e.u_texsize_icon), u_texture: new re(t63, e.u_texture), u_texture_icon: new re(t63, e.u_texture_icon), u_gamma_scale: new N(t63, e.u_gamma_scale), u_device_pixel_ratio: new N(t63, e.u_device_pixel_ratio), u_is_halo: new re(t63, e.u_is_halo), u_translation: new ee(t63, e.u_translation), u_pitched_scale: new N(t63, e.u_pitched_scale) });
var ug = (t63, e, r3, n, i, o, a, s3, l, u3, c, p, h) => {
  let f = a.transform;
  return { u_is_size_zoom_constant: +(t63 === "constant" || t63 === "source"), u_is_size_feature_constant: +(t63 === "constant" || t63 === "camera"), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: f.cameraToCenterDistance, u_pitch: f.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +r3, u_aspect_ratio: f.width / f.height, u_fade_change: a.options.fadeDuration ? a.symbolFadeChange : 1, u_label_plane_matrix: s3, u_coord_matrix: l, u_is_text: +c, u_pitch_with_map: +n, u_is_along_line: i, u_is_variable_anchor: o, u_texsize: p, u_texture: 0, u_translation: u3, u_pitched_scale: h };
};
var cg = (t63, e, r3, n, i, o, a, s3, l, u3, c, p, h, f) => {
  let d = a.transform;
  return Z(ug(t63, e, r3, n, i, o, a, s3, l, u3, c, p, f), { u_gamma_scale: n ? Math.cos(d.pitch * Math.PI / 180) * d.cameraToCenterDistance : 1, u_device_pixel_ratio: a.pixelRatio, u_is_halo: +h });
};
var BT = (t63, e, r3, n, i, o, a, s3, l, u3, c, p, h) => Z(cg(t63, e, r3, n, i, o, a, s3, l, u3, true, c, true, h), { u_texsize_icon: p, u_texture_icon: 1 });
$i();
var zT = (t63, e) => ({ u_opacity: new N(t63, e.u_opacity), u_color: new Bt(t63, e.u_color) });
var VT = (t63, e) => ({ u_opacity: new N(t63, e.u_opacity), u_image: new re(t63, e.u_image), u_pattern_tl_a: new ee(t63, e.u_pattern_tl_a), u_pattern_br_a: new ee(t63, e.u_pattern_br_a), u_pattern_tl_b: new ee(t63, e.u_pattern_tl_b), u_pattern_br_b: new ee(t63, e.u_pattern_br_b), u_texsize: new ee(t63, e.u_texsize), u_mix: new N(t63, e.u_mix), u_pattern_size_a: new ee(t63, e.u_pattern_size_a), u_pattern_size_b: new ee(t63, e.u_pattern_size_b), u_scale_a: new N(t63, e.u_scale_a), u_scale_b: new N(t63, e.u_scale_b), u_pixel_coord_upper: new ee(t63, e.u_pixel_coord_upper), u_pixel_coord_lower: new ee(t63, e.u_pixel_coord_lower), u_tile_units_to_pixels: new N(t63, e.u_tile_units_to_pixels) });
var UT = (t63, e) => ({ u_opacity: t63, u_color: e });
var NT = (t63, e, r3, n, i) => Z(Kw(r3, i, e, n), { u_opacity: t63 });
$i();
var GT = (t63, e) => ({ u_sun_pos: new gt(t63, e.u_sun_pos), u_atmosphere_blend: new N(t63, e.u_atmosphere_blend), u_globe_position: new gt(t63, e.u_globe_position), u_globe_radius: new N(t63, e.u_globe_radius), u_inv_proj_matrix: new ft(t63, e.u_inv_proj_matrix) });
var jT = (t63, e, r3, n, i) => ({ u_sun_pos: t63, u_atmosphere_blend: e, u_globe_position: r3, u_globe_radius: n, u_inv_proj_matrix: i });
$i();
var HT = (t63, e) => ({ u_sky_color: new Bt(t63, e.u_sky_color), u_horizon_color: new Bt(t63, e.u_horizon_color), u_horizon: new ee(t63, e.u_horizon), u_horizon_normal: new ee(t63, e.u_horizon_normal), u_sky_horizon_blend: new N(t63, e.u_sky_horizon_blend), u_sky_blend: new N(t63, e.u_sky_blend) });
var XT = (t63, e, r3) => {
  let n = Math.cos(e.rollInRadians), i = Math.sin(e.rollInRadians), o = va(e), s3 = e.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }).projectionTransition;
  return { u_sky_color: t63.properties.get("sky-color"), u_horizon_color: t63.properties.get("horizon-color"), u_horizon: [(e.width / 2 - o * i) * r3, (e.height / 2 + o * n) * r3], u_horizon_normal: [-i, n], u_sky_horizon_blend: t63.properties.get("sky-horizon-blend") * e.height / 2 * r3, u_sky_blend: s3 };
};
var ZT = (t63, e) => {
};
var qT = { fillExtrusion: Jw, fillExtrusionPattern: Qw, fill: tT, fillPattern: rT, fillOutline: nT, fillOutlinePattern: iT, circle: lT, collisionBox: cT, collisionCircle: pT, debug: mT, depth: ZT, clippingMask: ZT, heatmap: dT, heatmapTexture: yT, hillshade: gT, hillshadePrepare: xT, colorRelief: vT, line: wT, lineGradient: TT, linePattern: ST, lineSDF: CT, raster: DT, symbolIcon: kT, symbolSDF: FT, symbolTextAndIcon: OT, background: zT, backgroundPattern: VT, terrain: jw, terrainDepth: Hw, terrainCoords: Xw, projectionErrorMeasurement: Aw, atmosphere: GT, sky: HT };
$i();
$i();
var Fh = class {
  constructor(e, r3, n) {
    this.context = e;
    let i = e.gl;
    this.buffer = i.createBuffer(), this.dynamicDraw = !!n, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), i.bufferData(i.ELEMENT_ARRAY_BUFFER, r3.arrayBuffer, this.dynamicDraw ? i.DYNAMIC_DRAW : i.STATIC_DRAW), this.dynamicDraw || delete r3.arrayBuffer;
  }
  bind() {
    this.context.bindElementBuffer.set(this.buffer);
  }
  updateData(e) {
    let r3 = this.context.gl;
    if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
    this.context.unbindVAO(), this.bind(), r3.bufferSubData(r3.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
  }
  destroy() {
    let e = this.context.gl;
    this.buffer && (e.deleteBuffer(this.buffer), delete this.buffer);
  }
};
$i();
var $O = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
var Oh = class {
  constructor(e, r3, n, i) {
    this.length = r3.length, this.attributes = n, this.itemSize = r3.bytesPerElement, this.dynamicDraw = i, this.context = e;
    let o = e.gl;
    this.buffer = o.createBuffer(), e.bindVertexBuffer.set(this.buffer), o.bufferData(o.ARRAY_BUFFER, r3.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || delete r3.arrayBuffer;
  }
  bind() {
    this.context.bindVertexBuffer.set(this.buffer);
  }
  updateData(e) {
    if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
    let r3 = this.context.gl;
    this.bind(), r3.bufferSubData(r3.ARRAY_BUFFER, 0, e.arrayBuffer);
  }
  enableAttributes(e, r3) {
    for (let n = 0; n < this.attributes.length; n++) {
      let i = this.attributes[n], o = r3.attributes[i.name];
      o !== void 0 && e.enableVertexAttribArray(o);
    }
  }
  setVertexAttribPointers(e, r3, n) {
    for (let i = 0; i < this.attributes.length; i++) {
      let o = this.attributes[i], a = r3.attributes[o.name];
      a !== void 0 && e.vertexAttribPointer(a, o.components, e[$O[o.type]], false, this.itemSize, o.offset + this.itemSize * (n || 0));
    }
  }
  destroy() {
    let e = this.context.gl;
    this.buffer && (e.deleteBuffer(this.buffer), delete this.buffer);
  }
};
$i();
$i();
var Oe = class {
  constructor(e) {
    this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
  }
  get() {
    return this.current;
  }
  set(e) {
  }
  getDefault() {
    return this.default;
  }
  setDefault() {
    this.set(this.default);
  }
};
var Bh = class extends Oe {
  getDefault() {
    return K.transparent;
  }
  set(e) {
    let r3 = this.current;
    e.r === r3.r && e.g === r3.g && e.b === r3.b && e.a === r3.a && !this.dirty || (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = false);
  }
};
var zh = class extends Oe {
  getDefault() {
    return 1;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.clearDepth(e), this.current = e, this.dirty = false);
  }
};
var Vh = class extends Oe {
  getDefault() {
    return 0;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.clearStencil(e), this.current = e, this.dirty = false);
  }
};
var Uh = class extends Oe {
  getDefault() {
    return [true, true, true, true];
  }
  set(e) {
    let r3 = this.current;
    e[0] === r3[0] && e[1] === r3[1] && e[2] === r3[2] && e[3] === r3[3] && !this.dirty || (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = false);
  }
};
var Nh = class extends Oe {
  getDefault() {
    return true;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.depthMask(e), this.current = e, this.dirty = false);
  }
};
var Gh = class extends Oe {
  getDefault() {
    return 255;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.stencilMask(e), this.current = e, this.dirty = false);
  }
};
var jh = class extends Oe {
  getDefault() {
    return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
  }
  set(e) {
    let r3 = this.current;
    e.func === r3.func && e.ref === r3.ref && e.mask === r3.mask && !this.dirty || (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = false);
  }
};
var Hh = class extends Oe {
  getDefault() {
    let e = this.gl;
    return [e.KEEP, e.KEEP, e.KEEP];
  }
  set(e) {
    let r3 = this.current;
    e[0] === r3[0] && e[1] === r3[1] && e[2] === r3[2] && !this.dirty || (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = false);
  }
};
var Xh = class extends Oe {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let r3 = this.gl;
    e ? r3.enable(r3.STENCIL_TEST) : r3.disable(r3.STENCIL_TEST), this.current = e, this.dirty = false;
  }
};
var Zh = class extends Oe {
  getDefault() {
    return [0, 1];
  }
  set(e) {
    let r3 = this.current;
    e[0] === r3[0] && e[1] === r3[1] && !this.dirty || (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = false);
  }
};
var qh = class extends Oe {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let r3 = this.gl;
    e ? r3.enable(r3.DEPTH_TEST) : r3.disable(r3.DEPTH_TEST), this.current = e, this.dirty = false;
  }
};
var Yh = class extends Oe {
  getDefault() {
    return this.gl.LESS;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.depthFunc(e), this.current = e, this.dirty = false);
  }
};
var Wh = class extends Oe {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let r3 = this.gl;
    e ? r3.enable(r3.BLEND) : r3.disable(r3.BLEND), this.current = e, this.dirty = false;
  }
};
var $h = class extends Oe {
  getDefault() {
    let e = this.gl;
    return [e.ONE, e.ZERO];
  }
  set(e) {
    let r3 = this.current;
    e[0] === r3[0] && e[1] === r3[1] && !this.dirty || (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = false);
  }
};
var Kh = class extends Oe {
  getDefault() {
    return K.transparent;
  }
  set(e) {
    let r3 = this.current;
    e.r === r3.r && e.g === r3.g && e.b === r3.b && e.a === r3.a && !this.dirty || (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = false);
  }
};
var Jh = class extends Oe {
  getDefault() {
    return this.gl.FUNC_ADD;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.blendEquation(e), this.current = e, this.dirty = false);
  }
};
var Qh = class extends Oe {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let r3 = this.gl;
    e ? r3.enable(r3.CULL_FACE) : r3.disable(r3.CULL_FACE), this.current = e, this.dirty = false;
  }
};
var ef = class extends Oe {
  getDefault() {
    return this.gl.BACK;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.cullFace(e), this.current = e, this.dirty = false);
  }
};
var tf = class extends Oe {
  getDefault() {
    return this.gl.CCW;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.frontFace(e), this.current = e, this.dirty = false);
  }
};
var rf = class extends Oe {
  getDefault() {
    return null;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.useProgram(e), this.current = e, this.dirty = false);
  }
};
var nf = class extends Oe {
  getDefault() {
    return this.gl.TEXTURE0;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.activeTexture(e), this.current = e, this.dirty = false);
  }
};
var of = class extends Oe {
  getDefault() {
    let e = this.gl;
    return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
  }
  set(e) {
    let r3 = this.current;
    e[0] === r3[0] && e[1] === r3[1] && e[2] === r3[2] && e[3] === r3[3] && !this.dirty || (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = false);
  }
};
var af = class extends Oe {
  getDefault() {
    return null;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let r3 = this.gl;
    r3.bindFramebuffer(r3.FRAMEBUFFER, e), this.current = e, this.dirty = false;
  }
};
var sf = class extends Oe {
  getDefault() {
    return null;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let r3 = this.gl;
    r3.bindRenderbuffer(r3.RENDERBUFFER, e), this.current = e, this.dirty = false;
  }
};
var lf = class extends Oe {
  getDefault() {
    return null;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let r3 = this.gl;
    r3.bindTexture(r3.TEXTURE_2D, e), this.current = e, this.dirty = false;
  }
};
var uf = class extends Oe {
  getDefault() {
    return null;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let r3 = this.gl;
    r3.bindBuffer(r3.ARRAY_BUFFER, e), this.current = e, this.dirty = false;
  }
};
var cf = class extends Oe {
  getDefault() {
    return null;
  }
  set(e) {
    let r3 = this.gl;
    r3.bindBuffer(r3.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = false;
  }
};
var pf = class extends Oe {
  getDefault() {
    return null;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let r3 = this.gl;
    wr(r3) ? r3.bindVertexArray(e) : r3.getExtension("OES_vertex_array_object")?.bindVertexArrayOES(e), this.current = e, this.dirty = false;
  }
};
var hf = class extends Oe {
  getDefault() {
    return 4;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let r3 = this.gl;
    r3.pixelStorei(r3.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = false;
  }
};
var ff = class extends Oe {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let r3 = this.gl;
    r3.pixelStorei(r3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = false;
  }
};
var mf = class extends Oe {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let r3 = this.gl;
    r3.pixelStorei(r3.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = false;
  }
};
var eu = class extends Oe {
  constructor(e, r3) {
    super(e), this.context = e, this.parent = r3;
  }
  getDefault() {
    return null;
  }
};
var df = class extends eu {
  setDirty() {
    this.dirty = true;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    this.context.bindFramebuffer.set(this.parent);
    let r3 = this.gl;
    r3.framebufferTexture2D(r3.FRAMEBUFFER, r3.COLOR_ATTACHMENT0, r3.TEXTURE_2D, e, 0), this.current = e, this.dirty = false;
  }
};
var yf = class extends eu {
  set(e) {
    if (e === this.current && !this.dirty) return;
    this.context.bindFramebuffer.set(this.parent);
    let r3 = this.gl;
    r3.framebufferRenderbuffer(r3.FRAMEBUFFER, r3.DEPTH_ATTACHMENT, r3.RENDERBUFFER, e), this.current = e, this.dirty = false;
  }
};
var gf = class extends eu {
  set(e) {
    if (e === this.current && !this.dirty) return;
    this.context.bindFramebuffer.set(this.parent);
    let r3 = this.gl;
    r3.framebufferRenderbuffer(r3.FRAMEBUFFER, r3.DEPTH_STENCIL_ATTACHMENT, r3.RENDERBUFFER, e), this.current = e, this.dirty = false;
  }
};
$i();
var YT = "Framebuffer is not complete";
function WT(t63) {
  return t63.message === YT;
}
function $T() {
  return new Error(YT);
}
var xf = class {
  constructor(e, r3, n, i, o) {
    this.context = e, this.width = r3, this.height = n;
    let a = e.gl, s3 = this.framebuffer = a.createFramebuffer();
    if (this.colorAttachment = new df(e, s3), i) this.depthAttachment = o ? new gf(e, s3) : new yf(e, s3);
    else if (o) throw new Error("Stencil cannot be set without depth");
    if (a.checkFramebufferStatus(a.FRAMEBUFFER) !== a.FRAMEBUFFER_COMPLETE) throw $T();
  }
  destroy() {
    let e = this.context.gl, r3 = this.colorAttachment.get();
    if (r3 && e.deleteTexture(r3), this.depthAttachment) {
      let n = this.depthAttachment.get();
      n && e.deleteRenderbuffer(n);
    }
    e.deleteFramebuffer(this.framebuffer);
  }
};
var bf = class {
  constructor(e) {
    if (this.gl = e, this.clearColor = new Bh(this), this.clearDepth = new zh(this), this.clearStencil = new Vh(this), this.colorMask = new Uh(this), this.depthMask = new Nh(this), this.stencilMask = new Gh(this), this.stencilFunc = new jh(this), this.stencilOp = new Hh(this), this.stencilTest = new Xh(this), this.depthRange = new Zh(this), this.depthTest = new qh(this), this.depthFunc = new Yh(this), this.blend = new Wh(this), this.blendFunc = new $h(this), this.blendColor = new Kh(this), this.blendEquation = new Jh(this), this.cullFace = new Qh(this), this.cullFaceSide = new ef(this), this.frontFace = new tf(this), this.program = new rf(this), this.activeTexture = new nf(this), this.viewport = new of(this), this.bindFramebuffer = new af(this), this.bindRenderbuffer = new sf(this), this.bindTexture = new lf(this), this.bindVertexBuffer = new uf(this), this.bindElementBuffer = new cf(this), this.bindVertexArray = new pf(this), this.pixelStoreUnpack = new hf(this), this.pixelStoreUnpackPremultiplyAlpha = new ff(this), this.pixelStoreUnpackFlipY = new mf(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), wr(e)) {
      this.HALF_FLOAT = e.HALF_FLOAT;
      let r3 = e.getExtension("EXT_color_buffer_half_float");
      this.RGBA16F = e.RGBA16F ?? r3?.RGBA16F_EXT, this.RGB16F = e.RGB16F ?? r3?.RGB16F_EXT, e.getExtension("EXT_color_buffer_float");
    } else {
      e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
      let r3 = e.getExtension("OES_texture_half_float");
      this.HALF_FLOAT = r3?.HALF_FLOAT_OES;
    }
  }
  setDefault() {
    this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
  }
  setDirty() {
    this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
  }
  createIndexBuffer(e, r3) {
    return new Fh(this, e, r3);
  }
  createVertexBuffer(e, r3, n) {
    return new Oh(this, e, r3, n);
  }
  createRenderbuffer(e, r3, n) {
    let i = this.gl, o = i.createRenderbuffer();
    return this.bindRenderbuffer.set(o), i.renderbufferStorage(i.RENDERBUFFER, e, r3, n), this.bindRenderbuffer.set(null), o;
  }
  createFramebuffer(e, r3, n, i) {
    return new xf(this, e, r3, n, i);
  }
  clear({ color: e, depth: r3, stencil: n }) {
    let i = this.gl, o = 0;
    e && (o |= i.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([true, true, true, true])), typeof r3 < "u" && (o |= i.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(r3), this.depthMask.set(true)), typeof n < "u" && (o |= i.STENCIL_BUFFER_BIT, this.clearStencil.set(n), this.stencilMask.set(255)), i.clear(o);
  }
  setCullFace(e) {
    e.enable === false ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
  }
  setDepthMode(e) {
    e.func === this.gl.ALWAYS && !e.mask ? this.depthTest.set(false) : (this.depthTest.set(true), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range));
  }
  setStencilMode(e) {
    e.test.func === this.gl.ALWAYS && !e.mask ? this.stencilTest.set(false) : (this.stencilTest.set(true), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask }));
  }
  setColorMode(e) {
    Dr(e.blendFunction, De.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
  }
  createVertexArray() {
    return wr(this.gl) ? this.gl.createVertexArray() : this.gl.getExtension("OES_vertex_array_object")?.createVertexArrayOES();
  }
  deleteVertexArray(e) {
    return wr(this.gl) ? this.gl.deleteVertexArray(e) : this.gl.getExtension("OES_vertex_array_object")?.deleteVertexArrayOES(e);
  }
  unbindVAO() {
    this.bindVertexArray.set(null);
  }
};
$i();
var vf = s(fe(), 1);
$i();
var _f;
function pg(t63, e, r3, n, i) {
  let o = t63.context, a = t63.transform, s3 = o.gl, l = t63.useProgram("collisionBox"), u3 = [], c = 0, p = 0;
  for (let b = 0; b < n.length; b++) {
    let v3 = n[b], w3 = e.getTile(v3).getBucket(r3);
    if (!w3) continue;
    let T = i ? w3.textCollisionBox : w3.iconCollisionBox, S = w3.collisionCircleArray;
    S.length > 0 && (u3.push({ circleArray: S, circleOffset: p, coord: v3 }), c += S.length / 4, p = c), T && l.draw(o, s3.LINES, ne.disabled, pe.disabled, t63.colorModeForRenderPass(), le.disabled, hT(t63.transform), t63.style.map.terrain && t63.style.map.terrain.getTerrainData(v3), a.getProjectionData({ overscaledTileID: v3, applyGlobeMatrix: true, applyTerrainMatrix: true }), r3.id, T.layoutVertexBuffer, T.indexBuffer, T.segments, null, t63.transform.zoom, null, null, T.collisionVertexBuffer);
  }
  if (!i || !u3.length) return;
  let h = t63.useProgram("collisionCircle"), f = new up();
  f.resize(c * 4), f._trim();
  let d = 0;
  for (let b of u3) for (let v3 = 0; v3 < b.circleArray.length / 4; v3++) {
    let P = v3 * 4, w3 = b.circleArray[P + 0], T = b.circleArray[P + 1], S = b.circleArray[P + 2], C3 = b.circleArray[P + 3];
    f.emplace(d++, w3, T, S, C3, 0), f.emplace(d++, w3, T, S, C3, 1), f.emplace(d++, w3, T, S, C3, 2), f.emplace(d++, w3, T, S, C3, 3);
  }
  (!_f || _f.length < c * 2) && (_f = KO(c));
  let g = o.createIndexBuffer(_f, true), x = o.createVertexBuffer(f, U0.members, true);
  for (let b of u3) {
    let v3 = fT(t63.transform);
    h.draw(o, s3.TRIANGLES, ne.disabled, pe.disabled, t63.colorModeForRenderPass(), le.disabled, v3, t63.style.map.terrain && t63.style.map.terrain.getTerrainData(b.coord), null, r3.id, x, g, de2.simpleSegment(0, b.circleOffset * 2, b.circleArray.length, b.circleArray.length / 2), null, t63.transform.zoom, null, null, null);
  }
  x.destroy(), g.destroy();
}
function KO(t63) {
  let e = t63 * 2, r3 = new pp();
  r3.resize(e), r3._trim();
  for (let n = 0; n < e; n++) {
    let i = n * 6;
    r3.uint16[i + 0] = n * 4 + 0, r3.uint16[i + 1] = n * 4 + 1, r3.uint16[i + 2] = n * 4 + 2, r3.uint16[i + 3] = n * 4 + 2, r3.uint16[i + 4] = n * 4 + 3, r3.uint16[i + 5] = n * 4 + 0;
  }
  return r3;
}
var JO = B.identity(new Float32Array(16));
function QT(t63, e, r3, n, i, o) {
  if (t63.renderPass !== "translucent") return;
  let { isRenderingToTexture: a } = o, s3 = pe.disabled, l = t63.colorModeForRenderPass();
  (r3._unevaluatedLayout.hasValue("text-variable-anchor") || r3._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && eB(n, t63, r3, e, r3.layout.get("text-rotation-alignment"), r3.layout.get("text-pitch-alignment"), r3.paint.get("text-translate"), r3.paint.get("text-translate-anchor"), i), r3.paint.get("icon-opacity").constantOr(1) !== 0 && KT(t63, e, r3, n, false, r3.paint.get("icon-translate"), r3.paint.get("icon-translate-anchor"), r3.layout.get("icon-rotation-alignment"), r3.layout.get("icon-pitch-alignment"), r3.layout.get("icon-keep-upright"), s3, l, a), r3.paint.get("text-opacity").constantOr(1) !== 0 && KT(t63, e, r3, n, true, r3.paint.get("text-translate"), r3.paint.get("text-translate-anchor"), r3.layout.get("text-rotation-alignment"), r3.layout.get("text-pitch-alignment"), r3.layout.get("text-keep-upright"), s3, l, a), e.map.showCollisionBoxes && (pg(t63, e, r3, n, true), pg(t63, e, r3, n, false));
}
function QO(t63, e, r3, n, i, o) {
  let { horizontalAlign: a, verticalAlign: s3 } = Op(t63), l = -(a - 0.5) * e, u3 = -(s3 - 0.5) * r3;
  return new vf.default((l / i + n[0]) * o, (u3 / i + n[1]) * o);
}
function eB(t63, e, r3, n, i, o, a, s3, l) {
  let u3 = e.transform, c = e.style.map.terrain, p = i === "map", h = o === "map";
  for (let f of t63) {
    let d = n.getTile(f), g = d.getBucket(r3);
    if (!g || !g.text || !g.text.segments.get().length) continue;
    let x = g.textSizeData, b = co(x, u3.zoom), v3 = yt(d, 1, e.transform.zoom), P = Nl(p, e.transform, v3), w3 = r3.layout.get("icon-text-fit") !== "none" && g.hasIconData();
    if (b) {
      let T = Math.pow(2, u3.zoom - d.tileID.overscaledZ), S = c ? (A, E) => c.getElevation(f, A, E) : null, C3 = Yt(u3, d, a, s3);
      rB(g, p, h, l, u3, P, T, b, w3, C3, f.toUnwrapped(), S);
    }
  }
}
function tB(t63, e, r3, n, i, o) {
  let a = e.tileAnchorPoint.add(new vf.default(e.translation[0], e.translation[1]));
  if (e.pitchWithMap) {
    let s3 = n.mult(o);
    r3 || (s3 = s3.rotate(-i));
    let l = a.add(s3);
    return fh(l.x, l.y, e.pitchedLabelPlaneMatrix, e.getElevation).point;
  } else if (r3) {
    let l = _i(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(t63), u3 = Math.atan(l.y / l.x) + (l.x < 0 ? Math.PI : 0);
    return t63.add(n.rotate(u3));
  } else return t63.add(n);
}
function rB(t63, e, r3, n, i, o, a, s3, l, u3, c, p) {
  let h = t63.text.placedSymbolArray, f = t63.text.dynamicLayoutVertexArray, d = t63.icon.dynamicLayoutVertexArray, g = {};
  f.clear();
  for (let x = 0; x < h.length; x++) {
    let b = h.get(x), v3 = t63.allowVerticalPlacement && !b.placedOrientation, P = !b.hidden && b.crossTileID && !v3 ? n[b.crossTileID] : null;
    if (!P) yo(b.numGlyphs, f);
    else {
      let w3 = new vf.default(b.anchorX, b.anchorY), T = { getElevation: p, width: i.width, height: i.height, pitchedLabelPlaneMatrix: o, lineVertexArray: null, pitchWithMap: r3, transform: i, projectionCache: null, tileAnchorPoint: w3, translation: u3, unwrappedTileID: c }, S = r3 ? Oy(w3.x, w3.y, T) : _i(w3.x, w3.y, T), C3 = ky(i.cameraToCenterDistance, S.signedDistanceFromCamera), A = ha(t63.textSizeData, s3, b) * C3 / mi;
      r3 && (A *= t63.tilePixelRatio / a);
      let { width: E, height: L, anchor: F, textOffset: O, textBoxScale: z } = P, I = QO(F, E, L, O, z, A), R = i.getPitchedTextCorrection(w3.x + u3[0], w3.y + u3[1], c), H = tB(S.point, T, e, I, -i.bearingInRadians, R), W = t63.allowVerticalPlacement && b.placedOrientation === 2 ? Math.PI / 2 : 0;
      for (let $ = 0; $ < b.numGlyphs; $++) po(f, H, W);
      l && b.associatedIconIndex >= 0 && (g[b.associatedIconIndex] = { shiftedAnchor: H, angle: W });
    }
  }
  if (l) {
    d.clear();
    let x = t63.icon.placedSymbolArray;
    for (let b = 0; b < x.length; b++) {
      let v3 = x.get(b);
      if (v3.hidden) yo(v3.numGlyphs, d);
      else {
        let P = g[b];
        if (!P) yo(v3.numGlyphs, d);
        else for (let w3 = 0; w3 < v3.numGlyphs; w3++) po(d, P.shiftedAnchor, P.angle);
      }
    }
    t63.icon.dynamicLayoutVertexBuffer.updateData(d);
  }
  t63.text.dynamicLayoutVertexBuffer.updateData(f);
}
function nB(t63, e, r3) {
  return r3.iconsInText && e ? "symbolTextAndIcon" : t63 ? "symbolSDF" : "symbolIcon";
}
function KT(t63, e, r3, n, i, o, a, s3, l, u3, c, p, h) {
  let f = t63.context, d = f.gl, g = t63.transform, x = s3 === "map", b = l === "map", v3 = s3 !== "viewport" && r3.layout.get("symbol-placement") !== "point", P = x && !b && !v3, w3 = !r3.layout.get("symbol-sort-key").isConstant(), T = false, S = t63.getDepthModeForSublayer(0, ne.ReadOnly), C3 = r3._unevaluatedLayout.hasValue("text-variable-anchor") || r3._unevaluatedLayout.hasValue("text-variable-anchor-offset"), A = [], E = g.getCircleRadiusCorrection();
  for (let L of n) {
    let F = e.getTile(L), O = F.getBucket(r3);
    if (!O) continue;
    let z = i ? O.text : O.icon;
    if (!z || !z.segments.get().length || !z.hasVisibleVertices) continue;
    let I = z.programConfigurations.get(r3.id), R = i || O.sdfIcons, H = i ? O.textSizeData : O.iconSizeData, W = b || g.pitch !== 0, $ = t63.useProgram(nB(R, i, O), I), he = co(H, g.zoom), Xe = t63.style.map.terrain && t63.style.map.terrain.getTerrainData(L), be, ye = [0, 0], Ze, st, vt = null, dt;
    if (i) {
      if (Ze = F.glyphAtlasTexture, st = d.LINEAR, be = F.glyphAtlasTexture.size, O.iconsInText) {
        ye = F.imageAtlasTexture.size, vt = F.imageAtlasTexture;
        let At = H.kind === "composite" || H.kind === "camera";
        dt = W || t63.options.rotating || t63.options.zooming || At ? d.LINEAR : d.NEAREST;
      }
    } else {
      let At = r3.layout.get("icon-size").constantOr(0) !== 1 || O.iconsNeedLinear;
      Ze = F.imageAtlasTexture, st = R || t63.options.rotating || t63.options.zooming || At || W ? d.LINEAR : d.NEAREST, be = F.imageAtlasTexture.size;
    }
    let zt = yt(F, 1, t63.transform.zoom), cr = Nl(x, t63.transform, zt), rn = B.create();
    B.invert(rn, cr);
    let pr = K1(b, x, t63.transform, zt), Ct = Yt(g, F, o, a), Ya = g.getProjectionData({ overscaledTileID: L, applyGlobeMatrix: !h, applyTerrainMatrix: true }), Lo = C3 && O.hasTextData(), Li = r3.layout.get("icon-text-fit") !== "none" && Lo && O.hasIconData();
    if (v3) {
      let At = t63.style.map.terrain ? (Di, Ro) => t63.style.map.terrain.getElevation(L, Di, Ro) : null, Ar = r3.layout.get("text-rotation-alignment") === "map";
      J1(O, t63, i, cr, rn, b, u3, Ar, L.toUnwrapped(), g.width, g.height, Ct, At);
    }
    let xn = i && C3 || Li, Do = b ? cr : t63.transform.clipSpaceToPixelsMatrix, Ir = v3 || xn ? JO : Do, Hn = R && r3.paint.get(i ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0, bn2;
    R ? O.iconsInText ? bn2 = BT(H.kind, he, P, b, v3, xn, t63, Ir, pr, Ct, be, ye, E) : bn2 = cg(H.kind, he, P, b, v3, xn, t63, Ir, pr, Ct, i, be, true, E) : bn2 = ug(H.kind, he, P, b, v3, xn, t63, Ir, pr, Ct, i, be, E);
    let Dt = { program: $, buffers: z, uniformValues: bn2, projectionData: Ya, atlasTexture: Ze, atlasTextureIcon: vt, atlasInterpolation: st, atlasInterpolationIcon: dt, isSDF: R, hasHalo: Hn };
    if (w3 && O.canOverlap) {
      T = true;
      let At = z.segments.get();
      for (let Ar of At) A.push({ segments: new de2([Ar]), sortKey: Ar.sortKey, state: Dt, terrainData: Xe });
    } else A.push({ segments: z.segments, sortKey: 0, state: Dt, terrainData: Xe });
  }
  T && A.sort((L, F) => L.sortKey - F.sortKey);
  for (let L of A) {
    let F = L.state;
    if (f.activeTexture.set(d.TEXTURE0), F.atlasTexture.bind(F.atlasInterpolation, d.CLAMP_TO_EDGE), F.atlasTextureIcon && (f.activeTexture.set(d.TEXTURE1), F.atlasTextureIcon && F.atlasTextureIcon.bind(F.atlasInterpolationIcon, d.CLAMP_TO_EDGE)), F.isSDF) {
      let O = F.uniformValues;
      F.hasHalo && (O.u_is_halo = 1, JT(F.buffers, L.segments, r3, t63, F.program, S, c, p, O, F.projectionData, L.terrainData)), O.u_is_halo = 0;
    }
    JT(F.buffers, L.segments, r3, t63, F.program, S, c, p, F.uniformValues, F.projectionData, L.terrainData);
  }
}
function JT(t63, e, r3, n, i, o, a, s3, l, u3, c) {
  let p = n.context, h = p.gl;
  i.draw(p, h.TRIANGLES, o, a, s3, le.backCCW, l, c, u3, r3.id, t63.layoutVertexBuffer, t63.indexBuffer, e, r3.paint, n.transform.zoom, t63.programConfigurations.get(r3.id), t63.dynamicLayoutVertexBuffer, t63.opacityVertexBuffer);
}
$i();
function eS(t63, e, r3, n, i) {
  if (t63.renderPass !== "translucent") return;
  let { isRenderingToTexture: o } = i, a = r3.paint.get("circle-opacity"), s3 = r3.paint.get("circle-stroke-width"), l = r3.paint.get("circle-stroke-opacity"), u3 = !r3.layout.get("circle-sort-key").isConstant();
  if (a.constantOr(1) === 0 && (s3.constantOr(1) === 0 || l.constantOr(1) === 0)) return;
  let c = t63.context, p = c.gl, h = t63.transform, f = t63.getDepthModeForSublayer(0, ne.ReadOnly), d = pe.disabled, g = t63.colorModeForRenderPass(), x = [], b = h.getCircleRadiusCorrection();
  for (let v3 = 0; v3 < n.length; v3++) {
    let P = n[v3], w3 = e.getTile(P), T = w3.getBucket(r3);
    if (!T) continue;
    let S = r3.paint.get("circle-translate"), C3 = r3.paint.get("circle-translate-anchor"), A = Yt(h, w3, S, C3), E = T.programConfigurations.get(r3.id), L = t63.useProgram("circle", E), F = T.layoutVertexBuffer, O = T.indexBuffer, z = t63.style.map.terrain && t63.style.map.terrain.getTerrainData(P), I = uT(t63, w3, r3, A, b), R = h.getProjectionData({ overscaledTileID: P, applyGlobeMatrix: !o, applyTerrainMatrix: true }), H = { programConfiguration: E, program: L, layoutVertexBuffer: F, indexBuffer: O, uniformValues: I, terrainData: z, projectionData: R };
    if (u3) {
      let W = T.segments.get();
      for (let $ of W) x.push({ segments: new de2([$]), sortKey: $.sortKey, state: H });
    } else x.push({ segments: T.segments, sortKey: 0, state: H });
  }
  u3 && x.sort((v3, P) => v3.sortKey - P.sortKey);
  for (let v3 of x) {
    let { programConfiguration: P, program: w3, layoutVertexBuffer: T, indexBuffer: S, uniformValues: C3, terrainData: A, projectionData: E } = v3.state, L = v3.segments;
    w3.draw(c, p.TRIANGLES, f, d, g, le.backCCW, C3, A, E, r3.id, T, S, L, r3.paint, t63.transform.zoom, P);
  }
}
$i();
function tS(t63, e, r3, n, i) {
  if (r3.paint.get("heatmap-opacity") === 0) return;
  let o = t63.context, { isRenderingToTexture: a, isRenderingGlobe: s3 } = i;
  if (t63.style.map.terrain) {
    for (let l of n) {
      let u3 = e.getTile(l);
      e.hasRenderableParent(l) || (t63.renderPass === "offscreen" ? aB(t63, u3, r3, l, s3) : t63.renderPass === "translucent" && sB(t63, r3, l, a, s3));
    }
    o.viewport.set([0, 0, t63.width, t63.height]);
  } else t63.renderPass === "offscreen" ? iB(t63, e, r3, n) : t63.renderPass === "translucent" && oB(t63, r3);
}
function iB(t63, e, r3, n) {
  let i = t63.context, o = i.gl, a = t63.transform, s3 = pe.disabled, l = new De([o.ONE, o.ONE], K.transparent, [true, true, true, true]);
  lB(i, t63, r3), i.clear({ color: K.transparent });
  for (let u3 = 0; u3 < n.length; u3++) {
    let c = n[u3];
    if (e.hasRenderableParent(c)) continue;
    let p = e.getTile(c), h = p.getBucket(r3);
    if (!h) continue;
    let f = h.programConfigurations.get(r3.id), d = t63.useProgram("heatmap", f), g = a.getProjectionData({ overscaledTileID: c, applyGlobeMatrix: true, applyTerrainMatrix: false }), x = a.getCircleRadiusCorrection();
    d.draw(i, o.TRIANGLES, ne.disabled, s3, l, le.backCCW, sg(p, a.zoom, r3.paint.get("heatmap-intensity"), x), null, g, r3.id, h.layoutVertexBuffer, h.indexBuffer, h.segments, r3.paint, a.zoom, f);
  }
  i.viewport.set([0, 0, t63.width, t63.height]);
}
function oB(t63, e) {
  let r3 = t63.context, n = r3.gl;
  r3.setColorMode(t63.colorModeForRenderPass());
  let i = e.heatmapFbos.get(na);
  if (!i) return;
  r3.activeTexture.set(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, i.colorAttachment.get()), r3.activeTexture.set(n.TEXTURE1), nS(r3, e).bind(n.LINEAR, n.CLAMP_TO_EDGE), t63.useProgram("heatmapTexture").draw(r3, n.TRIANGLES, ne.disabled, pe.disabled, t63.colorModeForRenderPass(), le.disabled, lg(t63, e, 0, 1), null, null, e.id, t63.viewportBuffer, t63.quadTriangleIndexBuffer, t63.viewportSegments, e.paint, t63.transform.zoom);
}
function aB(t63, e, r3, n, i) {
  let o = t63.context, a = o.gl, s3 = pe.disabled, l = new De([a.ONE, a.ONE], K.transparent, [true, true, true, true]), u3 = e.getBucket(r3);
  if (!u3) return;
  let c = n.key, p = r3.heatmapFbos.get(c);
  p || (p = rS(o, e.tileSize, e.tileSize), r3.heatmapFbos.set(c, p)), o.bindFramebuffer.set(p.framebuffer), o.viewport.set([0, 0, e.tileSize, e.tileSize]), o.clear({ color: K.transparent });
  let h = u3.programConfigurations.get(r3.id), f = t63.useProgram("heatmap", h, !i), d = t63.transform.getProjectionData({ overscaledTileID: e.tileID, applyGlobeMatrix: true, applyTerrainMatrix: true }), g = t63.style.map.terrain.getTerrainData(n);
  f.draw(o, a.TRIANGLES, ne.disabled, s3, l, le.disabled, sg(e, t63.transform.zoom, r3.paint.get("heatmap-intensity"), 1), g, d, r3.id, u3.layoutVertexBuffer, u3.indexBuffer, u3.segments, r3.paint, t63.transform.zoom, h);
}
function sB(t63, e, r3, n, i) {
  let o = t63.context, a = o.gl, s3 = t63.transform;
  o.setColorMode(t63.colorModeForRenderPass());
  let l = nS(o, e), u3 = r3.key, c = e.heatmapFbos.get(u3);
  if (!c) return;
  o.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, c.colorAttachment.get()), o.activeTexture.set(a.TEXTURE1), l.bind(a.LINEAR, a.CLAMP_TO_EDGE);
  let p = s3.getProjectionData({ overscaledTileID: r3, applyTerrainMatrix: i, applyGlobeMatrix: !n });
  t63.useProgram("heatmapTexture").draw(o, a.TRIANGLES, ne.disabled, pe.disabled, t63.colorModeForRenderPass(), le.disabled, lg(t63, e, 0, 1), null, p, e.id, t63.rasterBoundsBuffer, t63.quadTriangleIndexBuffer, t63.rasterBoundsSegments, e.paint, s3.zoom), c.destroy(), e.heatmapFbos.delete(u3);
}
function lB(t63, e, r3) {
  let n = t63.gl;
  t63.activeTexture.set(n.TEXTURE1), t63.viewport.set([0, 0, e.width / 4, e.height / 4]);
  let i = r3.heatmapFbos.get(na);
  i ? (n.bindTexture(n.TEXTURE_2D, i.colorAttachment.get()), t63.bindFramebuffer.set(i.framebuffer)) : (i = rS(t63, e.width / 4, e.height / 4), r3.heatmapFbos.set(na, i));
}
function rS(t63, e, r3) {
  let n = t63.gl, i = n.createTexture();
  n.bindTexture(n.TEXTURE_2D, i), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.LINEAR);
  let o = t63.HALF_FLOAT ?? n.UNSIGNED_BYTE, a = t63.RGBA16F ?? n.RGBA;
  n.texImage2D(n.TEXTURE_2D, 0, a, e, r3, 0, n.RGBA, o, null);
  let s3 = t63.createFramebuffer(e, r3, false, false);
  return s3.colorAttachment.set(i), s3;
}
function nS(t63, e) {
  return e.colorRampTexture || (e.colorRampTexture = new Se(t63, e.colorRamp, t63.gl.RGBA)), e.colorRampTexture;
}
$i();
function iS(t63, e, r3, n, i) {
  if (t63.renderPass !== "translucent") return;
  let { isRenderingToTexture: o } = i, a = r3.paint.get("line-opacity"), s3 = r3.paint.get("line-width");
  if (a.constantOr(1) === 0 || s3.constantOr(1) === 0) return;
  let l = t63.getDepthModeForSublayer(0, ne.ReadOnly), u3 = t63.colorModeForRenderPass(), c = r3.paint.get("line-dasharray"), p = r3.paint.get("line-pattern"), h = p.constantOr(1), f = r3.paint.get("line-gradient"), d = r3.getCrossfadeParameters(), g = h ? "linePattern" : c ? "lineSDF" : f ? "lineGradient" : "line", x = t63.context, b = x.gl, v3 = t63.transform, P = true;
  for (let w3 of n) {
    let T = e.getTile(w3);
    if (h && !T.patternsLoaded()) continue;
    let S = T.getBucket(r3);
    if (!S) continue;
    let C3 = S.programConfigurations.get(r3.id), A = t63.context.program.get(), E = t63.useProgram(g, C3), L = P || E.program !== A, F = t63.style.map.terrain && t63.style.map.terrain.getTerrainData(w3), O = p.constantOr(null);
    if (O && T.imageAtlas) {
      let W = T.imageAtlas, $ = W.patternPositions[O.to.toString()], he = W.patternPositions[O.from.toString()];
      $ && he && C3.setConstantPatternPositions($, he);
    }
    let z = v3.getProjectionData({ overscaledTileID: w3, applyGlobeMatrix: !o, applyTerrainMatrix: true }), I = v3.getPixelScale(), R = h ? IT(t63, T, r3, I, d) : c ? AT(t63, T, r3, I, c, d) : f ? MT(t63, T, r3, I, S.lineClipsArray.length) : kh(t63, T, r3, I);
    if (h) x.activeTexture.set(b.TEXTURE0), T.imageAtlasTexture.bind(b.LINEAR, b.CLAMP_TO_EDGE), C3.updatePaintBuffers(d);
    else if (c && (L || t63.lineAtlas.dirty)) x.activeTexture.set(b.TEXTURE0), t63.lineAtlas.bind(x);
    else if (f) {
      let W = S.gradients[r3.id], $ = W.texture;
      if (r3.gradientVersion !== W.version) {
        let he = 256;
        if (r3.stepInterpolant) {
          let Xe = e.getSource().maxzoom, be = w3.canonical.z === Xe ? Math.ceil(1 << t63.transform.maxZoom - w3.canonical.z) : 1, st = S.maxLineLength / 8192 * 1024 * be;
          he = ce(Bb(st), 256, x.maxTextureSize);
        }
        W.gradient = bp({ expression: r3.gradientExpression(), evaluationKey: "lineProgress", resolution: he, image: W.gradient || void 0, clips: S.lineClipsArray }), W.texture ? W.texture.update(W.gradient) : W.texture = new Se(x, W.gradient, b.RGBA), W.version = r3.gradientVersion, $ = W.texture;
      }
      x.activeTexture.set(b.TEXTURE0), $.bind(r3.stepInterpolant ? b.NEAREST : b.LINEAR, b.CLAMP_TO_EDGE);
    }
    let H = t63.stencilModeForClipping(w3);
    E.draw(x, b.TRIANGLES, l, H, u3, le.disabled, R, F, z, r3.id, S.layoutVertexBuffer, S.indexBuffer, S.segments, r3.paint, t63.transform.zoom, C3, S.layoutVertexBuffer2), P = false;
  }
}
$i();
$i();
function Pf(t63, e, r3, n, i) {
  if (!r3 || !n || !n.imageAtlas) return;
  let o = n.imageAtlas.patternPositions, a = o[r3.to.toString()], s3 = o[r3.from.toString()];
  if (!a && s3 && (a = s3), !s3 && a && (s3 = a), !a || !s3) {
    let l = i.getPaintProperty(e);
    a = o[l], s3 = o[l];
  }
  a && s3 && t63.setConstantPatternPositions(a, s3);
}
function aS(t63, e, r3, n, i) {
  let o = r3.paint.get("fill-color"), a = r3.paint.get("fill-opacity");
  if (a.constantOr(1) === 0) return;
  let { isRenderingToTexture: s3 } = i, l = t63.colorModeForRenderPass(), u3 = r3.paint.get("fill-pattern"), c = t63.opaquePassEnabledForLayer() && !u3.constantOr(1) && o.constantOr(K.transparent).a === 1 && a.constantOr(0) === 1 ? "opaque" : "translucent";
  if (t63.renderPass === c) {
    let p = t63.getDepthModeForSublayer(1, t63.renderPass === "opaque" ? ne.ReadWrite : ne.ReadOnly);
    oS(t63, e, r3, n, p, l, false, s3);
  }
  if (t63.renderPass === "translucent" && r3.paint.get("fill-antialias")) {
    let p = t63.getDepthModeForSublayer(r3.getPaintProperty("fill-outline-color") ? 2 : 0, ne.ReadOnly);
    oS(t63, e, r3, n, p, l, true, s3);
  }
}
function oS(t63, e, r3, n, i, o, a, s3) {
  let l = t63.context.gl, u3 = "fill-pattern", c = r3.paint.get(u3), p = c && c.constantOr(1), h = r3.getCrossfadeParameters(), f, d, g, x, b, v3 = t63.transform, P = r3.paint.get("fill-translate"), w3 = r3.paint.get("fill-translate-anchor");
  a ? (d = p && !r3.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", f = l.LINES) : (d = p ? "fillPattern" : "fill", f = l.TRIANGLES);
  let T = c.constantOr(null);
  for (let S of n) {
    let C3 = e.getTile(S);
    if (p && !C3.patternsLoaded()) continue;
    let A = C3.getBucket(r3);
    if (!A) continue;
    let E = A.programConfigurations.get(r3.id), L = t63.useProgram(d, E), F = t63.style.map.terrain && t63.style.map.terrain.getTerrainData(S);
    p && (t63.context.activeTexture.set(l.TEXTURE0), C3.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), E.updatePaintBuffers(h)), Pf(E, u3, T, C3, r3);
    let O = v3.getProjectionData({ overscaledTileID: S, applyGlobeMatrix: !s3, applyTerrainMatrix: true }), z = Yt(v3, C3, P, w3);
    if (!a) x = A.indexBuffer, b = A.segments, g = p ? og(t63, h, C3, z) : oT(z);
    else {
      x = A.indexBuffer2, b = A.segments2;
      let R = [l.drawingBufferWidth, l.drawingBufferHeight];
      g = d === "fillOutlinePattern" && p ? sT(t63, h, C3, R, z) : aT(R, z);
    }
    let I = t63.stencilModeForClipping(S);
    L.draw(t63.context, f, i, I, o, le.backCCW, g, F, O, r3.id, A.layoutVertexBuffer, x, b, r3.paint, t63.transform.zoom, E);
  }
}
$i();
function sS(t63, e, r3, n, i) {
  let o = r3.paint.get("fill-extrusion-opacity");
  if (o === 0) return;
  let { isRenderingToTexture: a } = i;
  if (t63.renderPass === "translucent") {
    let s3 = new ne(t63.context.gl.LEQUAL, ne.ReadWrite, t63.depthRangeFor3D);
    if (o === 1 && !r3.paint.get("fill-extrusion-pattern").constantOr(1)) {
      let l = t63.colorModeForRenderPass();
      hg(t63, e, r3, n, s3, pe.disabled, l, a);
    } else hg(t63, e, r3, n, s3, pe.disabled, De.disabled, a), hg(t63, e, r3, n, s3, t63.stencilModeFor3D(), t63.colorModeForRenderPass(), a);
  }
}
function hg(t63, e, r3, n, i, o, a, s3) {
  let l = t63.context, u3 = l.gl, c = "fill-extrusion-pattern", p = r3.paint.get(c), h = p.constantOr(1), f = r3.getCrossfadeParameters(), d = r3.paint.get("fill-extrusion-opacity"), g = p.constantOr(null), x = t63.transform;
  for (let b of n) {
    let v3 = e.getTile(b), P = v3.getBucket(r3);
    if (!P) continue;
    let w3 = t63.style.map.terrain && t63.style.map.terrain.getTerrainData(b), T = P.programConfigurations.get(r3.id), S = t63.useProgram(h ? "fillExtrusionPattern" : "fillExtrusion", T);
    h && (t63.context.activeTexture.set(u3.TEXTURE0), v3.imageAtlasTexture.bind(u3.LINEAR, u3.CLAMP_TO_EDGE), T.updatePaintBuffers(f));
    let C3 = x.getProjectionData({ overscaledTileID: b, applyGlobeMatrix: !s3, applyTerrainMatrix: true });
    Pf(T, c, g, v3, r3);
    let A = Yt(x, v3, r3.paint.get("fill-extrusion-translate"), r3.paint.get("fill-extrusion-translate-anchor")), E = r3.paint.get("fill-extrusion-vertical-gradient"), L = h ? eT(t63, E, d, A, b, f, v3) : ig(t63, E, d, A);
    S.draw(l, l.gl.TRIANGLES, i, o, a, le.backCCW, L, w3, C3, r3.id, P.layoutVertexBuffer, P.indexBuffer, P.segments, r3.paint, t63.transform.zoom, T, t63.style.map.terrain && P.centroidVertexBuffer);
  }
}
$i();
function lS(t63, e, r3, n, i) {
  if (t63.renderPass !== "offscreen" && t63.renderPass !== "translucent") return;
  let { isRenderingToTexture: o } = i, a = t63.context, l = t63.style.projection.useSubdivision, u3 = t63.getDepthModeForSublayer(0, ne.ReadOnly), c = t63.colorModeForRenderPass();
  if (t63.renderPass === "offscreen") uB(t63, e, n, r3, u3, pe.disabled, c), a.viewport.set([0, 0, t63.width, t63.height]);
  else if (t63.renderPass === "translucent") if (l) {
    let [p, h, f] = t63.stencilConfigForOverlapTwoPass(n);
    fg(t63, e, r3, f, p, u3, c, false, o), fg(t63, e, r3, f, h, u3, c, true, o);
  } else {
    let [p, h] = t63.getStencilConfigForOverlapAndUpdateStencilID(n);
    fg(t63, e, r3, h, p, u3, c, false, o);
  }
}
function fg(t63, e, r3, n, i, o, a, s3, l) {
  let u3 = t63.style.projection, c = t63.context, p = t63.transform, h = c.gl, f = [`#define NUM_ILLUMINATION_SOURCES ${r3.paint.get("hillshade-highlight-color").values.length}`], d = t63.useProgram("hillshade", null, false, f), g = !t63.options.moving;
  for (let x of n) {
    let b = e.getTile(x), v3 = b.fbo;
    if (!v3) continue;
    let P = u3.getMeshFromTileID(c, x.canonical, s3, true, "raster"), w3 = t63.style.map.terrain?.getTerrainData(x);
    c.activeTexture.set(h.TEXTURE0), h.bindTexture(h.TEXTURE_2D, v3.colorAttachment.get());
    let T = p.getProjectionData({ overscaledTileID: x, aligned: g, applyGlobeMatrix: !l, applyTerrainMatrix: true });
    d.draw(c, h.TRIANGLES, o, i[x.overscaledZ], a, le.backCCW, bT(t63, b, r3), w3, T, r3.id, P.vertexBuffer, P.indexBuffer, P.segments);
  }
}
function uB(t63, e, r3, n, i, o, a) {
  let s3 = t63.context, l = s3.gl;
  for (let u3 of r3) {
    let c = e.getTile(u3), p = c.dem;
    if (!p || !p.data || !c.needsHillshadePrepare) continue;
    let h = p.dim, f = p.stride, d = p.getPixels();
    if (s3.activeTexture.set(l.TEXTURE1), s3.pixelStoreUnpackPremultiplyAlpha.set(false), c.demTexture = c.demTexture || t63.getTileTexture(f), c.demTexture) {
      let x = c.demTexture;
      x.update(d, { premultiply: false }), x.bind(l.NEAREST, l.CLAMP_TO_EDGE);
    } else c.demTexture = new Se(s3, d, l.RGBA, { premultiply: false }), c.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE);
    s3.activeTexture.set(l.TEXTURE0);
    let g = c.fbo;
    if (!g) {
      let x = new Se(s3, { width: h, height: h, data: null }, l.RGBA);
      x.bind(l.LINEAR, l.CLAMP_TO_EDGE), g = c.fbo = s3.createFramebuffer(h, h, true, false), g.colorAttachment.set(x.texture);
    }
    s3.bindFramebuffer.set(g.framebuffer), s3.viewport.set([0, 0, h, h]), t63.useProgram("hillshadePrepare").draw(s3, l.TRIANGLES, i, o, a, le.disabled, _T(c.tileID, p), null, null, n.id, t63.rasterBoundsBuffer, t63.quadTriangleIndexBuffer, t63.rasterBoundsSegments), c.needsHillshadePrepare = false;
  }
}
$i();
function uS(t63, e, r3, n, i) {
  if (t63.renderPass !== "translucent" || !n.length) return;
  let { isRenderingToTexture: o } = i, s3 = t63.style.projection.useSubdivision, l = t63.getDepthModeForSublayer(0, ne.ReadOnly), u3 = t63.colorModeForRenderPass();
  if (s3) {
    let [c, p, h] = t63.stencilConfigForOverlapTwoPass(n);
    mg(t63, e, r3, h, c, l, u3, false, o), mg(t63, e, r3, h, p, l, u3, true, o);
  } else {
    let [c, p] = t63.getStencilConfigForOverlapAndUpdateStencilID(n);
    mg(t63, e, r3, p, c, l, u3, false, o);
  }
}
function mg(t63, e, r3, n, i, o, a, s3, l) {
  let u3 = t63.style.projection, c = t63.context, p = t63.transform, h = c.gl, f = t63.useProgram("colorRelief"), d = !t63.options.moving, g = true;
  for (let x of n) {
    let b = e.getTile(x), v3 = b.dem;
    if (g) {
      let A = h.getParameter(h.MAX_TEXTURE_SIZE), { elevationTexture: E, colorTexture: L } = r3.getColorRampTextures(c, A, v3.getUnpackVector());
      c.activeTexture.set(h.TEXTURE1), E.bind(h.NEAREST, h.CLAMP_TO_EDGE), c.activeTexture.set(h.TEXTURE4), L.bind(h.LINEAR, h.CLAMP_TO_EDGE), g = false;
    }
    if (!v3 || !v3.data) continue;
    let P = v3.stride, w3 = v3.getPixels();
    if (c.activeTexture.set(h.TEXTURE0), c.pixelStoreUnpackPremultiplyAlpha.set(false), b.demTexture = b.demTexture || t63.getTileTexture(P), b.demTexture) {
      let A = b.demTexture;
      A.update(w3, { premultiply: false }), A.bind(h.LINEAR, h.CLAMP_TO_EDGE);
    } else b.demTexture = new Se(c, w3, h.RGBA, { premultiply: false }), b.demTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE);
    let T = u3.getMeshFromTileID(c, x.canonical, s3, true, "raster"), S = t63.style.map.terrain?.getTerrainData(x), C3 = p.getProjectionData({ overscaledTileID: x, aligned: d, applyGlobeMatrix: !l, applyTerrainMatrix: true });
    f.draw(c, h.TRIANGLES, o, i[x.overscaledZ], a, le.backCCW, PT(r3, b.dem), S, C3, r3.id, T.vertexBuffer, T.indexBuffer, T.segments);
  }
}
$i();
var tu = s(fe(), 1);
var dg = [new tu.default(0, 0), new tu.default(8192, 0), new tu.default(8192, 8192), new tu.default(0, 8192)];
function cS(t63, e, r3, n, i) {
  if (t63.renderPass !== "translucent" || r3.paint.get("raster-opacity") === 0 || !n.length) return;
  let { isRenderingToTexture: o } = i, a = e.getSource(), l = t63.style.projection.useSubdivision;
  if (a instanceof _r) wf(t63, e, r3, n, null, false, false, a.tileCoords, a.flippedWindingOrder, o);
  else if (l) {
    let [u3, c, p] = t63.stencilConfigForOverlapTwoPass(n);
    wf(t63, e, r3, p, u3, false, true, dg, false, o), wf(t63, e, r3, p, c, true, true, dg, false, o);
  } else {
    let [u3, c] = t63.getStencilConfigForOverlapAndUpdateStencilID(n);
    wf(t63, e, r3, c, u3, false, true, dg, false, o);
  }
}
function wf(t63, e, r3, n, i, o, a, s3, l = false, u3 = false) {
  let c = n[n.length - 1].overscaledZ, p = t63.context, h = p.gl, f = t63.useProgram("raster"), d = t63.transform, g = t63.style.projection, x = t63.colorModeForRenderPass(), b = !t63.options.moving;
  for (let v3 of n) {
    let P = t63.getDepthModeForSublayer(v3.overscaledZ - c, r3.paint.get("raster-opacity") === 1 ? ne.ReadWrite : ne.ReadOnly, h.LESS), w3 = e.getTile(v3);
    w3.registerFadeDuration(r3.paint.get("raster-fade-duration"));
    let T = e.findLoadedParent(v3, 0), S = e.findLoadedSibling(v3), A = cB(w3, T || S || null, e, r3, t63.transform, t63.style.map.terrain), E, L, F = r3.paint.get("raster-resampling") === "nearest" ? h.NEAREST : h.LINEAR;
    p.activeTexture.set(h.TEXTURE0), w3.texture.bind(F, h.CLAMP_TO_EDGE, h.LINEAR_MIPMAP_NEAREST), p.activeTexture.set(h.TEXTURE1), T ? (T.texture.bind(F, h.CLAMP_TO_EDGE, h.LINEAR_MIPMAP_NEAREST), E = Math.pow(2, T.tileID.overscaledZ - w3.tileID.overscaledZ), L = [w3.tileID.canonical.x * E % 1, w3.tileID.canonical.y * E % 1]) : w3.texture.bind(F, h.CLAMP_TO_EDGE, h.LINEAR_MIPMAP_NEAREST), w3.texture.useMipmap && p.extTextureFilterAnisotropic && t63.transform.pitch > 20 && h.texParameterf(h.TEXTURE_2D, p.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, p.extTextureFilterAnisotropicMax);
    let O = t63.style.map.terrain && t63.style.map.terrain.getTerrainData(v3), z = d.getProjectionData({ overscaledTileID: v3, aligned: b, applyGlobeMatrix: !u3, applyTerrainMatrix: true }), I = RT(L || [0, 0], E || 1, A, r3, s3), R = g.getMeshFromTileID(p, v3.canonical, o, a, "raster"), H = i ? i[v3.overscaledZ] : pe.disabled;
    f.draw(p, h.TRIANGLES, P, H, x, l ? le.frontCCW : le.backCCW, I, O, z, r3.id, R.vertexBuffer, R.indexBuffer, R.segments);
  }
}
function cB(t63, e, r3, n, i, o) {
  let a = n.paint.get("raster-fade-duration");
  if (!o && a > 0) {
    let s3 = ae.now(), l = (s3 - t63.timeAdded) / a, u3 = e ? (s3 - e.timeAdded) / a : -1, c = r3.getSource(), p = mo(i, { tileSize: c.tileSize, roundZoom: c.roundZoom }), h = !e || Math.abs(e.tileID.overscaledZ - p) > Math.abs(t63.tileID.overscaledZ - p), f = h && t63.refreshedUponExpiration ? 1 : ce(h ? l : 1 - u3, 0, 1);
    return t63.refreshedUponExpiration && l >= 1 && (t63.refreshedUponExpiration = false), e ? { opacity: 1, mix: 1 - f } : { opacity: f, mix: 0 };
  } else return { opacity: 1, mix: 0 };
}
$i();
function pS(t63, e, r3, n, i) {
  let o = r3.paint.get("background-color"), a = r3.paint.get("background-opacity");
  if (a === 0) return;
  let { isRenderingToTexture: s3 } = i, l = t63.context, u3 = l.gl, c = t63.style.projection, p = t63.transform, h = p.tileSize, f = r3.paint.get("background-pattern");
  if (t63.isPatternMissing(f)) return;
  let d = !f && o.a === 1 && a === 1 && t63.opaquePassEnabledForLayer() ? "opaque" : "translucent";
  if (t63.renderPass !== d) return;
  let g = pe.disabled, x = t63.getDepthModeForSublayer(0, d === "opaque" ? ne.ReadWrite : ne.ReadOnly), b = t63.colorModeForRenderPass(), v3 = t63.useProgram(f ? "backgroundPattern" : "background"), P = n || bi(p, { tileSize: h, terrain: t63.style.map.terrain });
  f && (l.activeTexture.set(u3.TEXTURE0), t63.imageManager.bind(t63.context));
  let w3 = r3.getCrossfadeParameters();
  for (let T of P) {
    let S = p.getProjectionData({ overscaledTileID: T, applyGlobeMatrix: !s3, applyTerrainMatrix: true }), C3 = f ? NT(a, t63, f, { tileID: T, tileSize: h }, w3) : UT(a, o), A = t63.style.map.terrain && t63.style.map.terrain.getTerrainData(T), E = c.getMeshFromTileID(l, T.canonical, false, true, "raster");
    v3.draw(l, u3.TRIANGLES, x, g, b, le.backCCW, C3, A, S, r3.id, E.vertexBuffer, E.indexBuffer, E.segments);
  }
}
$i();
var pB = new K(1, 0, 0, 1);
var hB = new K(0, 1, 0, 1);
var fB = new K(0, 0, 1, 1);
var mB = new K(1, 0, 1, 1);
var dB = new K(0, 1, 1, 1);
function mS(t63) {
  let e = t63.transform.padding, r3 = 3;
  hS(t63, t63.transform.height - (e.top || 0), r3, pB), hS(t63, e.bottom || 0, r3, hB), fS(t63, e.left || 0, r3, fB), fS(t63, t63.transform.width - (e.right || 0), r3, mB);
  let n = t63.transform.centerPoint;
  yB(t63, n.x, t63.transform.height - n.y, dB);
}
function yB(t63, e, r3, n) {
  Tf(t63, e - 2 / 2, r3 - 20 / 2, 2, 20, n), Tf(t63, e - 20 / 2, r3 - 2 / 2, 20, 2, n);
}
function hS(t63, e, r3, n) {
  Tf(t63, 0, e + r3 / 2, t63.transform.width, r3, n);
}
function fS(t63, e, r3, n) {
  Tf(t63, e - r3 / 2, 0, r3, t63.transform.height, n);
}
function Tf(t63, e, r3, n, i, o) {
  let a = t63.context, s3 = a.gl;
  s3.enable(s3.SCISSOR_TEST), s3.scissor(e * t63.pixelRatio, r3 * t63.pixelRatio, n * t63.pixelRatio, i * t63.pixelRatio), a.clear({ color: o }), s3.disable(s3.SCISSOR_TEST);
}
function dS(t63, e, r3) {
  for (let n = 0; n < r3.length; n++) gB(t63, e, r3[n]);
}
function gB(t63, e, r3) {
  let n = t63.context, i = n.gl, o = t63.useProgram("debug"), a = ne.disabled, s3 = pe.disabled, l = t63.colorModeForRenderPass(), u3 = "$debug", c = t63.style.map.terrain && t63.style.map.terrain.getTerrainData(r3);
  n.activeTexture.set(i.TEXTURE0);
  let p = e.getTileByID(r3.key).latestRawTileData, h = p && p.byteLength || 0, f = Math.floor(h / 1024), d = e.getTile(r3).tileSize, g = 512 / Math.min(d, 512) * (r3.overscaledZ / t63.transform.zoom) * 0.5, x = r3.canonical.toString();
  r3.overscaledZ !== r3.canonical.z && (x += ` => ${r3.overscaledZ}`);
  let b = `${x} ${f}kB`;
  xB(t63, b);
  let v3 = t63.transform.getProjectionData({ overscaledTileID: r3, applyGlobeMatrix: true, applyTerrainMatrix: true });
  o.draw(n, i.TRIANGLES, a, s3, De.alphaBlended, le.disabled, ag(K.transparent, g), null, v3, u3, t63.debugBuffer, t63.quadTriangleIndexBuffer, t63.debugSegments), o.draw(n, i.LINE_STRIP, a, s3, l, le.disabled, ag(K.red), c, v3, u3, t63.debugBuffer, t63.tileBorderIndexBuffer, t63.debugSegments);
}
function xB(t63, e) {
  t63.initDebugOverlayCanvas();
  let r3 = t63.debugOverlayCanvas, n = t63.context.gl, i = t63.debugOverlayCanvas.getContext("2d");
  i.clearRect(0, 0, r3.width, r3.height), i.shadowColor = "white", i.shadowBlur = 2, i.lineWidth = 1.5, i.strokeStyle = "white", i.textBaseline = "top", i.font = "bold 36px Open Sans, sans-serif", i.fillText(e, 5, 5), i.strokeText(e, 5, 5), t63.debugOverlayTexture.update(r3), t63.debugOverlayTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE);
}
function yS(t63, e) {
  let r3 = null, i = Object.values(t63._layers).flatMap((l) => l.source && !l.isHidden(e) ? [t63.sourceCaches[l.source]] : []), o = i.filter((l) => l.getSource().type === "vector"), a = i.filter((l) => l.getSource().type !== "vector"), s3 = (l) => {
    (!r3 || r3.getSource().maxzoom < l.getSource().maxzoom) && (r3 = l);
  };
  return o.forEach((l) => s3(l)), r3 || a.forEach((l) => s3(l)), r3;
}
$i();
function gS(t63, e, r3, n) {
  let { isRenderingGlobe: i } = n, o = t63.context, a = r3.implementation, s3 = t63.style.projection, l = t63.transform, u3 = l.getProjectionDataForCustomLayer(i), c = { farZ: l.farZ, nearZ: l.nearZ, fov: l.fov * Math.PI / 180, modelViewProjectionMatrix: l.modelViewProjectionMatrix, projectionMatrix: l.projectionMatrix, shaderData: { variantName: s3.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${s3.shaderPreludeCode.vertexSource}`, define: s3.shaderDefine }, defaultProjectionData: u3 }, p = a.renderingMode ? a.renderingMode : "2d";
  if (t63.renderPass === "offscreen") {
    let h = a.prerender;
    h && (t63.setCustomLayerDefaults(), o.setColorMode(t63.colorModeForRenderPass()), h.call(a, o.gl, c), o.setDirty(), t63.setBaseState());
  } else if (t63.renderPass === "translucent") {
    t63.setCustomLayerDefaults(), o.setColorMode(t63.colorModeForRenderPass()), o.setStencilMode(pe.disabled);
    let h = p === "3d" ? t63.getDepthModeFor3D() : t63.getDepthModeForSublayer(0, ne.ReadOnly);
    o.setDepthMode(h), a.render(o.gl, c), o.setDirty(), t63.setBaseState(), o.bindFramebuffer.set(null);
  }
}
$i();
function xS(t63, e) {
  let r3 = t63.context, n = r3.gl, i = t63.transform, o = De.unblended, a = new ne(n.LEQUAL, ne.ReadWrite, [0, 1]), s3 = e.sourceCache.getRenderableTiles(), l = t63.useProgram("terrainDepth");
  r3.bindFramebuffer.set(e.getFramebuffer("depth").framebuffer), r3.viewport.set([0, 0, t63.width / devicePixelRatio, t63.height / devicePixelRatio]), r3.clear({ color: K.transparent, depth: 1 });
  for (let u3 of s3) {
    let c = e.getTerrainMesh(u3.tileID), p = e.getTerrainData(u3.tileID), h = i.getProjectionData({ overscaledTileID: u3.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true }), f = qw(e.getMeshFrameDelta(i.zoom));
    l.draw(r3, n.TRIANGLES, a, pe.disabled, o, le.backCCW, f, p, h, "terrain", c.vertexBuffer, c.indexBuffer, c.segments);
  }
  r3.bindFramebuffer.set(null), r3.viewport.set([0, 0, t63.width, t63.height]);
}
function bS(t63, e) {
  let r3 = t63.context, n = r3.gl, i = t63.transform, o = De.unblended, a = new ne(n.LEQUAL, ne.ReadWrite, [0, 1]), s3 = e.getCoordsTexture(), l = e.sourceCache.getRenderableTiles(), u3 = t63.useProgram("terrainCoords");
  r3.bindFramebuffer.set(e.getFramebuffer("coords").framebuffer), r3.viewport.set([0, 0, t63.width / devicePixelRatio, t63.height / devicePixelRatio]), r3.clear({ color: K.transparent, depth: 1 }), e.coordsIndex = [];
  for (let c of l) {
    let p = e.getTerrainMesh(c.tileID), h = e.getTerrainData(c.tileID);
    r3.activeTexture.set(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, s3.texture);
    let f = Yw(255 - e.coordsIndex.length, e.getMeshFrameDelta(i.zoom)), d = i.getProjectionData({ overscaledTileID: c.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
    u3.draw(r3, n.TRIANGLES, a, pe.disabled, o, le.backCCW, f, h, d, "terrain", p.vertexBuffer, p.indexBuffer, p.segments), e.coordsIndex.push(c.tileID.key);
  }
  r3.bindFramebuffer.set(null), r3.viewport.set([0, 0, t63.width, t63.height]);
}
function yg(t63, e, r3, n) {
  let { isRenderingGlobe: i } = n, o = t63.context, a = o.gl, s3 = t63.transform, l = t63.colorModeForRenderPass(), u3 = t63.getDepthModeFor3D(), c = t63.useProgram("terrain");
  o.bindFramebuffer.set(null), o.viewport.set([0, 0, t63.width, t63.height]);
  for (let p of r3) {
    let h = e.getTerrainMesh(p.tileID), f = t63.renderToTexture.getTexture(p), d = e.getTerrainData(p.tileID);
    o.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, f.texture);
    let g = e.getMeshFrameDelta(s3.zoom), x = s3.calculateFogMatrix(p.tileID.toUnwrapped()), b = Zw(g, x, t63.style.sky, s3.pitch, i), v3 = s3.getProjectionData({ overscaledTileID: p.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
    c.draw(o, a.TRIANGLES, u3, pe.disabled, l, le.backCCW, b, d, v3, "terrain", h.vertexBuffer, h.indexBuffer, h.segments);
  }
}
$i();
function _S(t63, e) {
  if (!e.mesh) {
    let r3 = new Et();
    r3.emplaceBack(-1, -1), r3.emplaceBack(1, -1), r3.emplaceBack(1, 1), r3.emplaceBack(-1, 1);
    let n = new Qe();
    n.emplaceBack(0, 1, 2), n.emplaceBack(0, 2, 3), e.mesh = new ar(t63.createVertexBuffer(r3, Pr.members), t63.createIndexBuffer(n), de2.simpleSegment(0, 0, r3.length, n.length));
  }
  return e.mesh;
}
function vS(t63, e) {
  let r3 = t63.context, n = r3.gl, i = XT(e, t63.style.map.transform, t63.pixelRatio), o = new ne(n.LEQUAL, ne.ReadWrite, [0, 1]), a = pe.disabled, s3 = t63.colorModeForRenderPass(), l = t63.useProgram("sky"), u3 = _S(r3, e);
  l.draw(r3, n.TRIANGLES, o, a, s3, le.disabled, i, null, void 0, "sky", u3.vertexBuffer, u3.indexBuffer, u3.segments);
}
function bB(t63, e) {
  let r3 = t63.properties.get("position"), n = [-r3.x, -r3.y, -r3.z], i = B.identity(new Float64Array(16));
  return t63.properties.get("anchor") === "map" && (B.rotateZ(i, i, e.rollInRadians), B.rotateX(i, i, -e.pitchInRadians), B.rotateZ(i, i, e.bearingInRadians), B.rotateX(i, i, e.center.lat * Math.PI / 180), B.rotateY(i, i, -e.center.lng * Math.PI / 180)), V.transformMat4(n, n, i), n;
}
function PS(t63, e, r3) {
  let n = t63.context, i = n.gl, o = t63.useProgram("atmosphere"), a = new ne(i.LEQUAL, ne.ReadOnly, [0, 1]), s3 = t63.transform, l = bB(r3, t63.transform), u3 = s3.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }), c = e.properties.get("atmosphere-blend") * u3.projectionTransition;
  if (c === 0) return;
  let p = bo(s3.worldSize, s3.center.lat), h = s3.inverseProjectionMatrix, f = new Float64Array(4);
  f[3] = 1, Ne.transformMat4(f, f, s3.modelViewProjectionMatrix), f[0] /= f[3], f[1] /= f[3], f[2] /= f[3], f[3] = 1, Ne.transformMat4(f, f, h), f[0] /= f[3], f[1] /= f[3], f[2] /= f[3], f[3] = 1;
  let d = [f[0], f[1], f[2]], g = jT(l, c, d, p, h), x = _S(n, e);
  o.draw(n, i.TRIANGLES, a, pe.disabled, De.alphaBlended, le.disabled, g, null, null, "atmosphere", x.vertexBuffer, x.indexBuffer, x.segments);
}
var Sf = class {
  constructor(e, r3) {
    this.context = new bf(e), this.transform = r3, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: B.identity(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = Rn.maxUnderzooming + Rn.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new wa();
  }
  resize(e, r3, n) {
    if (this.width = Math.floor(e * n), this.height = Math.floor(r3 * n), this.pixelRatio = n, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (let i of this.style._order) this.style._layers[i].resize();
  }
  setup() {
    let e = this.context, r3 = new Et();
    r3.emplaceBack(0, 0), r3.emplaceBack(8192, 0), r3.emplaceBack(0, 8192), r3.emplaceBack(8192, 8192), this.tileExtentBuffer = e.createVertexBuffer(r3, Pr.members), this.tileExtentSegments = de2.simpleSegment(0, 0, 4, 2);
    let n = new Et();
    n.emplaceBack(0, 0), n.emplaceBack(8192, 0), n.emplaceBack(0, 8192), n.emplaceBack(8192, 8192), this.debugBuffer = e.createVertexBuffer(n, Pr.members), this.debugSegments = de2.simpleSegment(0, 0, 4, 5);
    let i = new ep();
    i.emplaceBack(0, 0, 0, 0), i.emplaceBack(8192, 0, 8192, 0), i.emplaceBack(0, 8192, 0, 8192), i.emplaceBack(8192, 8192, 8192, 8192), this.rasterBoundsBuffer = e.createVertexBuffer(i, Nw.members), this.rasterBoundsSegments = de2.simpleSegment(0, 0, 4, 2);
    let o = new Et();
    o.emplaceBack(0, 0), o.emplaceBack(8192, 0), o.emplaceBack(0, 8192), o.emplaceBack(8192, 8192), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(o, Pr.members), this.rasterBoundsSegmentsPosOnly = de2.simpleSegment(0, 0, 4, 5);
    let a = new Et();
    a.emplaceBack(0, 0), a.emplaceBack(1, 0), a.emplaceBack(0, 1), a.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(a, Pr.members), this.viewportSegments = de2.simpleSegment(0, 0, 4, 2);
    let s3 = new ol2();
    s3.emplaceBack(0), s3.emplaceBack(1), s3.emplaceBack(3), s3.emplaceBack(2), s3.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(s3);
    let l = new Qe();
    l.emplaceBack(1, 0, 2), l.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(l);
    let u3 = this.context.gl;
    this.stencilClearMode = new pe({ func: u3.ALWAYS, mask: 0 }, 0, 255, u3.ZERO, u3.ZERO, u3.ZERO), this.tileExtentMesh = new ar(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
  }
  clearStencil() {
    let e = this.context, r3 = e.gl;
    this.nextStencilID = 1, this.currentStencilSource = void 0;
    let n = B.create();
    B.ortho(n, 0, this.width, this.height, 0, 0, 1), B.scale(n, n, [r3.drawingBufferWidth, r3.drawingBufferHeight, 0]);
    let i = { mainMatrix: n, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: n };
    this.useProgram("clippingMask", null, true).draw(e, r3.TRIANGLES, ne.disabled, this.stencilClearMode, De.disabled, le.disabled, null, null, i, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
  }
  _renderTileClippingMasks(e, r3, n) {
    if (this.currentStencilSource === e.source || !e.isTileClipped() || !r3 || !r3.length) return;
    this.currentStencilSource = e.source, this.nextStencilID + r3.length > 256 && this.clearStencil();
    let i = this.context;
    i.setColorMode(De.disabled), i.setDepthMode(ne.disabled);
    let o = {};
    for (let a of r3) o[a.key] = this.nextStencilID++;
    this._renderTileMasks(o, r3, n, true), this._renderTileMasks(o, r3, n, false), this._tileClippingMaskIDs = o;
  }
  _renderTileMasks(e, r3, n, i) {
    let o = this.context, a = o.gl, s3 = this.style.projection, l = this.transform, u3 = this.useProgram("clippingMask");
    for (let c of r3) {
      let p = e[c.key], h = this.style.map.terrain && this.style.map.terrain.getTerrainData(c), f = s3.getMeshFromTileID(this.context, c.canonical, i, true, "stencil"), d = l.getProjectionData({ overscaledTileID: c, applyGlobeMatrix: !n, applyTerrainMatrix: true });
      u3.draw(o, a.TRIANGLES, ne.disabled, new pe({ func: a.ALWAYS, mask: 0 }, p, 255, a.KEEP, a.KEEP, a.REPLACE), De.disabled, n ? le.disabled : le.backCCW, null, h, d, "$clipping", f.vertexBuffer, f.indexBuffer, f.segments);
    }
  }
  _renderTilesDepthBuffer() {
    let e = this.context, r3 = e.gl, n = this.style.projection, i = this.transform, o = this.useProgram("depth"), a = this.getDepthModeFor3D(), s3 = bi(i, { tileSize: i.tileSize });
    for (let l of s3) {
      let u3 = this.style.map.terrain && this.style.map.terrain.getTerrainData(l), c = n.getMeshFromTileID(this.context, l.canonical, true, true, "raster"), p = i.getProjectionData({ overscaledTileID: l, applyGlobeMatrix: true, applyTerrainMatrix: true });
      o.draw(e, r3.TRIANGLES, a, pe.disabled, De.disabled, le.backCCW, null, u3, p, "$clipping", c.vertexBuffer, c.indexBuffer, c.segments);
    }
  }
  stencilModeFor3D() {
    this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
    let e = this.nextStencilID++, r3 = this.context.gl;
    return new pe({ func: r3.NOTEQUAL, mask: 255 }, e, 255, r3.KEEP, r3.KEEP, r3.REPLACE);
  }
  stencilModeForClipping(e) {
    let r3 = this.context.gl;
    return new pe({ func: r3.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, r3.KEEP, r3.KEEP, r3.REPLACE);
  }
  getStencilConfigForOverlapAndUpdateStencilID(e) {
    let r3 = this.context.gl, n = e.sort((a, s3) => s3.overscaledZ - a.overscaledZ), i = n[n.length - 1].overscaledZ, o = n[0].overscaledZ - i + 1;
    if (o > 1) {
      this.currentStencilSource = void 0, this.nextStencilID + o > 256 && this.clearStencil();
      let a = {};
      for (let s3 = 0; s3 < o; s3++) a[s3 + i] = new pe({ func: r3.GEQUAL, mask: 255 }, s3 + this.nextStencilID, 255, r3.KEEP, r3.KEEP, r3.REPLACE);
      return this.nextStencilID += o, [a, n];
    }
    return [{ [i]: pe.disabled }, n];
  }
  stencilConfigForOverlapTwoPass(e) {
    let r3 = this.context.gl, n = e.sort((a, s3) => s3.overscaledZ - a.overscaledZ), i = n[n.length - 1].overscaledZ, o = n[0].overscaledZ - i + 1;
    if (this.clearStencil(), o > 1) {
      let a = {}, s3 = {};
      for (let l = 0; l < o; l++) a[l + i] = new pe({ func: r3.GREATER, mask: 255 }, o + 1 + l, 255, r3.KEEP, r3.KEEP, r3.REPLACE), s3[l + i] = new pe({ func: r3.GREATER, mask: 255 }, 1 + l, 255, r3.KEEP, r3.KEEP, r3.REPLACE);
      return this.nextStencilID = o * 2 + 1, [a, s3, n];
    } else return this.nextStencilID = 3, [{ [i]: new pe({ func: r3.GREATER, mask: 255 }, 2, 255, r3.KEEP, r3.KEEP, r3.REPLACE) }, { [i]: new pe({ func: r3.GREATER, mask: 255 }, 1, 255, r3.KEEP, r3.KEEP, r3.REPLACE) }, n];
  }
  colorModeForRenderPass() {
    let e = this.context.gl;
    return this._showOverdrawInspector ? new De([e.CONSTANT_COLOR, e.ONE], new K(0.125, 0.125, 0.125, 0), [true, true, true, true]) : this.renderPass === "opaque" ? De.unblended : De.alphaBlended;
  }
  getDepthModeForSublayer(e, r3, n) {
    if (!this.opaquePassEnabledForLayer()) return ne.disabled;
    let i = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
    return new ne(n || this.context.gl.LEQUAL, r3, [i, i]);
  }
  getDepthModeFor3D() {
    return new ne(this.context.gl.LEQUAL, ne.ReadWrite, this.depthRangeFor3D);
  }
  opaquePassEnabledForLayer() {
    return this.currentLayer < this.opaquePassCutoff;
  }
  render(e, r3) {
    this.style = e, this.options = r3, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(ae.now()), this.imageManager.beginFrame();
    let n = this.style._order, i = this.style.sourceCaches, o = {}, a = {}, s3 = {}, l = { isRenderingToTexture: false, isRenderingGlobe: e.projection?.transitionState > 0 };
    for (let c in i) {
      let p = i[c];
      p.used && p.prepare(this.context), o[c] = p.getVisibleCoordinates(false), a[c] = o[c].slice().reverse(), s3[c] = p.getVisibleCoordinates(true).reverse();
    }
    this.opaquePassCutoff = 1 / 0;
    for (let c = 0; c < n.length; c++) {
      let p = n[c];
      if (this.style._layers[p].is3D()) {
        this.opaquePassCutoff = c;
        break;
      }
    }
    this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
    for (let c of n) {
      let p = this.style._layers[c];
      if (!p.hasOffscreenPass() || p.isHidden(this.transform.zoom)) continue;
      let h = a[p.source];
      p.type !== "custom" && !h.length || this.renderLayer(this, i[p.source], p, h, l);
    }
    if (this.style.projection?.updateGPUdependent({ context: this.context, useProgram: (c) => this.useProgram(c) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: r3.showOverdrawInspector ? K.black : K.transparent, depth: 1 }), this.clearStencil(), this.style.sky && vS(this, this.style.sky), this._showOverdrawInspector = r3.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = n.length - 1; this.currentLayer >= 0; this.currentLayer--) {
      let c = this.style._layers[n[this.currentLayer]], p = i[c.source], h = o[c.source];
      this._renderTileClippingMasks(c, h, false), this.renderLayer(this, p, c, h, l);
    }
    this.renderPass = "translucent";
    let u3 = false;
    for (this.currentLayer = 0; this.currentLayer < n.length; this.currentLayer++) {
      let c = this.style._layers[n[this.currentLayer]], p = i[c.source];
      if (this.renderToTexture && this.renderToTexture.renderLayer(c, l)) continue;
      !this.opaquePassEnabledForLayer() && !u3 && (u3 = true, l.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
      let h = (c.type === "symbol" ? s3 : a)[c.source];
      this._renderTileClippingMasks(c, o[c.source], !!this.renderToTexture), this.renderLayer(this, p, c, h, l);
    }
    if (l.isRenderingGlobe && PS(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
      let c = yS(this.style, this.transform.zoom);
      c && dS(this, c, c.getVisibleCoordinates());
    }
    this.options.showPadding && mS(this), this.context.setDefault();
  }
  maybeDrawDepthAndCoords(e) {
    if (!this.style || !this.style.map || !this.style.map.terrain) return;
    let r3 = this.terrainFacilitator.matrix, n = this.transform.modelViewProjectionMatrix, i = this.terrainFacilitator.dirty;
    i || (i = e ? !B.exactEquals(r3, n) : !B.equals(r3, n)), i || (i = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), i && (B.copy(r3, n), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, xS(this, this.style.map.terrain), bS(this, this.style.map.terrain));
  }
  renderLayer(e, r3, n, i, o) {
    n.isHidden(this.transform.zoom) || n.type !== "background" && n.type !== "custom" && !(i || []).length || (this.id = n.id, a1(n) ? QT(e, r3, n, i, this.style.placement.variableOffsets, o) : Zv(n) ? eS(e, r3, n, i, o) : Kv(n) ? tS(e, r3, n, i, o) : O0(n) ? iS(e, r3, n, i, o) : f0(n) ? aS(e, r3, n, i, o) : C0(n) ? sS(e, r3, n, i, o) : e0(n) ? lS(e, r3, n, i, o) : n0(n) ? uS(e, r3, n, i, o) : h1(n) ? cS(e, r3, n, i, o) : u1(n) ? pS(e, r3, n, i, o) : m1(n) && gS(e, r3, n, o));
  }
  saveTileTexture(e) {
    let r3 = this._tileTextures[e.size[0]];
    r3 ? r3.push(e) : this._tileTextures[e.size[0]] = [e];
  }
  getTileTexture(e) {
    let r3 = this._tileTextures[e];
    return r3 && r3.length > 0 ? r3.pop() : null;
  }
  isPatternMissing(e) {
    if (!e) return false;
    if (!e.from || !e.to) return true;
    let r3 = this.imageManager.getPattern(e.from.toString()), n = this.imageManager.getPattern(e.to.toString());
    return !r3 || !n;
  }
  useProgram(e, r3, n = false, i = []) {
    this.cache = this.cache || {};
    let o = !!this.style.map.terrain, a = this.style.projection, s3 = n ? or.projectionMercator : a.shaderPreludeCode, l = n ? Yy : a.shaderDefine, u3 = `/${n ? Wy : a.shaderVariantName}`, c = r3 ? r3.cacheKey : "", p = this._showOverdrawInspector ? "/overdraw" : "", h = o ? "/terrain" : "", f = i ? `/${i.join("/")}` : "", d = e + c + u3 + p + h + f;
    return this.cache[d] || (this.cache[d] = new Dh(this.context, or[e], r3, qT[e], this._showOverdrawInspector, o, s3, l, i)), this.cache[d];
  }
  setCustomLayerDefaults() {
    this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
  }
  setBaseState() {
    let e = this.context.gl;
    this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
  }
  initDebugOverlayCanvas() {
    if (this.debugOverlayCanvas == null) {
      this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512;
      let e = this.context.gl;
      this.debugOverlayTexture = new Se(this.context, this.debugOverlayCanvas, e.RGBA);
    }
  }
  destroy() {
    this.debugOverlayTexture && this.debugOverlayTexture.destroy();
  }
  overLimit() {
    let { drawingBufferWidth: e, drawingBufferHeight: r3 } = this.context.gl;
    return this.width !== e || this.height !== r3;
  }
};
$i();
$i();
function Cf(t63, e) {
  let r3 = false, n = null, i = null, o, a = () => {
    n = null, r3 && (t63.apply(i, o), n = setTimeout(a, e), r3 = false);
  };
  return (...s3) => (r3 = true, i = this, o = s3, n || a(), n);
}
var ru = class {
  constructor(e) {
    this._getCurrentHash = () => {
      let e3 = window.location.hash.replace("#", "");
      if (this._hashName) {
        let r3;
        return e3.split("&").map((n) => n.split("=")).forEach((n) => {
          n[0] === this._hashName && (r3 = n);
        }), (r3 && r3[1] || "").split("/");
      }
      return e3.split("/");
    };
    this._onHashChange = () => {
      let e3 = this._getCurrentHash();
      if (!this._isValidHash(e3)) return false;
      let r3 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e3[3] || 0) : this._map.getBearing();
      return this._map.jumpTo({ center: [+e3[2], +e3[1]], zoom: +e3[0], bearing: r3, pitch: +(e3[4] || 0) }), true;
    };
    this._updateHashUnthrottled = () => {
      let e3 = window.location.href.replace(/(#.*)?$/, this.getHashString());
      window.history.replaceState(window.history.state, null, e3);
    };
    this._removeHash = () => {
      let e3 = this._getCurrentHash();
      if (e3.length === 0) return;
      let r3 = e3.join("/"), n = r3;
      n.split("&").length > 0 && (n = n.split("&")[0]), this._hashName && (n = `${this._hashName}=${r3}`);
      let i = window.location.hash.replace(n, "");
      i.startsWith("#&") ? i = i.slice(0, 1) + i.slice(2) : i === "#" && (i = "");
      let o = window.location.href.replace(/(#.+)?$/, i);
      o = o.replace("&&", "&"), window.history.replaceState(window.history.state, null, o);
    };
    this._updateHash = Cf(this._updateHashUnthrottled, 30 * 1e3 / 100);
    this._hashName = e && encodeURIComponent(e);
  }
  addTo(e) {
    return this._map = e, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
  }
  remove() {
    return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
  }
  getHashString(e) {
    let r3 = this._map.getCenter(), n = Math.round(this._map.getZoom() * 100) / 100, i = Math.ceil((n * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), o = Math.pow(10, i), a = Math.round(r3.lng * o) / o, s3 = Math.round(r3.lat * o) / o, l = this._map.getBearing(), u3 = this._map.getPitch(), c = "";
    if (e ? c += `/${a}/${s3}/${n}` : c += `${n}/${s3}/${a}`, (l || u3) && (c += `/${Math.round(l * 10) / 10}`), u3 && (c += `/${Math.round(u3)}`), this._hashName) {
      let p = this._hashName, h = false, f = window.location.hash.slice(1).split("&").map((d) => {
        let g = d.split("=")[0];
        return g === p ? (h = true, `${g}=${c}`) : d;
      }).filter((d) => d);
      return h || f.push(`${p}=${c}`), `#${f.join("&")}`;
    }
    return `#${c}`;
  }
  _isValidHash(e) {
    if (e.length < 3 || e.some(isNaN)) return false;
    try {
      new J(+e[2], +e[1]);
    } catch {
      return false;
    }
    let r3 = +e[0], n = +(e[3] || 0), i = +(e[4] || 0);
    return r3 >= this._map.getMinZoom() && r3 <= this._map.getMaxZoom() && n >= -180 && n <= 180 && i >= this._map.getMinPitch() && i <= this._map.getMaxPitch();
  }
};
$i();
$i();
var wS = s(fe(), 1);
var ou = { linearity: 0.3, easing: is(0, 0, 0.3, 1) };
var _B = Z({ deceleration: 2500, maxSpeed: 1400 }, ou);
var vB = Z({ deceleration: 20, maxSpeed: 1400 }, ou);
var PB = Z({ deceleration: 1e3, maxSpeed: 360 }, ou);
var wB = Z({ deceleration: 1e3, maxSpeed: 90 }, ou);
var TB = Z({ deceleration: 1e3, maxSpeed: 360 }, ou);
var Mf = class {
  constructor(e) {
    this._map = e, this.clear();
  }
  clear() {
    this._inertiaBuffer = [];
  }
  record(e) {
    this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: ae.now(), settings: e });
  }
  _drainInertiaBuffer() {
    let e = this._inertiaBuffer, r3 = ae.now(), n = 160;
    for (; e.length > 0 && r3 - e[0].time > n; ) e.shift();
  }
  _onMoveEnd(e) {
    if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
    let r3 = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new wS.default(0, 0), pinchAround: void 0, around: void 0 };
    for (let { settings: a } of this._inertiaBuffer) r3.zoom += a.zoomDelta || 0, r3.bearing += a.bearingDelta || 0, r3.pitch += a.pitchDelta || 0, r3.roll += a.rollDelta || 0, a.panDelta && r3.pan._add(a.panDelta), a.around && (r3.around = a.around), a.pinchAround && (r3.pinchAround = a.pinchAround);
    let i = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, o = {};
    if (r3.pan.mag()) {
      let a = iu(r3.pan.mag(), i, Z({}, _B, e || {})), s3 = r3.pan.mult(a.amount / r3.pan.mag()), l = this._map.cameraHelper.handlePanInertia(s3, this._map.transform);
      o.center = l.easingCenter, o.offset = l.easingOffset, nu(o, a);
    }
    if (r3.zoom) {
      let a = iu(r3.zoom, i, vB);
      o.zoom = this._map.transform.zoom + a.amount, nu(o, a);
    }
    if (r3.bearing) {
      let a = iu(r3.bearing, i, PB);
      o.bearing = this._map.transform.bearing + ce(a.amount, -179, 179), nu(o, a);
    }
    if (r3.pitch) {
      let a = iu(r3.pitch, i, wB);
      o.pitch = this._map.transform.pitch + a.amount, nu(o, a);
    }
    if (r3.roll) {
      let a = iu(r3.roll, i, TB);
      o.roll = this._map.transform.roll + ce(a.amount, -179, 179), nu(o, a);
    }
    if (o.zoom || o.bearing) {
      let a = r3.pinchAround === void 0 ? r3.around : r3.pinchAround;
      o.around = a ? this._map.unproject(a) : this._map.getCenter();
    }
    return this.clear(), Z(o, { noMoveStart: true });
  }
};
function nu(t63, e) {
  (!t63.duration || t63.duration < e.duration) && (t63.duration = e.duration, t63.easing = e.easing);
}
function iu(t63, e, r3) {
  let { maxSpeed: n, linearity: i, deceleration: o } = r3, a = ce(t63 * i / (e / 1e3), -n, n), s3 = Math.abs(a) / (o * i);
  return { easing: r3.easing, duration: s3 * 1e3, amount: a * (s3 / 2) };
}
$i();
$i();
var TS = s(fe(), 1);
var Lt = class extends U {
  preventDefault() {
    this._defaultPrevented = true;
  }
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  constructor(e, r3, n, i = {}) {
    n = n instanceof MouseEvent ? n : new MouseEvent(e, n);
    let o = ie.mousePos(r3.getCanvas(), n), a = r3.unproject(o);
    super(e, Z({ point: o, lngLat: a, originalEvent: n }, i)), this._defaultPrevented = false, this.target = r3;
  }
};
var wi = class extends U {
  preventDefault() {
    this._defaultPrevented = true;
  }
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  constructor(e, r3, n) {
    let i = e === "touchend" ? n.changedTouches : n.touches, o = ie.touchPos(r3.getCanvasContainer(), i), a = o.map((u3) => r3.unproject(u3)), s3 = o.reduce((u3, c, p, h) => u3.add(c.div(h.length)), new TS.default(0, 0)), l = r3.unproject(s3);
    super(e, { points: o, point: s3, lngLats: a, lngLat: l, originalEvent: n }), this._defaultPrevented = false;
  }
};
var au = class extends U {
  preventDefault() {
    this._defaultPrevented = true;
  }
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  constructor(e, r3, n) {
    super(e, { originalEvent: n }), this._defaultPrevented = false;
  }
};
var If = class {
  constructor(e, r3) {
    this._map = e, this._clickTolerance = r3.clickTolerance;
  }
  reset() {
    delete this._mousedownPos;
  }
  wheel(e) {
    return this._firePreventable(new au(e.type, this._map, e));
  }
  mousedown(e, r3) {
    return this._mousedownPos = r3, this._firePreventable(new Lt(e.type, this._map, e));
  }
  mouseup(e) {
    this._map.fire(new Lt(e.type, this._map, e));
  }
  click(e, r3) {
    this._mousedownPos && this._mousedownPos.dist(r3) >= this._clickTolerance || this._map.fire(new Lt(e.type, this._map, e));
  }
  dblclick(e) {
    return this._firePreventable(new Lt(e.type, this._map, e));
  }
  mouseover(e) {
    this._map.fire(new Lt(e.type, this._map, e));
  }
  mouseout(e) {
    this._map.fire(new Lt(e.type, this._map, e));
  }
  touchstart(e) {
    return this._firePreventable(new wi(e.type, this._map, e));
  }
  touchmove(e) {
    this._map.fire(new wi(e.type, this._map, e));
  }
  touchend(e) {
    this._map.fire(new wi(e.type, this._map, e));
  }
  touchcancel(e) {
    this._map.fire(new wi(e.type, this._map, e));
  }
  _firePreventable(e) {
    if (this._map.fire(e), e.defaultPrevented) return {};
  }
  isEnabled() {
    return true;
  }
  isActive() {
    return false;
  }
  enable() {
  }
  disable() {
  }
};
var Af = class {
  constructor(e) {
    this._map = e;
  }
  reset() {
    this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
  }
  mousemove(e) {
    this._map.fire(new Lt(e.type, this._map, e));
  }
  mousedown() {
    this._delayContextMenu = true, this._ignoreContextMenu = false;
  }
  mouseup() {
    this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new Lt("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
  }
  contextmenu(e) {
    this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new Lt(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
  }
  isEnabled() {
    return true;
  }
  isActive() {
    return false;
  }
  enable() {
  }
  disable() {
  }
};
$i();
$i();
var SS = s(fe(), 1);
var Ur = class {
  constructor(e) {
    this._map = e;
  }
  get transform() {
    return this._map._requestedCameraState || this._map.transform;
  }
  get center() {
    return { lng: this.transform.center.lng, lat: this.transform.center.lat };
  }
  get zoom() {
    return this.transform.zoom;
  }
  get pitch() {
    return this.transform.pitch;
  }
  get bearing() {
    return this.transform.bearing;
  }
  unproject(e) {
    return this.transform.screenPointToLocation(SS.default.convert(e), this._map.terrain);
  }
};
var su = class {
  constructor(e, r3) {
    this._map = e, this._tr = new Ur(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = r3.clickTolerance || 1;
  }
  isEnabled() {
    return !!this._enabled;
  }
  isActive() {
    return !!this._active;
  }
  enable() {
    this.isEnabled() || (this._enabled = true);
  }
  disable() {
    this.isEnabled() && (this._enabled = false);
  }
  mousedown(e, r3) {
    this.isEnabled() && e.shiftKey && e.button === 0 && (ie.disableDrag(), this._startPos = this._lastPos = r3, this._active = true);
  }
  mousemoveWindow(e, r3) {
    if (!this._active) return;
    let n = r3;
    if (this._lastPos.equals(n) || !this._box && n.dist(this._startPos) < this._clickTolerance) return;
    let i = this._startPos;
    this._lastPos = n, this._box || (this._box = ie.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
    let o = Math.min(i.x, n.x), a = Math.max(i.x, n.x), s3 = Math.min(i.y, n.y), l = Math.max(i.y, n.y);
    ie.setTransform(this._box, `translate(${o}px,${s3}px)`), this._box.style.width = `${a - o}px`, this._box.style.height = `${l - s3}px`;
  }
  mouseupWindow(e, r3) {
    if (!this._active || e.button !== 0) return;
    let n = this._startPos, i = r3;
    if (this.reset(), ie.suppressClick(), n.x === i.x && n.y === i.y) this._fireEvent("boxzoomcancel", e);
    else return this._map.fire(new U("boxzoomend", { originalEvent: e })), { cameraAnimation: (o) => o.fitScreenCoordinates(n, i, this._tr.bearing, { linear: true }) };
  }
  keydown(e) {
    this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e));
  }
  reset() {
    this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (ie.remove(this._box), this._box = null), ie.enableDrag(), delete this._startPos, delete this._lastPos;
  }
  _fireEvent(e, r3) {
    return this._map.fire(new U(e, { originalEvent: r3 }));
  }
};
$i();
$i();
var CS = s(fe(), 1);
$i();
function lu(t63, e) {
  if (t63.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${t63.length}, points ${e.length}`);
  let r3 = {};
  for (let n = 0; n < t63.length; n++) r3[t63[n].identifier] = e[n];
  return r3;
}
function SB(t63) {
  let e = new CS.default(0, 0);
  for (let r3 of t63) e._add(r3);
  return e.div(t63.length);
}
var xg = 500;
var CB = 500;
var Ef = 30;
var gg = class {
  constructor(e) {
    this.reset(), this.numTouches = e.numTouches;
  }
  reset() {
    delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
  }
  touchstart(e, r3, n) {
    (this.centroid || n.length > this.numTouches) && (this.aborted = true), !this.aborted && (this.startTime === void 0 && (this.startTime = e.timeStamp), n.length === this.numTouches && (this.centroid = SB(r3), this.touches = lu(n, r3)));
  }
  touchmove(e, r3, n) {
    if (this.aborted || !this.centroid) return;
    let i = lu(n, r3);
    for (let o in this.touches) {
      let a = this.touches[o], s3 = i[o];
      (!s3 || s3.dist(a) > Ef) && (this.aborted = true);
    }
  }
  touchend(e, r3, n) {
    if ((!this.centroid || e.timeStamp - this.startTime > CB) && (this.aborted = true), n.length === 0) {
      let i = !this.aborted && this.centroid;
      if (this.reset(), i) return i;
    }
  }
};
var _o = class {
  constructor(e) {
    this.singleTap = new gg(e), this.numTaps = e.numTaps, this.reset();
  }
  reset() {
    this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
  }
  touchstart(e, r3, n) {
    this.singleTap.touchstart(e, r3, n);
  }
  touchmove(e, r3, n) {
    this.singleTap.touchmove(e, r3, n);
  }
  touchend(e, r3, n) {
    let i = this.singleTap.touchend(e, r3, n);
    if (i) {
      let o = e.timeStamp - this.lastTime < xg, a = !this.lastTap || this.lastTap.dist(i) < Ef;
      if ((!o || !a) && this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = i, this.count === this.numTaps) return this.reset(), i;
    }
  }
};
var Lf = class {
  constructor(e) {
    this._tr = new Ur(e), this._zoomIn = new _o({ numTouches: 1, numTaps: 2 }), this._zoomOut = new _o({ numTouches: 2, numTaps: 1 }), this.reset();
  }
  reset() {
    this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
  }
  touchstart(e, r3, n) {
    this._zoomIn.touchstart(e, r3, n), this._zoomOut.touchstart(e, r3, n);
  }
  touchmove(e, r3, n) {
    this._zoomIn.touchmove(e, r3, n), this._zoomOut.touchmove(e, r3, n);
  }
  touchend(e, r3, n) {
    let i = this._zoomIn.touchend(e, r3, n), o = this._zoomOut.touchend(e, r3, n), a = this._tr;
    if (i) return this._active = true, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (s3) => s3.easeTo({ duration: 300, zoom: a.zoom + 1, around: a.unproject(i) }, { originalEvent: e }) };
    if (o) return this._active = true, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (s3) => s3.easeTo({ duration: 300, zoom: a.zoom - 1, around: a.unproject(o) }, { originalEvent: e }) };
  }
  touchcancel() {
    this.reset();
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};
$i();
var MS = s(fe(), 1);
$i();
var Ti = class {
  constructor(e) {
    this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
  }
  reset(e) {
    this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(e);
  }
  _move(...e) {
    let r3 = this._moveFunction(...e);
    if (r3.bearingDelta || r3.pitchDelta || r3.rollDelta || r3.around || r3.panDelta) return this._active = true, r3;
  }
  dragStart(e, r3) {
    !this.isEnabled() || this._lastPoint || this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(r3) ? r3[0] : r3, this._activateOnStart && this._lastPoint && (this._active = true));
  }
  dragMove(e, r3) {
    if (!this.isEnabled()) return;
    let n = this._lastPoint;
    if (!n) return;
    if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) {
      this.reset(e);
      return;
    }
    let i = Array.isArray(r3) ? r3[0] : r3;
    if (!(!this._moved && i.dist(n) < this._clickTolerance)) return this._moved = true, this._lastPoint = i, this._move(n, i);
  }
  dragEnd(e) {
    !this.isEnabled() || !this._lastPoint || this._moveStateManager.isValidEndEvent(e) && (this._moved && ie.suppressClick(), this.reset(e));
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
  getClickTolerance() {
    return this._clickTolerance;
  }
};
$i();
var MB = 0;
var IB = 2;
var AB = { [MB]: 1, [IB]: 2 };
function EB(t63, e) {
  let r3 = AB[e];
  return t63.buttons === void 0 || (t63.buttons & r3) !== r3;
}
var vo = class {
  constructor(e) {
    this._correctEvent = e.checkCorrectEvent;
  }
  startMove(e) {
    let r3 = ie.mouseButton(e);
    this._eventButton = r3;
  }
  endMove(e) {
    delete this._eventButton;
  }
  isValidStartEvent(e) {
    return this._correctEvent(e);
  }
  isValidMoveEvent(e) {
    return !EB(e, this._eventButton);
  }
  isValidEndEvent(e) {
    return ie.mouseButton(e) === this._eventButton;
  }
};
var bg = 0;
var _g = 2;
var Df = (t63) => {
  t63.mousedown = t63.dragStart, t63.mousemoveWindow = t63.dragMove, t63.mouseup = t63.dragEnd, t63.contextmenu = (e) => {
    e.preventDefault();
  };
};
function IS({ enable: t63, clickTolerance: e }) {
  let r3 = new vo({ checkCorrectEvent: (n) => ie.mouseButton(n) === bg && !n.ctrlKey });
  return new Ti({ clickTolerance: e, move: (n, i) => ({ around: i, panDelta: i.sub(n) }), activateOnStart: true, moveStateManager: r3, enable: t63, assignEvents: Df });
}
function AS({ enable: t63, clickTolerance: e, aroundCenter: r3 = true, minPixelCenterThreshold: n = 100, rotateDegreesPerPixelMoved: i = 0.8 }, o) {
  let a = new vo({ checkCorrectEvent: (s3) => ie.mouseButton(s3) === bg && s3.ctrlKey || ie.mouseButton(s3) === _g && !s3.ctrlKey });
  return new Ti({ clickTolerance: e, move: (s3, l) => {
    let u3 = o();
    if (r3 && Math.abs(u3.y - s3.y) > n) return { bearingDelta: ed(new MS.default(s3.x, l.y), l, u3) };
    let c = (l.x - s3.x) * i;
    return r3 && l.y < u3.y && (c = -c), { bearingDelta: c };
  }, moveStateManager: a, enable: t63, assignEvents: Df });
}
function ES({ enable: t63, clickTolerance: e, pitchDegreesPerPixelMoved: r3 = -0.5 }) {
  let n = new vo({ checkCorrectEvent: (i) => ie.mouseButton(i) === bg && i.ctrlKey || ie.mouseButton(i) === _g });
  return new Ti({ clickTolerance: e, move: (i, o) => ({ pitchDelta: (o.y - i.y) * r3 }), moveStateManager: n, enable: t63, assignEvents: Df });
}
function LS({ enable: t63, clickTolerance: e, rollDegreesPerPixelMoved: r3 = 0.3 }, n) {
  let i = new vo({ checkCorrectEvent: (o) => ie.mouseButton(o) === _g && o.ctrlKey });
  return new Ti({ clickTolerance: e, move: (o, a) => {
    let s3 = n(), l = (a.x - o.x) * r3;
    return a.y < s3.y && (l = -l), { rollDelta: l };
  }, moveStateManager: i, enable: t63, assignEvents: Df });
}
$i();
var Rf = s(fe(), 1);
var kf = class {
  constructor(e, r3) {
    this._clickTolerance = e.clickTolerance || 1, this._map = r3, this.reset();
  }
  reset() {
    this._active = false, this._touches = {}, this._sum = new Rf.default(0, 0);
  }
  _shouldBePrevented(e) {
    let r3 = this._map.cooperativeGestures.isEnabled() ? 2 : 1;
    return e < r3;
  }
  touchstart(e, r3, n) {
    return this._calculateTransform(e, r3, n);
  }
  touchmove(e, r3, n) {
    if (this._active) {
      if (this._shouldBePrevented(n.length)) {
        this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e);
        return;
      }
      return e.preventDefault(), this._calculateTransform(e, r3, n);
    }
  }
  touchend(e, r3, n) {
    this._calculateTransform(e, r3, n), this._active && this._shouldBePrevented(n.length) && this.reset();
  }
  touchcancel() {
    this.reset();
  }
  _calculateTransform(e, r3, n) {
    n.length > 0 && (this._active = true);
    let i = lu(n, r3), o = new Rf.default(0, 0), a = new Rf.default(0, 0), s3 = 0;
    for (let c in i) {
      let p = i[c], h = this._touches[c];
      h && (o._add(p), a._add(p.sub(h)), s3++, i[c] = p);
    }
    if (this._touches = i, this._shouldBePrevented(s3) || !a.mag()) return;
    let l = a.div(s3);
    return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : { around: o.div(s3), panDelta: l };
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};
$i();
var uu = class {
  constructor() {
    this.reset();
  }
  reset() {
    this._active = false, delete this._firstTwoTouches;
  }
  touchstart(e, r3, n) {
    this._firstTwoTouches || n.length < 2 || (this._firstTwoTouches = [n[0].identifier, n[1].identifier], this._start([r3[0], r3[1]]));
  }
  touchmove(e, r3, n) {
    if (!this._firstTwoTouches) return;
    e.preventDefault();
    let [i, o] = this._firstTwoTouches, a = Ff(n, r3, i), s3 = Ff(n, r3, o);
    if (!a || !s3) return;
    let l = this._aroundCenter ? null : a.add(s3).div(2);
    return this._move([a, s3], l, e);
  }
  touchend(e, r3, n) {
    if (!this._firstTwoTouches) return;
    let [i, o] = this._firstTwoTouches, a = Ff(n, r3, i), s3 = Ff(n, r3, o);
    a && s3 || (this._active && ie.suppressClick(), this.reset());
  }
  touchcancel() {
    this.reset();
  }
  enable(e) {
    this._enabled = true, this._aroundCenter = !!e && e.around === "center";
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return !!this._enabled;
  }
  isActive() {
    return !!this._active;
  }
};
function Ff(t63, e, r3) {
  for (let n = 0; n < t63.length; n++) if (t63[n].identifier === r3) return e[n];
}
var LB = 0.1;
function DS(t63, e) {
  return Math.log(t63 / e) / Math.LN2;
}
var cu = class extends uu {
  reset() {
    super.reset(), delete this._distance, delete this._startDistance;
  }
  _start(e) {
    this._startDistance = this._distance = e[0].dist(e[1]);
  }
  _move(e, r3) {
    let n = this._distance;
    if (this._distance = e[0].dist(e[1]), !(!this._active && Math.abs(DS(this._distance, this._startDistance)) < LB)) return this._active = true, { zoomDelta: DS(this._distance, n), pinchAround: r3 };
  }
};
var DB = 25;
function RS(t63, e) {
  return t63.angleWith(e) * 180 / Math.PI;
}
var pu = class extends uu {
  reset() {
    super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
  }
  _start(e) {
    this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
  }
  _move(e, r3, n) {
    let i = this._vector;
    if (this._vector = e[0].sub(e[1]), !(!this._active && this._isBelowThreshold(this._vector))) return this._active = true, { bearingDelta: RS(this._vector, i), pinchAround: r3 };
  }
  _isBelowThreshold(e) {
    this._minDiameter = Math.min(this._minDiameter, e.mag());
    let r3 = Math.PI * this._minDiameter, n = DB / r3 * 360, i = RS(e, this._startVector);
    return Math.abs(i) < n;
  }
};
function vg(t63) {
  return Math.abs(t63.y) > Math.abs(t63.x);
}
var RB = 100;
var hu = class extends uu {
  constructor(r3) {
    super();
    this._currentTouchCount = 0;
    this._map = r3;
  }
  reset() {
    super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
  }
  touchstart(r3, n, i) {
    super.touchstart(r3, n, i), this._currentTouchCount = i.length;
  }
  _start(r3) {
    this._lastPoints = r3, vg(r3[0].sub(r3[1])) && (this._valid = false);
  }
  _move(r3, n, i) {
    if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
    let o = r3[0].sub(this._lastPoints[0]), a = r3[1].sub(this._lastPoints[1]);
    return this._valid = this.gestureBeginsVertically(o, a, i.timeStamp), this._valid ? (this._lastPoints = r3, this._active = true, { pitchDelta: (o.y + a.y) / 2 * -0.5 }) : void 0;
  }
  gestureBeginsVertically(r3, n, i) {
    if (this._valid !== void 0) return this._valid;
    let o = 2, a = r3.mag() >= o, s3 = n.mag() >= o;
    if (!a && !s3) return;
    if (!a || !s3) return this._firstMove === void 0 && (this._firstMove = i), i - this._firstMove < RB ? void 0 : false;
    let l = r3.y > 0 == n.y > 0;
    return vg(r3) && vg(n) && l;
  }
};
$i();
var kB = { panStep: 100, bearingStep: 15, pitchStep: 10 };
var fu = class {
  constructor(e) {
    this._tr = new Ur(e);
    let r3 = kB;
    this._panStep = r3.panStep, this._bearingStep = r3.bearingStep, this._pitchStep = r3.pitchStep, this._rotationDisabled = false;
  }
  reset() {
    this._active = false;
  }
  keydown(e) {
    if (e.altKey || e.ctrlKey || e.metaKey) return;
    let r3 = 0, n = 0, i = 0, o = 0, a = 0;
    switch (e.keyCode) {
      case 61:
      case 107:
      case 171:
      case 187:
        r3 = 1;
        break;
      case 189:
      case 109:
      case 173:
        r3 = -1;
        break;
      case 37:
        e.shiftKey ? n = -1 : (e.preventDefault(), o = -1);
        break;
      case 39:
        e.shiftKey ? n = 1 : (e.preventDefault(), o = 1);
        break;
      case 38:
        e.shiftKey ? i = 1 : (e.preventDefault(), a = -1);
        break;
      case 40:
        e.shiftKey ? i = -1 : (e.preventDefault(), a = 1);
        break;
      default:
        return;
    }
    return this._rotationDisabled && (n = 0, i = 0), { cameraAnimation: (s3) => {
      let l = this._tr;
      s3.easeTo({ duration: 300, easeId: "keyboardHandler", easing: FB, zoom: r3 ? Math.round(l.zoom) + r3 * (e.shiftKey ? 2 : 1) : l.zoom, bearing: l.bearing + n * this._bearingStep, pitch: l.pitch + i * this._pitchStep, offset: [-o * this._panStep, -a * this._panStep], center: l.center }, { originalEvent: e });
    } };
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
  disableRotation() {
    this._rotationDisabled = true;
  }
  enableRotation() {
    this._rotationDisabled = false;
  }
};
function FB(t63) {
  return t63 * (2 - t63);
}
$i();
var kS = 4.000244140625;
var OB = 1 / 100;
var BB = 1 / 450;
var zB = 2;
var VB = 5;
var mu = class {
  constructor(e, r3) {
    this._onTimeout = (e3) => {
      this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e3);
    };
    this._map = e, this._tr = new Ur(e), this._triggerRenderFrame = r3, this._delta = 0, this._defaultZoomRate = OB, this._wheelZoomRate = BB;
  }
  setZoomRate(e) {
    this._defaultZoomRate = e;
  }
  setWheelZoomRate(e) {
    this._wheelZoomRate = e;
  }
  isEnabled() {
    return !!this._enabled;
  }
  isActive() {
    return !!this._active || this._finishTimeout !== void 0;
  }
  isZooming() {
    return !!this._zooming;
  }
  enable(e) {
    this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e && e.around === "center");
  }
  disable() {
    this.isEnabled() && (this._enabled = false);
  }
  _shouldBePrevented(e) {
    return this._map.cooperativeGestures.isEnabled() ? !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e)) : false;
  }
  wheel(e) {
    if (!this.isEnabled()) return;
    if (this._shouldBePrevented(e)) {
      this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
      return;
    }
    let r3 = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? e.deltaY * 40 : e.deltaY, n = ae.now(), i = n - (this._lastWheelEventTime || 0);
    this._lastWheelEventTime = n, r3 !== 0 && r3 % kS === 0 ? this._type = "wheel" : r3 !== 0 && Math.abs(r3) < 4 ? this._type = "trackpad" : i > 400 ? (this._type = null, this._lastValue = r3, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(i * r3) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, r3 += this._lastValue)), e.shiftKey && r3 && (r3 = r3 / 4), this._type && (this._lastWheelEvent = e, this._delta -= r3, this._active || this._start(e)), e.preventDefault();
  }
  _start(e) {
    if (!this._delta) return;
    this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
    let r3 = ie.mousePos(this._map.getCanvas(), e), n = this._tr;
    this._aroundCenter ? this._aroundPoint = n.transform.locationToScreenPoint(J.convert(n.center)) : this._aroundPoint = r3, this._frameId || (this._frameId = true, this._triggerRenderFrame());
  }
  renderFrame() {
    if (!this._frameId || (this._frameId = null, !this.isActive())) return;
    let e = this._tr.transform;
    if (typeof this._lastExpectedZoom == "number") {
      let s3 = e.zoom - this._lastExpectedZoom;
      typeof this._startZoom == "number" && (this._startZoom += s3), typeof this._targetZoom == "number" && (this._targetZoom += s3);
    }
    if (this._delta !== 0) {
      let s3 = this._type === "wheel" && Math.abs(this._delta) > kS ? this._wheelZoomRate : this._defaultZoomRate, l = zB / (1 + Math.exp(-Math.abs(this._delta * s3)));
      this._delta < 0 && l !== 0 && (l = 1 / l);
      let u3 = typeof this._targetZoom != "number" ? e.scale : lt(this._targetZoom);
      this._targetZoom = e.getConstrained(e.getCameraLngLat(), rt(u3 * l)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
    }
    let r3 = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom, n = this._startZoom, i = this._easing, o = false, a;
    if (this._type === "wheel" && n && i) {
      let s3 = ae.now() - this._lastWheelEventTime, l = Math.min((s3 + VB) / 200, 1), u3 = i(l);
      a = Fe.number(n, r3, u3), l < 1 ? this._frameId || (this._frameId = true) : o = true;
    } else a = r3, o = true;
    return this._active = true, o && (this._active = false, this._finishTimeout = setTimeout(() => {
      this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
    }, 200)), this._lastExpectedZoom = a, { noInertia: true, needsRenderFrame: !o, zoomDelta: a - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
  }
  _smoothOutEasing(e) {
    let r3 = os;
    if (this._prevEase) {
      let n = this._prevEase, i = (ae.now() - n.start) / n.duration, o = n.easing(i + 0.01) - n.easing(i), a = 0.27 / Math.sqrt(o * o + 1e-4) * 0.01, s3 = Math.sqrt(0.27 * 0.27 - a * a);
      r3 = is(a, s3, 0.25, 1);
    }
    return this._prevEase = { start: ae.now(), duration: e, easing: r3 }, r3;
  }
  reset() {
    this._active = false, this._zooming = false, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
  }
};
$i();
var du = class {
  constructor(e, r3) {
    this._clickZoom = e, this._tapZoom = r3;
  }
  enable() {
    this._clickZoom.enable(), this._tapZoom.enable();
  }
  disable() {
    this._clickZoom.disable(), this._tapZoom.disable();
  }
  isEnabled() {
    return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
  }
  isActive() {
    return this._clickZoom.isActive() || this._tapZoom.isActive();
  }
};
$i();
var Of = class {
  constructor(e) {
    this._tr = new Ur(e), this.reset();
  }
  reset() {
    this._active = false;
  }
  dblclick(e, r3) {
    return e.preventDefault(), { cameraAnimation: (n) => {
      n.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(r3) }, { originalEvent: e });
    } };
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};
$i();
var Bf = class {
  constructor() {
    this._tap = new _o({ numTouches: 1, numTaps: 1 }), this.reset();
  }
  reset() {
    this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
  }
  touchstart(e, r3, n) {
    if (!this._swipePoint) if (!this._tapTime) this._tap.touchstart(e, r3, n);
    else {
      let i = r3[0], o = e.timeStamp - this._tapTime < xg, a = this._tapPoint.dist(i) < Ef;
      !o || !a ? this.reset() : n.length > 0 && (this._swipePoint = i, this._swipeTouch = n[0].identifier);
    }
  }
  touchmove(e, r3, n) {
    if (!this._tapTime) this._tap.touchmove(e, r3, n);
    else if (this._swipePoint) {
      if (n[0].identifier !== this._swipeTouch) return;
      let i = r3[0], o = i.y - this._swipePoint.y;
      return this._swipePoint = i, e.preventDefault(), this._active = true, { zoomDelta: o / 128 };
    }
  }
  touchend(e, r3, n) {
    if (this._tapTime) this._swipePoint && n.length === 0 && this.reset();
    else {
      let i = this._tap.touchend(e, r3, n);
      i && (this._tapTime = e.timeStamp, this._tapPoint = i);
    }
  }
  touchcancel() {
    this.reset();
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};
$i();
var yu = class {
  constructor(e, r3, n) {
    this._el = e, this._mousePan = r3, this._touchPan = n;
  }
  enable(e) {
    this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
  }
  disable() {
    this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
  }
  isEnabled() {
    return this._mousePan.isEnabled() && this._touchPan.isEnabled();
  }
  isActive() {
    return this._mousePan.isActive() || this._touchPan.isActive();
  }
};
$i();
var gu = class {
  constructor(e, r3, n, i) {
    this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = r3, this._mousePitch = n, this._mouseRoll = i;
  }
  enable() {
    this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
  }
  disable() {
    this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
  }
  isEnabled() {
    return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
  }
  isActive() {
    return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
  }
};
$i();
var xu = class {
  constructor(e, r3, n, i) {
    this._el = e, this._touchZoom = r3, this._touchRotate = n, this._tapDragZoom = i, this._rotationDisabled = false, this._enabled = true;
  }
  enable(e) {
    this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
  }
  disable() {
    this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
  }
  isEnabled() {
    return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
  }
  isActive() {
    return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
  }
  disableRotation() {
    this._rotationDisabled = true, this._touchRotate.disable();
  }
  enableRotation() {
    this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
  }
};
$i();
var bu = class {
  constructor(e, r3) {
    this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey";
    this._map = e, this._options = r3, this._enabled = false;
  }
  isActive() {
    return false;
  }
  reset() {
  }
  _setupUI() {
    if (this._container) return;
    let e = this._map.getCanvasContainer();
    e.classList.add("maplibregl-cooperative-gestures"), this._container = ie.create("div", "maplibregl-cooperative-gesture-screen", e);
    let r3 = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
    this._bypassKey === "metaKey" && (r3 = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
    let n = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), i = document.createElement("div");
    i.className = "maplibregl-desktop-message", i.textContent = r3, this._container.appendChild(i);
    let o = document.createElement("div");
    o.className = "maplibregl-mobile-message", o.textContent = n, this._container.appendChild(o), this._container.setAttribute("aria-hidden", "true");
  }
  _destroyUI() {
    this._container && (ie.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
  }
  enable() {
    this._setupUI(), this._enabled = true;
  }
  disable() {
    this._enabled = false, this._destroyUI();
  }
  isEnabled() {
    return this._enabled;
  }
  isBypassed(e) {
    return e[this._bypassKey];
  }
  notifyGestureBlocked(e, r3) {
    this._enabled && (this._map.fire(new U("cooperativegestureprevented", { gestureType: e, originalEvent: r3 })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
      this._container.classList.remove("maplibregl-show");
    }, 100));
  }
};
var FS = s(fe(), 1);
var zf = (t63) => t63.zoom || t63.drag || t63.roll || t63.pitch || t63.rotate;
var wg = class extends U {
};
function Pg(t63) {
  return t63.panDelta && t63.panDelta.mag() || t63.zoomDelta || t63.bearingDelta || t63.pitchDelta || t63.rollDelta;
}
var Vf = class {
  constructor(e, r3) {
    this.handleWindowEvent = (e3) => {
      this.handleEvent(e3, `${e3.type}Window`);
    };
    this.handleEvent = (e3, r4) => {
      if (e3.type === "blur") {
        this.stop(true);
        return;
      }
      this._updatingCamera = true;
      let n3 = e3.type === "renderFrame" ? void 0 : e3, i = { needsRenderFrame: false }, o = {}, a = {};
      for (let { handlerName: u3, handler: c, allowed: p } of this._handlers) {
        if (!c.isEnabled()) continue;
        let h;
        if (this._blockedByActive(a, p, u3)) c.reset();
        else if (c[r4 || e3.type]) {
          if (Wb(e3, r4 || e3.type)) {
            let f = ie.mousePos(this._map.getCanvas(), e3);
            h = c[r4 || e3.type](e3, f);
          } else if (Yb(e3, r4 || e3.type)) {
            let f = e3.touches, d = this._getMapTouches(f), g = ie.touchPos(this._map.getCanvas(), d);
            h = c[r4 || e3.type](e3, g, d);
          } else $b(r4 || e3.type) || (h = c[r4 || e3.type](e3));
          this.mergeHandlerResult(i, o, h, u3, n3), h && h.needsRenderFrame && this._triggerRenderFrame();
        }
        (h || c.isActive()) && (a[u3] = c);
      }
      let s3 = {};
      for (let u3 in this._previousActiveHandlers) a[u3] || (s3[u3] = n3);
      this._previousActiveHandlers = a, (Object.keys(s3).length || Pg(i)) && (this._changes.push([i, o, s3]), this._triggerRenderFrame()), (Object.keys(a).length || Pg(i)) && this._map._stop(true), this._updatingCamera = false;
      let { cameraAnimation: l } = i;
      l && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], l(this._map));
    };
    this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Mf(e), this._bearingSnap = r3.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(r3);
    let n = this._el;
    this._listeners = [[n, "touchstart", { passive: true }], [n, "touchmove", { passive: false }], [n, "touchend", void 0], [n, "touchcancel", void 0], [n, "mousedown", void 0], [n, "mousemove", void 0], [n, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [n, "mouseover", void 0], [n, "mouseout", void 0], [n, "dblclick", void 0], [n, "click", void 0], [n, "keydown", { capture: false }], [n, "keyup", void 0], [n, "wheel", { passive: false }], [n, "contextmenu", void 0], [window, "blur", void 0]];
    for (let [i, o, a] of this._listeners) ie.addEventListener(i, o, i === document ? this.handleWindowEvent : this.handleEvent, a);
  }
  destroy() {
    for (let [e, r3, n] of this._listeners) ie.removeEventListener(e, r3, e === document ? this.handleWindowEvent : this.handleEvent, n);
  }
  _addDefaultHandlers(e) {
    let r3 = this._map, n = r3.getCanvasContainer();
    this._add("mapEvent", new If(r3, e));
    let i = r3.boxZoom = new su(r3, e);
    this._add("boxZoom", i), e.interactive && e.boxZoom && i.enable();
    let o = r3.cooperativeGestures = new bu(r3, e.cooperativeGestures);
    this._add("cooperativeGestures", o), e.cooperativeGestures && o.enable();
    let a = new Lf(r3), s3 = new Of(r3);
    r3.doubleClickZoom = new du(s3, a), this._add("tapZoom", a), this._add("clickZoom", s3), e.interactive && e.doubleClickZoom && r3.doubleClickZoom.enable();
    let l = new Bf();
    this._add("tapDragZoom", l);
    let u3 = r3.touchPitch = new hu(r3);
    this._add("touchPitch", u3), e.interactive && e.touchPitch && r3.touchPitch.enable(e.touchPitch);
    let c = () => r3.project(r3.getCenter()), p = AS(e, c), h = ES(e), f = LS(e, c);
    r3.dragRotate = new gu(e, p, h, f), this._add("mouseRotate", p, ["mousePitch"]), this._add("mousePitch", h, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", f, ["mousePitch"]), e.interactive && e.dragRotate && r3.dragRotate.enable();
    let d = IS(e), g = new kf(e, r3);
    r3.dragPan = new yu(n, d, g), this._add("mousePan", d), this._add("touchPan", g, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && r3.dragPan.enable(e.dragPan);
    let x = new pu(), b = new cu();
    r3.touchZoomRotate = new xu(n, b, x, l), this._add("touchRotate", x, ["touchPan", "touchZoom"]), this._add("touchZoom", b, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && r3.touchZoomRotate.enable(e.touchZoomRotate);
    let v3 = r3.scrollZoom = new mu(r3, () => this._triggerRenderFrame());
    this._add("scrollZoom", v3, ["mousePan"]), e.interactive && e.scrollZoom && r3.scrollZoom.enable(e.scrollZoom);
    let P = r3.keyboard = new fu(r3);
    this._add("keyboard", P), e.interactive && e.keyboard && r3.keyboard.enable(), this._add("blockableMapEvent", new Af(r3));
  }
  _add(e, r3, n) {
    this._handlers.push({ handlerName: e, handler: r3, allowed: n }), this._handlersById[e] = r3;
  }
  stop(e) {
    if (!this._updatingCamera) {
      for (let { handler: r3 } of this._handlers) r3.reset();
      this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
    }
  }
  isActive() {
    for (let { handler: e } of this._handlers) if (e.isActive()) return true;
    return false;
  }
  isZooming() {
    return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
  }
  isRotating() {
    return !!this._eventsInProgress.rotate;
  }
  isMoving() {
    return !!zf(this._eventsInProgress) || this.isZooming();
  }
  _blockedByActive(e, r3, n) {
    for (let i in e) if (i !== n && (!r3 || r3.indexOf(i) < 0)) return true;
    return false;
  }
  _getMapTouches(e) {
    let r3 = [];
    for (let n of e) {
      let i = n.target;
      this._el.contains(i) && r3.push(n);
    }
    return r3;
  }
  mergeHandlerResult(e, r3, n, i, o) {
    if (!n) return;
    Z(e, n);
    let a = { handlerName: i, originalEvent: n.originalEvent || o };
    n.zoomDelta !== void 0 && (r3.zoom = a), n.panDelta !== void 0 && (r3.drag = a), n.rollDelta !== void 0 && (r3.roll = a), n.pitchDelta !== void 0 && (r3.pitch = a), n.bearingDelta !== void 0 && (r3.rotate = a);
  }
  _applyChanges() {
    let e = {}, r3 = {}, n = {};
    for (let [i, o, a] of this._changes) i.panDelta && (e.panDelta = (e.panDelta || new FS.default(0, 0))._add(i.panDelta)), i.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + i.zoomDelta), i.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + i.bearingDelta), i.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + i.pitchDelta), i.rollDelta && (e.rollDelta = (e.rollDelta || 0) + i.rollDelta), i.around !== void 0 && (e.around = i.around), i.pinchAround !== void 0 && (e.pinchAround = i.pinchAround), i.noInertia && (e.noInertia = i.noInertia), Z(r3, o), Z(n, a);
    this._updateMapTransform(e, r3, n), this._changes = [];
  }
  _updateMapTransform(e, r3, n) {
    let i = this._map, o = i._getTransformForUpdate(), a = i.terrain;
    if (!Pg(e) && !(a && this._terrainMovement)) return this._fireEvents(r3, n, true);
    i._stop(true);
    let { panDelta: s3, zoomDelta: l, bearingDelta: u3, pitchDelta: c, rollDelta: p, around: h, pinchAround: f } = e;
    f !== void 0 && (h = f), h = h || i.transform.centerPoint, a && !o.isPointOnMapSurface(h) && (h = o.centerPoint);
    let d = { panDelta: s3, zoomDelta: l, rollDelta: p, pitchDelta: c, bearingDelta: u3, around: h };
    this._map.cameraHelper.useGlobeControls && !o.isPointOnMapSurface(h) && (h = o.centerPoint);
    let g = h.distSqr(o.centerPoint) < 0.01 ? o.center : o.screenPointToLocation(s3 ? h.sub(s3) : h);
    a ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(d, o), !this._terrainMovement && (r3.drag || r3.zoom) ? (this._terrainMovement = true, this._map._elevationFreeze = true, this._map.cameraHelper.handleMapControlsPan(d, o, g)) : r3.drag && this._terrainMovement ? o.setCenter(o.screenPointToLocation(o.centerPoint.sub(s3))) : this._map.cameraHelper.handleMapControlsPan(d, o, g)) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(d, o), this._map.cameraHelper.handleMapControlsPan(d, o, g)), i._applyUpdatedTransform(o), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(r3, n, true);
  }
  _fireEvents(e, r3, n) {
    let i = zf(this._eventsInProgress), o = zf(e), a = {};
    for (let p in e) {
      let { originalEvent: h } = e[p];
      this._eventsInProgress[p] || (a[`${p}start`] = h), this._eventsInProgress[p] = e[p];
    }
    !i && o && this._fireEvent("movestart", o.originalEvent);
    for (let p in a) this._fireEvent(p, a[p]);
    o && this._fireEvent("move", o.originalEvent);
    for (let p in e) {
      let { originalEvent: h } = e[p];
      this._fireEvent(p, h);
    }
    let s3 = {}, l;
    for (let p in this._eventsInProgress) {
      let { handlerName: h, originalEvent: f } = this._eventsInProgress[p];
      this._handlersById[h].isActive() || (delete this._eventsInProgress[p], l = r3[h] || f, s3[`${p}end`] = l);
    }
    for (let p in s3) this._fireEvent(p, s3[p]);
    let u3 = zf(this._eventsInProgress), c = (i || o) && !u3;
    if (c && this._terrainMovement) {
      this._map._elevationFreeze = false, this._terrainMovement = false;
      let p = this._map._getTransformForUpdate();
      this._map.getCenterClampedToGround() && p.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(p);
    }
    if (n && c) {
      this._updatingCamera = true;
      let p = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), h = (f) => f !== 0 && -this._bearingSnap < f && f < this._bearingSnap;
      p && (p.essential || !ae.prefersReducedMotion) ? (h(p.bearing || this._map.getBearing()) && (p.bearing = 0), p.freezeElevation = true, this._map.easeTo(p, { originalEvent: l })) : (this._map.fire(new U("moveend", { originalEvent: l })), h(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
    }
  }
  _fireEvent(e, r3) {
    this._map.fire(new U(e, r3 ? { originalEvent: r3 } : {}));
  }
  _requestFrame() {
    return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e) => {
      delete this._frameId, this.handleEvent(new wg("renderFrame", { timeStamp: e })), this._applyChanges();
    });
  }
  _triggerRenderFrame() {
    this._frameId === void 0 && (this._frameId = this._requestFrame());
  }
};
$i();
var Ra = s(fe(), 1);
var Uf = class extends Ee {
  constructor(r3, n, i) {
    super();
    this._renderFrameCallback = () => {
      let r4 = Math.min((ae.now() - this._easeStart) / this._easeOptions.duration, 1);
      this._onEaseFrame(this._easeOptions.easing(r4)), r4 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
    };
    this._moving = false, this._zooming = false, this.transform = r3, this._bearingSnap = i.bearingSnap, this.cameraHelper = n, this.on("moveend", () => {
      delete this._requestedCameraState;
    });
  }
  migrateProjection(r3, n) {
    r3.apply(this.transform), this.transform = r3, this.cameraHelper = n;
  }
  getCenter() {
    return new J(this.transform.center.lng, this.transform.center.lat);
  }
  setCenter(r3, n) {
    return this.jumpTo({ center: r3 }, n);
  }
  getCenterElevation() {
    return this.transform.elevation;
  }
  setCenterElevation(r3, n) {
    return this.jumpTo({ elevation: r3 }, n), this;
  }
  getCenterClampedToGround() {
    return this._centerClampedToGround;
  }
  setCenterClampedToGround(r3) {
    this._centerClampedToGround = r3;
  }
  panBy(r3, n, i) {
    return r3 = Ra.default.convert(r3).mult(-1), this.panTo(this.transform.center, Z({ offset: r3 }, n), i);
  }
  panTo(r3, n, i) {
    return this.easeTo(Z({ center: r3 }, n), i);
  }
  getZoom() {
    return this.transform.zoom;
  }
  setZoom(r3, n) {
    return this.jumpTo({ zoom: r3 }, n), this;
  }
  zoomTo(r3, n, i) {
    return this.easeTo(Z({ zoom: r3 }, n), i);
  }
  zoomIn(r3, n) {
    return this.zoomTo(this.getZoom() + 1, r3, n), this;
  }
  zoomOut(r3, n) {
    return this.zoomTo(this.getZoom() - 1, r3, n), this;
  }
  getVerticalFieldOfView() {
    return this.transform.fov;
  }
  setVerticalFieldOfView(r3, n) {
    return r3 != this.transform.fov && (this.transform.setFov(r3), this.fire(new U("movestart", n)).fire(new U("move", n)).fire(new U("moveend", n))), this;
  }
  getBearing() {
    return this.transform.bearing;
  }
  setBearing(r3, n) {
    return this.jumpTo({ bearing: r3 }, n), this;
  }
  getPadding() {
    return this.transform.padding;
  }
  setPadding(r3, n) {
    return this.jumpTo({ padding: r3 }, n), this;
  }
  rotateTo(r3, n, i) {
    return this.easeTo(Z({ bearing: r3 }, n), i);
  }
  resetNorth(r3, n) {
    return this.rotateTo(0, Z({ duration: 1e3 }, r3), n), this;
  }
  resetNorthPitch(r3, n) {
    return this.easeTo(Z({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, r3), n), this;
  }
  snapToNorth(r3, n) {
    return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(r3, n) : this;
  }
  getPitch() {
    return this.transform.pitch;
  }
  setPitch(r3, n) {
    return this.jumpTo({ pitch: r3 }, n), this;
  }
  getRoll() {
    return this.transform.roll;
  }
  setRoll(r3, n) {
    return this.jumpTo({ roll: r3 }, n), this;
  }
  cameraForBounds(r3, n) {
    r3 = mt.convert(r3).adjustAntiMeridian();
    let i = n && n.bearing || 0;
    return this._cameraForBoxAndBearing(r3.getNorthWest(), r3.getSouthEast(), i, n);
  }
  _cameraForBoxAndBearing(r3, n, i, o) {
    let a = { top: 0, bottom: 0, right: 0, left: 0 };
    if (o = Z({ padding: a, offset: [0, 0], maxZoom: this.transform.maxZoom }, o), typeof o.padding == "number") {
      let c = o.padding;
      o.padding = { top: c, bottom: c, right: c, left: c };
    }
    let s3 = Z(a, o.padding);
    o.padding = s3;
    let l = this.transform, u3 = new mt(r3, n);
    return this.cameraHelper.cameraForBoxAndBearing(o, s3, u3, i, l);
  }
  fitBounds(r3, n, i) {
    return this._fitInternal(this.cameraForBounds(r3, n), n, i);
  }
  fitScreenCoordinates(r3, n, i, o, a) {
    return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(Ra.default.convert(r3)), this.transform.screenPointToLocation(Ra.default.convert(n)), i, o), o, a);
  }
  _fitInternal(r3, n, i) {
    return r3 ? (n = Z(r3, n), delete n.padding, n.linear ? this.easeTo(n, i) : this.flyTo(n, i)) : this;
  }
  jumpTo(r3, n) {
    this.stop();
    let i = this._getTransformForUpdate(), o = false, a = false, s3 = false, l = i.zoom;
    this.cameraHelper.handleJumpToCenterZoom(i, r3);
    let u3 = i.zoom !== l;
    return "elevation" in r3 && i.elevation !== +r3.elevation && i.setElevation(+r3.elevation), "bearing" in r3 && i.bearing !== +r3.bearing && (o = true, i.setBearing(+r3.bearing)), "pitch" in r3 && i.pitch !== +r3.pitch && (a = true, i.setPitch(+r3.pitch)), "roll" in r3 && i.roll !== +r3.roll && (s3 = true, i.setRoll(+r3.roll)), r3.padding != null && !i.isPaddingEqual(r3.padding) && i.setPadding(r3.padding), this._applyUpdatedTransform(i), this.fire(new U("movestart", n)).fire(new U("move", n)), u3 && this.fire(new U("zoomstart", n)).fire(new U("zoom", n)).fire(new U("zoomend", n)), o && this.fire(new U("rotatestart", n)).fire(new U("rotate", n)).fire(new U("rotateend", n)), a && this.fire(new U("pitchstart", n)).fire(new U("pitch", n)).fire(new U("pitchend", n)), s3 && this.fire(new U("rollstart", n)).fire(new U("roll", n)).fire(new U("rollend", n)), this.fire(new U("moveend", n));
  }
  calculateCameraOptionsFromTo(r3, n, i, o = 0) {
    let a = xe.fromLngLat(r3, n), s3 = xe.fromLngLat(i, o), l = s3.x - a.x, u3 = s3.y - a.y, c = s3.z - a.z, p = Math.hypot(l, u3, c);
    if (p === 0) throw new Error("Can't calculate camera options with same From and To");
    let h = Math.hypot(l, u3), f = rt(this.transform.cameraToCenterDistance / p / this.transform.tileSize), d = Math.atan2(l, -u3) * 180 / Math.PI, g = Math.acos(h / p) * 180 / Math.PI;
    return g = c < 0 ? 90 - g : 90 + g, { center: s3.toLngLat(), elevation: o, zoom: f, pitch: g, bearing: d };
  }
  calculateCameraOptionsFromCameraLngLatAltRotation(r3, n, i, o, a) {
    let s3 = this.transform.calculateCenterFromCameraLngLatAlt(r3, n, i, o);
    return { center: s3.center, elevation: s3.elevation, zoom: s3.zoom, bearing: i, pitch: o, roll: a };
  }
  easeTo(r3, n) {
    this._stop(false, r3.easeId), r3 = Z({ offset: [0, 0], duration: 500, easing: os }, r3), (r3.animate === false || !r3.essential && ae.prefersReducedMotion) && (r3.duration = 0);
    let i = this._getTransformForUpdate(), o = this.getBearing(), a = i.pitch, s3 = i.roll, l = "bearing" in r3 ? this._normalizeBearing(r3.bearing, o) : o, u3 = "pitch" in r3 ? +r3.pitch : a, c = "roll" in r3 ? this._normalizeBearing(r3.roll, s3) : s3, p = "padding" in r3 ? r3.padding : i.padding, h = Ra.default.convert(r3.offset), f, d;
    r3.around && (f = J.convert(r3.around), d = i.locationToScreenPoint(f));
    let g = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, x = this.cameraHelper.handleEaseTo(i, { bearing: l, pitch: u3, roll: c, padding: p, around: f, aroundPoint: d, offsetAsPoint: h, offset: r3.offset, zoom: r3.zoom, center: r3.center });
    return this._rotating = this._rotating || o !== l, this._pitching = this._pitching || u3 !== a, this._rolling = this._rolling || c !== s3, this._padding = !i.isPaddingEqual(p), this._zooming = this._zooming || x.isZooming, this._easeId = r3.easeId, this._prepareEase(n, r3.noMoveStart, g), this.terrain && this._prepareElevation(x.elevationCenter), this._ease((b) => {
      x.easeFunc(b), this.terrain && !r3.freezeElevation && this._updateElevation(b), this._applyUpdatedTransform(i), this._fireMoveEvents(n);
    }, (b) => {
      this.terrain && r3.freezeElevation && this._finalizeElevation(), this._afterEase(n, b);
    }, r3), this;
  }
  _prepareEase(r3, n, i = {}) {
    this._moving = true, !n && !i.moving && this.fire(new U("movestart", r3)), this._zooming && !i.zooming && this.fire(new U("zoomstart", r3)), this._rotating && !i.rotating && this.fire(new U("rotatestart", r3)), this._pitching && !i.pitching && this.fire(new U("pitchstart", r3)), this._rolling && !i.rolling && this.fire(new U("rollstart", r3));
  }
  _prepareElevation(r3) {
    this._elevationCenter = r3, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(r3, this.transform.tileZoom), this._elevationFreeze = true;
  }
  _updateElevation(r3) {
    this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
    let n = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
    if (r3 < 1 && n !== this._elevationTarget) {
      let i = this._elevationTarget - this._elevationStart, o = (n - (i * r3 + this._elevationStart)) / (1 - r3);
      this._elevationStart += r3 * (i - o), this._elevationTarget = n;
    }
    this.transform.setElevation(Fe.number(this._elevationStart, this._elevationTarget, r3));
  }
  _finalizeElevation() {
    this._elevationFreeze = false, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
  }
  _getTransformForUpdate() {
    return !this.transformCameraUpdate && !this.terrain ? this.transform : (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState);
  }
  _elevateCameraIfInsideTerrain(r3) {
    return {};
  }
  _applyUpdatedTransform(r3) {
    let n = [];
    if (n.push((o) => this._elevateCameraIfInsideTerrain(o)), this.transformCameraUpdate && n.push((o) => this.transformCameraUpdate(o)), !n.length) return;
    let i = r3.clone();
    for (let o of n) {
      let a = i.clone(), { center: s3, zoom: l, roll: u3, pitch: c, bearing: p, elevation: h } = o(a);
      s3 && a.setCenter(s3), h !== void 0 && a.setElevation(h), l !== void 0 && a.setZoom(l), u3 !== void 0 && a.setRoll(u3), c !== void 0 && a.setPitch(c), p !== void 0 && a.setBearing(p), i.apply(a);
    }
    this.transform.apply(i);
  }
  _fireMoveEvents(r3) {
    this.fire(new U("move", r3)), this._zooming && this.fire(new U("zoom", r3)), this._rotating && this.fire(new U("rotate", r3)), this._pitching && this.fire(new U("pitch", r3)), this._rolling && this.fire(new U("roll", r3));
  }
  _afterEase(r3, n) {
    if (this._easeId && n && this._easeId === n) return;
    delete this._easeId;
    let i = this._zooming, o = this._rotating, a = this._pitching, s3 = this._rolling;
    this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._rolling = false, this._padding = false, i && this.fire(new U("zoomend", r3)), o && this.fire(new U("rotateend", r3)), a && this.fire(new U("pitchend", r3)), s3 && this.fire(new U("rollend", r3)), this.fire(new U("moveend", r3));
  }
  flyTo(r3, n) {
    if (!r3.essential && ae.prefersReducedMotion) {
      let I = nn(r3, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
      return this.jumpTo(I, n);
    }
    this.stop(), r3 = Z({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: os }, r3);
    let i = this._getTransformForUpdate(), o = i.bearing, a = i.pitch, s3 = i.roll, l = i.padding, u3 = "bearing" in r3 ? this._normalizeBearing(r3.bearing, o) : o, c = "pitch" in r3 ? +r3.pitch : a, p = "roll" in r3 ? this._normalizeBearing(r3.roll, s3) : s3, h = "padding" in r3 ? r3.padding : i.padding, f = Ra.default.convert(r3.offset), d = i.centerPoint.add(f), g = i.screenPointToLocation(d), x = this.cameraHelper.handleFlyTo(i, { bearing: u3, pitch: c, roll: p, padding: h, locationAtOffset: g, offsetAsPoint: f, center: r3.center, minZoom: r3.minZoom, zoom: r3.zoom }), b = r3.curve, v3 = Math.max(i.width, i.height), P = v3 / x.scaleOfZoom, w3 = x.pixelPathLength;
    if (typeof x.scaleOfMinZoom == "number") {
      let I = v3 / x.scaleOfMinZoom;
      b = Math.sqrt(I / w3 * 2);
    }
    let T = b * b;
    function S(I) {
      let R = (P * P - v3 * v3 + (I ? -1 : 1) * T * T * w3 * w3) / (2 * (I ? P : v3) * T * w3);
      return Math.log(Math.sqrt(R * R + 1) - R);
    }
    function C3(I) {
      return (Math.exp(I) - Math.exp(-I)) / 2;
    }
    function A(I) {
      return (Math.exp(I) + Math.exp(-I)) / 2;
    }
    function E(I) {
      return C3(I) / A(I);
    }
    let L = S(false), F = function(I) {
      return A(L) / A(L + b * I);
    }, O = function(I) {
      return v3 * ((A(L) * E(L + b * I) - C3(L)) / T) / w3;
    }, z = (S(true) - L) / b;
    if (Math.abs(w3) < 2e-6 || !isFinite(z)) {
      if (Math.abs(v3 - P) < 1e-6) return this.easeTo(r3, n);
      let I = P < v3 ? -1 : 1;
      z = Math.abs(Math.log(P / v3)) / b, O = () => 0, F = (R) => Math.exp(I * b * R);
    }
    if ("duration" in r3) r3.duration = +r3.duration;
    else {
      let I = "screenSpeed" in r3 ? +r3.screenSpeed / b : +r3.speed;
      r3.duration = 1e3 * z / I;
    }
    return r3.maxDuration && r3.duration > r3.maxDuration && (r3.duration = 0), this._zooming = true, this._rotating = o !== u3, this._pitching = c !== a, this._rolling = p !== s3, this._padding = !i.isPaddingEqual(h), this._prepareEase(n, false), this.terrain && this._prepareElevation(x.targetCenter), this._ease((I) => {
      let R = I * z, H = 1 / F(R), W = O(R);
      this._rotating && i.setBearing(Fe.number(o, u3, I)), this._pitching && i.setPitch(Fe.number(a, c, I)), this._rolling && i.setRoll(Fe.number(s3, p, I)), this._padding && (i.interpolatePadding(l, h, I), d = i.centerPoint.add(f)), x.easeFunc(I, H, W, d), this.terrain && !r3.freezeElevation && this._updateElevation(I), this._applyUpdatedTransform(i), this._fireMoveEvents(n);
    }, () => {
      this.terrain && r3.freezeElevation && this._finalizeElevation(), this._afterEase(n);
    }, r3), this;
  }
  isEasing() {
    return !!this._easeFrameId;
  }
  stop() {
    return this._stop();
  }
  _stop(r3, n) {
    if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
      let i = this._onEaseEnd;
      delete this._onEaseEnd, i.call(this, n);
    }
    return r3 || this.handlers?.stop(false), this;
  }
  _ease(r3, n, i) {
    i.animate === false || i.duration === 0 ? (r3(1), n()) : (this._easeStart = ae.now(), this._easeOptions = i, this._onEaseFrame = r3, this._onEaseEnd = n, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
  }
  _normalizeBearing(r3, n) {
    r3 = Rr(r3, -180, 180);
    let i = Math.abs(r3 - n);
    return Math.abs(r3 - 360 - n) < i && (r3 -= 360), Math.abs(r3 + 360 - n) < i && (r3 += 360), r3;
  }
  queryTerrainElevation(r3) {
    return this.terrain ? this.terrain.getElevationForLngLatZoom(J.convert(r3), this.transform.tileZoom) : null;
  }
};
var Bn = s(fe(), 1);
$i();
var Tg = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
var _u = class {
  constructor(e = Tg) {
    this._toggleAttribution = () => {
      this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
    };
    this._updateData = (e3) => {
      e3 && (e3.sourceDataType === "metadata" || e3.sourceDataType === "visibility" || e3.dataType === "style" || e3.type === "terrain") && this._updateAttributions();
    };
    this._updateCompact = () => {
      this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === false ? this._container.setAttribute("open", "") : !this._container.classList.contains("maplibregl-compact") && !this._container.classList.contains("maplibregl-attrib-empty") && (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
    };
    this._updateCompactMinimize = () => {
      this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
    };
    this.options = e;
  }
  getDefaultPosition() {
    return "bottom-right";
  }
  onAdd(e) {
    return this._map = e, this._compact = this.options.compact, this._container = ie.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = ie.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = ie.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
  }
  onRemove() {
    ie.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
  }
  _setElementTitle(e, r3) {
    let n = this._map._getUIString(`AttributionControl.${r3}`);
    e.title = n, e.setAttribute("aria-label", n);
  }
  _updateAttributions() {
    if (!this._map.style) return;
    let e = [];
    if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((i) => typeof i != "string" ? "" : i)) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
      let i = this._map.style.stylesheet;
      this.styleOwner = i.owner, this.styleId = i.id;
    }
    let r3 = this._map.style.sourceCaches;
    for (let i in r3) {
      let o = r3[i];
      if (o.used || o.usedForTerrain) {
        let a = o.getSource();
        a.attribution && e.indexOf(a.attribution) < 0 && e.push(a.attribution);
      }
    }
    e = e.filter((i) => String(i).trim()), e.sort((i, o) => i.length - o.length), e = e.filter((i, o) => {
      for (let a = o + 1; a < e.length; a++) if (e[a].indexOf(i) >= 0) return false;
      return true;
    });
    let n = e.join(" | ");
    n !== this._attribHTML && (this._attribHTML = n, e.length ? (this._innerContainer.innerHTML = ie.sanitize(n), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
  }
};
$i();
var vu = class {
  constructor(e = {}) {
    this._updateCompact = () => {
      let e3 = this._container.children;
      if (e3.length) {
        let r3 = e3[0];
        this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== false && r3.classList.add("maplibregl-compact") : r3.classList.remove("maplibregl-compact");
      }
    };
    this.options = e;
  }
  getDefaultPosition() {
    return "bottom-left";
  }
  onAdd(e) {
    this._map = e, this._compact = this.options && this.options.compact, this._container = ie.create("div", "maplibregl-ctrl");
    let r3 = ie.create("a", "maplibregl-ctrl-logo");
    return r3.target = "_blank", r3.rel = "noopener nofollow", r3.href = "https://maplibre.org/", r3.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), r3.setAttribute("rel", "noopener nofollow"), this._container.appendChild(r3), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
  }
  onRemove() {
    ie.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
  }
};
$i();
var Nf = class {
  constructor() {
    this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
  }
  add(e) {
    let r3 = ++this._id;
    return this._queue.push({ callback: e, id: r3, cancelled: false }), r3;
  }
  remove(e) {
    let r3 = this._currentlyRunning, n = r3 ? this._queue.concat(r3) : this._queue;
    for (let i of n) if (i.id === e) {
      i.cancelled = true;
      return;
    }
  }
  run(e = 0) {
    if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
    let r3 = this._currentlyRunning = this._queue;
    this._queue = [];
    for (let n of r3) if (!n.cancelled && (n.callback(e), this._cleared)) break;
    this._cleared = false, this._currentlyRunning = false;
  }
  clear() {
    this._currentlyRunning && (this._cleared = true), this._queue = [];
  }
};
$i();
var jf = ((n) => (n.create = "create", n.load = "load", n.fullLoad = "fullLoad", n))(jf || {});
var Gf = null;
var Pu = [];
var UB = 60;
var Sg = 1e3 / UB;
var Cg = "loadTime";
var Mg = "fullLoadTime";
var ka = { mark(t63) {
  performance.mark(t63);
}, frame(t63) {
  let e = t63;
  if (Gf != null) {
    let r3 = e - Gf;
    Pu.push(r3);
  }
  Gf = e;
}, clearMetrics() {
  Gf = null, Pu = [], performance.clearMeasures(Cg), performance.clearMeasures(Mg);
  for (let t63 in jf) performance.clearMarks(jf[t63]);
}, getPerformanceMetrics() {
  performance.measure(Cg, "create", "load"), performance.measure(Mg, "create", "fullLoad");
  let t63 = performance.getEntriesByName(Cg)[0].duration, e = performance.getEntriesByName(Mg)[0].duration, r3 = Pu.length, i = 1 / (Pu.reduce((s3, l) => s3 + l, 0) / r3 / 1e3), o = Pu.filter((s3) => s3 > Sg).reduce((s3, l) => s3 + (l - Sg) / Sg, 0), a = o / (r3 + o) * 100;
  return { loadTime: t63, fullLoadTime: e, fps: i, percentDroppedFrames: a, totalFrames: r3 };
} };
$i();
$i();
var OS = ze([{ name: "a_pos3d", type: "Int16", components: 3 }]);
$i();
var Hf = class extends Ee {
  constructor(r3) {
    super();
    this._lastTilesetChange = ae.now();
    this.sourceCache = r3, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = r3._source.tileSize * 2 ** this.deltaZoom, r3.usedForTerrain = true, r3.tileSize = this.tileSize;
  }
  destruct() {
    this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
  }
  update(r3, n) {
    this.sourceCache.update(r3, n), this._renderableTilesKeys = [];
    let i = {};
    for (let o of bi(r3, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: n, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) i[o.key] = true, this._renderableTilesKeys.push(o.key), this._tiles[o.key] || (o.terrainRttPosMatrix32f = new Float64Array(16), B.ortho(o.terrainRttPosMatrix32f, 0, 8192, 8192, 0, 0, 1), this._tiles[o.key] = new _a(o, this.tileSize), this._lastTilesetChange = ae.now());
    for (let o in this._tiles) i[o] || delete this._tiles[o];
  }
  freeRtt(r3) {
    for (let n in this._tiles) {
      let i = this._tiles[n];
      (!r3 || i.tileID.equals(r3) || i.tileID.isChildOf(r3) || r3.isChildOf(i.tileID)) && (i.rtt = []);
    }
  }
  getRenderableTiles() {
    return this._renderableTilesKeys.map((r3) => this.getTileByID(r3));
  }
  getTileByID(r3) {
    return this._tiles[r3];
  }
  getTerrainCoords(r3, n) {
    return n ? this._getTerrainCoordsForTileRanges(r3, n) : this._getTerrainCoordsForRegularTile(r3);
  }
  _getTerrainCoordsForRegularTile(r3) {
    let n = {};
    for (let i of this._renderableTilesKeys) {
      let o = this._tiles[i].tileID, a = r3.clone(), s3 = Hr();
      if (o.canonical.equals(r3.canonical)) B.ortho(s3, 0, 8192, 8192, 0, 0, 1);
      else if (o.canonical.isChildOf(r3.canonical)) {
        let l = o.canonical.z - r3.canonical.z, u3 = o.canonical.x - (o.canonical.x >> l << l), c = o.canonical.y - (o.canonical.y >> l << l), p = 8192 >> l;
        B.ortho(s3, 0, p, p, 0, 0, 1), B.translate(s3, s3, [-u3 * p, -c * p, 0]);
      } else if (r3.canonical.isChildOf(o.canonical)) {
        let l = r3.canonical.z - o.canonical.z, u3 = r3.canonical.x - (r3.canonical.x >> l << l), c = r3.canonical.y - (r3.canonical.y >> l << l), p = 8192 >> l;
        B.ortho(s3, 0, 8192, 8192, 0, 0, 1), B.translate(s3, s3, [u3 * p, c * p, 0]), B.scale(s3, s3, [1 / 2 ** l, 1 / 2 ** l, 0]);
      } else continue;
      a.terrainRttPosMatrix32f = new Float32Array(s3), n[i] = a;
    }
    return n;
  }
  _getTerrainCoordsForTileRanges(r3, n) {
    let i = {};
    for (let o of this._renderableTilesKeys) {
      let a = this._tiles[o].tileID;
      if (!this._isWithinTileRanges(a, n)) continue;
      let s3 = r3.clone(), l = Hr();
      if (a.canonical.z === r3.canonical.z) {
        let u3 = r3.canonical.x - a.canonical.x, c = r3.canonical.y - a.canonical.y;
        B.ortho(l, 0, 8192, 8192, 0, 0, 1), B.translate(l, l, [u3 * 8192, c * 8192, 0]);
      } else if (a.canonical.z > r3.canonical.z) {
        let u3 = a.canonical.z - r3.canonical.z, c = a.canonical.x - (a.canonical.x >> u3 << u3), p = a.canonical.y - (a.canonical.y >> u3 << u3), h = r3.canonical.x - (a.canonical.x >> u3), f = r3.canonical.y - (a.canonical.y >> u3), d = 8192 >> u3;
        B.ortho(l, 0, d, d, 0, 0, 1), B.translate(l, l, [-c * d + h * 8192, -p * d + f * 8192, 0]);
      } else {
        let u3 = r3.canonical.z - a.canonical.z, c = r3.canonical.x - (r3.canonical.x >> u3 << u3), p = r3.canonical.y - (r3.canonical.y >> u3 << u3), h = (r3.canonical.x >> u3) - a.canonical.x, f = (r3.canonical.y >> u3) - a.canonical.y, d = 8192 << u3;
        B.ortho(l, 0, d, d, 0, 0, 1), B.translate(l, l, [c * 8192 + h * d, p * 8192 + f * d, 0]);
      }
      s3.terrainRttPosMatrix32f = new Float32Array(l), i[o] = s3;
    }
    return i;
  }
  getSourceTile(r3, n) {
    let i = this.sourceCache._source, o = r3.overscaledZ - this.deltaZoom;
    if (o > i.maxzoom && (o = i.maxzoom), o < i.minzoom) return null;
    this._sourceTileCache[r3.key] || (this._sourceTileCache[r3.key] = r3.scaledTo(o).key);
    let a = this.sourceCache.getTileByID(this._sourceTileCache[r3.key]);
    if (!(a && a.dem) && n) for (; o >= i.minzoom && !(a && a.dem); ) a = this.sourceCache.getTileByID(r3.scaledTo(o--).key);
    return a;
  }
  anyTilesAfterTime(r3 = Date.now()) {
    return this._lastTilesetChange >= r3;
  }
  _isWithinTileRanges(r3, n) {
    return n[r3.canonical.z] && r3.canonical.x >= n[r3.canonical.z].minTileX && r3.canonical.x <= n[r3.canonical.z].maxTileX && r3.canonical.y >= n[r3.canonical.z].minTileY && r3.canonical.y <= n[r3.canonical.z].maxTileY;
  }
};
var Xf = class {
  constructor(e, r3, n) {
    this._meshCache = {};
    this.painter = e, this.sourceCache = new Hf(r3), this.options = n, this.exaggeration = typeof n.exaggeration == "number" ? n.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
  }
  getDEMElevation(e, r3, n, i = 8192) {
    if (!(r3 >= 0 && r3 < i && n >= 0 && n < i)) return 0;
    let o = this.getTerrainData(e), a = o.tile?.dem;
    if (!a) return 0;
    let s3 = wt.transformMat4([], [r3 / i * 8192, n / i * 8192], o.u_terrain_matrix), l = [s3[0] * a.dim, s3[1] * a.dim], u3 = Math.floor(l[0]), c = Math.floor(l[1]), p = l[0] - u3, h = l[1] - c;
    return a.get(u3, c) * (1 - p) * (1 - h) + a.get(u3 + 1, c) * p * (1 - h) + a.get(u3, c + 1) * (1 - p) * h + a.get(u3 + 1, c + 1) * p * h;
  }
  getElevationForLngLatZoom(e, r3) {
    if (!F1(r3, e.wrap())) return 0;
    let { tileID: n, mercatorX: i, mercatorY: o } = this._getOverscaledTileIDFromLngLatZoom(e, r3);
    return this.getElevation(n, i % 8192, o % 8192, 8192);
  }
  getElevation(e, r3, n, i = 8192) {
    return this.getDEMElevation(e, r3, n, i) * this.exaggeration;
  }
  getTerrainData(e) {
    if (!this._emptyDemTexture) {
      let i = this.painter.context, o = new Le2({ width: 1, height: 1 }, new Uint8Array(1 * 4));
      this._emptyDepthTexture = new Se(i, o, i.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new Se(i, new Le2({ width: 1, height: 1 }), i.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(i.gl.NEAREST, i.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = B.identity([]);
    }
    let r3 = this.sourceCache.getSourceTile(e, true);
    if (r3 && r3.dem && (!r3.demTexture || r3.needsTerrainPrepare)) {
      let i = this.painter.context;
      r3.demTexture = this.painter.getTileTexture(r3.dem.stride), r3.demTexture ? r3.demTexture.update(r3.dem.getPixels(), { premultiply: false }) : r3.demTexture = new Se(i, r3.dem.getPixels(), i.gl.RGBA, { premultiply: false }), r3.demTexture.bind(i.gl.NEAREST, i.gl.CLAMP_TO_EDGE), r3.needsTerrainPrepare = false;
    }
    let n = r3 && r3 + r3.tileID.key + e.key;
    if (n && !this._demMatrixCache[n]) {
      let i = this.sourceCache.sourceCache._source.maxzoom, o = e.canonical.z - r3.tileID.canonical.z;
      e.overscaledZ > e.canonical.z && (e.canonical.z >= i ? o = e.canonical.z - i : ve2("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
      let a = e.canonical.x - (e.canonical.x >> o << o), s3 = e.canonical.y - (e.canonical.y >> o << o), l = B.fromScaling(new Float64Array(16), [1 / (8192 << o), 1 / (8192 << o), 0]);
      B.translate(l, l, [a * 8192, s3 * 8192, 0]), this._demMatrixCache[e.key] = { matrix: l, coord: e };
    }
    return { u_depth: 2, u_terrain: 3, u_terrain_dim: r3 && r3.dem && r3.dem.dim || 1, u_terrain_matrix: n ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: r3 && r3.dem && r3.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (r3 && r3.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: r3 };
  }
  getFramebuffer(e) {
    let r3 = this.painter, n = r3.width / devicePixelRatio, i = r3.height / devicePixelRatio;
    return this._fbo && (this._fbo.width !== n || this._fbo.height !== i) && (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new Se(r3.context, { width: n, height: i, data: null }, r3.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(r3.context.gl.NEAREST, r3.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new Se(r3.context, { width: n, height: i, data: null }, r3.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(r3.context.gl.NEAREST, r3.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = r3.context.createFramebuffer(n, i, true, false), this._fbo.depthAttachment.set(r3.context.createRenderbuffer(r3.context.gl.DEPTH_COMPONENT16, n, i))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
  }
  getCoordsTexture() {
    let e = this.painter.context;
    if (this._coordsTexture) return this._coordsTexture;
    let r3 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
    for (let o = 0, a = 0; o < this._coordsTextureSize; o++) for (let s3 = 0; s3 < this._coordsTextureSize; s3++, a += 4) r3[a + 0] = s3 & 255, r3[a + 1] = o & 255, r3[a + 2] = s3 >> 8 << 4 | o >> 8, r3[a + 3] = 0;
    let n = new Le2({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(r3.buffer)), i = new Se(e, n, e.gl.RGBA, { premultiply: false });
    return i.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = i, i;
  }
  pointCoordinate(e) {
    this.painter.maybeDrawDepthAndCoords(true);
    let r3 = new Uint8Array(4), n = this.painter.context, i = n.gl, o = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), a = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), s3 = Math.round(this.painter.height / devicePixelRatio);
    n.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), i.readPixels(o, s3 - a - 1, 1, 1, i.RGBA, i.UNSIGNED_BYTE, r3), n.bindFramebuffer.set(null);
    let l = r3[0] + (r3[2] >> 4 << 8), u3 = r3[1] + ((r3[2] & 15) << 8), c = this.coordsIndex[255 - r3[3]], p = c && this.sourceCache.getTileByID(c);
    if (!p) return null;
    let h = this._coordsTextureSize, f = (1 << p.tileID.canonical.z) * h;
    return new xe((p.tileID.canonical.x * h + l) / f + p.tileID.wrap, (p.tileID.canonical.y * h + u3) / f, this.getElevation(p.tileID, l, u3, h));
  }
  depthAtPoint(e) {
    let r3 = new Uint8Array(4), n = this.painter.context, i = n.gl;
    return n.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), i.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, i.RGBA, i.UNSIGNED_BYTE, r3), n.bindFramebuffer.set(null), (r3[0] / (256 * 256 * 256) + r3[1] / (256 * 256) + r3[2] / 256 + r3[3]) / 256;
  }
  getTerrainMesh(e) {
    let r3 = this.painter.style.projection?.transitionState > 0, n = r3 && e.canonical.y === 0, i = r3 && e.canonical.y === (1 << e.canonical.z) - 1, o = `m_${n ? "n" : ""}_${i ? "s" : ""}`;
    if (this._meshCache[o]) return this._meshCache[o];
    let a = this.painter.context, s3 = new Qc(), l = new Qe(), u3 = this.meshSize, c = 8192 / u3, p = u3 * u3;
    for (let C3 = 0; C3 <= u3; C3++) for (let A = 0; A <= u3; A++) s3.emplaceBack(A * c, C3 * c, 0);
    for (let C3 = 0; C3 < p; C3 += u3 + 1) for (let A = 0; A < u3; A++) l.emplaceBack(A + C3, u3 + A + C3 + 1, u3 + A + C3 + 2), l.emplaceBack(A + C3, u3 + A + C3 + 2, A + C3 + 1);
    let h = s3.length, f = 0, d = h + (u3 + 1), g = (u3 + 1) * u3, x = n ? fn : 0, b = n ? 0 : 1, v3 = i ? En : 8192, P = i ? 0 : 1;
    for (let C3 = 0; C3 <= u3; C3++) s3.emplaceBack(C3 * c, x, b);
    for (let C3 = 0; C3 <= u3; C3++) s3.emplaceBack(C3 * c, v3, P);
    for (let C3 = 0; C3 < u3; C3++) l.emplaceBack(g + C3, d + C3, d + C3 + 1), l.emplaceBack(g + C3, d + C3 + 1, g + C3 + 1), l.emplaceBack(f + C3, h + C3 + 1, h + C3), l.emplaceBack(f + C3, f + C3 + 1, h + C3 + 1);
    let w3 = s3.length, T = w3 + (u3 + 1) * 2;
    for (let C3 of [0, 1]) for (let A = 0; A <= u3; A++) for (let E of [0, 1]) s3.emplaceBack(C3 * 8192, A * c, E);
    for (let C3 = 0; C3 < u3 * 2; C3 += 2) l.emplaceBack(w3 + C3, w3 + C3 + 1, w3 + C3 + 3), l.emplaceBack(w3 + C3, w3 + C3 + 3, w3 + C3 + 2), l.emplaceBack(T + C3, T + C3 + 3, T + C3 + 1), l.emplaceBack(T + C3, T + C3 + 2, T + C3 + 3);
    let S = new ar(a.createVertexBuffer(s3, OS.members), a.createIndexBuffer(l), de2.simpleSegment(0, 0, s3.length, l.length));
    return this._meshCache[o] = S, S;
  }
  getMeshFrameDelta(e) {
    return 2 * Math.PI * nr / Math.pow(2, Math.max(e, 0)) / 5;
  }
  getMinTileElevationForLngLatZoom(e, r3) {
    let { tileID: n } = this._getOverscaledTileIDFromLngLatZoom(e, r3);
    return this.getMinMaxElevation(n).minElevation ?? 0;
  }
  getMinMaxElevation(e) {
    let r3 = this.getTerrainData(e).tile, n = { minElevation: null, maxElevation: null };
    return r3 && r3.dem && (n.minElevation = r3.dem.min * this.exaggeration, n.maxElevation = r3.dem.max * this.exaggeration), n;
  }
  _getOverscaledTileIDFromLngLatZoom(e, r3) {
    let n = xe.fromLngLat(e.wrap()), i = (1 << r3) * 8192, o = n.x * i, a = n.y * i, s3 = Math.floor(o / 8192), l = Math.floor(a / 8192);
    return { tileID: new Ye2(r3, 0, r3, s3, l), mercatorX: o, mercatorY: a };
  }
};
$i();
$i();
var Zf = class {
  constructor(e, r3, n) {
    this._context = e;
    this._size = r3;
    this._tileSize = n;
    this._objects = [], this._recentlyUsed = [], this._stamp = 0;
  }
  destruct() {
    for (let e of this._objects) e.texture.destroy(), e.fbo.destroy();
  }
  _createObject(e) {
    let r3 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), n = new Se(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
    return n.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), r3.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), r3.colorAttachment.set(n.texture), { id: e, fbo: r3, texture: n, stamp: -1, inUse: false };
  }
  getObjectForId(e) {
    return this._objects[e];
  }
  useObject(e) {
    e.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((r3) => e.id !== r3), this._recentlyUsed.push(e.id);
  }
  stampObject(e) {
    e.stamp = ++this._stamp;
  }
  getOrCreateFreeObject() {
    for (let r3 of this._recentlyUsed) if (!this._objects[r3].inUse) return this._objects[r3];
    if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
    let e = this._createObject(this._objects.length);
    return this._objects.push(e), e;
  }
  freeObject(e) {
    e.inUse = false;
  }
  freeAllObjects() {
    for (let e of this._objects) this.freeObject(e);
  }
  isFull() {
    return this._objects.length < this._size ? false : this._objects.some((e) => !e.inUse) === false;
  }
};
var Fa = { background: true, fill: true, line: true, raster: true, hillshade: true, "color-relief": true };
var qf = class {
  constructor(e, r3) {
    this.painter = e, this.terrain = r3, this.pool = new Zf(e.context, 30, r3.sourceCache.tileSize * r3.qualityFactor);
  }
  destruct() {
    this.pool.destruct();
  }
  getTexture(e) {
    return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
  }
  prepareForRender(e, r3) {
    this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter((n) => !e._layers[n].isHidden(r3)), this._coordsAscending = {};
    for (let n in e.sourceCaches) {
      this._coordsAscending[n] = {};
      let i = e.sourceCaches[n].getVisibleCoordinates(), o = e.sourceCaches[n].getSource(), a = o instanceof _r ? o.terrainTileRanges : null;
      for (let s3 of i) {
        let l = this.terrain.sourceCache.getTerrainCoords(s3, a);
        for (let u3 in l) this._coordsAscending[n][u3] || (this._coordsAscending[n][u3] = []), this._coordsAscending[n][u3].push(l[u3]);
      }
    }
    this._coordsAscendingStr = {};
    for (let n of e._order) {
      let i = e._layers[n], o = i.source;
      if (Fa[i.type] && !this._coordsAscendingStr[o]) {
        this._coordsAscendingStr[o] = {};
        for (let a in this._coordsAscending[o]) this._coordsAscendingStr[o][a] = this._coordsAscending[o][a].map((s3) => s3.key).sort().join();
      }
    }
    for (let n of this._renderableTiles) for (let i in this._coordsAscendingStr) {
      let o = this._coordsAscendingStr[i][n.tileID.key];
      o && o !== n.rttCoords[i] && (n.rtt = []);
    }
  }
  renderLayer(e, r3) {
    if (e.isHidden(this.painter.transform.zoom)) return false;
    let n = { ...r3, isRenderingToTexture: true }, i = e.type, o = this.painter, a = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
    if (Fa[i] && ((!this._prevType || !Fa[this._prevType]) && this._stacks.push([]), this._prevType = i, this._stacks[this._stacks.length - 1].push(e.id), !a)) return true;
    if (Fa[this._prevType] || Fa[i] && a) {
      this._prevType = i;
      let s3 = this._stacks.length - 1, l = this._stacks[s3] || [];
      for (let u3 of this._renderableTiles) {
        if (this.pool.isFull() && (yg(this.painter, this.terrain, this._rttTiles, n), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(u3), u3.rtt[s3]) {
          let p = this.pool.getObjectForId(u3.rtt[s3].id);
          if (p.stamp === u3.rtt[s3].stamp) {
            this.pool.useObject(p);
            continue;
          }
        }
        let c = this.pool.getOrCreateFreeObject();
        this.pool.useObject(c), this.pool.stampObject(c), u3.rtt[s3] = { id: c.id, stamp: c.stamp }, o.context.bindFramebuffer.set(c.fbo.framebuffer), o.context.clear({ color: K.transparent, stencil: 0 }), o.currentStencilSource = void 0;
        for (let p = 0; p < l.length; p++) {
          let h = o.style._layers[l[p]], f = h.source ? this._coordsAscending[h.source][u3.tileID.key] : [u3.tileID];
          o.context.viewport.set([0, 0, c.fbo.width, c.fbo.height]), o._renderTileClippingMasks(h, f, true), o.renderLayer(o, o.style.sourceCaches[h.source], h, f, n), h.source && (u3.rttCoords[h.source] = this._coordsAscendingStr[h.source][u3.tileID.key]);
        }
      }
      return yg(this.painter, this.terrain, this._rttTiles, n), this._rttTiles = [], this.pool.freeAllObjects(), Fa[i];
    }
    return false;
  }
};
$i();
var BS = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" };
var NB = Yu.version;
var Wf = -2;
var VS = 22;
var Si = 0;
var US = 60;
var Yf = 180;
var zS = { hash: false, interactive: true, bearingSnap: 7, attributionControl: Tg, maplibreLogo: false, refreshExpiredTiles: true, canvasContextAttributes: { antialias: false, preserveDrawingBuffer: false, powerPreference: "high-performance", failIfMajorPerformanceCaveat: false, desynchronized: false, contextType: void 0 }, scrollZoom: true, minZoom: Wf, maxZoom: VS, minPitch: Si, maxPitch: US, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, trackResize: true, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: true, maxTileCacheSize: null, maxTileCacheZoomLevels: $t.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: true, rollEnabled: false, validateStyle: true, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: true, centerClampedToGround: true };
var Ig = class extends Uf {
  constructor(r3) {
    ka.mark("create");
    let n = { ...zS, ...r3, canvasContextAttributes: { ...zS.canvasContextAttributes, ...r3.canvasContextAttributes } };
    if (n.minZoom != null && n.maxZoom != null && n.minZoom > n.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
    if (n.minPitch != null && n.maxPitch != null && n.minPitch > n.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
    if (n.minPitch != null && n.minPitch < Si) throw new Error(`minPitch must be greater than or equal to ${Si}`);
    if (n.maxPitch != null && n.maxPitch > Yf) throw new Error(`maxPitch must be less than or equal to ${Yf}`);
    let i = new Fn(), o = new On2();
    n.minZoom !== void 0 && i.setMinZoom(n.minZoom), n.maxZoom !== void 0 && i.setMaxZoom(n.maxZoom), n.minPitch !== void 0 && i.setMinPitch(n.minPitch), n.maxPitch !== void 0 && i.setMaxPitch(n.maxPitch), n.renderWorldCopies !== void 0 && i.setRenderWorldCopies(n.renderWorldCopies);
    super(i, o, { bearingSnap: n.bearingSnap });
    this._idleTriggered = false;
    this._crossFadingFactor = 1;
    this._renderTaskQueue = new Nf();
    this._controls = [];
    this._mapId = oc();
    this._contextLost = (r4) => {
      r4.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new U("webglcontextlost", { originalEvent: r4 }));
    };
    this._contextRestored = (r4) => {
      this._setupPainter(), this.resize(), this._update(), this.fire(new U("webglcontextrestored", { originalEvent: r4 }));
    };
    this._onMapScroll = (r4) => {
      if (r4.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
    };
    this._onWindowOnline = () => {
      this._update();
    };
    if (this._interactive = n.interactive, this._maxTileCacheSize = n.maxTileCacheSize, this._maxTileCacheZoomLevels = n.maxTileCacheZoomLevels, this._canvasContextAttributes = { ...n.canvasContextAttributes }, this._trackResize = n.trackResize === true, this._bearingSnap = n.bearingSnap, this._centerClampedToGround = n.centerClampedToGround, this._refreshExpiredTiles = n.refreshExpiredTiles === true, this._fadeDuration = n.fadeDuration, this._crossSourceCollisions = n.crossSourceCollisions === true, this._collectResourceTiming = n.collectResourceTiming === true, this._locale = { ...BS, ...n.locale }, this._clickTolerance = n.clickTolerance, this._overridePixelRatio = n.pixelRatio, this._maxCanvasSize = n.maxCanvasSize, this.transformCameraUpdate = n.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = n.cancelPendingTileRequestsWhileZooming === true, this._imageQueueHandle = Gt.addThrottleControl(() => this.isMoving()), this._requestManager = new hc(n.transformRequest), typeof n.container == "string") {
      if (this._container = document.getElementById(n.container), !this._container) throw new Error(`Container '${n.container}' not found.`);
    } else if (n.container instanceof HTMLElement) this._container = n.container;
    else throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
    if (n.maxBounds && this.setMaxBounds(n.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
      this.painter.terrainFacilitator.dirty = true, this._update(true);
    }), this.once("idle", () => {
      this._idleTriggered = true;
    }), typeof window < "u") {
      addEventListener("online", this._onWindowOnline, false);
      let l = false, u3 = Cf((c) => {
        this._trackResize && !this._removed && (this.resize(c), this.redraw());
      }, 50);
      this._resizeObserver = new ResizeObserver((c) => {
        if (!l) {
          l = true;
          return;
        }
        u3(c);
      }), this._resizeObserver.observe(this._container);
    }
    this.handlers = new Vf(this, n);
    let a = typeof n.hash == "string" && n.hash || void 0;
    this._hash = n.hash && new ru(a).addTo(this), (!this._hash || !this._hash._onHashChange()) && (this.jumpTo({ center: n.center, elevation: n.elevation, zoom: n.zoom, bearing: n.bearing, pitch: n.pitch, roll: n.roll }), n.bounds && (this.resize(), this.fitBounds(n.bounds, Z({}, n.fitBoundsOptions, { duration: 0 }))));
    let s3 = typeof n.style == "string" || n.style?.projection?.type !== "globe";
    this.resize(null, s3), this._localIdeographFontFamily = n.localIdeographFontFamily, this._validateStyle = n.validateStyle, n.style && this.setStyle(n.style, { localIdeographFontFamily: n.localIdeographFontFamily }), n.attributionControl && this.addControl(new _u(typeof n.attributionControl == "boolean" ? void 0 : n.attributionControl)), n.maplibreLogo && this.addControl(new vu(), n.logoPosition), this.on("style.load", () => {
      if (s3 || this._resizeTransform(), this.transform.unmodified) {
        let l = nn(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
        this.jumpTo(l);
      }
    }), this.on("data", (l) => {
      this._update(l.dataType === "style"), this.fire(new U(`${l.dataType}data`, l));
    }), this.on("dataloading", (l) => {
      this.fire(new U(`${l.dataType}dataloading`, l));
    }), this.on("dataabort", (l) => {
      this.fire(new U("sourcedataabort", l));
    });
  }
  _getMapId() {
    return this._mapId;
  }
  setGlobalStateProperty(r3, n) {
    return this.style.setGlobalStateProperty(r3, n), this._update(true);
  }
  getGlobalState() {
    return this.style.getGlobalState();
  }
  addControl(r3, n) {
    if (n === void 0 && (r3.getDefaultPosition ? n = r3.getDefaultPosition() : n = "top-right"), !r3 || !r3.onAdd) return this.fire(new Q(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
    let i = r3.onAdd(this);
    this._controls.push(r3);
    let o = this._controlPositions[n];
    return n.indexOf("bottom") !== -1 ? o.insertBefore(i, o.firstChild) : o.appendChild(i), this;
  }
  removeControl(r3) {
    if (!r3 || !r3.onRemove) return this.fire(new Q(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
    let n = this._controls.indexOf(r3);
    return n > -1 && this._controls.splice(n, 1), r3.onRemove(this), this;
  }
  hasControl(r3) {
    return this._controls.indexOf(r3) > -1;
  }
  calculateCameraOptionsFromTo(r3, n, i, o) {
    return o == null && this.terrain && (o = this.terrain.getElevationForLngLatZoom(i, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(r3, n, i, o);
  }
  resize(r3, n = true) {
    let [i, o] = this._containerDimensions(), a = this._getClampedPixelRatio(i, o);
    if (this._resizeCanvas(i, o, a), this.painter.resize(i, o, a), this.painter.overLimit()) {
      let l = this.painter.context.gl;
      this._maxCanvasSize = [l.drawingBufferWidth, l.drawingBufferHeight];
      let u3 = this._getClampedPixelRatio(i, o);
      this._resizeCanvas(i, o, u3), this.painter.resize(i, o, u3);
    }
    this._resizeTransform(n);
    let s3 = !this._moving;
    return s3 && (this.stop(), this.fire(new U("movestart", r3)).fire(new U("move", r3))), this.fire(new U("resize", r3)), s3 && this.fire(new U("moveend", r3)), this;
  }
  _resizeTransform(r3 = true) {
    let [n, i] = this._containerDimensions();
    this.transform.resize(n, i, r3), this._requestedCameraState?.resize(n, i, r3);
  }
  _getClampedPixelRatio(r3, n) {
    let { 0: i, 1: o } = this._maxCanvasSize, a = this.getPixelRatio(), s3 = r3 * a, l = n * a, u3 = s3 > i ? i / s3 : 1, c = l > o ? o / l : 1;
    return Math.min(u3, c) * a;
  }
  getPixelRatio() {
    return this._overridePixelRatio ?? devicePixelRatio;
  }
  setPixelRatio(r3) {
    this._overridePixelRatio = r3, this.resize();
  }
  getBounds() {
    return this.transform.getBounds();
  }
  getMaxBounds() {
    return this.transform.getMaxBounds();
  }
  setMaxBounds(r3) {
    return this.transform.setMaxBounds(mt.convert(r3)), this._update();
  }
  setMinZoom(r3) {
    if (r3 = r3 ?? Wf, r3 >= Wf && r3 <= this.transform.maxZoom) return this.transform.setMinZoom(r3), this._update(), this.getZoom() < r3 && this.setZoom(r3), this;
    throw new Error(`minZoom must be between ${Wf} and the current maxZoom, inclusive`);
  }
  getMinZoom() {
    return this.transform.minZoom;
  }
  setMaxZoom(r3) {
    if (r3 = r3 ?? VS, r3 >= this.transform.minZoom) return this.transform.setMaxZoom(r3), this._update(), this.getZoom() > r3 && this.setZoom(r3), this;
    throw new Error("maxZoom must be greater than the current minZoom");
  }
  getMaxZoom() {
    return this.transform.maxZoom;
  }
  setMinPitch(r3) {
    if (r3 = r3 ?? Si, r3 < Si) throw new Error(`minPitch must be greater than or equal to ${Si}`);
    if (r3 >= Si && r3 <= this.transform.maxPitch) return this.transform.setMinPitch(r3), this._update(), this.getPitch() < r3 && this.setPitch(r3), this;
    throw new Error(`minPitch must be between ${Si} and the current maxPitch, inclusive`);
  }
  getMinPitch() {
    return this.transform.minPitch;
  }
  setMaxPitch(r3) {
    if (r3 = r3 ?? US, r3 > Yf) throw new Error(`maxPitch must be less than or equal to ${Yf}`);
    if (r3 >= this.transform.minPitch) return this.transform.setMaxPitch(r3), this._update(), this.getPitch() > r3 && this.setPitch(r3), this;
    throw new Error("maxPitch must be greater than the current minPitch");
  }
  getMaxPitch() {
    return this.transform.maxPitch;
  }
  getRenderWorldCopies() {
    return this.transform.renderWorldCopies;
  }
  setRenderWorldCopies(r3) {
    return this.transform.setRenderWorldCopies(r3), this._update();
  }
  project(r3) {
    return this.transform.locationToScreenPoint(J.convert(r3), this.style && this.terrain);
  }
  unproject(r3) {
    return this.transform.screenPointToLocation(Bn.default.convert(r3), this.terrain);
  }
  isMoving() {
    return this._moving || this.handlers?.isMoving();
  }
  isZooming() {
    return this._zooming || this.handlers?.isZooming();
  }
  isRotating() {
    return this._rotating || this.handlers?.isRotating();
  }
  _createDelegatedListener(r3, n, i) {
    if (r3 === "mouseenter" || r3 === "mouseover") {
      let o = false;
      return { layers: n, listener: i, delegates: { mousemove: (l) => {
        let u3 = n.filter((p) => this.getLayer(p)), c = u3.length !== 0 ? this.queryRenderedFeatures(l.point, { layers: u3 }) : [];
        c.length ? o || (o = true, i.call(this, new Lt(r3, this, l.originalEvent, { features: c }))) : o = false;
      }, mouseout: () => {
        o = false;
      } } };
    } else if (r3 === "mouseleave" || r3 === "mouseout") {
      let o = false;
      return { layers: n, listener: i, delegates: { mousemove: (l) => {
        let u3 = n.filter((p) => this.getLayer(p));
        (u3.length !== 0 ? this.queryRenderedFeatures(l.point, { layers: u3 }) : []).length ? o = true : o && (o = false, i.call(this, new Lt(r3, this, l.originalEvent)));
      }, mouseout: (l) => {
        o && (o = false, i.call(this, new Lt(r3, this, l.originalEvent)));
      } } };
    } else {
      let o = (a) => {
        let s3 = n.filter((u3) => this.getLayer(u3)), l = s3.length !== 0 ? this.queryRenderedFeatures(a.point, { layers: s3 }) : [];
        l.length && (a.features = l, i.call(this, a), delete a.features);
      };
      return { layers: n, listener: i, delegates: { [r3]: o } };
    }
  }
  _saveDelegatedListener(r3, n) {
    this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[r3] = this._delegatedListeners[r3] || [], this._delegatedListeners[r3].push(n);
  }
  _removeDelegatedListener(r3, n, i) {
    if (!this._delegatedListeners || !this._delegatedListeners[r3]) return;
    let o = this._delegatedListeners[r3];
    for (let a = 0; a < o.length; a++) {
      let s3 = o[a];
      if (s3.listener === i && s3.layers.length === n.length && s3.layers.every((l) => n.includes(l))) {
        for (let l in s3.delegates) this.off(l, s3.delegates[l]);
        o.splice(a, 1);
        return;
      }
    }
  }
  on(r3, n, i) {
    if (i === void 0) return super.on(r3, n);
    let o = typeof n == "string" ? [n] : n, a = this._createDelegatedListener(r3, o, i);
    this._saveDelegatedListener(r3, a);
    for (let s3 in a.delegates) this.on(s3, a.delegates[s3]);
    return { unsubscribe: () => {
      this._removeDelegatedListener(r3, o, i);
    } };
  }
  once(r3, n, i) {
    if (i === void 0) return super.once(r3, n);
    let o = typeof n == "string" ? [n] : n, a = this._createDelegatedListener(r3, o, i);
    for (let s3 in a.delegates) {
      let l = a.delegates[s3];
      a.delegates[s3] = (...u3) => {
        this._removeDelegatedListener(r3, o, i), l(...u3);
      };
    }
    this._saveDelegatedListener(r3, a);
    for (let s3 in a.delegates) this.once(s3, a.delegates[s3]);
    return this;
  }
  off(r3, n, i) {
    if (i === void 0) return super.off(r3, n);
    let o = typeof n == "string" ? [n] : n;
    return this._removeDelegatedListener(r3, o, i), this;
  }
  queryRenderedFeatures(r3, n) {
    if (!this.style) return [];
    let i, o = r3 instanceof Bn.default || Array.isArray(r3), a = o ? r3 : [[0, 0], [this.transform.width, this.transform.height]];
    if (n = n || (o ? {} : r3) || {}, a instanceof Bn.default || typeof a[0] == "number") i = [Bn.default.convert(a)];
    else {
      let s3 = Bn.default.convert(a[0]), l = Bn.default.convert(a[1]);
      i = [s3, new Bn.default(l.x, s3.y), l, new Bn.default(s3.x, l.y), s3];
    }
    return this.style.queryRenderedFeatures(i, n, this.transform);
  }
  querySourceFeatures(r3, n) {
    return this.style.querySourceFeatures(r3, n);
  }
  setStyle(r3, n) {
    return n = Z({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, n), n.diff !== false && n.localIdeographFontFamily === this._localIdeographFontFamily && this.style && r3 ? (this._diffStyle(r3, n), this) : (this._localIdeographFontFamily = n.localIdeographFontFamily, this._updateStyle(r3, n));
  }
  setTransformRequest(r3) {
    return this._requestManager.setTransformRequest(r3), this;
  }
  _getUIString(r3) {
    let n = this._locale[r3];
    if (n == null) throw new Error(`Missing UI string '${r3}'`);
    return n;
  }
  _updateStyle(r3, n) {
    if (n.transformStyle && this.style && !this.style._loaded) {
      this.style.once("style.load", () => this._updateStyle(r3, n));
      return;
    }
    let i = this.style && n.transformStyle ? this.style.serialize() : void 0;
    if (this.style && (this.style.setEventedParent(null), this.style._remove(!r3)), r3) this.style = new Da(this, n || {});
    else return this.style?.projection?.destroy(), delete this.style, this;
    return this.style.setEventedParent(this, { style: this.style }), typeof r3 == "string" ? this.style.loadURL(r3, n, i) : this.style.loadJSON(r3, n, i), this;
  }
  _lazyInitEmptyStyle() {
    this.style || (this.style = new Da(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
  }
  _diffStyle(r3, n) {
    if (typeof r3 == "string") {
      let i = r3, o = this._requestManager.transformRequest(i, "Style");
      Kn(o, new AbortController()).then((a) => {
        this._updateDiff(a.data, n);
      }).catch((a) => {
        a && this.fire(new Q(a));
      });
    } else typeof r3 == "object" && this._updateDiff(r3, n);
  }
  _updateDiff(r3, n) {
    try {
      this.style.setState(r3, n) && this._update(true);
    } catch (i) {
      ve2(`Unable to perform style diff: ${i.message || i.error || i}.  Rebuilding the style from scratch.`), this._updateStyle(r3, n);
    }
  }
  getStyle() {
    if (this.style) return this.style.serialize();
  }
  isStyleLoaded() {
    return this.style ? this.style.loaded() : ve2("There is no style added to the map.");
  }
  addSource(r3, n) {
    return this._lazyInitEmptyStyle(), this.style.addSource(r3, n), this._update(true);
  }
  isSourceLoaded(r3) {
    let n = this.style && this.style.sourceCaches[r3];
    if (n === void 0) {
      this.fire(new Q(new Error(`There is no source with ID '${r3}'`)));
      return;
    }
    return n.loaded();
  }
  setTerrain(r3) {
    if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), !r3) this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
    else {
      let n = this.style.sourceCaches[r3.source];
      if (!n) throw new Error(`cannot load terrain, because there exists no source with ID: ${r3.source}`);
      this.terrain === null && n.reload();
      for (let i in this.style._layers) {
        let o = this.style._layers[i];
        o.type === "hillshade" && o.source === r3.source && ve2("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), o.type === "color-relief" && o.source === r3.source && ve2("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
      }
      this.terrain = new Xf(this.painter, n, r3), this.painter.renderToTexture = new qf(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (i) => {
        i.dataType === "style" ? this.terrain.sourceCache.freeRtt() : i.dataType === "source" && i.tile && (i.sourceId === r3.source && !this._elevationFreeze && (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), i.source?.type === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(i.tile.tileID));
      }, this.style.on("data", this._terrainDataCallback);
    }
    return this.fire(new U("terrain", { terrain: r3 })), this;
  }
  getTerrain() {
    return this.terrain?.options ?? null;
  }
  areTilesLoaded() {
    let r3 = this.style && this.style.sourceCaches;
    for (let n in r3) {
      let o = r3[n]._tiles;
      for (let a in o) {
        let s3 = o[a];
        if (!(s3.state === "loaded" || s3.state === "errored")) return false;
      }
    }
    return true;
  }
  removeSource(r3) {
    return this.style.removeSource(r3), this._update(true);
  }
  getSource(r3) {
    return this.style.getSource(r3);
  }
  setSourceTileLodParams(r3, n, i) {
    if (i) {
      let o = this.getSource(i);
      if (!o) throw new Error(`There is no source with ID "${i}", cannot set LOD parameters`);
      o.calculateTileZoom = sh(Math.max(1, r3), Math.max(1, n));
    } else for (let o in this.style.sourceCaches) this.style.sourceCaches[o].getSource().calculateTileZoom = sh(Math.max(1, r3), Math.max(1, n));
    return this._update(true), this;
  }
  refreshTiles(r3, n) {
    let i = this.style.sourceCaches[r3];
    if (!i) throw new Error(`There is no source cache with ID "${r3}", cannot refresh tile`);
    n === void 0 ? i.reload(true) : i.refreshTiles(n.map((o) => new di(o.z, o.x, o.y)));
  }
  addImage(r3, n, i = {}) {
    let { pixelRatio: o = 1, sdf: a = false, stretchX: s3, stretchY: l, content: u3, textFitWidth: c, textFitHeight: p } = i;
    this._lazyInitEmptyStyle();
    let h = 0;
    if (n instanceof HTMLImageElement || Wt(n)) {
      let { width: f, height: d, data: g } = ae.getImageData(n);
      this.style.addImage(r3, { data: new Le2({ width: f, height: d }, g), pixelRatio: o, stretchX: s3, stretchY: l, content: u3, textFitWidth: c, textFitHeight: p, sdf: a, version: h });
    } else {
      if (n.width === void 0 || n.height === void 0) return this.fire(new Q(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
      {
        let { width: f, height: d, data: g } = n, x = n;
        return this.style.addImage(r3, { data: new Le2({ width: f, height: d }, new Uint8Array(g)), pixelRatio: o, stretchX: s3, stretchY: l, content: u3, textFitWidth: c, textFitHeight: p, sdf: a, version: h, userImage: x }), x.onAdd && x.onAdd(this, r3), this;
      }
    }
  }
  updateImage(r3, n) {
    let i = this.style.getImage(r3);
    if (!i) return this.fire(new Q(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
    let o = n instanceof HTMLImageElement || Wt(n) ? ae.getImageData(n) : n, { width: a, height: s3, data: l } = o;
    if (a === void 0 || s3 === void 0) return this.fire(new Q(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
    if (a !== i.data.width || s3 !== i.data.height) return this.fire(new Q(new Error("The width and height of the updated image must be that same as the previous version of the image")));
    let u3 = !(n instanceof HTMLImageElement || Wt(n));
    return i.data.replace(l, u3), this.style.updateImage(r3, i), this;
  }
  getImage(r3) {
    return this.style.getImage(r3);
  }
  hasImage(r3) {
    return r3 ? !!this.style.getImage(r3) : (this.fire(new Q(new Error("Missing required image id"))), false);
  }
  removeImage(r3) {
    this.style.removeImage(r3);
  }
  loadImage(r3) {
    return Gt.getImage(this._requestManager.transformRequest(r3, "Image"), new AbortController());
  }
  listImages() {
    return this.style.listImages();
  }
  addLayer(r3, n) {
    return this._lazyInitEmptyStyle(), this.style.addLayer(r3, n), this._update(true);
  }
  moveLayer(r3, n) {
    return this.style.moveLayer(r3, n), this._update(true);
  }
  removeLayer(r3) {
    return this.style.removeLayer(r3), this._update(true);
  }
  getLayer(r3) {
    return this.style.getLayer(r3);
  }
  getLayersOrder() {
    return this.style.getLayersOrder();
  }
  setLayerZoomRange(r3, n, i) {
    return this.style.setLayerZoomRange(r3, n, i), this._update(true);
  }
  setFilter(r3, n, i = {}) {
    return this.style.setFilter(r3, n, i), this._update(true);
  }
  getFilter(r3) {
    return this.style.getFilter(r3);
  }
  setPaintProperty(r3, n, i, o = {}) {
    return this.style.setPaintProperty(r3, n, i, o), this._update(true);
  }
  getPaintProperty(r3, n) {
    return this.style.getPaintProperty(r3, n);
  }
  setLayoutProperty(r3, n, i, o = {}) {
    return this.style.setLayoutProperty(r3, n, i, o), this._update(true);
  }
  getLayoutProperty(r3, n) {
    return this.style.getLayoutProperty(r3, n);
  }
  setGlyphs(r3, n = {}) {
    return this._lazyInitEmptyStyle(), this.style.setGlyphs(r3, n), this._update(true);
  }
  getGlyphs() {
    return this.style.getGlyphsUrl();
  }
  addSprite(r3, n, i = {}) {
    return this._lazyInitEmptyStyle(), this.style.addSprite(r3, n, i, (o) => {
      o || this._update(true);
    }), this;
  }
  removeSprite(r3) {
    return this._lazyInitEmptyStyle(), this.style.removeSprite(r3), this._update(true);
  }
  getSprite() {
    return this.style.getSprite();
  }
  setSprite(r3, n = {}) {
    return this._lazyInitEmptyStyle(), this.style.setSprite(r3, n, (i) => {
      i || this._update(true);
    }), this;
  }
  setLight(r3, n = {}) {
    return this._lazyInitEmptyStyle(), this.style.setLight(r3, n), this._update(true);
  }
  getLight() {
    return this.style.getLight();
  }
  setSky(r3, n = {}) {
    return this._lazyInitEmptyStyle(), this.style.setSky(r3, n), this._update(true);
  }
  getSky() {
    return this.style.getSky();
  }
  setFeatureState(r3, n) {
    return this.style.setFeatureState(r3, n), this._update();
  }
  removeFeatureState(r3, n) {
    return this.style.removeFeatureState(r3, n), this._update();
  }
  getFeatureState(r3) {
    return this.style.getFeatureState(r3);
  }
  getContainer() {
    return this._container;
  }
  getCanvasContainer() {
    return this._canvasContainer;
  }
  getCanvas() {
    return this._canvas;
  }
  _containerDimensions() {
    let r3 = 0, n = 0;
    return this._container && (r3 = this._container.clientWidth || 400, n = this._container.clientHeight || 300), [r3, n];
  }
  _setupContainer() {
    let r3 = this._container;
    r3.classList.add("maplibregl-map");
    let n = this._canvasContainer = ie.create("div", "maplibregl-canvas-container", r3);
    this._interactive && n.classList.add("maplibregl-interactive"), this._canvas = ie.create("canvas", "maplibregl-canvas", n), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
    let i = this._containerDimensions(), o = this._getClampedPixelRatio(i[0], i[1]);
    this._resizeCanvas(i[0], i[1], o);
    let a = this._controlContainer = ie.create("div", "maplibregl-control-container", r3), s3 = this._controlPositions = {};
    ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((l) => {
      s3[l] = ie.create("div", `maplibregl-ctrl-${l} `, a);
    }), this._container.addEventListener("scroll", this._onMapScroll, false);
  }
  _resizeCanvas(r3, n, i) {
    this._canvas.width = Math.floor(i * r3), this._canvas.height = Math.floor(i * n), this._canvas.style.width = `${r3}px`, this._canvas.style.height = `${n}px`;
  }
  _setupPainter() {
    let r3 = { ...this._canvasContextAttributes, alpha: true, depth: true, stencil: true, premultipliedAlpha: true }, n = null;
    this._canvas.addEventListener("webglcontextcreationerror", (o) => {
      n = { requestedAttributes: r3 }, o && (n.statusMessage = o.statusMessage, n.type = o.type);
    }, { once: true });
    let i = null;
    if (this._canvasContextAttributes.contextType ? i = this._canvas.getContext(this._canvasContextAttributes.contextType, r3) : i = this._canvas.getContext("webgl2", r3) || this._canvas.getContext("webgl", r3), !i) {
      let o = "Failed to initialize WebGL";
      throw n ? (n.message = o, new Error(JSON.stringify(n))) : new Error(o);
    }
    this.painter = new Sf(i, this.transform), cs.testSupport(i);
  }
  migrateProjection(r3, n) {
    super.migrateProjection(r3, n), this.painter.transform = r3, this.fire(new U("projectiontransition", { newProjection: this.style.projection.name }));
  }
  loaded() {
    return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
  }
  _update(r3) {
    return !this.style || !this.style._loaded ? this : (this._styleDirty = this._styleDirty || r3, this._sourcesDirty = true, this.triggerRepaint(), this);
  }
  _requestRenderFrame(r3) {
    return this._update(), this._renderTaskQueue.add(r3);
  }
  _cancelRenderFrame(r3) {
    this._renderTaskQueue.remove(r3);
  }
  _render(r3) {
    let n = this._idleTriggered ? this._fadeDuration : 0, i = this.style.projection?.transitionState > 0;
    if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(r3), this._removed) return;
    let o = false;
    if (this.style && this._styleDirty) {
      this._styleDirty = false;
      let l = this.transform.zoom, u3 = ae.now();
      this.style.zoomHistory.update(l, u3);
      let c = new Te(l, { now: u3, fadeDuration: n, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition(), globalState: this.style.getGlobalState() }), p = c.crossFadingFactor();
      (p !== 1 || p !== this._crossFadingFactor) && (o = true, this._crossFadingFactor = p), this.style.update(c);
    }
    let a = this.style.projection?.transitionState > 0 !== i;
    this.style.projection?.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState(this.style.projection?.transitionState, this.style.projection?.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || a) && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, n, this._crossSourceCollisions, a), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: n, showPadding: this.showPadding }), this.fire(new U("render")), this.loaded() && !this._loaded && (this._loaded = true, ka.mark("load"), this.fire(new U("load"))), this.style && (this.style.hasTransitions() || o) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
    let s3 = this._sourcesDirty || this._styleDirty || this._placementDirty;
    return s3 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new U("idle")), this._loaded && !this._fullyLoaded && !s3 && (this._fullyLoaded = true, ka.mark("fullLoad")), this;
  }
  redraw() {
    return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
  }
  remove() {
    this._hash && this._hash.remove();
    for (let n of this._controls) n.onRemove(this);
    this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, false), Gt.removeThrottleControl(this._imageQueueHandle), this._resizeObserver?.disconnect();
    let r3 = this.painter.context.gl.getExtension("WEBGL_lose_context");
    r3?.loseContext && r3.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), ie.remove(this._canvasContainer), ie.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, false), this._container.classList.remove("maplibregl-map"), ka.clearMetrics(), this._removed = true, this.fire(new U("remove"));
  }
  triggerRepaint() {
    this.style && !this._frameRequest && (this._frameRequest = new AbortController(), ae.frame(this._frameRequest, (r3) => {
      ka.frame(r3), this._frameRequest = null;
      try {
        this._render(r3);
      } catch (n) {
        if (!Jb(n) && !WT(n)) throw n;
      }
    }, () => {
    }));
  }
  get showTileBoundaries() {
    return !!this._showTileBoundaries;
  }
  set showTileBoundaries(r3) {
    this._showTileBoundaries !== r3 && (this._showTileBoundaries = r3, this._update());
  }
  get showPadding() {
    return !!this._showPadding;
  }
  set showPadding(r3) {
    this._showPadding !== r3 && (this._showPadding = r3, this._update());
  }
  get showCollisionBoxes() {
    return !!this._showCollisionBoxes;
  }
  set showCollisionBoxes(r3) {
    this._showCollisionBoxes !== r3 && (this._showCollisionBoxes = r3, r3 ? this.style._generateCollisionBoxes() : this._update());
  }
  get showOverdrawInspector() {
    return !!this._showOverdrawInspector;
  }
  set showOverdrawInspector(r3) {
    this._showOverdrawInspector !== r3 && (this._showOverdrawInspector = r3, this._update());
  }
  get repaint() {
    return !!this._repaint;
  }
  set repaint(r3) {
    this._repaint !== r3 && (this._repaint = r3, this.triggerRepaint());
  }
  get vertices() {
    return !!this._vertices;
  }
  set vertices(r3) {
    this._vertices = r3, this._update();
  }
  get version() {
    return NB;
  }
  getCameraTargetElevation() {
    return this.transform.elevation;
  }
  getProjection() {
    return this.style.getProjection();
  }
  setProjection(r3) {
    return this._lazyInitEmptyStyle(), this.style.setProjection(r3), this._update(true);
  }
};
$i();
var GB = s(fe(), 1);
$i();
$i();
$i();
var ZB = s(fe(), 1);
$i();
$i();
$i();
$i();
$i();
$i();
$i();
var YB = s(fe(), 1);
var Yxe = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
var WB = s(fe(), 1);
var t_e = Yu.version;
function r_e(t63) {
  $t.WORKER_URL = t63;
}
$i();
$i();
$i();
$i();
$i();
$i();
$i();
var Ht = 63710088e-1;
var GS = { centimeters: Ht * 100, centimetres: Ht * 100, degrees: Ht / 111325, feet: Ht * 3.28084, inches: Ht * 39.37, kilometers: Ht / 1e3, kilometres: Ht / 1e3, meters: Ht, metres: Ht, miles: Ht / 1609.344, millimeters: Ht * 1e3, millimetres: Ht * 1e3, nauticalmiles: Ht / 1852, radians: 1, yards: Ht * 1.0936 };
var o_e = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: 1 / 1e3, kilometres: 1 / 1e3, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / Ht, yards: 1.0936133 };
function Ci(t63, e, r3) {
  r3 === void 0 && (r3 = {});
  var n = { type: "Feature" };
  return (r3.id === 0 || r3.id) && (n.id = r3.id), r3.bbox && (n.bbox = r3.bbox), n.properties = e || {}, n.geometry = t63, n;
}
function $B(t63, e, r3) {
  if (r3 === void 0 && (r3 = {}), !t63) throw new Error("coordinates is required");
  if (!Array.isArray(t63)) throw new Error("coordinates must be an Array");
  if (t63.length < 2) throw new Error("coordinates must be at least 2 numbers long");
  if (!NS(t63[0]) || !NS(t63[1])) throw new Error("coordinates must contain numbers");
  var n = { type: "Point", coordinates: t63 };
  return Ci(n, e, r3);
}
function a_e(t63, e, r3) {
  r3 === void 0 && (r3 = {});
  for (var n = 0, i = t63; n < i.length; n++) {
    var o = i[n];
    if (o.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
    for (var a = 0; a < o[o.length - 1].length; a++) if (o[o.length - 1][a] !== o[0][a]) throw new Error("First and last Position are not equivalent.");
  }
  var s3 = { type: "Polygon", coordinates: t63 };
  return Ci(s3, e, r3);
}
function jS(t63, e, r3) {
  if (r3 === void 0 && (r3 = {}), t63.length < 2) throw new Error("coordinates must be an array of two or more positions");
  var n = { type: "LineString", coordinates: t63 };
  return Ci(n, e, r3);
}
function s_e(t63, e) {
  e === void 0 && (e = {});
  var r3 = { type: "FeatureCollection" };
  return e.id && (r3.id = e.id), e.bbox && (r3.bbox = e.bbox), r3.features = t63, r3;
}
function l_e(t63, e, r3) {
  r3 === void 0 && (r3 = {});
  var n = { type: "MultiLineString", coordinates: t63 };
  return Ci(n, e, r3);
}
function u_e(t63, e, r3) {
  r3 === void 0 && (r3 = {});
  var n = { type: "MultiPolygon", coordinates: t63 };
  return Ci(n, e, r3);
}
function c_e(t63, e) {
  e === void 0 && (e = "kilometers");
  var r3 = GS[e];
  if (!r3) throw new Error(e + " units is invalid");
  return t63 * r3;
}
function p_e(t63, e) {
  e === void 0 && (e = "kilometers");
  var r3 = GS[e];
  if (!r3) throw new Error(e + " units is invalid");
  return t63 / r3;
}
function h_e(t63) {
  var e = t63 % (2 * Math.PI);
  return e * 180 / Math.PI;
}
function f_e(t63) {
  var e = t63 % 360;
  return e * Math.PI / 180;
}
function NS(t63) {
  return !isNaN(t63) && t63 !== null && !Array.isArray(t63);
}
function $f(t63, e, r3) {
  if (t63 !== null) for (var n, i, o, a, s3, l, u3, c = 0, p = 0, h, f = t63.type, d = f === "FeatureCollection", g = f === "Feature", x = d ? t63.features.length : 1, b = 0; b < x; b++) {
    u3 = d ? t63.features[b].geometry : g ? t63.geometry : t63, h = u3 ? u3.type === "GeometryCollection" : false, s3 = h ? u3.geometries.length : 1;
    for (var v3 = 0; v3 < s3; v3++) {
      var P = 0, w3 = 0;
      if (a = h ? u3.geometries[v3] : u3, a !== null) {
        l = a.coordinates;
        var T = a.type;
        switch (c = r3 && (T === "Polygon" || T === "MultiPolygon") ? 1 : 0, T) {
          case null:
            break;
          case "Point":
            if (e(l, p, b, P, w3) === false) return false;
            p++, P++;
            break;
          case "LineString":
          case "MultiPoint":
            for (n = 0; n < l.length; n++) {
              if (e(l[n], p, b, P, w3) === false) return false;
              p++, T === "MultiPoint" && P++;
            }
            T === "LineString" && P++;
            break;
          case "Polygon":
          case "MultiLineString":
            for (n = 0; n < l.length; n++) {
              for (i = 0; i < l[n].length - c; i++) {
                if (e(l[n][i], p, b, P, w3) === false) return false;
                p++;
              }
              T === "MultiLineString" && P++, T === "Polygon" && w3++;
            }
            T === "Polygon" && P++;
            break;
          case "MultiPolygon":
            for (n = 0; n < l.length; n++) {
              for (w3 = 0, i = 0; i < l[n].length; i++) {
                for (o = 0; o < l[n][i].length - c; o++) {
                  if (e(l[n][i][o], p, b, P, w3) === false) return false;
                  p++;
                }
                w3++;
              }
              P++;
            }
            break;
          case "GeometryCollection":
            for (n = 0; n < a.geometries.length; n++) if ($f(a.geometries[n], e, r3) === false) return false;
            break;
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
    }
  }
}
function x_e(t63, e) {
  if (t63.type === "Feature") e(t63, 0);
  else if (t63.type === "FeatureCollection") for (var r3 = 0; r3 < t63.features.length && e(t63.features[r3], r3) !== false; r3++) ;
}
function KB(t63, e) {
  var r3, n, i, o, a, s3, l, u3, c, p, h = 0, f = t63.type === "FeatureCollection", d = t63.type === "Feature", g = f ? t63.features.length : 1;
  for (r3 = 0; r3 < g; r3++) {
    for (s3 = f ? t63.features[r3].geometry : d ? t63.geometry : t63, u3 = f ? t63.features[r3].properties : d ? t63.properties : {}, c = f ? t63.features[r3].bbox : d ? t63.bbox : void 0, p = f ? t63.features[r3].id : d ? t63.id : void 0, l = s3 ? s3.type === "GeometryCollection" : false, a = l ? s3.geometries.length : 1, i = 0; i < a; i++) {
      if (o = l ? s3.geometries[i] : s3, o === null) {
        if (e(null, h, u3, c, p) === false) return false;
        continue;
      }
      switch (o.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (e(o, h, u3, c, p) === false) return false;
          break;
        }
        case "GeometryCollection": {
          for (n = 0; n < o.geometries.length; n++) if (e(o.geometries[n], h, u3, c, p) === false) return false;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    h++;
  }
}
function JB(t63, e) {
  KB(t63, function(r3, n, i, o, a) {
    var s3 = r3 === null ? null : r3.type;
    switch (s3) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return e(Ci(r3, i, { bbox: o, id: a }), n, 0) === false ? false : void 0;
    }
    var l;
    switch (s3) {
      case "MultiPoint":
        l = "Point";
        break;
      case "MultiLineString":
        l = "LineString";
        break;
      case "MultiPolygon":
        l = "Polygon";
        break;
    }
    for (var u3 = 0; u3 < r3.coordinates.length; u3++) {
      var c = r3.coordinates[u3], p = { type: l, coordinates: c };
      if (e(Ci(p, i), n, u3) === false) return false;
    }
  });
}
function QB(t63, e) {
  JB(t63, function(r3, n, i) {
    var o = 0;
    if (r3.geometry) {
      var a = r3.geometry.type;
      if (!(a === "Point" || a === "MultiPoint")) {
        var s3, l = 0, u3 = 0, c = 0;
        if ($f(r3, function(p, h, f, d, g) {
          if (s3 === void 0 || n > l || d > u3 || g > c) {
            s3 = p, l = n, u3 = d, c = g, o = 0;
            return;
          }
          var x = jS([s3, p], r3.properties);
          if (e(x, n, i, g, o) === false) return false;
          o++, s3 = p;
        }) === false) return false;
      }
    }
  });
}
function b_e(t63, e, r3) {
  var n = r3, i = false;
  return QB(t63, function(o, a, s3, l, u3) {
    i === false && r3 === void 0 ? n = o : n = e(n, o, a, s3, l, u3), i = true;
  }), n;
}
function Ag(t63) {
  var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return $f(t63, function(r3) {
    e[0] > r3[0] && (e[0] = r3[0]), e[1] > r3[1] && (e[1] = r3[1]), e[2] < r3[0] && (e[2] = r3[0]), e[3] < r3[1] && (e[3] = r3[1]);
  }), e;
}
Ag.default = Ag;
var HS = Ag;
function XS(t63) {
  return HS(t63);
}
$i();
$i();
$i();
$i();
$i();
var Oa = class {
  constructor() {
    t(this, "hover", false);
    t(this, "dirty", false);
  }
};
$i();
$i();
var ZS = external_exports.union([external_exports.enum(["low", "medium", "high", "always-visible"]), external_exports.number()]);
var qS = ["", "", "low", "medium", "high", "always-visible"];
var ez = 2;
var tz = 3;
var rz = 5;
function YS(t63) {
  return Math.min(rz, Math.max(ez, t63));
}
function Ba(t63) {
  if (typeof t63 == "number") return YS(t63);
  let e = qS.indexOf(t63);
  return e === -1 ? tz : e;
}
function D_e(t63) {
  let e = YS(t63);
  return qS[e];
}
$i();
$i();
$i();
var nz = zod_default.enum(Fx);
var iz = (t63) => {
  let e = t63[0];
  for (let r3 = 1; r3 < t63.length; r3++) {
    let n = t63[r3];
    if (n <= e) return false;
    e = n;
  }
  return true;
};
var oz = (t63) => {
  let e = t63[0];
  for (let r3 = 1; r3 < t63.length; r3++) {
    let n = t63[r3];
    if (n >= e) return false;
    e = n;
  }
  return true;
};
var az = (t63) => iz(t63) || oz(t63);
var WS = zod_default.object({ on: zod_default.literal("zoom-level"), input: zod_default.tuple([zod_default.number()]).rest(zod_default.number()).refine(az, { message: "input array must be strictly increasing or decreasing" }), output: zod_default.tuple([zod_default.number()]).rest(zod_default.number()), easing: nz.default("linear") }).refine((t63) => t63.input.length === t63.output.length, { message: "input and output must have the same length" });
$i();
function Kf(t63) {
  "@babel/helpers - typeof";
  return Kf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Kf(t63);
}
var sz = /^\s+/;
var lz = /\s+$/;
function oe(t63, e) {
  if (t63 = t63 || "", e = e || {}, t63 instanceof oe) return t63;
  if (!(this instanceof oe)) return new oe(t63, e);
  var r3 = uz(t63);
  this._originalInput = t63, this._r = r3.r, this._g = r3.g, this._b = r3.b, this._a = r3.a, this._roundA = Math.round(100 * this._a) / 100, this._format = e.format || r3.format, this._gradientType = e.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = r3.ok;
}
oe.prototype = { isDark: function() {
  return this.getBrightness() < 128;
}, isLight: function() {
  return !this.isDark();
}, isValid: function() {
  return this._ok;
}, getOriginalInput: function() {
  return this._originalInput;
}, getFormat: function() {
  return this._format;
}, getAlpha: function() {
  return this._a;
}, getBrightness: function() {
  var e = this.toRgb();
  return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3;
}, getLuminance: function() {
  var e = this.toRgb(), r3, n, i, o, a, s3;
  return r3 = e.r / 255, n = e.g / 255, i = e.b / 255, r3 <= 0.03928 ? o = r3 / 12.92 : o = Math.pow((r3 + 0.055) / 1.055, 2.4), n <= 0.03928 ? a = n / 12.92 : a = Math.pow((n + 0.055) / 1.055, 2.4), i <= 0.03928 ? s3 = i / 12.92 : s3 = Math.pow((i + 0.055) / 1.055, 2.4), 0.2126 * o + 0.7152 * a + 0.0722 * s3;
}, setAlpha: function(e) {
  return this._a = rC(e), this._roundA = Math.round(100 * this._a) / 100, this;
}, toHsv: function() {
  var e = KS(this._r, this._g, this._b);
  return { h: e.h * 360, s: e.s, v: e.v, a: this._a };
}, toHsvString: function() {
  var e = KS(this._r, this._g, this._b), r3 = Math.round(e.h * 360), n = Math.round(e.s * 100), i = Math.round(e.v * 100);
  return this._a == 1 ? "hsv(" + r3 + ", " + n + "%, " + i + "%)" : "hsva(" + r3 + ", " + n + "%, " + i + "%, " + this._roundA + ")";
}, toHsl: function() {
  var e = $S(this._r, this._g, this._b);
  return { h: e.h * 360, s: e.s, l: e.l, a: this._a };
}, toHslString: function() {
  var e = $S(this._r, this._g, this._b), r3 = Math.round(e.h * 360), n = Math.round(e.s * 100), i = Math.round(e.l * 100);
  return this._a == 1 ? "hsl(" + r3 + ", " + n + "%, " + i + "%)" : "hsla(" + r3 + ", " + n + "%, " + i + "%, " + this._roundA + ")";
}, toHex: function(e) {
  return JS(this._r, this._g, this._b, e);
}, toHexString: function(e) {
  return "#" + this.toHex(e);
}, toHex8: function(e) {
  return fz(this._r, this._g, this._b, this._a, e);
}, toHex8String: function(e) {
  return "#" + this.toHex8(e);
}, toRgb: function() {
  return { r: Math.round(this._r), g: Math.round(this._g), b: Math.round(this._b), a: this._a };
}, toRgbString: function() {
  return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
}, toPercentageRgb: function() {
  return { r: Math.round(ot(this._r, 255) * 100) + "%", g: Math.round(ot(this._g, 255) * 100) + "%", b: Math.round(ot(this._b, 255) * 100) + "%", a: this._a };
}, toPercentageRgbString: function() {
  return this._a == 1 ? "rgb(" + Math.round(ot(this._r, 255) * 100) + "%, " + Math.round(ot(this._g, 255) * 100) + "%, " + Math.round(ot(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(ot(this._r, 255) * 100) + "%, " + Math.round(ot(this._g, 255) * 100) + "%, " + Math.round(ot(this._b, 255) * 100) + "%, " + this._roundA + ")";
}, toName: function() {
  return this._a === 0 ? "transparent" : this._a < 1 ? false : Sz[JS(this._r, this._g, this._b, true)] || false;
}, toFilter: function(e) {
  var r3 = "#" + QS(this._r, this._g, this._b, this._a), n = r3, i = this._gradientType ? "GradientType = 1, " : "";
  if (e) {
    var o = oe(e);
    n = "#" + QS(o._r, o._g, o._b, o._a);
  }
  return "progid:DXImageTransform.Microsoft.gradient(" + i + "startColorstr=" + r3 + ",endColorstr=" + n + ")";
}, toString: function(e) {
  var r3 = !!e;
  e = e || this._format;
  var n = false, i = this._a < 1 && this._a >= 0, o = !r3 && i && (e === "hex" || e === "hex6" || e === "hex3" || e === "hex4" || e === "hex8" || e === "name");
  return o ? e === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (e === "rgb" && (n = this.toRgbString()), e === "prgb" && (n = this.toPercentageRgbString()), (e === "hex" || e === "hex6") && (n = this.toHexString()), e === "hex3" && (n = this.toHexString(true)), e === "hex4" && (n = this.toHex8String(true)), e === "hex8" && (n = this.toHex8String()), e === "name" && (n = this.toName()), e === "hsl" && (n = this.toHslString()), e === "hsv" && (n = this.toHsvString()), n || this.toHexString());
}, clone: function() {
  return oe(this.toString());
}, _applyModification: function(e, r3) {
  var n = e.apply(null, [this].concat([].slice.call(r3)));
  return this._r = n._r, this._g = n._g, this._b = n._b, this.setAlpha(n._a), this;
}, lighten: function() {
  return this._applyModification(gz, arguments);
}, brighten: function() {
  return this._applyModification(xz, arguments);
}, darken: function() {
  return this._applyModification(bz, arguments);
}, desaturate: function() {
  return this._applyModification(mz, arguments);
}, saturate: function() {
  return this._applyModification(dz, arguments);
}, greyscale: function() {
  return this._applyModification(yz, arguments);
}, spin: function() {
  return this._applyModification(_z, arguments);
}, _applyCombination: function(e, r3) {
  return e.apply(null, [this].concat([].slice.call(r3)));
}, analogous: function() {
  return this._applyCombination(wz, arguments);
}, complement: function() {
  return this._applyCombination(vz, arguments);
}, monochromatic: function() {
  return this._applyCombination(Tz, arguments);
}, splitcomplement: function() {
  return this._applyCombination(Pz, arguments);
}, triad: function() {
  return this._applyCombination(eC, [3]);
}, tetrad: function() {
  return this._applyCombination(eC, [4]);
} };
oe.fromRatio = function(t63, e) {
  if (Kf(t63) == "object") {
    var r3 = {};
    for (var n in t63) t63.hasOwnProperty(n) && (n === "a" ? r3[n] = t63[n] : r3[n] = wu(t63[n]));
    t63 = r3;
  }
  return oe(t63, e);
};
function uz(t63) {
  var e = { r: 0, g: 0, b: 0 }, r3 = 1, n = null, i = null, o = null, a = false, s3 = false;
  return typeof t63 == "string" && (t63 = Az(t63)), Kf(t63) == "object" && (Vn(t63.r) && Vn(t63.g) && Vn(t63.b) ? (e = cz(t63.r, t63.g, t63.b), a = true, s3 = String(t63.r).substr(-1) === "%" ? "prgb" : "rgb") : Vn(t63.h) && Vn(t63.s) && Vn(t63.v) ? (n = wu(t63.s), i = wu(t63.v), e = hz(t63.h, n, i), a = true, s3 = "hsv") : Vn(t63.h) && Vn(t63.s) && Vn(t63.l) && (n = wu(t63.s), o = wu(t63.l), e = pz(t63.h, n, o), a = true, s3 = "hsl"), t63.hasOwnProperty("a") && (r3 = t63.a)), r3 = rC(r3), { ok: a, format: t63.format || s3, r: Math.min(255, Math.max(e.r, 0)), g: Math.min(255, Math.max(e.g, 0)), b: Math.min(255, Math.max(e.b, 0)), a: r3 };
}
function cz(t63, e, r3) {
  return { r: ot(t63, 255) * 255, g: ot(e, 255) * 255, b: ot(r3, 255) * 255 };
}
function $S(t63, e, r3) {
  t63 = ot(t63, 255), e = ot(e, 255), r3 = ot(r3, 255);
  var n = Math.max(t63, e, r3), i = Math.min(t63, e, r3), o, a, s3 = (n + i) / 2;
  if (n == i) o = a = 0;
  else {
    var l = n - i;
    switch (a = s3 > 0.5 ? l / (2 - n - i) : l / (n + i), n) {
      case t63:
        o = (e - r3) / l + (e < r3 ? 6 : 0);
        break;
      case e:
        o = (r3 - t63) / l + 2;
        break;
      case r3:
        o = (t63 - e) / l + 4;
        break;
    }
    o /= 6;
  }
  return { h: o, s: a, l: s3 };
}
function pz(t63, e, r3) {
  var n, i, o;
  t63 = ot(t63, 360), e = ot(e, 100), r3 = ot(r3, 100);
  function a(u3, c, p) {
    return p < 0 && (p += 1), p > 1 && (p -= 1), p < 1 / 6 ? u3 + (c - u3) * 6 * p : p < 1 / 2 ? c : p < 2 / 3 ? u3 + (c - u3) * (2 / 3 - p) * 6 : u3;
  }
  if (e === 0) n = i = o = r3;
  else {
    var s3 = r3 < 0.5 ? r3 * (1 + e) : r3 + e - r3 * e, l = 2 * r3 - s3;
    n = a(l, s3, t63 + 1 / 3), i = a(l, s3, t63), o = a(l, s3, t63 - 1 / 3);
  }
  return { r: n * 255, g: i * 255, b: o * 255 };
}
function KS(t63, e, r3) {
  t63 = ot(t63, 255), e = ot(e, 255), r3 = ot(r3, 255);
  var n = Math.max(t63, e, r3), i = Math.min(t63, e, r3), o, a, s3 = n, l = n - i;
  if (a = n === 0 ? 0 : l / n, n == i) o = 0;
  else {
    switch (n) {
      case t63:
        o = (e - r3) / l + (e < r3 ? 6 : 0);
        break;
      case e:
        o = (r3 - t63) / l + 2;
        break;
      case r3:
        o = (t63 - e) / l + 4;
        break;
    }
    o /= 6;
  }
  return { h: o, s: a, v: s3 };
}
function hz(t63, e, r3) {
  t63 = ot(t63, 360) * 6, e = ot(e, 100), r3 = ot(r3, 100);
  var n = Math.floor(t63), i = t63 - n, o = r3 * (1 - e), a = r3 * (1 - i * e), s3 = r3 * (1 - (1 - i) * e), l = n % 6, u3 = [r3, a, o, o, s3, r3][l], c = [s3, r3, r3, a, o, o][l], p = [o, o, s3, r3, r3, a][l];
  return { r: u3 * 255, g: c * 255, b: p * 255 };
}
function JS(t63, e, r3, n) {
  var i = [tn(Math.round(t63).toString(16)), tn(Math.round(e).toString(16)), tn(Math.round(r3).toString(16))];
  return n && i[0].charAt(0) == i[0].charAt(1) && i[1].charAt(0) == i[1].charAt(1) && i[2].charAt(0) == i[2].charAt(1) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("");
}
function fz(t63, e, r3, n, i) {
  var o = [tn(Math.round(t63).toString(16)), tn(Math.round(e).toString(16)), tn(Math.round(r3).toString(16)), tn(nC(n))];
  return i && o[0].charAt(0) == o[0].charAt(1) && o[1].charAt(0) == o[1].charAt(1) && o[2].charAt(0) == o[2].charAt(1) && o[3].charAt(0) == o[3].charAt(1) ? o[0].charAt(0) + o[1].charAt(0) + o[2].charAt(0) + o[3].charAt(0) : o.join("");
}
function QS(t63, e, r3, n) {
  var i = [tn(nC(n)), tn(Math.round(t63).toString(16)), tn(Math.round(e).toString(16)), tn(Math.round(r3).toString(16))];
  return i.join("");
}
oe.equals = function(t63, e) {
  return !t63 || !e ? false : oe(t63).toRgbString() == oe(e).toRgbString();
};
oe.random = function() {
  return oe.fromRatio({ r: Math.random(), g: Math.random(), b: Math.random() });
};
function mz(t63, e) {
  e = e === 0 ? 0 : e || 10;
  var r3 = oe(t63).toHsl();
  return r3.s -= e / 100, r3.s = Jf(r3.s), oe(r3);
}
function dz(t63, e) {
  e = e === 0 ? 0 : e || 10;
  var r3 = oe(t63).toHsl();
  return r3.s += e / 100, r3.s = Jf(r3.s), oe(r3);
}
function yz(t63) {
  return oe(t63).desaturate(100);
}
function gz(t63, e) {
  e = e === 0 ? 0 : e || 10;
  var r3 = oe(t63).toHsl();
  return r3.l += e / 100, r3.l = Jf(r3.l), oe(r3);
}
function xz(t63, e) {
  e = e === 0 ? 0 : e || 10;
  var r3 = oe(t63).toRgb();
  return r3.r = Math.max(0, Math.min(255, r3.r - Math.round(255 * -(e / 100)))), r3.g = Math.max(0, Math.min(255, r3.g - Math.round(255 * -(e / 100)))), r3.b = Math.max(0, Math.min(255, r3.b - Math.round(255 * -(e / 100)))), oe(r3);
}
function bz(t63, e) {
  e = e === 0 ? 0 : e || 10;
  var r3 = oe(t63).toHsl();
  return r3.l -= e / 100, r3.l = Jf(r3.l), oe(r3);
}
function _z(t63, e) {
  var r3 = oe(t63).toHsl(), n = (r3.h + e) % 360;
  return r3.h = n < 0 ? 360 + n : n, oe(r3);
}
function vz(t63) {
  var e = oe(t63).toHsl();
  return e.h = (e.h + 180) % 360, oe(e);
}
function eC(t63, e) {
  if (isNaN(e) || e <= 0) throw new Error("Argument to polyad must be a positive number");
  for (var r3 = oe(t63).toHsl(), n = [oe(t63)], i = 360 / e, o = 1; o < e; o++) n.push(oe({ h: (r3.h + o * i) % 360, s: r3.s, l: r3.l }));
  return n;
}
function Pz(t63) {
  var e = oe(t63).toHsl(), r3 = e.h;
  return [oe(t63), oe({ h: (r3 + 72) % 360, s: e.s, l: e.l }), oe({ h: (r3 + 216) % 360, s: e.s, l: e.l })];
}
function wz(t63, e, r3) {
  e = e || 6, r3 = r3 || 30;
  var n = oe(t63).toHsl(), i = 360 / r3, o = [oe(t63)];
  for (n.h = (n.h - (i * e >> 1) + 720) % 360; --e; ) n.h = (n.h + i) % 360, o.push(oe(n));
  return o;
}
function Tz(t63, e) {
  e = e || 6;
  for (var r3 = oe(t63).toHsv(), n = r3.h, i = r3.s, o = r3.v, a = [], s3 = 1 / e; e--; ) a.push(oe({ h: n, s: i, v: o })), o = (o + s3) % 1;
  return a;
}
oe.mix = function(t63, e, r3) {
  r3 = r3 === 0 ? 0 : r3 || 50;
  var n = oe(t63).toRgb(), i = oe(e).toRgb(), o = r3 / 100, a = { r: (i.r - n.r) * o + n.r, g: (i.g - n.g) * o + n.g, b: (i.b - n.b) * o + n.b, a: (i.a - n.a) * o + n.a };
  return oe(a);
};
oe.readability = function(t63, e) {
  var r3 = oe(t63), n = oe(e);
  return (Math.max(r3.getLuminance(), n.getLuminance()) + 0.05) / (Math.min(r3.getLuminance(), n.getLuminance()) + 0.05);
};
oe.isReadable = function(t63, e, r3) {
  var n = oe.readability(t63, e), i, o;
  switch (o = false, i = Ez(r3), i.level + i.size) {
    case "AAsmall":
    case "AAAlarge":
      o = n >= 4.5;
      break;
    case "AAlarge":
      o = n >= 3;
      break;
    case "AAAsmall":
      o = n >= 7;
      break;
  }
  return o;
};
oe.mostReadable = function(t63, e, r3) {
  var n = null, i = 0, o, a, s3, l;
  r3 = r3 || {}, a = r3.includeFallbackColors, s3 = r3.level, l = r3.size;
  for (var u3 = 0; u3 < e.length; u3++) o = oe.readability(t63, e[u3]), o > i && (i = o, n = oe(e[u3]));
  return oe.isReadable(t63, n, { level: s3, size: l }) || !a ? n : (r3.includeFallbackColors = false, oe.mostReadable(t63, ["#fff", "#000"], r3));
};
var Lg = oe.names = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "0ff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "00f", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", burntsienna: "ea7e5d", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "0ff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "f0f", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "663399", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" };
var Sz = oe.hexNames = Cz(Lg);
function Cz(t63) {
  var e = {};
  for (var r3 in t63) t63.hasOwnProperty(r3) && (e[t63[r3]] = r3);
  return e;
}
function rC(t63) {
  return t63 = parseFloat(t63), (isNaN(t63) || t63 < 0 || t63 > 1) && (t63 = 1), t63;
}
function ot(t63, e) {
  Mz(t63) && (t63 = "100%");
  var r3 = Iz(t63);
  return t63 = Math.min(e, Math.max(0, parseFloat(t63))), r3 && (t63 = parseInt(t63 * e, 10) / 100), Math.abs(t63 - e) < 1e-6 ? 1 : t63 % e / parseFloat(e);
}
function Jf(t63) {
  return Math.min(1, Math.max(0, t63));
}
function Tr(t63) {
  return parseInt(t63, 16);
}
function Mz(t63) {
  return typeof t63 == "string" && t63.indexOf(".") != -1 && parseFloat(t63) === 1;
}
function Iz(t63) {
  return typeof t63 == "string" && t63.indexOf("%") != -1;
}
function tn(t63) {
  return t63.length == 1 ? "0" + t63 : "" + t63;
}
function wu(t63) {
  return t63 <= 1 && (t63 = t63 * 100 + "%"), t63;
}
function nC(t63) {
  return Math.round(parseFloat(t63) * 255).toString(16);
}
function tC(t63) {
  return Tr(t63) / 255;
}
var en = (function() {
  var t63 = "[-\\+]?\\d+%?", e = "[-\\+]?\\d*\\.\\d+%?", r3 = "(?:" + e + ")|(?:" + t63 + ")", n = "[\\s|\\(]+(" + r3 + ")[,|\\s]+(" + r3 + ")[,|\\s]+(" + r3 + ")\\s*\\)?", i = "[\\s|\\(]+(" + r3 + ")[,|\\s]+(" + r3 + ")[,|\\s]+(" + r3 + ")[,|\\s]+(" + r3 + ")\\s*\\)?";
  return { CSS_UNIT: new RegExp(r3), rgb: new RegExp("rgb" + n), rgba: new RegExp("rgba" + i), hsl: new RegExp("hsl" + n), hsla: new RegExp("hsla" + i), hsv: new RegExp("hsv" + n), hsva: new RegExp("hsva" + i), hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/, hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/ };
})();
function Vn(t63) {
  return !!en.CSS_UNIT.exec(t63);
}
function Az(t63) {
  t63 = t63.replace(sz, "").replace(lz, "").toLowerCase();
  var e = false;
  if (Lg[t63]) t63 = Lg[t63], e = true;
  else if (t63 == "transparent") return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var r3;
  return (r3 = en.rgb.exec(t63)) ? { r: r3[1], g: r3[2], b: r3[3] } : (r3 = en.rgba.exec(t63)) ? { r: r3[1], g: r3[2], b: r3[3], a: r3[4] } : (r3 = en.hsl.exec(t63)) ? { h: r3[1], s: r3[2], l: r3[3] } : (r3 = en.hsla.exec(t63)) ? { h: r3[1], s: r3[2], l: r3[3], a: r3[4] } : (r3 = en.hsv.exec(t63)) ? { h: r3[1], s: r3[2], v: r3[3] } : (r3 = en.hsva.exec(t63)) ? { h: r3[1], s: r3[2], v: r3[3], a: r3[4] } : (r3 = en.hex8.exec(t63)) ? { r: Tr(r3[1]), g: Tr(r3[2]), b: Tr(r3[3]), a: tC(r3[4]), format: e ? "name" : "hex8" } : (r3 = en.hex6.exec(t63)) ? { r: Tr(r3[1]), g: Tr(r3[2]), b: Tr(r3[3]), format: e ? "name" : "hex" } : (r3 = en.hex4.exec(t63)) ? { r: Tr(r3[1] + "" + r3[1]), g: Tr(r3[2] + "" + r3[2]), b: Tr(r3[3] + "" + r3[3]), a: tC(r3[4] + "" + r3[4]), format: e ? "name" : "hex8" } : (r3 = en.hex3.exec(t63)) ? { r: Tr(r3[1] + "" + r3[1]), g: Tr(r3[2] + "" + r3[2]), b: Tr(r3[3] + "" + r3[3]), format: e ? "name" : "hex" } : false;
}
function Ez(t63) {
  var e, r3;
  return t63 = t63 || { level: "AA", size: "small" }, e = (t63.level || "AA").toUpperCase(), r3 = (t63.size || "small").toLowerCase(), e !== "AA" && e !== "AAA" && (e = "AA"), r3 !== "small" && r3 !== "large" && (r3 = "small"), { level: e, size: r3 };
}
var bt = { RIGHT: "right", LEFT: "left", TOP: "top", HIDDEN: "hidden", CENTER: "center" };
var Po = "low-priority";
var iC = Object.values(bt);
var Dg = [bt.RIGHT, bt.LEFT, bt.TOP, bt.HIDDEN];
var oC = external_exports.object({ margin: external_exports.number().min(6).default(6), maxLines: external_exports.number().min(1).default(2), textSize: external_exports.number().min(0).default(11.5), maxWidth: external_exports.number().min(0).default(150), lineHeight: external_exports.number().min(0).default(1.2), color: external_exports.string().default("#333"), outlineColor: external_exports.string().default("white"), textColor: external_exports.string().optional(), textOutlineColor: external_exports.string().optional(), pinColor: external_exports.string().optional(), pinOutlineColor: external_exports.string().optional(), pinColorInactive: external_exports.string().optional(), pinOutlineColorInactive: external_exports.string().optional(), icon: external_exports.string().optional(), iconSize: external_exports.number().min(0).default(20), iconScale: external_exports.union([external_exports.number(), WS]).default(1), iconPadding: external_exports.number().min(0).default(2), iconFit: external_exports.enum(["fill", "contain", "cover"]).default("cover"), iconOverflow: external_exports.enum(["visible", "hidden"]).default("hidden"), iconVisible: external_exports.union([external_exports.boolean(), external_exports.number()]).default(true), opacity: external_exports.number().min(0).max(1).default(1) });
var aC = oC.transform((t63) => ({ ...t63, textColor: t63.textColor ?? t63.color, textOutlineColor: t63.textOutlineColor ?? t63.outlineColor, pinColor: t63.pinColor ?? t63.color, pinOutlineColor: t63.pinOutlineColor ?? t63.outlineColor, pinColorInactive: t63.pinColorInactive ?? oe(t63.pinColor ?? t63.color).toRgbString(), pinOutlineColorInactive: t63.pinOutlineColorInactive ?? oe(t63.pinOutlineColor ?? t63.outlineColor).toRgbString() }));
var q_e = external_exports.strictObject(oC.shape);
var sC = (t63) => aC.parse(t63);
var Lz = external_exports.object({ rank: ZS.optional(), appearance: aC.optional(), interactive: external_exports.boolean().default(false), textPlacement: external_exports.union([external_exports.enum(iC), external_exports.array(external_exports.enum(iC))]).default(Dg) });
var Rg = (t63) => {
  Lz.parse(t63 ?? {});
};
var Y_e = (t63, e, r3) => {
  external_exports.array(external_exports.number()).min(2).max(3).parse(t63), external_exports.string().parse(e), Rg(r3);
};
var lC = ["color", "outlineColor", "margin"];
var Dz = [...lC, "maxLines", "lineHeight", "textSize", "maxWidth", "textColor", "textOutlineColor", "opacity"];
var Rz = [...lC, "icon", "pinColor", "pinOutlineColor", "pinColorInactive", "pinOutlineColorInactive"];
var uC = (t63, e) => Dz.some((r3) => e[r3] != null && t63[r3] !== e[r3]);
var cC = (t63, e) => Rz.some((r3) => e[r3] != null && t63[r3] !== e[r3]);
var pC = 4;
var Fz = 6;
var fC = 6.5;
var Qf = fC / 2;
var hC = [Qf, Qf, Qf, Qf];
var za = class za2 {
  constructor(e, r3, n) {
    t(this, "lines", 0);
    t(this, "id");
    t(this, "rank");
    t(this, "type", "label");
    t(this, "initialRank");
    t(this, "contextConfigured", false);
    t(this, "fillText");
    t(this, "newStyle", {});
    t(this, "currentOpacity", 0);
    t(this, "visibilityNeedsUpdate", false);
    t(this, "activePlacement", bt.RIGHT);
    t(this, "text");
    t(this, "style", { top: 0, left: 0, textLabelVisible: true, pinVisibility: 1, textAlign: "left" });
    t(this, "projection", new at());
    t(this, "labelCacheId");
    t(this, "_cache", {});
    t(this, "appearance");
    t(this, "options");
    t(this, "visible", true);
    t(this, "enabled", true);
    t(this, "isOccluded", false);
    t(this, "offscreen", false);
    t(this, "canShow", false);
    t(this, "activeBoundingBox", { x: 0, y: 0, w: 0, h: 0 });
    t(this, "dimensions", { width: 0, height: 0 });
    t(this, "currentStrategyIndex", -1);
    t(this, "totalPinSize", 0);
    t(this, "iconScale", 1);
    t(this, "iconPadding");
    t(this, "dirty", true);
    t(this, "textDirty", true);
    t(this, "pinDirty", true);
    t(this, "attachedDirty", true);
    t(this, "collisionDirty", true);
    t(this, "lastTextAlign");
    t(this, "imageHash");
    t(this, "pinSize", 0);
    t(this, "iconVisible", false);
    t(this, "dp");
    t(this, "animate", true);
    t(this, "onStrategySelected", (e3) => {
      if (this.currentStrategyIndex === e3) return;
      this.currentStrategyIndex = e3;
      let r4 = this.strategies[e3];
      if (this.activePlacement = r4?.name ?? this.activePlacement, r4) {
        r4.onStrategySelected();
        let n3 = this.style;
        this.style = this.newStyle, this.newStyle = n3;
      }
    });
    t(this, "packedMessage", { x: 0, y: 0, enabled: false, rank: 0, bboxes: [], shouldCollideWithScreenEdges: false, lockedToStrategyIndex: -1 });
    if (this.id = r3.id ?? Vt(), this.options = r3 ?? {}, this.text = e, this.dp = (o = 1) => o * n.pixelRatio, typeof r3.rank == "string") this.rank = Ba(r3.rank), this.initialRank = this.rank;
    else if (r3.rank != null && r3.rank > 0) this.rank = r3.rank, this.initialRank = r3.rank;
    else {
      let o = Math.trunc(yc.env.NODE_ENV === "test" ? za2.testId : za2.testId * 10) / 10;
      za2.testId += 1e-3, this.rank = o, this.initialRank = o;
    }
    this.options.textPlacement = r3.textPlacement ?? Dg;
    let i = sC(r3.appearance ?? {});
    this.appearance = i, this.iconPadding = i.iconPadding;
  }
  get scaledPinSize() {
    return this.totalPinSize * this.iconScale;
  }
  get scaledIconPadding() {
    return this.appearance.iconPadding * this.iconScale;
  }
  calculatePinSize() {
    let e = this.dp();
    this.iconVisible && typeof this.appearance.iconSize < "u" && this.imageHash ? this.pinSize = this.dp(this.appearance.iconSize) : this.pinSize = this.dp(fC), this.totalPinSize = Math.ceil((this.pinSize + 2.5) / e);
  }
  getNoTextBbox(e) {
    let r3 = this.scaledPinSize / 2 + e;
    return [r3, r3, r3, r3];
  }
  getHiddenTextPlacementBbox(e) {
    return this.iconVisible ? this.getNoTextBbox(e) : hC;
  }
  getBoundingBoxForPlacement(e) {
    let { width: r3, height: n } = this.dimensions, { margin: i } = this.appearance, o = Math.max(Fz, i);
    if (this.text === "") return this.getNoTextBbox(o);
    let a = Math.max(this.scaledPinSize, n);
    switch (e) {
      case bt.RIGHT:
        return [a / 2 + o, a / 2 + o, this.scaledPinSize / 2 + o, this.scaledPinSize / 2 + r3 + o];
      case bt.LEFT:
        return [a / 2 + o, a / 2 + o, this.scaledPinSize / 2 + r3 + o, this.scaledPinSize / 2 + o];
      case bt.TOP: {
        let s3 = this.dp();
        return [n + this.scaledPinSize / 2 / s3 + o, this.scaledPinSize / 2 + o, r3 / 2 + o, r3 / 2 + o];
      }
      case bt.CENTER:
        return [n / 2 + o, n / 2 + o, r3 / 2 + o, r3 / 2 + o];
      case bt.HIDDEN:
        return this.getHiddenTextPlacementBbox(o);
      case Po:
        return hC;
      default:
        return this.getNoTextBbox(o);
    }
  }
  getStrategyStyleForPlacement(e) {
    let { width: r3, height: n } = this.dimensions;
    switch (e) {
      case bt.TOP:
        this.newStyle.pinVisibility = 1, this.newStyle.textAlign = "center", this.newStyle.textLabelVisible = true, this.newStyle.top = -n - this.scaledPinSize / 2, this.newStyle.left = -r3 / 2;
        return;
      case bt.LEFT:
        this.newStyle.textAlign = "right", this.newStyle.pinVisibility = 1, this.newStyle.top = -n / 2, this.newStyle.left = -r3 - this.scaledPinSize / 2 - pC, this.newStyle.textLabelVisible = true;
        return;
      case bt.RIGHT:
        this.newStyle.textAlign = "left", this.newStyle.pinVisibility = 1, this.newStyle.top = -n / 2, this.newStyle.left = this.scaledPinSize / 2 + pC, this.newStyle.textLabelVisible = true;
        return;
      case bt.CENTER:
        this.newStyle.pinVisibility = 0, this.newStyle.textAlign = "center", this.newStyle.textLabelVisible = true, this.newStyle.top = -n / 2, this.newStyle.left = -r3 / 2;
        return;
      case bt.HIDDEN:
        this.newStyle.pinVisibility = this.iconVisible ? 1 : 0.5, this.newStyle.textLabelVisible = false, this.newStyle.top = 0, this.newStyle.left = 0;
        return;
      case Po:
      default:
        this.newStyle.pinVisibility = 0.5, this.newStyle.textLabelVisible = false, this.newStyle.top = 0, this.newStyle.left = 0;
        return;
    }
  }
  get strategies() {
    let e = Array.isArray(this.options.textPlacement) ? this.options.textPlacement : [this.options.textPlacement], r3 = [], n = false;
    for (let i of e) this.options.rank === "always-visible" && i === bt.HIDDEN && e.length > 1 || (r3.push({ name: i, getBoundingBox: () => this.getBoundingBoxForPlacement(i), onStrategySelected: () => this.getStrategyStyleForPlacement(i) }), i === bt.HIDDEN && (n = true));
    return n && r3.push({ name: Po, getBoundingBox: () => this.getBoundingBoxForPlacement(Po), onStrategySelected: () => this.getStrategyStyleForPlacement(Po) }), r3;
  }
  recomputeCurrentStrategy(e = this.iconScale) {
    if (this.iconScale !== e || this.dirty) {
      let r3 = this.strategies[this.currentStrategyIndex];
      if (this.iconScale = e, this.collisionDirty = true, r3) {
        r3.onStrategySelected();
        let n = this.style;
        this.style = this.newStyle, this.newStyle = n;
      }
      this.dirty = false;
    }
  }
  toPackedMessage(e = false) {
    this.visible && e && this.collisionDirty === false && this.currentStrategyIndex != null && this.currentStrategyIndex !== -1 ? this.packedMessage.lockedToStrategyIndex = this.currentStrategyIndex : this.packedMessage.lockedToStrategyIndex = -1, this.packedMessage.x = this.projection.x, this.packedMessage.y = this.projection.y, this.packedMessage.enabled = this.enabled, this.packedMessage.rank = this.rank;
    let r3 = this.strategies[this.currentStrategyIndex], n = this.text === "" || r3?.name === bt.HIDDEN || r3?.name === Po;
    if (!n && this.currentStrategyIndex !== -1 && this.currentStrategyIndex !== this.packedMessage.bboxes[0]?.[4]) {
      let i = this.packedMessage.bboxes.findIndex((o) => o[4] === this.currentStrategyIndex);
      if (i !== -1) {
        let o = this.packedMessage.bboxes.splice(i, 1)[0];
        this.packedMessage.bboxes.unshift(o);
      }
    }
    if (!this.collisionDirty) return this.packedMessage;
    this.packedMessage.bboxes = [];
    for (let i = 0; i < this.strategies.length; i++) {
      let o = this.strategies[i];
      !n && i === this.currentStrategyIndex && this.currentStrategyIndex !== -1 ? this.packedMessage.bboxes.unshift([...o.getBoundingBox(), i]) : this.packedMessage.bboxes.push([...o.getBoundingBox(), i]);
    }
    return this.packedMessage.shouldCollideWithScreenEdges = false, this.collisionDirty = false, this.packedMessage;
  }
  destroy() {
  }
};
t(za, "testId", 0);
var kg = za;
var mC = kg;
$i();
var YC = s(jC());
$i();
var HC = "0.6";
var We = { TOP: "top", BOTTOM: "bottom", LEFT: "left", RIGHT: "right", CENTER: "center", TOP_LEFT: "top-left", TOP_RIGHT: "top-right", BOTTOM_LEFT: "bottom-left", BOTTOM_RIGHT: "bottom-right", HIDDEN: "hidden" };
var Xg = Object.values(We);
var XC = [We.CENTER, We.HIDDEN];
var ZC = Object.freeze({ size: 8, color: "#666" });
var Zg = external_exports.object({ rank: external_exports.union([external_exports.enum(["low", "medium", "high", "always-visible"]), external_exports.number()]).optional(), interactive: external_exports.union([external_exports.boolean(), external_exports.literal("pointer-events-auto")]).optional(), id: external_exports.string().optional(), placement: external_exports.union([external_exports.enum(Xg), external_exports.array(external_exports.enum(Xg))]).optional(), dynamicResize: external_exports.boolean().optional(), zIndex: external_exports.number().optional(), lowPriorityPin: external_exports.object({ size: external_exports.number().positive().optional(), color: external_exports.string().optional() }).optional() });
function xve(t63, e, r3) {
  external_exports.array(external_exports.number()).min(2).max(3).parse(t63), external_exports.string().parse(e), Zg.parse(r3);
}
var Ga = class Ga2 {
  constructor(e, r3 = {}) {
    t(this, "id");
    t(this, "type", "marker");
    t(this, "rank", 0);
    t(this, "initialRank", 0);
    t(this, "activePlacement", "center");
    t(this, "pointerEvents", "none");
    t(this, "options", { rank: "low", interactive: false, id: "", placement: XC, dynamicResize: false, occluderId: 0, zIndex: void 0, verticalOffset: 0, lowPriorityPin: { ...ZC } });
    t(this, "projection", new at());
    t(this, "enabled", true);
    t(this, "canShow", false);
    t(this, "visible", true);
    t(this, "isOccluded", false);
    t(this, "offscreen", false);
    t(this, "strategyIndex", -1);
    t(this, "activeBoundingBox", { x: 0, y: 0, w: 0, h: 0 });
    t(this, "dimensions", { width: 0, height: 0 });
    t(this, "markerContainer");
    t(this, "containerEl");
    t(this, "contentEl", null);
    t(this, "contentHtml", "");
    t(this, "style", { top: "0px", left: "0px" });
    t(this, "dirty", false);
    t(this, "attachedDirty", true);
    t(this, "collisionDirty", true);
    t(this, "visibilityNeedsUpdate", "show");
    t(this, "animation", null);
    t(this, "currentStrategyIndex", -1);
    t(this, "onStrategySelected", (e3, r4 = false) => {
      if (this.currentStrategyIndex === e3 && !r4) return;
      this.currentStrategyIndex = e3;
      let n = this.strategies[e3];
      if (this.activePlacement = n?.name ?? "center", this.activePlacement === We.HIDDEN) {
        this.markerContainer.setAttribute("data-placement", We.HIDDEN);
        let i = this.options.lowPriorityPin, o = i.size, a = i.color;
        this.markerContainer.style.setProperty("--mappedin-pin-size", `${o}px`), this.markerContainer.style.setProperty("--pin-color", a), this.markerContainer.style.opacity = HC, this.style.top = -o / 2 + "px", this.style.left = -o / 2 + "px";
      } else {
        this.markerContainer.setAttribute("data-placement", this.activePlacement), this.markerContainer.style.removeProperty("--mappedin-pin-size"), this.markerContainer.style.removeProperty("--pin-color"), this.markerContainer.style.opacity = "1";
        let { width: i, height: o } = this.dimensions, a = -o / 2 + "px", s3 = -i / 2 + "px";
        switch (this.style.top = a, this.style.left = s3, this.activePlacement) {
          case We.TOP: {
            this.style.top = -o + "px";
            break;
          }
          case We.BOTTOM: {
            this.style.top = "0px";
            break;
          }
          case We.LEFT: {
            this.style.left = -i + "px";
            break;
          }
          case We.RIGHT: {
            this.style.left = "0px";
            break;
          }
          case We.TOP_LEFT: {
            this.style.top = -o + "px", this.style.left = -i + "px";
            break;
          }
          case We.TOP_RIGHT: {
            this.style.top = -o + "px", this.style.left = "0px";
            break;
          }
          case We.BOTTOM_LEFT: {
            this.style.top = "0px", this.style.left = -i + "px";
            break;
          }
          case We.BOTTOM_RIGHT: {
            this.style.top = "0px", this.style.left = "0px";
            break;
          }
          case We.CENTER:
          default:
            this.style.top = a, this.style.left = s3;
        }
      }
      this.markerContainer.style.top = this.style.top, this.markerContainer.style.left = this.style.left;
    });
    t(this, "packedMessage", { x: 0, y: 0, enabled: false, rank: 0, bboxes: [], lockedToStrategyIndex: -1, shouldCollideWithScreenEdges: false });
    if (this.id = r3?.id || Vt(), this.options = (0, YC.default)(this.options, r3), this.options.placement = r3.placement ?? this.options.placement, typeof r3.rank == "string") this.rank = Ba(r3.rank);
    else if (r3.rank != null && r3.rank > 0) this.rank = r3.rank;
    else {
      let n = Math.trunc(yc.env.NODE_ENV === "test" ? Ga2.testId : Ga2.testId * 10) / 10;
      Ga2.testId += 1e-3, this.rank = n;
    }
    typeof r3.interactive == "string" && (this.pointerEvents = r3.interactive === "pointer-events-auto" ? "auto" : "none"), this.contentHtml = e, this.initialRank = this.rank, this.markerContainer = document.createElement("div"), this.markerContainer.className = "mappedin-marker", this.markerContainer.style.opacity = "0", this.markerContainer.innerHTML = `<div class="mappedin-marker-content">${this.contentHtml}</div>`, this.markerContainer.setAttribute("data-marker-id", this.id.toString()), this.containerEl = this.markerContainer.firstElementChild ?? null, this.contentEl = this.markerContainer.firstElementChild?.firstElementChild ?? null;
  }
  updateDimensions(e, r3) {
    if (e != null && r3 != null) this.dimensions = { width: e, height: r3 };
    else {
      let { width: n, height: i } = this.markerContainer.getBoundingClientRect();
      this.dimensions = { width: n, height: i };
    }
    Object.assign(this.markerContainer, { width: this.dimensions.width + "px", height: this.dimensions.height + "px" }), this.currentStrategyIndex = -1;
  }
  get strategies() {
    let { width: e, height: r3 } = this.dimensions;
    if (e === 0 || r3 === 0) return [];
    let n = Array.isArray(this.options.placement) ? this.options.placement : [this.options.placement], i = [];
    for (let o of n) this.options.rank === "always-visible" && o === We.HIDDEN && n.length > 1 || i.push({ name: o, getBoundingBox: () => {
      let a = r3 / 2, s3 = r3 / 2, l = e / 2, u3 = e / 2;
      switch (o) {
        case We.TOP: {
          a = r3, s3 = 0;
          break;
        }
        case We.BOTTOM: {
          a = 0, s3 = r3;
          break;
        }
        case We.LEFT: {
          l = e, u3 = 0;
          break;
        }
        case We.RIGHT: {
          l = 0, u3 = e;
          break;
        }
        case We.TOP_LEFT: {
          a = r3, l = e, s3 = 0, u3 = 0;
          break;
        }
        case We.TOP_RIGHT: {
          a = r3, u3 = e, s3 = 0, l = 0;
          break;
        }
        case We.BOTTOM_LEFT: {
          s3 = r3, l = e, a = 0, u3 = 0;
          break;
        }
        case We.BOTTOM_RIGHT: {
          s3 = r3, u3 = e, a = 0, l = 0;
          break;
        }
        case We.HIDDEN:
          let c = Math.max(2, 4 / 2);
          return [this.options.lowPriorityPin.size / 2 + c, this.options.lowPriorityPin.size / 2 + c, this.options.lowPriorityPin.size / 2 + c, this.options.lowPriorityPin.size / 2 + c];
      }
      return [a + 4, s3 + 4, l + 4, u3 + 4];
    } });
    return i;
  }
  toPackedMessage(e = false) {
    this.packedMessage.x = this.projection.x, this.packedMessage.y = this.projection.y, this.packedMessage.enabled = this.enabled, this.packedMessage.rank = this.rank, this.packedMessage.shouldCollideWithScreenEdges = true;
    let r3 = this.currentStrategyIndex !== -1 && this.currentStrategyIndex !== this.lowPriorityPinStrategyIndex;
    if (this.visible && e && r3 && this.collisionDirty === false ? this.packedMessage.lockedToStrategyIndex = this.currentStrategyIndex : this.packedMessage.lockedToStrategyIndex = -1, r3 && this.currentStrategyIndex !== this.packedMessage.bboxes[0]?.[4]) {
      let n = this.packedMessage.bboxes.findIndex((i) => i[4] === this.currentStrategyIndex);
      if (n !== -1) {
        let i = this.packedMessage.bboxes.splice(n, 1)[0];
        this.packedMessage.bboxes.unshift(i);
      }
    }
    if (!this.collisionDirty) return this.packedMessage;
    this.packedMessage.bboxes = [];
    for (let n = 0; n < this.strategies.length; n++) {
      let i = this.strategies[n];
      n === this.currentStrategyIndex && r3 ? this.packedMessage.bboxes.unshift([...i.getBoundingBox(), n]) : this.packedMessage.bboxes.push([...i.getBoundingBox(), n]);
    }
    return this.collisionDirty = false, this.packedMessage;
  }
  get lowPriorityPinStrategyIndex() {
    return this.options.rank === "always-visible" ? -1 : this.strategies.findIndex((e) => e.name === We.HIDDEN);
  }
  destroy() {
  }
};
t(Ga, "testId", 0);
var qC = Ga;
$i();
var Co = class extends de {
  constructor() {
    super(...arguments);
    t(this, "type", "geometry");
    t(this, "userData", { entityId: "", type: "geometry" });
  }
  raycast(r3, n) {
    this.userData.type === "model" && this.children[0] && r3.intersectObject(this.children[0], true).forEach((i) => {
      n.push(i);
    });
  }
};
var Sr = class {
  constructor(e, r3) {
    t(this, "id", Vt());
    t(this, "components");
    t(this, "parentId");
    t(this, "entities2D", /* @__PURE__ */ new Map());
    this.components = [e, r3];
  }
  get object3d() {
    return this.components[0].mesh;
  }
  get parentObject3D() {
    return this.components[0].mesh?.parent;
  }
  get type() {
    return this.components[0].type;
  }
  attach(e) {
    this.parentObject3D instanceof lr ? e.object3d.userData.attachedEntityId = this.id : this.entities2D.set(e.id, e);
  }
  detach(e) {
    this.parentObject3D instanceof lr && (e.object3d.userData.parentEntityId = void 0), this.entities2D.delete(e.id);
  }
  removeAllEntities() {
    for (let e of this.entities2D.values()) this.detach(e);
  }
};
$i();
var gn = class extends de {
};
var Gn = class {
  constructor(e, r3, n = 0) {
    t(this, "id");
    t(this, "verticalOffset");
    t(this, "occluderId");
    t(this, "object3d", new gn());
    t(this, "components");
    t(this, "disposed", false);
    t(this, "worldPosition", new C());
    this.id = e.id || Vt(), this.components = [e], this.verticalOffset = n, this.object3d = new gn(), this.object3d.position.set(r3.x, r3.y, r3.z + n), this.object3d.userData.entityId = this.id, this.object3d.userData.type = this.type, this.positionDirty = true;
  }
  get type() {
    return this.components[0].type;
  }
  get parentObject3D() {
    return this.object3d.parent;
  }
  get attachedTo() {
    return this.object3d.userData.attachedEntityId;
  }
  get position() {
    return this.positionDirty && (this.object3d.matrixAutoUpdate = true, this.object3d.getWorldPosition(this.worldPosition), this.positionDirty = false, this.object3d.matrixAutoUpdate = false), this.worldPosition;
  }
  get positionDirty() {
    return this.object3d.userData.worldPositionDirty;
  }
  set positionDirty(e) {
    this.object3d.userData.worldPositionDirty = e;
  }
  updatePosition(e) {
    this.object3d.position.copy(e), this.positionDirty = true;
  }
  setAltitude(e) {
    this.object3d.position.z = e, this.positionDirty = true;
  }
};
$i();
$i();
var WC = class extends Ka {
  constructor(r3, n, i = true) {
    super();
    t(this, "rendererState");
    t(this, "convertTo3DMapPosition");
    t(this, "textSet", /* @__PURE__ */ new Set());
    t(this, "batchedTextMap", /* @__PURE__ */ new Map());
    t(this, "useWorker", true);
    t(this, "debugTextAreaMesh", /* @__PURE__ */ new Map());
    i === false && (this.useWorker = false, IV(false)), this.rendererState = r3, this.convertTo3DMapPosition = n;
  }
  remove(r3) {
    this.textSet.delete(r3);
  }
  update(r3) {
    let n, i, o, a = [];
    for (let s3 of this.rendererState.geometry3DIdsInScene) if (n = this.rendererState.geometry3DMap.get(s3), n?.type === "text3d") {
      i = n.components[0], o = n.components[1];
      let l = i.mesh?.parent;
      if (!l || !(l instanceof ur) || !(i instanceof um)) continue;
      if ("textArea" in i.feature.properties && i.mesh != null && i.polygonEntityId != null && i.textMesh == null && i.mesh.parent != null && i.feature.properties?.textArea?.position != null) {
        if (this.textSet.has(i.polygonEntityId)) continue;
        this.textSet.add(i.polygonEntityId), this.batchedTextMap.has(l) || this.batchedTextMap.set(l, ja().then(({ BatchedText: p }) => {
          let h = new p();
          return h.type = "batchedtext", l.add(h), h;
        }));
        let c = this.batchedTextMap.get(l);
        if (!c) throw new Error("batched text required");
        a.push($C({ entityId: s3, textComponent: i, styleComponent: o, convertTo3DMapPosition: this.convertTo3DMapPosition, batchedMeshPromise: c, rendererState: this.rendererState, type: "text-area" }).then(() => {
          this.publish("render");
        }));
      } else if (i.mesh != null && i.textMesh == null && i.mesh.parent != null) {
        if (this.textSet.has(s3.toString())) continue;
        this.textSet.add(s3.toString()), this.batchedTextMap.has(l) || this.batchedTextMap.set(l, ja().then(({ BatchedText: p }) => {
          let h = new p();
          return h.type = "batchedtext", l.add(h), h;
        }));
        let c = this.batchedTextMap.get(l);
        if (!c) throw new Error("batched text required");
        a.push($C({ entityId: s3, textComponent: i, styleComponent: o, convertTo3DMapPosition: this.convertTo3DMapPosition, batchedMeshPromise: c, rendererState: this.rendererState, type: "point" }).then(() => {
          this.publish("render");
        }));
      }
      let u3 = this.batchedTextMap.get(l);
      i.textMesh && u3 && i.polygonEntityId != null && Promise.all([u3, Promise.resolve({ meshComponent: i, styleComponent: o })]).then(([c, { meshComponent: p, styleComponent: h }]) => {
        let { textMesh: f } = p;
        if (c && f) {
          let d = Wg(c, f);
          p.visible && !d ? c.add(f) : !p.visible && d && c.remove(f);
        }
        h.flipToFaceCamera && this.flipIfNeeded(p, r3);
      });
    }
    return Promise.all(a);
  }
  flipIfNeeded(r3, n) {
    let i = r3.textMesh;
    if (!i) return false;
    let o = i.rotation.z, a = qu(o + n);
    a > Math.PI / 2 && a < 3 * Math.PI / 2 && (i.rotation.z = qu(o + Math.PI));
  }
  showTextAreaMesh() {
    let r3, n;
    for (let i of this.rendererState.geometry3DIdsInScene) if (r3 = this.rendererState.geometry3DMap.get(i), r3?.type === "text3d" && (n = r3.components[0], "textArea" in n.feature.properties)) {
      let o = n.feature.properties.textArea;
      if (!o) continue;
      let a = new Ls(o.maxWidth, o.maxHeight), s3 = new ve(a, new ps({ color: "pink" })), { textMesh: l } = n;
      if (!l) continue;
      let u3 = this.convertTo3DMapPosition(o.position, Eu);
      s3.position.copy(u3), s3.position.z = l.position.z - 0.1, s3.rotation.z = l.rotation.z, qg.identity(), qg.makeRotationAxis(new C(0, 0, 1), l.userData.rotationZ), Eu.set(o.maxWidth / 2, 0, 0), Eu.applyMatrix4(qg), s3.position.x -= Eu.x, s3.position.y -= Eu.y, this.rendererState.entityScene.add(s3), this.debugTextAreaMesh.set(i, s3);
    }
    this.publish("render");
  }
  hideTextAreaMesh() {
    this.debugTextAreaMesh.forEach((r3) => {
      this.rendererState.entityScene.remove(r3);
    }), this.debugTextAreaMesh.clear(), this.publish("render");
  }
};
function IV(t63) {
  ja().then(({ configureTroikaTextBuilder: e }) => {
    e({ useWorker: t63 });
  });
}
var qg = new kt();
var Eu = new C();
var Yg;
async function Vve(t63) {
  let { preloadFont: e } = await ja();
  return e(t63);
}
function ja() {
  return Yg || (Yg = import("./text3d-EZBY7L7A-DFM6IF44.js").then((t63) => t63)), Yg;
}
async function $C({ entityId: t63, textComponent: e, styleComponent: r3, convertTo3DMapPosition: n, batchedMeshPromise: i, rendererState: o, type: a = "text-area" }) {
  return Promise.all([ja(), Promise.resolve({ entityId: t63, meshComponent: e, styleComponent: r3 })]).then(([{ createTroikaTextPoint: s3, createTroikaTextArea: l }, u3]) => a === "text-area" ? l(u3.entityId, u3.meshComponent, u3.styleComponent, n) : s3(u3.entityId, u3.meshComponent, u3.styleComponent, n)).catch((s3) => {
    Pt.warn("Trouble creating text: ", s3);
  }).then((s3) => {
    if (!s3?.text) return;
    let l = [Promise.resolve(s3.text), i, Promise.resolve()];
    if (e.polygonEntityId) {
      let u3 = o.geometry3DMap.get(e.polygonEntityId);
      if (u3?.type === "geometry") {
        let c = u3.components[0], p = u3.components[1];
        c.textMesh = s3.text, s3.text.position.z = p.altitude + p.height + AV;
      }
    } else l[2] = ja().then(({ syncText: u3 }) => u3(s3.text));
    return Promise.all(l);
  }).then((s3) => {
    if (!s3) return;
    let [l, u3] = s3;
    u3.add(l), e.batchedText || (e.batchedText = u3);
  });
}
function Wg(t63, e) {
  return t63._members.has(e);
}
var AV = 0.5;
var EV = external_exports.object({ visible: external_exports.boolean(), color: external_exports.string(), flipToFaceCamera: external_exports.boolean(), font: external_exports.string().optional(), fontSize: external_exports.number(), margin: external_exports.union([external_exports.number(), external_exports.tuple([external_exports.number(), external_exports.number(), external_exports.number(), external_exports.number()])]), outlineColor: external_exports.string(), outlineOpacity: external_exports.number(), outlineBlur: external_exports.union([external_exports.number(), external_exports.string()]), outlineWidth: external_exports.number(), outlineOffsetX: external_exports.number(), outlineOffsetY: external_exports.number(), strokeWidth: external_exports.number(), maxWidth: external_exports.number().optional(), maxHeight: external_exports.number().optional(), strokeOpacity: external_exports.number(), strokeColor: external_exports.string(), fillOpacity: external_exports.number(), hoverColor: external_exports.string().optional(), id: external_exports.union([external_exports.string(), external_exports.number()]), type: external_exports.literal("text3d"), position: external_exports.tuple([external_exports.number(), external_exports.number(), external_exports.number()]), content: external_exports.string() });
var KC = external_exports.strictObject(EV.partial().omit({ id: true, type: true }).shape);
var JC = external_exports.strictObject(KC.omit({ margin: true, position: true, maxWidth: true, maxHeight: true, content: true }).shape);
var Zve = external_exports.strictObject({ appearance: KC.optional(), parentId: external_exports.string().optional() });
var um = class {
  constructor(e) {
    t(this, "mesh", new Co());
    t(this, "textMesh");
    t(this, "type", "text3d");
    t(this, "feature");
    t(this, "parent");
    t(this, "batchedText");
    t(this, "polygonEntityId");
    this.feature = e;
  }
  get visible() {
    return this.batchedText && this.textMesh ? Wg(this.batchedText, this.textMesh) : this.textMesh ? this.textMesh.visible : false;
  }
  set visible(e) {
    this.batchedText && this.textMesh ? e ? this.batchedText.addText(this.textMesh) : this.batchedText.removeText(this.textMesh) : this.textMesh && (this.textMesh.visible = e), this.mesh.visible = e;
  }
};
$i();
var Ha;
var cm = class {
  constructor(e) {
    t(this, "color");
    t(this, "dirty", true);
    t(this, "enabled", true);
    v(this, Ha, false);
    t(this, "edgeColors");
    t(this, "edgeVisibility");
    t(this, "geometry");
    t(this, "ranges");
    t(this, "topFaceVerticesIndices");
    this.color = e;
  }
  get currentOpacity() {
    return this.edgeColors && this.ranges ? this.edgeColors.array[this.ranges.start * 4 + 3] : 0;
  }
  set visible(e) {
    if (!this.edgeVisibility || !this.ranges || u(this, Ha) === e) return;
    w(this, Ha, e);
    let r3 = this.edgeVisibility.array, n = e ? 1 : 0;
    for (let i = 0; i < this.ranges.count; i++) {
      let o = this.ranges.start + i;
      r3[o] = n;
    }
    this.edgeVisibility.needsUpdate = true;
  }
  get visible() {
    return u(this, Ha);
  }
  get currentColor() {
    return this.edgeColors && this.ranges ? [this.edgeColors.array[this.ranges.start * 4], this.edgeColors.array[this.ranges.start * 4 + 1], this.edgeColors.array[this.ranges.start * 4 + 2]] : [0, 0, 0];
  }
};
Ha = /* @__PURE__ */ new WeakMap();
$i();
$i();
$i();
var pm = class extends On {
  constructor(r3) {
    let n = r3, i = 3, o = i * 4;
    super(new Uint8Array(r3 * o), i, r3, Pe, cn);
    t(this, "_width");
    t(this, "_height");
    t(this, "_propertiesLength");
    this._width = o, this._height = n, this._propertiesLength = i;
  }
  setColor(r3, n, i) {
    let o = this.image.data, a = r3 * this._width;
    o[a] = Math.round(n.r * 255), o[a + 1] = Math.round(n.g * 255), o[a + 2] = Math.round(n.b * 255), o[a + 3] = 0, o[a + 4] = Math.round(i.r * 255), o[a + 5] = Math.round(i.g * 255), o[a + 6] = Math.round(i.b * 255), o[a + 7] = 0, this.needsUpdate = true;
  }
  getColor(r3) {
    let n = this.image.data, i = r3 * this._width, o = new Nt(n[i] / 255, n[i + 1] / 255, n[i + 2] / 255), a = new Nt(n[i + 4] / 255, n[i + 5] / 255, n[i + 6] / 255);
    return { color: o, topColor: a };
  }
  setTexture(r3, n, i) {
    let o = this.image.data, a = r3 * this._width;
    o[a + 8] = n ? 255 : 0, o[a + 9] = i ? 255 : 0, o[a + 10] = 0, o[a + 11] = 0, this.needsUpdate = true;
  }
  getTexture(r3) {
    let n = this.image.data, i = r3 * this._width, o = n[i + 8] === 255, a = n[i + 9] === 255;
    return { texture: o, topTexture: a };
  }
};
$i();
var QC = `#define LAMBERT
varying vec3 vViewPosition;
varying vec4 vPosition;
varying vec2 vUv;
varying vec4 finalPosition;
varying float vVerticalOffset;
varying vec3 worldNormal;
varying float vBatchId;

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
	
  // To mitigate visual defects on machines such as windows and iOS
	vBatchId = getIndirectIndex(gl_DrawID) + 0.5;
	vViewPosition = - mvPosition.xyz;
	worldNormal = normal;
	vUv = uv;
  vVerticalOffset = position.z;
}
`;
$i();
var eM = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float uGradientEnd;
uniform float uGradientIntensity;
uniform float uMinSideAlpha;
uniform float uMaxSideAlpha;
uniform float uGradientStart;
uniform highp sampler2D uPropertiesTexture;
uniform highp sampler2D uTopTexture;
uniform highp sampler2D uTexture;
uniform float uRepeatYFactor;
uniform bool uBlendTexture;
varying float vBatchId;

varying vec2 vUv;
varying float vVerticalOffset;
varying vec3 worldNormal;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

vec3 blendTextureColor(vec3 diffuseColor, vec4 texColor) {
	vec3 texturedColor = diffuseColor * texColor.rgb;
	return mix(diffuseColor, texturedColor, texColor.a);
}

void main() {
	#include <clipping_planes_fragment>

	// get the normalized world normal of vertex fragment
	vec3 surfaceNormal = normalize(worldNormal);

	// get angle relative to Z up
	float angle = degrees(acos(abs(dot(surfaceNormal, vec3(0.0, 0.0, 1.0)))));

	int idx = int(vBatchId) * 1;
	vec3 diffuse = vec3(texelFetch(uPropertiesTexture, ivec2(0, idx), 0).rgb);
	bool shouldShowTexture = texelFetch(uPropertiesTexture, ivec2(2, idx), 0).r > 0.99;

	if(shouldShowTexture) {
		vec4 tex2d = texture2D(uTexture, vec2(vUv.x, vUv.y * uRepeatYFactor));
		diffuse = uBlendTexture ? blendTextureColor(diffuse, tex2d) : tex2d.rgb;
	}

	// if this is a fragment facing upwards, use topColor. Avoid any sort of '==' comparison, due to floating point precision issue
	if(angle < 0.02) {
		bool shouldShowTopTexture = texelFetch(uPropertiesTexture, ivec2(2, idx), 0).g > 0.99;

		if(shouldShowTopTexture) {
			vec4 topTex2d = texture2D(uTopTexture, vUv);
			diffuse = uBlendTexture ? blendTextureColor(diffuse, topTex2d) : topTex2d.rgb;
		} else {
			diffuse = vec3(texelFetch(uPropertiesTexture, ivec2(1, idx), 0).rgb);
		}
	}

	vec4 diffuseColor = vec4(diffuse, opacity);

	// only for vertical surfaces
	if(angle > 89.0 && angle < 91.0) {

		// get the percentage of the z position from the ground, up
		float percentFromZeroZ = max((abs(vVerticalOffset) - uGradientStart) / uGradientEnd, 0.0);

		// gradient based on percentage
		float alpha = smoothstep(uMinSideAlpha, uMaxSideAlpha, percentFromZeroZ);

		// mix the shadow color with the diffuse color based on the alpha and opacity
		diffuseColor = vec4(mix(diffuseColor.rgb, diffuseColor.rgb * (1.0 - uGradientIntensity), 1.0 - alpha), opacity);
	}

	ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;
var LV = -0.05;
var DV = 1;
var Lu = class extends ol {
  constructor(r3, n, i = 1) {
    super(r3);
    t(this, "propertiesTexture");
    t(this, "texturesVisible", false);
    t(this, "uniforms", { uGradientIntensity: { value: 0 }, uGradientEnd: { value: 0 }, uGradientStart: { value: 0 }, uTopTexture: { value: void 0 }, uTexture: { value: void 0 }, uRepeatYFactor: { value: 1 }, uBlendTexture: { value: false } });
    t(this, "colorSpace", ke);
    t(this, "showTextures", (r4) => {
      this.texturesVisible = true;
      let n3 = !!this.uniforms.uTexture.value, i3 = !!this.uniforms.uTopTexture.value;
      (n3 || i3) && (this.propertiesTexture.setTexture(r4, n3, i3), this.needsUpdate = true);
    });
    this.alphaTest = 0.01, this.propertiesTexture = new pm(n), this.uniforms.uRepeatYFactor.value = i, this.onBeforeCompile = (o) => {
      let a = this.uniforms.uGradientIntensity, s3 = this.uniforms.uGradientEnd, l = this.uniforms.uGradientStart, u3 = this.uniforms.uTopTexture, c = this.uniforms.uTexture, p = this.uniforms.uRepeatYFactor, h = this.uniforms.uBlendTexture;
      this.uniforms = o.uniforms, o.vertexShader = QC, o.fragmentShader = eM, Object.assign(this.uniforms, { uGradientIntensity: a, uGradientEnd: s3, uGradientStart: l, uMinSideAlpha: { value: LV }, uMaxSideAlpha: { value: DV }, uPropertiesTexture: { value: this.propertiesTexture }, uTopTexture: u3, uTexture: c, uRepeatYFactor: p, uBlendTexture: h });
    };
  }
  get repeatYFactor() {
    return this.uniforms.uRepeatYFactor.value;
  }
  set repeatYFactor(r3) {
    r3 !== this.uniforms.uRepeatYFactor.value && (this.uniforms.uRepeatYFactor.value = r3, this.needsUpdate = true);
  }
  get texture() {
    return this.uniforms.uTexture.value;
  }
  set texture(r3) {
    if (r3 == null) {
      this.uniforms.uTexture.value = null;
      return;
    }
    r3.wrapS = Cr, r3.wrapT = Cr, r3.colorSpace = this.colorSpace, this.uniforms.uTexture.value = r3;
  }
  get topTexture() {
    return this.uniforms.uTopTexture.value;
  }
  set topTexture(r3) {
    if (r3 == null) {
      this.uniforms.uTopTexture.value = null;
      return;
    }
    r3.wrapS = Cr, r3.wrapT = Cr, r3.colorSpace = this.colorSpace, this.uniforms.uTopTexture.value = r3;
  }
  get blendTexture() {
    return this.uniforms.uBlendTexture.value;
  }
  set blendTexture(r3) {
    r3 !== this.uniforms.uBlendTexture.value && (this.uniforms.uBlendTexture.value = r3, this.colorSpace = r3 ? ni : ke, this.texture && (this.texture.colorSpace = this.colorSpace), this.topTexture && (this.topTexture.colorSpace = this.colorSpace), this.needsUpdate = true);
  }
  setGradientShading(r3, n, i) {
    this.uniforms.uGradientStart.value = r3, this.uniforms.uGradientEnd.value = n, this.uniforms.uGradientIntensity.value = i;
  }
  getGradientShading() {
    return { start: this.uniforms.uGradientStart.value, end: this.uniforms.uGradientEnd.value, intensity: this.uniforms.uGradientIntensity.value };
  }
  setColor(r3, n, i) {
    this.propertiesTexture.setColor(r3, n, i);
  }
  getColor(r3) {
    return this.propertiesTexture.getColor(r3);
  }
  hideTextures(r3) {
    this.texturesVisible = false;
    let n = !!this.uniforms.uTexture.value, i = !!this.uniforms.uTopTexture.value;
    (n || i) && (this.propertiesTexture.setTexture(r3, false, false), this.needsUpdate = true);
  }
  removeSideTexture(r3) {
    if (this.texture) {
      this.texture.dispose(), this.uniforms.uTexture.value = null;
      let n = !!this.uniforms.uTopTexture.value;
      this.propertiesTexture.setTexture(r3, false, n), this.needsUpdate = true;
    }
  }
  removeTopTexture(r3) {
    if (this.topTexture) {
      this.topTexture.dispose(), this.uniforms.uTopTexture.value = null;
      let n = !!this.uniforms.uTexture.value;
      this.propertiesTexture.setTexture(r3, n, false), this.needsUpdate = true;
    }
  }
  dispose() {
    super.dispose(), this.propertiesTexture.dispose();
  }
};
$i();
var m0e = { top: 0, bottom: 0, left: 0, right: 0, type: "pixel" };
var Du = { enabled: false, thickness: 0, size: 0, offset: 0, segments: 3 };
function d0e(t63, e) {
  return { bevelEnabled: t63?.enabled ?? Du.enabled, bevelThickness: t63?.thickness ?? Du.thickness, bevelSize: t63?.size ?? (t63?.thickness || Du.size), bevelOffset: t63?.offset ?? Du.offset, bevelSegments: t63?.segments ?? Du.segments, depth: e };
}
var tM = "mappedin";
var rM = { GEOMETRY: 0, IMAGE_MESH: 1, ALWAYS_ON_TOP_PATHS: 10, ALWAYS_ON_TOP_MODELS: 11 };
var y0e = 250;
var g0e = "collision-worker.csp.js";
var x0e = "maplibre-worker.csp.js";
$i();
function k0e(t63, e) {
  let r3 = 0;
  for (let u3 of t63) r3 += u3.components[0]?.geometry?.attributes.position.count || 0;
  let n = new Nt(e.color), i;
  i = new Lu({ color: n, side: e.side === "back" ? Le : e.side === "front" ? Mn : ln, opacity: e.opacity ?? 1, transparent: e.opacity !== void 0 ? e.opacity < 1 : false, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1 }, t63.length);
  let o = new Xa(t63.length, r3, 0, i);
  o.renderOrder = rM.GEOMETRY;
  let a, s3, l;
  for (let u3 of t63) a = u3.components[0], !(!(a instanceof Mi) || !a.geometry) && (a.mesh = o, a.material = i, a.instanceIndex = o.addGeometry(a.geometry), o.addInstance(a.instanceIndex), o.userData.entities[a.instanceIndex] = u3.id, i instanceof Lu && i.setColor(a.instanceIndex, n, e.topColor ? new Nt(e.topColor) : n), s3 = o.getGeometryIdAt(a.instanceIndex), a.batchedProps && (l = o.getGeometryRangeAt(s3), l && (a.batchedProps.range = l), a.batchedProps.geometryId = s3));
  return o.perObjectFrustumCulled = true, o.matrixAutoUpdate = false, o;
}
function $g(t63) {
  return oe(t63).darken(30).toRgbString();
}
function F0e(t63, e, r3, n) {
  if (e.length < 1) return;
  t63.boundingBox || t63.computeBoundingBox();
  let i = t63.boundingBox, o = t63.getAttribute("position"), a = t63.getAttribute("normal"), s3 = t63.getAttribute("uv"), l, u3;
  t63.index ? (l = t63.index.count / 3, u3 = function(P, w3) {
    return t63.index.getX(P * 3 + w3);
  }) : (l = o.count / 3, u3 = function(P, w3) {
    return P * 3 + w3;
  });
  let c = new kt();
  c.makeRotationFromQuaternion(new bn().setFromEuler(new Ye(0, 0, r3 / 180 * Math.PI)));
  let p = e.find((P) => P.face === "top"), h;
  p && (h = { min: n(p.bounds[1], p.bounds[0], 0), max: n(p.bounds[3], p.bounds[2], i.max.z) });
  let f = e.find((P) => P.face === "side"), d;
  if (f && (d = { min: n(f.bounds[1], f.bounds[0], 0), max: n(f.bounds[3], f.bounds[2], i.max.z) }), !(!d && !h)) for (let P = 0; P < l; ++P) {
    let w3 = a.getX(u3(P, 0)) + a.getX(u3(P, 1)) + a.getX(u3(P, 2)), T = a.getY(u3(P, 0)) + a.getY(u3(P, 1)) + a.getY(u3(P, 2)), S = a.getZ(u3(P, 0)) + a.getZ(u3(P, 1)) + a.getZ(u3(P, 2)), C3 = Math.abs(w3), A = Math.abs(T), E = Math.abs(S);
    var g, x;
    C3 <= A && C3 <= E ? (g = "x", A <= E ? x = "y" : x = "z") : A <= C3 && A <= E ? (g = "y", C3 <= E ? x = "x" : x = "z") : (g = "z", C3 <= A ? x = "x" : x = "y"), g === "z" && (g = x, x = "z");
    let L, F, O, z, I, R;
    if (x === "z" || g === "z") {
      if (!f || !d) continue;
      L = f.repeat.u, F = f.repeat.v, O = f.offset.u, z = f.offset.v, I = f.rotation, R = d;
    } else {
      if (!p || !h) continue;
      L = p.repeat.u, F = p.repeat.v, O = p.offset.u, z = p.offset.v, I = (360 - r3 + p.rotation) % 360, R = h;
    }
    let { min: H, max: W } = R, $ = new de();
    $.position.set(H.x, H.y, 0), $.updateMatrix(), $.updateMatrixWorld();
    let he = H.clone().applyMatrix4(c), Xe = W.clone().applyMatrix4(c), be = Math.abs(Xe.x - he.x), ye = Math.abs(Xe.y - he.y), Ze = new C(be, ye, W.z).applyMatrix4($.matrixWorld), st = Math.abs(Ze[g] - H[g]), vt = Math.abs(Ze[x] - H[x]), dt = I * Math.PI / 180 || 0, zt = Math.cos(dt), cr = Math.sin(dt), rn = $.matrixWorld.clone().invert(), pr = new bn().setFromEuler(new Ye(0, 0, r3 / 180 * Math.PI));
    for (let Ct = 0; Ct < 3; Ct++) {
      let Lo = new C(o.getX(u3(P, Ct)), o.getY(u3(P, Ct)), o.getZ(u3(P, Ct))).applyMatrix4(rn);
      Lo.applyQuaternion(pr);
      let Li = Lo.applyMatrix4($.matrixWorld), xn = Li.x, Do = Li.y, Mr = Li.z;
      var b, v3;
      g === "x" ? b = L * (xn - H[g]) / st + O : g === "y" ? b = L * (Do - H[g]) / st + O : b = L * (Mr - H[g]) / st + O, x === "x" ? v3 = F * (xn - H[x]) / vt + z : x === "y" ? v3 = F * (Do - H[x]) / vt + z : v3 = F * (Mr - H[x]) / vt + z, b -= 0.5, v3 -= 0.5;
      let Ir = b * zt - v3 * cr + 0.5, Hn = b * cr + v3 * zt + 0.5;
      s3.setX(u3(P, Ct), Ir), s3.setY(u3(P, Ct), Hn);
    }
  }
}
$i();
var hm = class {
  constructor() {
    t(this, "focusMesh");
    t(this, "dirty", true);
  }
};
$i();
var fm = class {
  constructor(e, r3) {
    t(this, "texture");
    t(this, "topTexture");
    t(this, "showTexture", true);
    t(this, "showTopTexture", true);
    t(this, "textureInstance");
    t(this, "topTextureInstance");
    t(this, "dirty", true);
    this.texture = typeof e == "string" ? { path: e } : e, this.topTexture = typeof r3 == "string" ? { path: r3 } : r3;
  }
};
$i();
var mm = class {
  constructor() {
    t(this, "dirty", true);
    t(this, "needsRebuild", false);
    t(this, "mesh");
  }
  set visible(e) {
    this.mesh && (this.mesh.visible = e);
  }
  get visible() {
    return this.mesh ? this.mesh.visible : false;
  }
};
$i();
var dm = class {
  constructor() {
    t(this, "dirty", true);
    t(this, "needsRebuild", false);
    t(this, "verticalOffset", 1 / 0);
    t(this, "plane");
    t(this, "holeFillMesh");
    t(this, "topColor");
    t(this, "topVisible", true);
  }
};
function Ru(t63, e, r3) {
  if (e !== void 0) {
    if (t63.type === "model" || t63.type === "path" || t63.type === "marker" || t63.type === "label" || t63.type === "geometry" || t63.type === "group-container" || t63.type === "custom-geometry") return e === true ? (t63 instanceof Gn && t63.components[1] === void 0 ? (t63.components[1] = new Oa(), t63.components[1].dirty = true) : t63 instanceof Sr && t63.components[2] === void 0 ? (t63.components[2] = new Oa(), t63.components[2].dirty = true) : t63 instanceof ur && t63.components[0] === void 0 && (t63.components[0] = new Oa(), t63.components[0].dirty = true), true) : (t63 instanceof Gn ? t63.components[1] = void 0 : t63 instanceof Sr ? t63.components[2] = void 0 : t63 instanceof ur && (t63.components[0] = void 0), true);
    if (t63.type === "geometry-group") {
      let n;
      for (let i of t63.userData.entities3D.values()) n = r3.geometry3DMap.get(i), Ru(n, e, r3);
      return true;
    }
  }
  return false;
}
function d1e(t63, e, r3) {
  if (!(!r3?.color && !("topColor" in r3))) {
    if (r3 !== void 0 && t63.type === "geometry-group") {
      let n;
      for (let i of t63.userData.entities3D.values()) n = e.geometry3DMap.get(i), n && nM(n, r3);
      return true;
    }
    return false;
  }
}
function FV(t63, e) {
  e !== void 0 && t63.type === "geometry" && (t63.components[1].shading = e, t63.components[1].dirty = true);
}
function y1e(t63, e, r3) {
  if (r3 !== void 0 && t63.type === "geometry-group") {
    for (let n of t63.userData.entities3D.values()) {
      let i = e.geometry3DMap.get(n);
      i && FV(i, r3);
    }
    return true;
  }
  return false;
}
function g1e(t63, e) {
  e !== void 0 && t63.type === "geometry" && (e.showImage !== void 0 && (t63.components[1].showImage = e.showImage), e.flipImageToFaceCamera !== void 0 && (t63.components[1].flipImageToFaceCamera = e.flipImageToFaceCamera));
}
function OV(t63, e, r3) {
  if (r3 !== void 0) {
    if (t63.type === "geometry") {
      let n = t63.components[1];
      if (n.height !== r3) return n.height = r3, n.dirty = true, t63.components[3] && (t63.components[3].dirty = true), t63.components[5] && (t63.components[5].needsRebuild = true, t63.components[5].dirty = true), true;
    } else if (t63.type === "geometry-group") {
      for (let n of t63.userData.entities3D.values()) {
        let i = e.geometry3DMap.get(n);
        (i?.type === "geometry" || i?.type === "model") && OV(i, e, r3);
      }
      return true;
    }
  }
  return false;
}
function nM(t63, e) {
  if (e !== void 0) {
    let r3 = false;
    (t63.type === "path" || t63.type === "geometry") && (e.initialColor !== void 0 && e.initialColor !== t63.components[1].initialColor && (t63.components[1].initialColor = e.initialColor, r3 = true), e.color !== void 0 && e.color !== t63.components[1].color && (t63.components[1].color = e.color, r3 = true, t63.components[3] && (t63.components[3].color = $g(e.color), t63.components[3].dirty = true)), "topColor" in e && (t63.components[1].topColor = e.topColor, r3 = true), r3 && (t63.components[1].dirty = true));
  }
}
function x1e(t63, e, r3) {
  e !== void 0 && (t63.type === "label" || t63.type === "marker" ? t63.updatePosition(r3(e[1], e[0], e[2] || 0)) : t63.type === "custom-geometry" && t63.components[0].position.copy(r3(e[1], e[0], e[2] || 0)));
}
function b1e(t63, e) {
  return e !== void 0 && (t63.type === "marker" || t63.type === "label" || t63.type === "custom-geometry") && t63.parentObject3D !== e && t63.parentObject3D instanceof ur ? (t63.parentObject3D?.removeEntity(t63), e.addEntity(t63), true) : false;
}
function _1e(t63, e) {
  e !== void 0 && (t63.type === "marker" || t63.type === "label") && t63.components[0].enabled !== e && (t63.components[0].enabled = e);
}
function v1e(t63, e, r3) {
  if (e !== void 0 && t63.type === "marker") {
    let n = t63.components[0];
    if (e.contentHTML !== void 0) return n.containerEl.innerHTML = e.contentHTML, n.contentHtml = e.contentHTML, true;
    if (oM(t63, e.placement) && (n.collisionDirty = true), e.dynamicResize !== void 0) return n.options.dynamicResize = e.dynamicResize, true;
    if (e.options != null) {
      try {
        Zg.parse(e.options || {});
      } catch (i) {
        return Pt.error(i), false;
      }
      return e.options.interactive != null && (e.options.interactive === "pointer-events-auto" ? (n.pointerEvents = "auto", Ru(t63, false, r3)) : (n.pointerEvents = "none", Ru(t63, e.options.interactive, r3))), iM(t63, e.options.rank), true;
    }
  }
  return false;
}
function iM(t63, e) {
  return e !== void 0 && (t63.type === "marker" || t63.type === "label") ? (t63.components[0].rank = Ba(e), true) : false;
}
function BV(t63, e) {
  if (e?.options?.appearance == null) return;
  let r3 = e.options.appearance || {}, n = r3.opacity != null && r3.opacity !== t63.appearance.opacity;
  Jg(t63.appearance, r3), n && t63.canShow && t63.visibilityNeedsUpdate !== "hide" && (t63.visibilityNeedsUpdate = "show");
}
function P1e(t63, e, r3) {
  if (e !== void 0 && t63.type === "label") {
    let n = t63.components[0];
    e.text !== void 0 && e.text !== n.text && (n.text = e.text, n.textDirty = true);
    try {
      Rg(e.options ?? {});
    } catch (i) {
      Pt.error(i);
      return;
    }
    (uC(n.appearance, e.options?.appearance || {}) || e.options?.textPlacement != null) && (n.textDirty = true), cC(n.appearance, e.options?.appearance || {}) && (n.pinDirty = true), BV(n, e), oM(t63, e.options?.textPlacement) && (n.currentStrategyIndex = -1), Ru(t63, e.options?.interactive, r3), iM(t63, e.options?.rank);
  }
}
function oM(t63, e) {
  if (e !== void 0) {
    if (t63.type === "label") {
      let r3 = t63.components[0];
      return r3.options.textPlacement = e, true;
    } else if (t63.type === "marker") {
      let r3 = t63.components[0];
      return r3.options.placement = e, true;
    }
  }
  return false;
}
function w1e(t63, e) {
  e !== void 0 && t63.type === "geometry" && (t63.components[1].hoverColor = e, t63.components[1].dirty = true);
}
function T1e(t63, e) {
  if (e !== void 0) {
    let r3 = t63.components[2];
    if (t63.type === "geometry" && r3 != null) return r3.hover = e, r3.dirty = true, true;
  }
  return false;
}
function S1e(t63, e) {
  e !== void 0 && t63.type === "image" && (t63.components[1].flipImageToFaceCamera = e);
}
function C1e(t63, e) {
  e !== void 0 && t63.type === "geometry" && (t63.components[1].enableImageCollisions = e);
}
function aM(t63, e, r3) {
  if (r3 !== void 0) if (t63.type === "model" || t63.type === "path" || t63.type === "geometry" || t63.type === "custom-geometry" || t63.type === "image" || t63.type === "text3d") {
    r3 !== t63.components[1].visible && (t63.components[1].visible = r3, t63.components[1].dirty = true);
    let n = t63.components[3];
    return n && (n.dirty = true), true;
  } else {
    if (t63.type === "geometry-group") return t63.setVisible(r3), true;
    if (t63.type === "group-container") {
      if (t63.visible !== r3) return t63.setVisible(r3), r3 === false && t63.traverse((n) => {
        if (n instanceof gn) {
          let i = e.geometry2DMap.get(n.userData.entityId);
          if (i) {
            let o = i.components[0];
            o instanceof mC && (o.canShow = r3);
          }
        }
      }), true;
    } else if (t63.type === "label") return t63.components[0].visible = r3, true;
  }
  return false;
}
function zV(t63, e, r3) {
  if (r3 !== void 0) if (t63.type === "geometry-group") {
    for (let n of t63.userData.entities3D.values()) {
      let i = e.geometry3DMap.get(n);
      (i?.type === "geometry" || i?.type === "model") && zV(i, e, r3);
    }
    return true;
  } else if (t63.type === "group-container") {
    if (t63.opacity !== r3) {
      t63.setOpacity(r3);
      let n = 1;
      return t63.parent instanceof ur && (n = t63.parent.opacity), sM(t63, e, n), true;
    }
  } else t63 instanceof Sr && t63.components[1].opacity !== r3 && (t63.components[1].opacity = r3, t63.components[1].dirty = true);
  return false;
}
function sM(t63, e, r3 = 1) {
  if (t63.type === "group-container" && "children" in t63 && t63.children.length > 0) {
    let n = r3 * t63.opacity;
    t63.userData.computedOpacity = n;
    for (let i of t63.children) (i instanceof lr && i.type === "geometry-group" || i instanceof ur && i.type === "group-container") && sM(i, e, n);
  } else if (t63.type === "geometry-group") for (let n of t63.userData.entities3D.values()) {
    let i = e.geometry3DMap.get(n), o;
    (i?.type === "geometry" || i?.type === "model") && (o = i.components[1], o.dirty = true);
  }
}
function M1e(t63, e, r3) {
  let n = false;
  if (r3 !== void 0) {
    if (t63.type === "geometry-group") for (let i of t63.userData.entities3D.values()) {
      let o = e.geometry3DMap.get(i);
      o && VV(o, r3);
    }
    return true;
  }
  return n;
}
function VV(t63, e) {
  if (t63.type === "geometry" && (e?.texture != null || e?.topTexture != null)) {
    let r3 = false, n = t63.components[6];
    if (n == null ? (t63.components[6] = new fm(e?.texture, e?.topTexture), r3 = true) : (e?.texture != null && n?.texture !== e?.texture && (n.texture = typeof e.texture == "string" ? { path: e.texture } : e.texture, r3 = true, n.dirty = true), e?.topTexture != null && n?.topTexture !== e?.topTexture && (n.topTexture = typeof e.topTexture == "string" ? { path: e.topTexture } : e.topTexture, r3 = true, n.dirty = true)), r3 && t63.components[0] instanceof Mi) {
      let i = t63.components[0];
      return i.detached === false && (i.shouldDetach = true, i.dirty = true), true;
    }
  }
  return false;
}
function I1e(t63, e) {
  if (e !== void 0 && t63.type === "geometry") {
    let r3 = t63.components[1];
    if (r3.opacity !== e) {
      r3.opacity = e;
      let n = t63.components[0], i = t63.components[3];
      i && (i.dirty = true), n.detached === false && (n.shouldDetach = true, n.dirty = true), r3.dirty = true;
      let o = t63.parentObject3D;
      return o?.type === "geometry-group" && (o.userData.shadingDirty = true), true;
    }
  }
  return false;
}
function UV(t63, e, r3) {
  if (r3 !== void 0) if (t63.type === "geometry" || t63.type === "path" || t63.type === "custom-geometry") {
    let n = t63.components[1];
    if (n.altitude !== r3) return n.altitude = r3, n.dirty = true, t63.components[3] && (t63.components[3].dirty = true), t63.components[5] && (t63.components[5].needsRebuild = true, t63.components[5].dirty = true), true;
  } else {
    if (t63.type === "group-container" && t63.altitude !== r3) return t63.setAltitude(r3), true;
    if (t63.type === "geometry-group") {
      let n;
      for (let i of t63.userData.entities3D.values()) n = e.geometry3DMap.get(i), n && UV(n, e, r3);
    }
  }
  return false;
}
function NV(t63, e, r3) {
  if (r3 !== void 0) {
    if (t63.type === "geometry-group") for (let n of t63.userData.entities3D.values()) {
      let i = e.geometry3DMap.get(n);
      i instanceof Sr && NV(i, e, r3);
    }
    else if (t63.type === "geometry") {
      let n = t63.components[3], i = t63.components[1];
      !n && r3 === true ? t63.components[3] = new cm($g(i.color)) : n && (n.enabled = r3, n.dirty = true);
    }
    return true;
  }
  return false;
}
function A1e(t63, e) {
  if (e !== void 0) {
    let r3, n = 4;
    if (t63.type === "geometry" ? (r3 = t63.components[4], n = 4) : t63.type === "group-container" && (r3 = t63.components[1], n = 1), e === true && r3 == null) return t63.components[n] = new hm(), true;
    if (e === false && r3 != null) return t63.components[n] = void 0, true;
  }
  return false;
}
function E1e(t63, e) {
  if (e !== void 0 && t63.type === "geometry") {
    let r3 = t63.components[1];
    if (r3.renderOrder !== e) {
      r3.renderOrder = e;
      let n = t63.components[0];
      return n.detached === false && (n.shouldDetach = true, n.dirty = true), n.imageMesh && (n.imageMesh.renderOrder = e + 1), r3.dirty = true, true;
    }
  }
  return false;
}
function GV(t63, e, r3) {
  if (r3 != null) {
    if (t63.type === "geometry") {
      let n = t63.components[1];
      n.side !== r3 && (n.side = r3, n.dirty = true);
    } else if (t63.type === "geometry-group") for (let n of t63.userData.entities3D.values()) {
      let i = e.geometry3DMap.get(n);
      i instanceof Sr && GV(i, e, r3);
    }
  }
}
function L1e(t63, e) {
  if (e !== void 0 && t63.type === "geometry") {
    let r3 = t63.components[1], n;
    if (n = t63.components[5], e.borderVisible !== r3.borderVisible && e.borderVisible != null) {
      if (e.borderVisible === true) {
        if (n == null) {
          let i = new mm();
          t63.components[5] = i, n = t63.components[5];
        }
        n.visible = true, n.dirty = true;
      } else e.borderVisible === false && n != null && (n.visible = false, n.dirty = true);
      r3.borderVisible = e.borderVisible;
    }
    r3.borderColor !== e.borderColor && e.borderColor != null && (r3.borderColor = e.borderColor, n && (n.dirty = true)), r3.borderWidth !== e.borderWidth && e.borderWidth != null && (r3.borderWidth = e.borderWidth, n && (n.needsRebuild = true));
  }
}
function D1e(t63, e, r3) {
  let { visible: n, color: i } = r3;
  if (t63.type !== "path") return;
  let o = t63.components[0];
  n != null && aM(t63, e, n), i != null && nM(t63, { color: i }), Object.assign(o, jV(r3)), Kg(r3) || (o.materialDirty = true, r3.width != null && (o.dirty = true));
}
function jV(t63) {
  return ku(t63, HV);
}
var HV = ["animateArrowsOnPath", "displayArrowsOnPath", "width", "accentColor", "completeFraction", "highlightCompleteFraction", "highlightStartFraction", "highlightEndFraction", "highlightColor", "highlightWidthMultiplier", "dashed", "visibleThroughGeometry"];
function R1e(t63) {
  if (!(t63 instanceof Sr && t63.type === "text3d")) throw new Error("expect target is TextGeometry3D");
}
var XV = ["visible", "color", "strokeWidth", "outlineOffsetX", "outlineOffsetY", "outlineWidth", "outlineBlur", "outlineOpacity", "outlineColor", "strokeWidth", "strokeColor", "strokeOpacity", "maxWidth", "maxHeight", "font", "hoverColor", "fillOpacity", "fontSize", "flipToFaceCamera"];
function k1e(t63, e, r3) {
  aM(t63, e, r3.visible);
  let n = t63.components[1], i = ku(r3, XV);
  "margin" in r3 && Pt.warn("update to margin is not supported atm"), "content" in r3 && Pt.warn("content update is not supported atm");
  try {
    JC.parse(i);
  } catch (o) {
    Pt.error(o);
    return;
  }
  Object.keys(i).length > 0 && (Object.assign(n, i), n.dirty = true);
}
var ZV = ["color", "material", "opacity", "verticalOffset", "rotation", "position", "scale"];
function F1e(t63, e) {
  let r3 = ku(e, ZV), n = t63.components[1], i = t63.components[0];
  Object.keys(r3).length > 0 && (r3.material && (n.material = r3.material), r3.opacity != null && (n.opacity = r3.opacity), r3.verticalOffset != null && (n.verticalOffset = r3.verticalOffset), r3.color != null && (n.color = r3.color), r3.position != null && (i.feature.geometry.coordinates = r3.position, i.positionDirty = true), r3.rotation != null && (n.rotation = r3.rotation), r3.scale != null && (n.scale = r3.scale), r3.visibleThroughGeometry != null && (i.visibleThroughGeometry = r3.visibleThroughGeometry), n.dirty = true);
}
function O1e(t63, e) {
  if (e !== void 0 && t63.type === "model") {
    let r3 = t63.components[7];
    r3 == null && (t63.components[7] = new dm(), r3 = t63.components[7]), r3 = t63.components[7], e.clippingPlaneZOffset != null && r3.verticalOffset !== e.clippingPlaneZOffset && (r3.verticalOffset = e.clippingPlaneZOffset, r3.dirty = true), e.clippingPlaneTopColor != null && r3.topColor !== e.clippingPlaneTopColor && (r3.topColor = e.clippingPlaneTopColor, r3.dirty = true), e.clippingPlaneTopVisible != null && r3.topVisible !== e.clippingPlaneTopVisible && (r3.topVisible = e.clippingPlaneTopVisible, r3.dirty = true);
  }
}
$i();
$i();
var tx = s(gM());
function xM(t63) {
  this.name = "JSClipperError", this.message = t63, this.stack = new Error().stack;
}
xM.prototype = Error.prototype;
tx.default.Error = function(t63) {
  throw new xM(t63);
};
var jn = tx.default;
var U4 = "gray";
var rx = new jn.ClipperOffset();
var Zt = 100;
function nx(t63, e, r3) {
  let { color: n = U4, opacity: i = 1, width: o = 1, join: a = "round", cap: s3 = "round", height: l = 0.01, altitude: u3 = 0 } = r3 || {};
  Array.isArray(i) && (i = 0);
  let c = [], p = t63.geometry.coordinates.every((b) => b[2] != null);
  for (let b = 0; b < t63.geometry.coordinates.length - 1; b++) {
    let v3 = e(t63.geometry.coordinates[b][1], t63.geometry.coordinates[b][0], t63.geometry.coordinates[b][2]), P = e(t63.geometry.coordinates[b + 1][1], t63.geometry.coordinates[b + 1][0], t63.geometry.coordinates[b + 1][2]);
    c.push([v3, P]);
  }
  let h = c[0][0].y;
  rx.AddPaths(c.map((b) => b.map((v3) => ({ X: v3.x * Zt, Y: (p ? v3.z : v3.y) * Zt }))), a === "round" ? jn.JoinType.jsRound : a === "miter" ? jn.JoinType.jsMiter : jn.JoinType.jsSquare, s3 === "round" ? jn.EndType.etOpenRound : s3 === "butt" ? jn.EndType.etOpenButt : jn.EndType.etOpenSquare);
  let f = new jn.PolyTree();
  rx.Execute(f, o / 2 * Zt);
  let d = [], g = { bevelEnabled: false, depth: l };
  for (let b of f.m_AllPolys) {
    let v3 = new Zr();
    if (b.IsHole()) continue;
    let P = b.m_polygon;
    v3.moveTo(P[0].X / Zt, P[0].Y / Zt), P.slice(1).forEach((w3) => v3.lineTo(w3.X / Zt, w3.Y / Zt)), v3.lineTo(P[0].X / Zt, P[0].Y / Zt), v3.holes = b.m_Childs.map((w3) => {
      let T = new Cs(), S = w3.m_polygon;
      return T.moveTo(S[0].X / Zt, S[0].Y / Zt), S.slice(1).forEach((C3) => T.lineTo(C3.X / Zt, C3.Y / Zt)), T.lineTo(S[0].X / Zt, S[0].Y / Zt), T;
    }), d.push(new il(v3, g));
  }
  let x = M(d);
  return p && (x.rotateX(Math.PI / 2), x.translate(0, h + l / 2, u3 || 0)), x.userData = { style: { color: n, opacity: i } }, rx.Clear(), x;
}
$i();
$i();
var Cr2 = 63710088e-1;
var Q1e = { centimeters: Cr2 * 100, centimetres: Cr2 * 100, degrees: 360 / (2 * Math.PI), feet: Cr2 * 3.28084, inches: Cr2 * 39.37, kilometers: Cr2 / 1e3, kilometres: Cr2 / 1e3, meters: Cr2, metres: Cr2, miles: Cr2 / 1609.344, millimeters: Cr2 * 1e3, millimetres: Cr2 * 1e3, nauticalmiles: Cr2 / 1852, radians: 1, yards: Cr2 * 1.0936 };
function bM(t63, e, r3 = {}) {
  let n = { type: "Feature" };
  return (r3.id === 0 || r3.id) && (n.id = r3.id), r3.bbox && (n.bbox = r3.bbox), n.properties = e || {}, n.geometry = t63, n;
}
function _M(t63, e, r3 = {}) {
  if (t63.length < 2) throw new Error("coordinates must be an array of two or more positions");
  return bM({ type: "LineString", coordinates: t63 }, e, r3);
}
function vM(t63, e = {}) {
  let r3 = { type: "FeatureCollection" };
  return e.id && (r3.id = e.id), e.bbox && (r3.bbox = e.bbox), r3.features = t63, r3;
}
function PM(t63, e, r3 = {}) {
  return bM({ type: "MultiLineString", coordinates: t63 }, e, r3);
}
$i();
function _m(t63) {
  return t63.type === "Feature" ? t63.geometry : t63;
}
function N4(t63, e = {}) {
  let r3 = _m(t63);
  switch (!e.properties && t63.type === "Feature" && (e.properties = t63.properties), r3.type) {
    case "Polygon":
      return G4(r3, e);
    case "MultiPolygon":
      return j4(r3, e);
    default:
      throw new Error("invalid poly");
  }
}
function G4(t63, e = {}) {
  let n = _m(t63).coordinates, i = e.properties ? e.properties : t63.type === "Feature" ? t63.properties : {};
  return wM(n, i);
}
function j4(t63, e = {}) {
  let n = _m(t63).coordinates, i = e.properties ? e.properties : t63.type === "Feature" ? t63.properties : {}, o = [];
  return n.forEach((a) => {
    o.push(wM(a, i));
  }), vM(o);
}
function wM(t63, e) {
  return t63.length > 1 ? PM(t63, e) : _M(t63[0], e);
}
var ix = N4;
$i();
function TM(t63) {
  t63 && (t63.map && (t63.map.dispose(), t63.map = void 0), t63.dispose());
}
function ox(t63) {
  for (; t63.children.length > 0; ) ox(t63.children[0]);
  "geometry" in t63 && t63.geometry && t63.geometry.dispose(), "material" in t63 && Array.isArray(t63.material) ? t63.material.forEach(function(e) {
    TM(e);
  }) : "material" in t63 && typeof t63.material < "u" && TM(t63.material), t63.parent && t63.parent.remove(t63);
}
$i();
function SM(t63) {
  return t63 != null && t63.geometry.type === "Polygon" && t63.geometry.coordinates[0].length > 2;
}
function H4(t63, e) {
  let r3 = t63[0] * e[0] + t63[1] * e[1], n = Math.sqrt(t63[0] * t63[0] + t63[1] * t63[1]), i = Math.sqrt(e[0] * e[0] + e[1] * e[1]);
  if (n === 0 || i === 0) return 0;
  let o = r3 / (n * i), a = Math.max(-1, Math.min(1, o));
  return Math.acos(a) * (180 / Math.PI);
}
function X4(t63, e = 5) {
  if (t63.length < 3) return t63;
  let r3 = t63.length > 3 && t63[0][0] === t63[t63.length - 1][0] && t63[0][1] === t63[t63.length - 1][1], n = [], i = r3 ? t63.length - 1 : t63.length;
  for (let o = 0; o < i; o++) {
    let a = r3 && o === 0 ? t63[t63.length - 2] : t63[o - 1], s3 = t63[o], l = r3 && o === t63.length - 1 ? t63[1] : t63[o + 1];
    if (a == null || l == null) {
      n.push(s3);
      continue;
    }
    let u3 = [s3[0] - a[0], s3[1] - a[1]], c = [l[0] - s3[0], l[1] - s3[1]];
    H4(u3, c) > e && n.push(s3);
  }
  if (r3 && n.length > 0) {
    let o = n[0], a = n[n.length - 1];
    (o[0] !== a[0] || o[1] !== a[1]) && n.push([o[0], o[1]]);
  }
  return n;
}
function CM(t63, e = 5) {
  return { ...t63, geometry: { ...t63.geometry, coordinates: t63.geometry.coordinates.map((r3) => X4(r3, e)) } };
}
var IM = 0.1;
var Z4 = 15;
var q4 = 0.25;
var MM = class {
  constructor(e, r3) {
    t(this, "rendererState");
    t(this, "dirty", false);
    t(this, "convertTo3DMapPosition");
    t(this, "colorToMaterialCache", {});
    this.rendererState = e, this.convertTo3DMapPosition = r3;
  }
  update() {
    let e, r3, n, i;
    for (let o of this.rendererState.geometry3DIdsInScene) if (e = this.rendererState.geometry3DMap.get(o), e != null && (i = e.components[0], r3 = e.components[1], e.type === "geometry" && i instanceof Mi && SM(i.feature))) {
      if (n = e.components[5], n?.dirty) {
        if (n.mesh == null) try {
          let a = this.buildBorder(i.feature, r3, n);
          i.mesh?.add(a);
        } catch (a) {
          Pt.error(a), n.dirty = false;
        }
        n.mesh?.children.forEach((a) => {
          n && a.material.color.set(r3.borderColor);
        }), n.dirty = false, n.visible = r3.borderVisible;
      }
      if (n?.needsRebuild) {
        ox(n.mesh);
        try {
          let a = this.buildBorder(i.feature, r3, n);
          i.mesh?.add(a);
        } catch (a) {
          Pt.error(a);
        }
        n.needsRebuild = false, n.visible = r3.borderVisible;
      }
    }
  }
  buildBorder(e, r3, n) {
    let i = ix(e), o = CM(e, Z4), a = ix(o), s3 = r3.borderWidth / 2, l = r3.borderColor, u3 = nx(i, this.convertTo3DMapPosition, { width: s3, height: s3, color: l, cap: "square" }), c = u3.clone();
    c.translate(0, 0, r3.height);
    let p;
    a.geometry.type === "LineString" ? p = a.geometry.coordinates : p = a.geometry.coordinates.flat();
    let h = [];
    p.pop();
    for (let P of p || []) try {
      let w3 = nx({ type: "Feature", geometry: { type: "LineString", coordinates: [[P[0], P[1], 0], [P[0], P[1], r3.height]] }, properties: {} }, this.convertTo3DMapPosition, { width: s3, height: s3, color: l, cap: "butt" });
      h.push(w3);
    } catch (w3) {
      Pt.warn(w3);
    }
    let f = M([u3, c, ...h]), d = this.colorToMaterialCache[l]?.[0];
    d == null && (d = new ps({ color: l }));
    let g = this.colorToMaterialCache[l]?.[1];
    g == null && (g = new ps({ color: l })), this.colorToMaterialCache[l] = [d, g];
    let x = new de(), b = new ve(f, d), v3 = new ve(f, g);
    return x.add(b), x.add(v3), v3.material.depthWrite = false, v3.material.depthTest = false, v3.material.opacity = q4, v3.material.transparent = true, x.position.z = r3.altitude ?? 0, n.mesh = x, x;
  }
  destroy() {
    for (let [e, [r3, n]] of Object.entries(this.colorToMaterialCache)) r3.dispose(), n.dispose();
    this.colorToMaterialCache = {};
  }
};
var ax = "#ffffff";
var Y4 = 0.1;
var vm = 0.1;
var W4 = "#333333";
var Bu;
var zu;
var Vu;
var sx = class {
  constructor(e = {}) {
    t(this, "initialColor", ax);
    v(this, Bu, ax);
    t(this, "initialTopColor");
    v(this, zu);
    v(this, Vu);
    t(this, "dirty", true);
    t(this, "visible", true);
    t(this, "opacity", 1);
    t(this, "width", Y4);
    t(this, "height", vm);
    t(this, "initialHeight", vm);
    t(this, "altitude", 0);
    t(this, "join", "round");
    t(this, "cap", "round");
    t(this, "showImage", true);
    t(this, "flipImageToFaceCamera", true);
    t(this, "enableImageCollisions", false);
    t(this, "url");
    t(this, "side", "double");
    t(this, "renderOrder", 0);
    t(this, "shading");
    t(this, "bevel");
    t(this, "borderVisible", false);
    t(this, "borderColor", W4);
    t(this, "borderWidth");
    this.color = e?.color !== void 0 ? e.color : this.color, this.initialColor = this.color, this.width = e?.width !== void 0 ? e.width : this.width, this.opacity = e?.opacity !== void 0 ? e.opacity : this.opacity, this.visible = e?.visible !== void 0 ? e.visible : this.visible, this.height = e?.height !== void 0 ? e.height : this.height, this.initialHeight = this.height, this.altitude = e?.altitude !== void 0 ? e.altitude : this.altitude, this.join = e?.join !== void 0 ? e.join : this.join, this.cap = e?.cap !== void 0 ? e.cap : this.cap, this.topColor = e?.topColor, this.initialTopColor = this.topColor, this.showImage = e?.showImage !== void 0 ? e.showImage : this.showImage, this.flipImageToFaceCamera = e?.flipImageToFaceCamera !== void 0 ? e.flipImageToFaceCamera : this.flipImageToFaceCamera, this.url = e?.url, this.side = e?.side !== void 0 ? e.side : this.side, this.renderOrder = e?.renderOrder !== void 0 ? e.renderOrder : this.renderOrder, this.shading = e?.shading, this.bevel = e?.bevel, this.borderVisible = e?.borderVisible !== void 0 ? e.borderVisible : this.borderVisible, this.borderColor = e?.borderColor !== void 0 ? e.borderColor : this.borderColor, this.borderWidth = e?.borderWidth !== void 0 ? e.borderWidth : IM, this.enableImageCollisions = e?.enableImageCollisions !== void 0 ? e.enableImageCollisions : this.enableImageCollisions;
  }
  set color(e) {
    Zu(e) ? w(this, Bu, e) : Pt.warn(`Failed to update color. Invalid color "${e}".`);
  }
  get color() {
    return u(this, Bu);
  }
  set topColor(e) {
    e === void 0 || Zu(e) ? w(this, zu, e) : Pt.warn(`Failed to update top color. Invalid color "${e}".`);
  }
  get topColor() {
    return u(this, zu);
  }
  set hoverColor(e) {
    Zu(e) ? w(this, Vu, e) : Pt.warn(`Failed to update hover color. Invalid color "${e}".`);
  }
  get hoverColor() {
    return u(this, Vu);
  }
};
Bu = /* @__PURE__ */ new WeakMap(), zu = /* @__PURE__ */ new WeakMap(), Vu = /* @__PURE__ */ new WeakMap();
var Xa = class extends Jo {
  constructor() {
    super(...arguments);
    t(this, "type", "entityBatchedMesh");
    t(this, "userData", { entities: {} });
  }
};
var Uu;
var Eo;
var Mi = class {
  constructor(e) {
    t(this, "mesh");
    t(this, "imageMesh");
    t(this, "textMesh");
    t(this, "textEntityId");
    t(this, "type", "geometry");
    t(this, "dirty", true);
    t(this, "shouldDetach", false);
    t(this, "detached", false);
    t(this, "instanceIndex", -1);
    t(this, "geometry");
    t(this, "batchedProps");
    t(this, "material");
    t(this, "feature");
    t(this, "currentHeight", vm);
    t(this, "color", new Nt());
    t(this, "topColor", new Nt());
    t(this, "position", new C());
    t(this, "altitude", 0);
    v(this, Uu, 1);
    v(this, Eo);
    this.feature = e;
  }
  get visible() {
    return this.mesh && this.instanceIndex !== -1 ? this.mesh.getVisibleAt(this.instanceIndex) : false;
  }
  set visible(e) {
    this.mesh && this.instanceIndex !== -1 && this.mesh.setVisibleAt(this.instanceIndex, e);
  }
  get renderOrder() {
    return this.mesh ? this.mesh.renderOrder : 0;
  }
  set renderOrder(e) {
    this.mesh && (this.mesh.renderOrder = e);
  }
  setColor(e, r3) {
    this.color.set(e), this.topColor.set(r3), this.material && this.material.setColor(this.instanceIndex, this.color, this.topColor);
  }
  getColor() {
    return this.material?.getColor(this.instanceIndex);
  }
  get opacity() {
    return u(this, Uu);
  }
  set opacity(e) {
    if (this.material && (this.material.opacity = e, this.material.transparent = e < 1, this.material.needsUpdate = true), this.imageMesh) {
      let r3 = Array.isArray(this.imageMesh.material) ? this.imageMesh.material : [this.imageMesh.material];
      for (let n of r3) n.opacity = e, n.needsUpdate = true;
    }
    w(this, Uu, e);
  }
  get featureBbox() {
    return u(this, Eo) ? u(this, Eo) : (w(this, Eo, XS(this.feature)), u(this, Eo));
  }
};
Uu = /* @__PURE__ */ new WeakMap(), Eo = /* @__PURE__ */ new WeakMap();
var lr = class extends de {
  constructor(r3) {
    super();
    t(this, "visible", true);
    t(this, "type", "geometry-group");
    t(this, "components", []);
    t(this, "userData", { entityId: "", entities3D: /* @__PURE__ */ new Set(), dirty: true, shadingDirty: true });
    this.userData.entityId = r3;
  }
  setVisible(r3) {
    this.visible !== r3 && (this.visible = r3, this.dispatchEvent({ type: "childremoved", child: this }));
  }
  removeEntity() {
    this.dispatchEvent({ type: "childremoved", child: this });
  }
  getfirstChildEntityId() {
    let r3;
    for (let i of this.children) if (!i.userData.detached) {
      r3 = i;
      break;
    }
    return r3 instanceof Xa ? Object.values(r3.userData.entities)[0] : void 0;
  }
};
var ur = class t62 extends de {
  constructor(r3) {
    super();
    t(this, "childrenIds", /* @__PURE__ */ new Set());
    t(this, "children", []);
    t(this, "type", "group-container");
    t(this, "userData", { entityId: "", entities2D: /* @__PURE__ */ new Set(), dirty: true, occluderDirty: false, opacity: 1, computedOpacity: 1, preloadGeometry: false });
    t(this, "components", []);
    this.userData.entityId = r3;
  }
  addOccluderFeature(r3, n) {
    this.userData.occluderFeature = r3, this.userData.occluderId = n, this.userData.occluderDirty = true;
  }
  addEntity(r3) {
    r3 instanceof t62 ? (this.childrenIds.add(r3.userData.entityId), this.add(r3)) : r3 instanceof Gn ? (this.childrenIds.add(r3.id), this.add(r3.object3d), this.userData.entities2D.add(r3.id), r3.positionDirty = true) : r3 instanceof lr ? (this.childrenIds.add(r3.userData.entityId), this.add(r3)) : r3 instanceof Sr && r3.object3d && (this.childrenIds.add(r3.id), this.add(r3.object3d)), this.dispatchEvent({ type: "childadded", child: this });
  }
  removeEntity(r3) {
    r3 instanceof t62 ? (this.childrenIds.delete(r3.userData.entityId), this.remove(r3)) : r3 instanceof Gn ? (this.childrenIds.delete(r3.id), this.userData.entities2D.delete(r3.id), this.remove(r3.object3d)) : r3 instanceof lr ? (this.childrenIds.delete(r3.userData.entityId), this.remove(r3)) : r3 instanceof Sr && r3.object3d && (this.childrenIds.delete(r3.id), this.add(r3.object3d)), this.dispatchEvent({ type: "childremoved", child: this });
  }
  setVisible(r3) {
    this.visible !== r3 && (this.visible = r3, this.dispatchEvent({ type: "childremoved", child: this }));
  }
  setAltitude(r3) {
    this.position.z !== r3 && (this.position.z = r3, this.dispatchEvent({ type: "childremoved", child: this }), this.set2DGeometryChildrenPositionDirty());
  }
  set2DGeometryChildrenPositionDirty() {
    this.children.forEach((r3) => {
      r3 instanceof gn ? r3.userData.worldPositionDirty = true : r3 instanceof t62 && r3.set2DGeometryChildrenPositionDirty();
    });
  }
  get altitude() {
    return this.position.z;
  }
  setOpacity(r3) {
    this.userData.opacity = r3;
  }
  get opacity() {
    return this.userData.opacity;
  }
};
$i();
function $4(t63) {
  let e = t63.min, r3 = t63.max, n = new C(e.x, e.y, e.z), i = new C(r3.x, e.y, e.z), o = new C(e.x, r3.y, e.z), a = new C(r3.x, r3.y, e.z);
  return [n, i, o, a];
}
$i();
function AM(t63, e) {
  let r3;
  return typeof e == "string" || typeof e == "number" ? (r3 = t63.geometry2DMap.get(e), r3 == null && (r3 = t63.geometry3DMap.get(e))) : typeof e?.id == "string" || typeof e?.id == "number" ? (r3 = t63.geometry2DMap.get(e.id), r3 == null && (r3 = t63.geometry3DMap.get(e.id))) : r3 = e, r3;
}
function $Pe(t63, e, r3 = [], n = new Ie(), i) {
  (t63.getSystems().renderSystem.threeDdirty || t63.getSystems().renderSystem.twoDdirty) && t63.renderSync();
  let o = AM(t63.getInternalState(), e);
  return EM(o, r3, n, i), r3;
}
var Pm = new C();
function EM(t63, e = [], r3 = new Ie(), n) {
  if (t63.visible) {
    if (t63.isMesh || t63.isLine || t63.isPoints) {
      let i = t63.geometry;
      if (i.isBufferGeometry) {
        let o = i.attributes.position;
        for (let a = 0; a < o.count; a++) Pm.fromBufferAttribute(o, a), n !== void 0 && (Pm.z = n), e.push(Pm.clone()), r3.expandByPoint(Pm);
      }
    }
    for (let i of t63.children) EM(i, e, r3, n);
  }
}
$i();
function K4() {
  return typeof window > "u" ? 1 : Math.min(window.devicePixelRatio, 2);
}
$i();
function J4(t63, e, r3 = false) {
  let n = null, i = 0;
  return function(...o) {
    i++, i === 1 && r3 === true && t63(...o);
    let a = () => {
      (!r3 || i > 1) && t63(...o), n = null, i = 0;
    };
    clearTimeout(n), n = setTimeout(a, e);
  };
}
$i();
var Q4 = /* @__PURE__ */ (() => {
  let t63;
  return { getDeviceType() {
    if (t63) return t63;
    let { userAgent: e, platform: r3, maxTouchPoints: n } = window.navigator, i = /(iphone|ipod|ipad)/i.test(e), o = r3 === "iPad" || r3.indexOf("Mac") === 0 && n > 0 && !window.MSStream, a = /android/i.test(e);
    return t63 = { isIpad: o, isMobile: a || i || o, isSafari12: /Version\/12.+Safari/.test(e), isFirefox: /Firefox/.test(e), isWindows: /windows/i.test(e) }, t63;
  }, _reset() {
    t63 = void 0;
  } };
})();
var LM = Q4.getDeviceType;
var DM = /* @__PURE__ */ (() => {
  let t63, e, r3;
  function n() {
    if (e !== void 0) return e;
    t63 || (t63 = document.createElement("canvas"));
    let o = t63.getContext("webgl") || t63.getContext("experimental-webgl");
    if (!o) return e;
    try {
      let a = LM().isFirefox ? null : o.getExtension("WEBGL_debug_renderer_info");
      return e = a ? o.getParameter(a.UNMASKED_RENDERER_WEBGL) : o.getParameter(o.RENDERER), e;
    } catch {
      let s3 = new Error("Failed getting device info");
      throw s3.name = "FailedGettingDeviceInfo", s3;
    }
  }
  function i() {
    if (!LM().isWindows) return false;
    if (r3 !== void 0) return r3;
    let o = e5()?.toLowerCase() ?? "";
    return r3 = o.includes("intel") && (o.includes("uhd") || o.includes("iris")), r3;
  }
  return { getInfo: n, shouldDisableOffscreenCanvas: i, _setCanvas(o) {
    t63 = o, e = void 0, r3 = void 0;
  } };
})();
var e5 = DM.getInfo;
var t510 = DM.shouldDisableOffscreenCanvas;
$i();
function ku(t63, e) {
  let r3 = {};
  for (let n = 0; n < e.length; n++) {
    let i = e[n];
    i in t63 && (r3[i] = t63[i]);
  }
  return r3;
}
function Kg(t63) {
  return Object.keys(t63).length === 0;
}
$i();
var r5 = (t63) => (e) => {
  if (!e.includes("mappedin")) {
    let r3 = {};
    for (let n in t63) {
      let i = t63[n];
      e.includes("mappedin") || (t63[n] = i);
    }
    return { url: e, headers: r3 };
  }
  return { url: e, headers: t63 };
};
function xwe(t63, e, r3, n) {
  let i = t63 * (Math.PI / 180), o = n / Zn, a = t63 + o * 180 / Math.PI, s3 = r3 / Zn / Math.cos(i), l = e + s3 * 180 / Math.PI;
  return { lat: a, lon: l };
}
function bwe(t63, e, r3, n) {
  let i = r3 * (Math.PI / 180), o = n * (Math.PI / 180), a = t63 * (Math.PI / 180), s3 = e * (Math.PI / 180), l = i - a, u3 = o - s3, c = Zn * u3 * Math.cos(a), p = Zn * l;
  return { x: c, y: p };
}
var n5 = (t63, e, r3, n = false) => {
  let i = t63 instanceof ur && t63.userData.preloadGeometry, o = n || i && !t63.visible;
  if (t63.children && (t63.visible || i)) for (let a of t63.children) {
    if (a.visible && a.type && !o) if ("entities3D" in a.userData && a.userData?.entities3D && a instanceof lr) {
      e.add(a.userData.entityId);
      for (let s3 of a.userData.entities3D.values()) e.add(s3);
    } else (a.type === "group-container" || a.type === "custom-geometry" || a instanceof Co) && e.add(a.userData.entityId);
    a instanceof lr && a.userData.dirty && r3.add(a.userData.entityId), n5(a, e, r3, o);
  }
  return e;
};
var i5 = (t63, e) => {
  if (t63.children && t63.visible && !t63.userData?.hidden) for (let r3 of t63.children) r3.visible && r3 instanceof gn && e.add(r3.userData.entityId), i5(r3, e);
  return e;
};
function Jg(t63, e) {
  for (let r3 in e) if (!(r3 === "__proto__" || r3 === "constructor" || r3 === "prototype")) {
    if (e[r3] == null) {
      t63[r3] = void 0;
      continue;
    }
    Array.isArray(e[r3]) ? t63[r3] = e[r3] : typeof e[r3] == "object" ? Jg(t63[r3], e[r3]) : t63[r3] = e[r3];
  }
  return t63;
}
function _we(t63, e, r3) {
  let n = { translateX: t63.x, translateY: t63.y, translateZ: t63.z, scale: t63.meterInMercatorCoordinateUnits() }, i = new kt(), o = new C(n.scale, -n.scale, n.scale), a = new kt().makeTranslation(n.translateX, n.translateY, n.translateZ).scale(o);
  return { id: tM, type: "custom", renderingMode: "3d", render: (s3, l) => {
    i.fromArray(l.defaultProjectionData.mainMatrix), e.projectionMatrix = i.multiply(a), r3();
  } };
}
function o5(t63) {
  return fetch(t63, { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ grant_type: "client_credentials" }) });
}
async function vwe(t63) {
  let e = await o5(t63), { access_token: r3 } = await e.json();
  return { "x-mappedin-tiles-key": r3 };
}
function Pwe(t63, e = 0) {
  let r3 = 3735928559 ^ e, n = 1103547991 ^ e;
  for (let i = 0, o; i < t63.length; i++) o = t63.charCodeAt(i), r3 = Math.imul(r3 ^ o, 2654435761), n = Math.imul(n ^ o, 1597334677);
  return r3 = Math.imul(r3 ^ r3 >>> 16, 2246822507) ^ Math.imul(n ^ n >>> 13, 3266489909), n = Math.imul(n ^ n >>> 16, 2246822507) ^ Math.imul(r3 ^ r3 >>> 13, 3266489909), 4294967296 * (2097151 & n) + (r3 >>> 0);
}
function wwe(t63, e, r3) {
  let n = t63 * (Math.PI / 180) / 2, i = e / 2;
  return r3 * Math.tan(n) / i;
}
function Twe(t63) {
  return new mt(new J(t63[0][0], t63[0][1]), new J(t63[1][0], t63[1][1])).getCenter().toArray();
}
function Swe(t63, e) {
  return t63 < e || e <= 12;
}
function Cwe(t63) {
  let e = 1;
  return t63.type === "geometry-group" && t63.parent != null && t63.parent instanceof ur ? e = t63.parent.userData.computedOpacity : (t63.type === "geometry" || t63.type === "custom-geometry" || t63.type === "model") && t63.parentObject3D != null && t63.parentObject3D instanceof lr && t63.parentObject3D.parent != null && t63.parentObject3D.parent instanceof ur && (e = t63.parentObject3D.parent.userData.computedOpacity), e;
}
function Mwe(t63, e, r3 = 1e-10) {
  if (t63.length !== e.length) return false;
  let n = Math.abs(t63[0] - e[0]) < r3, i = Math.abs(t63[1] - e[1]) < r3;
  if (t63.length === 3 && e.length === 3) {
    let o = Math.abs(t63[2] - e[2]) < r3;
    return n && i && o;
  }
  return n && i;
}
var a5 = "maplibre-frustum-culling-hack";
function Iwe() {
  let t63 = new ki(0.01, 0.01, 0.01), e = new ps({ opacity: 0, depthWrite: false, transparent: true }), r3 = new ve(t63, e);
  return r3.position.copy(new C(0, 50, 0)), r3.frustumCulled = false, r3.name = a5, r3;
}
var Ei = new C();
var RM = new at();
function Awe(t63, e, r3 = new Al()) {
  return t63.traverse((n) => {
    if (n instanceof ve) {
      let o = n.geometry.attributes.position;
      if (e.position.distanceTo(n.position) < e.near) return;
      for (let s3 = 0; s3 < o.count; s3++) Ei.fromBufferAttribute(o, s3), Ei.applyMatrix4(n.matrixWorld), Ei.applyMatrix4(e.matrixWorldInverse), Ei.applyMatrix4(e.projectionMatrix), Ei.z < 1 && Ei.z > 0 && (RM.set(Ei.x, Ei.y), r3.expandByPoint(RM));
    }
  }), r3;
}
function kM(t63, e) {
  let r3 = e.clientWidth, n = e.clientHeight;
  return new at((t63.x + 1) * r3 / 2, (1 - t63.y) * n / 2);
}
function Ewe(t63, e, r3) {
  let n = document.createElement("div");
  n.style.position = "absolute", n.style.border = `2px solid ${e}`, n.style.pointerEvents = "none";
  let i = kM(new at(t63.min.x, t63.min.y), r3), o = kM(new at(t63.max.x, t63.max.y), r3);
  n.style.left = `${i.x}px`, n.style.top = `${o.y}px`;
  let a = Math.abs(o.x - i.x), s3 = Math.abs(o.y - i.y);
  return n.style.width = `${a}px`, n.style.height = `${s3}px`, r3.appendChild(n), n;
}
function Lwe(t63, e) {
  let r3 = 0, n = 0, i = t63.clientWidth, o = t63.clientHeight;
  if (e) {
    let { left: a, top: s3, right: l, bottom: u3, type: c } = e, p = a ?? 0, h = s3 ?? 0, f = l ?? 0, d = u3 ?? 0;
    c === "portion" ? (r3 = p * i, n = h * o, i = i - r3 - f * i, o = o - n - d * o) : (r3 = p, n = h, i = i - r3 - f, o = o - n - d);
  }
  return [r3, n, i, o].map((a) => Math.max(a, 0));
}
$i();
var lx = class {
  constructor(e) {
    t(this, "visible");
    t(this, "altitude");
    t(this, "color");
    t(this, "dirty", true);
    t(this, "maxWidth");
    t(this, "maxHeight");
    t(this, "hoverByPolygon");
    t(this, "flipToFaceCamera", FM.flipToFaceCamera);
    t(this, "font");
    t(this, "fillOpacity");
    t(this, "fontSize");
    t(this, "margin");
    t(this, "outlineWidth");
    t(this, "outlineBlur");
    t(this, "outlineOffsetX");
    t(this, "strokeColor");
    t(this, "strokeOpacity");
    t(this, "strokeWidth");
    t(this, "hoverColor");
    t(this, "outlineOffsetY");
    t(this, "outlineColor");
    t(this, "outlineOpacity");
    e && Object.assign(this, e);
  }
  getState(e = false) {
    let r3 = {};
    for (let n in this) !e && n === "dirty" || this[n] !== void 0 && (r3[n] = this[n]);
    return r3;
  }
};
var FM = Object.freeze({ visible: true, color: "black", flipToFaceCamera: true, fillOpacity: 1, font: void 0, fontSize: 2, margin: [0.2, 1, 0.2, 1.5], outlineColor: "black", outlineOpacity: 1, outlineWidth: 0, outlineOffsetX: 0, outlineOffsetY: 0, outlineBlur: 0, strokeOpacity: 1, strokeWidth: 0, maxWidth: void 0, maxHeight: void 0, strokeColor: "black", hoverColor: void 0 });
$i();
$i();
var ux = class {
  constructor(e) {
    t(this, "dirty", true);
    t(this, "visible", true);
    t(this, "opacity", 1);
    t(this, "verticalOffset", 0);
    t(this, "interactive", false);
    t(this, "color");
    t(this, "material");
    t(this, "rotation");
    t(this, "scale");
    t(this, "visibleThroughGeometry", false);
    t(this, "clippingPlaneZOffset", 1 / 0);
    t(this, "clippingPlaneTopColor");
    t(this, "clippingPlaneTopVisible", true);
    e && Object.assign(this, e);
  }
};
$i();
var s5 = [1, 1, 1];
var l5 = [0, 0, 0];

export {
  external_exports,
  zod_default,
  jC,
  NM,
  u5,
  Pt,
  Zn,
  XM,
  ZM,
  T5,
  Hu,
  S5,
  C5,
  qM,
  M5,
  I5,
  A5,
  k5,
  $a,
  Ex,
  U5,
  Vt,
  H5,
  Ka,
  Rm,
  Zu,
  tN,
  rN,
  Ox,
  tI,
  aN,
  nI,
  sN,
  qu,
  xe,
  Cf,
  Ig,
  WB,
  r_e,
  Ci,
  $B,
  a_e,
  jS,
  s_e,
  l_e,
  u_e,
  c_e,
  p_e,
  h_e,
  f_e,
  $f,
  x_e,
  JB,
  b_e,
  HS,
  ZS,
  rz,
  D_e,
  oe,
  iC,
  Dg,
  oC,
  sC,
  Y_e,
  mC,
  Xg,
  xve,
  qC,
  Co,
  Sr,
  Gn,
  WC,
  IV,
  Vve,
  EV,
  JC,
  Zve,
  um,
  cm,
  Lu,
  m0e,
  d0e,
  tM,
  rM,
  y0e,
  g0e,
  x0e,
  k0e,
  $g,
  F0e,
  hm,
  fm,
  dm,
  Ru,
  d1e,
  y1e,
  g1e,
  OV,
  nM,
  x1e,
  b1e,
  _1e,
  v1e,
  P1e,
  w1e,
  T1e,
  S1e,
  C1e,
  aM,
  zV,
  M1e,
  VV,
  I1e,
  UV,
  NV,
  A1e,
  E1e,
  GV,
  L1e,
  D1e,
  jV,
  R1e,
  k1e,
  F1e,
  O1e,
  jn,
  nx,
  ox,
  MM,
  ax,
  sx,
  Xa,
  Mi,
  lr,
  ur,
  $4,
  AM,
  $Pe,
  K4,
  J4,
  t510 as t5,
  r5,
  xwe,
  bwe,
  n5,
  i5,
  _we,
  vwe,
  Pwe,
  wwe,
  Twe,
  Swe,
  Cwe,
  Mwe,
  Iwe,
  Awe,
  Ewe,
  Lwe,
  lx,
  FM,
  ux,
  s5,
  l5
};
//# sourceMappingURL=chunk-4WA6YUVK.js.map
