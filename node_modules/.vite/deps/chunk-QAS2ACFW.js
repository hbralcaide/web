import {
  $i,
  $u,
  Ku,
  Qu,
  ge,
  xe
} from "./chunk-X36R2MTZ.js";

// node_modules/@mappedin/mappedin-js/lib/esm/chunk-MLCPE7I2.js
$i();
function M(o, l = false) {
  let r = o[0].index !== null, f = new Set(Object.keys(o[0].attributes)), i = new Set(Object.keys(o[0].morphAttributes)), c = {}, e = {}, h = o[0].morphTargetsRelative, u = new ge(), d = 0;
  for (let t = 0; t < o.length; ++t) {
    let s = o[t], a = 0;
    if (r !== (s.index !== null)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + t + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
    for (let n in s.attributes) {
      if (!f.has(n)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + t + '. All geometries must have compatible attributes; make sure "' + n + '" attribute exists among all geometries, or in none of them.'), null;
      c[n] === void 0 && (c[n] = []), c[n].push(s.attributes[n]), a++;
    }
    if (a !== f.size) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + t + ". Make sure all geometries have the same number of attributes."), null;
    if (h !== s.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + t + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
    for (let n in s.morphAttributes) {
      if (!i.has(n)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + t + ".  .morphAttributes must be consistent throughout all geometries."), null;
      e[n] === void 0 && (e[n] = []), e[n].push(s.morphAttributes[n]);
    }
    if (l) {
      let n;
      if (r) n = s.index.count;
      else if (s.attributes.position !== void 0) n = s.attributes.position.count;
      else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + t + ". The geometry must have either an index or a position attribute"), null;
      u.addGroup(d, n, t), d += n;
    }
  }
  if (r) {
    let t = 0, s = [];
    for (let a = 0; a < o.length; ++a) {
      let n = o[a].index;
      for (let m = 0; m < n.count; ++m) s.push(n.getX(m) + t);
      t += o[a].attributes.position.count;
    }
    u.setIndex(s);
  }
  for (let t in c) {
    let s = B(c[t]);
    if (!s) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + t + " attribute."), null;
    u.setAttribute(t, s);
  }
  for (let t in e) {
    let s = e[t][0].length;
    if (s === 0) break;
    u.morphAttributes = u.morphAttributes || {}, u.morphAttributes[t] = [];
    for (let a = 0; a < s; ++a) {
      let n = [];
      for (let p = 0; p < e[t].length; ++p) n.push(e[t][p][a]);
      let m = B(n);
      if (!m) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + t + " morphAttribute."), null;
      u.morphAttributes[t].push(m);
    }
  }
  return u;
}
function B(o) {
  let l, r, f, i = -1, c = 0;
  for (let d = 0; d < o.length; ++d) {
    let t = o[d];
    if (l === void 0 && (l = t.array.constructor), l !== t.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
    if (r === void 0 && (r = t.itemSize), r !== t.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
    if (f === void 0 && (f = t.normalized), f !== t.normalized) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
    if (i === -1 && (i = t.gpuType), i !== t.gpuType) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
    c += t.count * r;
  }
  let e = new l(c), h = new xe(e, r, f), u = 0;
  for (let d = 0; d < o.length; ++d) {
    let t = o[d];
    if (t.isInterleavedBufferAttribute) {
      let s = u / r;
      for (let a = 0, n = t.count; a < n; a++) for (let m = 0; m < r; m++) {
        let p = t.getComponent(a, m);
        h.setComponent(a + s, m, p);
      }
    } else e.set(t.array, u);
    u += t.count * r;
  }
  return i !== void 0 && (h.gpuType = i), h;
}
function R(o, l) {
  if (l === $u) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), o;
  if (l === Qu || l === Ku) {
    let r = o.getIndex();
    if (r === null) {
      let e = [], h = o.getAttribute("position");
      if (h !== void 0) {
        for (let u = 0; u < h.count; u++) e.push(u);
        o.setIndex(e), r = o.getIndex();
      } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), o;
    }
    let f = r.count - 2, i = [];
    if (l === Qu) for (let e = 1; e <= f; e++) i.push(r.getX(0)), i.push(r.getX(e)), i.push(r.getX(e + 1));
    else for (let e = 0; e < f; e++) e % 2 === 0 ? (i.push(r.getX(e)), i.push(r.getX(e + 1)), i.push(r.getX(e + 2))) : (i.push(r.getX(e + 2)), i.push(r.getX(e + 1)), i.push(r.getX(e)));
    i.length / 3 !== f && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    let c = o.clone();
    return c.setIndex(i), c.clearGroups(), c;
  } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", l), o;
}

export {
  M,
  R
};
//# sourceMappingURL=chunk-QAS2ACFW.js.map
