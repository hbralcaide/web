import {
  $y,
  Cr,
  bH,
  da,
  fI,
  ge,
  mI
} from "./chunk-WRTOVFXP.js";
import {
  Ka
} from "./chunk-4WA6YUVK.js";
import "./chunk-QAS2ACFW.js";
import {
  $i,
  Nt
} from "./chunk-X36R2MTZ.js";
import {
  t
} from "./chunk-J7CDIHLL.js";
import "./chunk-PLDDJCW6.js";

// node_modules/@mappedin/mappedin-js/lib/esm/inspector-66PSYVJU.js
$i();
$i();
$i();
$i();
var M = class n {
  constructor(e, i, t2, s, o = "div") {
    this.parent = e, this.object = i, this.property = t2, this._disabled = false, this._hidden = false, this.initialValue = this.getValue(), this.domElement = document.createElement(o), this.domElement.classList.add("controller"), this.domElement.classList.add(s), this.$name = document.createElement("div"), this.$name.classList.add("name"), n.nextNameID = n.nextNameID || 0, this.$name.id = `lil-gui-name-${++n.nextNameID}`, this.$widget = document.createElement("div"), this.$widget.classList.add("widget"), this.$disable = this.$widget, this.domElement.appendChild(this.$name), this.domElement.appendChild(this.$widget), this.domElement.addEventListener("keydown", (a) => a.stopPropagation()), this.domElement.addEventListener("keyup", (a) => a.stopPropagation()), this.parent.children.push(this), this.parent.controllers.push(this), this.parent.$children.appendChild(this.domElement), this._listenCallback = this._listenCallback.bind(this), this.name(t2);
  }
  name(e) {
    return this._name = e, this.$name.textContent = e, this;
  }
  onChange(e) {
    return this._onChange = e, this;
  }
  _callOnChange() {
    this.parent._callOnChange(this), this._onChange !== void 0 && this._onChange.call(this, this.getValue()), this._changed = true;
  }
  onFinishChange(e) {
    return this._onFinishChange = e, this;
  }
  _callOnFinishChange() {
    this._changed && (this.parent._callOnFinishChange(this), this._onFinishChange !== void 0 && this._onFinishChange.call(this, this.getValue())), this._changed = false;
  }
  reset() {
    return this.setValue(this.initialValue), this._callOnFinishChange(), this;
  }
  enable(e = true) {
    return this.disable(!e);
  }
  disable(e = true) {
    return e === this._disabled ? this : (this._disabled = e, this.domElement.classList.toggle("disabled", e), this.$disable.toggleAttribute("disabled", e), this);
  }
  show(e = true) {
    return this._hidden = !e, this.domElement.style.display = this._hidden ? "none" : "", this;
  }
  hide() {
    return this.show(false);
  }
  options(e) {
    let i = this.parent.add(this.object, this.property, e);
    return i.name(this._name), this.destroy(), i;
  }
  min(e) {
    return this;
  }
  max(e) {
    return this;
  }
  step(e) {
    return this;
  }
  decimals(e) {
    return this;
  }
  listen(e = true) {
    return this._listening = e, this._listenCallbackID !== void 0 && (cancelAnimationFrame(this._listenCallbackID), this._listenCallbackID = void 0), this._listening && this._listenCallback(), this;
  }
  _listenCallback() {
    this._listenCallbackID = requestAnimationFrame(this._listenCallback);
    let e = this.save();
    e !== this._listenPrevValue && this.updateDisplay(), this._listenPrevValue = e;
  }
  getValue() {
    return this.object[this.property];
  }
  setValue(e) {
    return this.getValue() !== e && (this.object[this.property] = e, this._callOnChange(), this.updateDisplay()), this;
  }
  updateDisplay() {
    return this;
  }
  load(e) {
    return this.setValue(e), this._callOnFinishChange(), this;
  }
  save() {
    return this.getValue();
  }
  destroy() {
    this.listen(false), this.parent.children.splice(this.parent.children.indexOf(this), 1), this.parent.controllers.splice(this.parent.controllers.indexOf(this), 1), this.parent.$children.removeChild(this.domElement);
  }
};
var W = class extends M {
  constructor(e, i, t2) {
    super(e, i, t2, "boolean", "label"), this.$input = document.createElement("input"), this.$input.setAttribute("type", "checkbox"), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$widget.appendChild(this.$input), this.$input.addEventListener("change", () => {
      this.setValue(this.$input.checked), this._callOnFinishChange();
    }), this.$disable = this.$input, this.updateDisplay();
  }
  updateDisplay() {
    return this.$input.checked = this.getValue(), this;
  }
};
function V(n3) {
  let e, i;
  return (e = n3.match(/(#|0x)?([a-f0-9]{6})/i)) ? i = e[2] : (e = n3.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/)) ? i = parseInt(e[1]).toString(16).padStart(2, 0) + parseInt(e[2]).toString(16).padStart(2, 0) + parseInt(e[3]).toString(16).padStart(2, 0) : (e = n3.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i)) && (i = e[1] + e[1] + e[2] + e[2] + e[3] + e[3]), i ? "#" + i : false;
}
var _e = { isPrimitive: true, match: (n3) => typeof n3 == "string", fromHexString: V, toHexString: V };
var D = { isPrimitive: true, match: (n3) => typeof n3 == "number", fromHexString: (n3) => parseInt(n3.substring(1), 16), toHexString: (n3) => "#" + n3.toString(16).padStart(6, 0) };
var Ee = { isPrimitive: false, match: (n3) => Array.isArray(n3), fromHexString(n3, e, i = 1) {
  let t2 = D.fromHexString(n3);
  e[0] = (t2 >> 16 & 255) / 255 * i, e[1] = (t2 >> 8 & 255) / 255 * i, e[2] = (t2 & 255) / 255 * i;
}, toHexString([n3, e, i], t2 = 1) {
  t2 = 255 / t2;
  let s = n3 * t2 << 16 ^ e * t2 << 8 ^ i * t2 << 0;
  return D.toHexString(s);
} };
var ke = { isPrimitive: false, match: (n3) => Object(n3) === n3, fromHexString(n3, e, i = 1) {
  let t2 = D.fromHexString(n3);
  e.r = (t2 >> 16 & 255) / 255 * i, e.g = (t2 >> 8 & 255) / 255 * i, e.b = (t2 & 255) / 255 * i;
}, toHexString({ r: n3, g: e, b: i }, t2 = 1) {
  t2 = 255 / t2;
  let s = n3 * t2 << 16 ^ e * t2 << 8 ^ i * t2 << 0;
  return D.toHexString(s);
} };
var Me = [_e, D, Ee, ke];
function Le(n3) {
  return Me.find((e) => e.match(n3));
}
var J = class extends M {
  constructor(e, i, t2, s) {
    super(e, i, t2, "color"), this.$input = document.createElement("input"), this.$input.setAttribute("type", "color"), this.$input.setAttribute("tabindex", -1), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$text = document.createElement("input"), this.$text.setAttribute("type", "text"), this.$text.setAttribute("spellcheck", "false"), this.$text.setAttribute("aria-labelledby", this.$name.id), this.$display = document.createElement("div"), this.$display.classList.add("display"), this.$display.appendChild(this.$input), this.$widget.appendChild(this.$display), this.$widget.appendChild(this.$text), this._format = Le(this.initialValue), this._rgbScale = s, this._initialValueHexString = this.save(), this._textFocused = false, this.$input.addEventListener("input", () => {
      this._setValueFromHexString(this.$input.value);
    }), this.$input.addEventListener("blur", () => {
      this._callOnFinishChange();
    }), this.$text.addEventListener("input", () => {
      let o = V(this.$text.value);
      o && this._setValueFromHexString(o);
    }), this.$text.addEventListener("focus", () => {
      this._textFocused = true, this.$text.select();
    }), this.$text.addEventListener("blur", () => {
      this._textFocused = false, this.updateDisplay(), this._callOnFinishChange();
    }), this.$disable = this.$text, this.updateDisplay();
  }
  reset() {
    return this._setValueFromHexString(this._initialValueHexString), this;
  }
  _setValueFromHexString(e) {
    if (this._format.isPrimitive) {
      let i = this._format.fromHexString(e);
      this.setValue(i);
    } else this._format.fromHexString(e, this.getValue(), this._rgbScale), this._callOnChange(), this.updateDisplay();
  }
  save() {
    return this._format.toHexString(this.getValue(), this._rgbScale);
  }
  load(e) {
    return this._setValueFromHexString(e), this._callOnFinishChange(), this;
  }
  updateDisplay() {
    return this.$input.value = this._format.toHexString(this.getValue(), this._rgbScale), this._textFocused || (this.$text.value = this.$input.value.substring(1)), this.$display.style.backgroundColor = this.$input.value, this;
  }
};
var F = class extends M {
  constructor(e, i, t2) {
    super(e, i, t2, "function"), this.$button = document.createElement("button"), this.$button.appendChild(this.$name), this.$widget.appendChild(this.$button), this.$button.addEventListener("click", (s) => {
      s.preventDefault(), this.getValue().call(this.object), this._callOnChange();
    }), this.$button.addEventListener("touchstart", () => {
    }, { passive: true }), this.$disable = this.$button;
  }
};
var Z = class extends M {
  constructor(e, i, t2, s, o, a) {
    super(e, i, t2, "number"), this._initInput(), this.min(s), this.max(o);
    let l = a !== void 0;
    this.step(l ? a : this._getImplicitStep(), l), this.updateDisplay();
  }
  decimals(e) {
    return this._decimals = e, this.updateDisplay(), this;
  }
  min(e) {
    return this._min = e, this._onUpdateMinMax(), this;
  }
  max(e) {
    return this._max = e, this._onUpdateMinMax(), this;
  }
  step(e, i = true) {
    return this._step = e, this._stepExplicit = i, this;
  }
  updateDisplay() {
    let e = this.getValue();
    if (this._hasSlider) {
      let i = (e - this._min) / (this._max - this._min);
      i = Math.max(0, Math.min(i, 1)), this.$fill.style.width = i * 100 + "%";
    }
    return this._inputFocused || (this.$input.value = this._decimals === void 0 ? e : e.toFixed(this._decimals)), this;
  }
  _initInput() {
    this.$input = document.createElement("input"), this.$input.setAttribute("type", "text"), this.$input.setAttribute("aria-labelledby", this.$name.id), window.matchMedia("(pointer: coarse)").matches && (this.$input.setAttribute("type", "number"), this.$input.setAttribute("step", "any")), this.$widget.appendChild(this.$input), this.$disable = this.$input;
    let i = () => {
      let f = parseFloat(this.$input.value);
      isNaN(f) || (this._stepExplicit && (f = this._snap(f)), this.setValue(this._clamp(f)));
    }, t2 = (f) => {
      let C = parseFloat(this.$input.value);
      isNaN(C) || (this._snapClampSetValue(C + f), this.$input.value = this.getValue());
    }, s = (f) => {
      f.key === "Enter" && this.$input.blur(), f.code === "ArrowUp" && (f.preventDefault(), t2(this._step * this._arrowKeyMultiplier(f))), f.code === "ArrowDown" && (f.preventDefault(), t2(this._step * this._arrowKeyMultiplier(f) * -1));
    }, o = (f) => {
      this._inputFocused && (f.preventDefault(), t2(this._step * this._normalizeMouseWheel(f)));
    }, a = false, l, h, m, d, g, r = 5, c = (f) => {
      l = f.clientX, h = m = f.clientY, a = true, d = this.getValue(), g = 0, window.addEventListener("mousemove", p), window.addEventListener("mouseup", v);
    }, p = (f) => {
      if (a) {
        let C = f.clientX - l, L = f.clientY - h;
        Math.abs(L) > r ? (f.preventDefault(), this.$input.blur(), a = false, this._setDraggingStyle(true, "vertical")) : Math.abs(C) > r && v();
      }
      if (!a) {
        let C = f.clientY - m;
        g -= C * this._step * this._arrowKeyMultiplier(f), d + g > this._max ? g = this._max - d : d + g < this._min && (g = this._min - d), this._snapClampSetValue(d + g);
      }
      m = f.clientY;
    }, v = () => {
      this._setDraggingStyle(false, "vertical"), this._callOnFinishChange(), window.removeEventListener("mousemove", p), window.removeEventListener("mouseup", v);
    }, x = () => {
      this._inputFocused = true;
    }, u = () => {
      this._inputFocused = false, this.updateDisplay(), this._callOnFinishChange();
    };
    this.$input.addEventListener("input", i), this.$input.addEventListener("keydown", s), this.$input.addEventListener("wheel", o, { passive: false }), this.$input.addEventListener("mousedown", c), this.$input.addEventListener("focus", x), this.$input.addEventListener("blur", u);
  }
  _initSlider() {
    this._hasSlider = true, this.$slider = document.createElement("div"), this.$slider.classList.add("slider"), this.$fill = document.createElement("div"), this.$fill.classList.add("fill"), this.$slider.appendChild(this.$fill), this.$widget.insertBefore(this.$slider, this.$input), this.domElement.classList.add("hasSlider");
    let e = (u, f, C, L, z) => (u - f) / (C - f) * (z - L) + L, i = (u) => {
      let f = this.$slider.getBoundingClientRect(), C = e(u, f.left, f.right, this._min, this._max);
      this._snapClampSetValue(C);
    }, t2 = (u) => {
      this._setDraggingStyle(true), i(u.clientX), window.addEventListener("mousemove", s), window.addEventListener("mouseup", o);
    }, s = (u) => {
      i(u.clientX);
    }, o = () => {
      this._callOnFinishChange(), this._setDraggingStyle(false), window.removeEventListener("mousemove", s), window.removeEventListener("mouseup", o);
    }, a = false, l, h, m = (u) => {
      u.preventDefault(), this._setDraggingStyle(true), i(u.touches[0].clientX), a = false;
    }, d = (u) => {
      u.touches.length > 1 || (this._hasScrollBar ? (l = u.touches[0].clientX, h = u.touches[0].clientY, a = true) : m(u), window.addEventListener("touchmove", g, { passive: false }), window.addEventListener("touchend", r));
    }, g = (u) => {
      if (a) {
        let f = u.touches[0].clientX - l, C = u.touches[0].clientY - h;
        Math.abs(f) > Math.abs(C) ? m(u) : (window.removeEventListener("touchmove", g), window.removeEventListener("touchend", r));
      } else u.preventDefault(), i(u.touches[0].clientX);
    }, r = () => {
      this._callOnFinishChange(), this._setDraggingStyle(false), window.removeEventListener("touchmove", g), window.removeEventListener("touchend", r);
    }, c = this._callOnFinishChange.bind(this), p = 400, v, x = (u) => {
      if (Math.abs(u.deltaX) < Math.abs(u.deltaY) && this._hasScrollBar) return;
      u.preventDefault();
      let C = this._normalizeMouseWheel(u) * this._step;
      this._snapClampSetValue(this.getValue() + C), this.$input.value = this.getValue(), clearTimeout(v), v = setTimeout(c, p);
    };
    this.$slider.addEventListener("mousedown", t2), this.$slider.addEventListener("touchstart", d, { passive: false }), this.$slider.addEventListener("wheel", x, { passive: false });
  }
  _setDraggingStyle(e, i = "horizontal") {
    this.$slider && this.$slider.classList.toggle("active", e), document.body.classList.toggle("lil-gui-dragging", e), document.body.classList.toggle(`lil-gui-${i}`, e);
  }
  _getImplicitStep() {
    return this._hasMin && this._hasMax ? (this._max - this._min) / 1e3 : 0.1;
  }
  _onUpdateMinMax() {
    !this._hasSlider && this._hasMin && this._hasMax && (this._stepExplicit || this.step(this._getImplicitStep(), false), this._initSlider(), this.updateDisplay());
  }
  _normalizeMouseWheel(e) {
    let { deltaX: i, deltaY: t2 } = e;
    return Math.floor(e.deltaY) !== e.deltaY && e.wheelDelta && (i = 0, t2 = -e.wheelDelta / 120, t2 *= this._stepExplicit ? 1 : 10), i + -t2;
  }
  _arrowKeyMultiplier(e) {
    let i = this._stepExplicit ? 1 : 10;
    return e.shiftKey ? i *= 10 : e.altKey && (i /= 10), i;
  }
  _snap(e) {
    let i = Math.round(e / this._step) * this._step;
    return parseFloat(i.toPrecision(15));
  }
  _clamp(e) {
    return e < this._min && (e = this._min), e > this._max && (e = this._max), e;
  }
  _snapClampSetValue(e) {
    this.setValue(this._clamp(this._snap(e)));
  }
  get _hasScrollBar() {
    let e = this.parent.root.$children;
    return e.scrollHeight > e.clientHeight;
  }
  get _hasMin() {
    return this._min !== void 0;
  }
  get _hasMax() {
    return this._max !== void 0;
  }
};
var Q = class extends M {
  constructor(e, i, t2, s) {
    super(e, i, t2, "option"), this.$select = document.createElement("select"), this.$select.setAttribute("aria-labelledby", this.$name.id), this.$display = document.createElement("div"), this.$display.classList.add("display"), this.$select.addEventListener("change", () => {
      this.setValue(this._values[this.$select.selectedIndex]), this._callOnFinishChange();
    }), this.$select.addEventListener("focus", () => {
      this.$display.classList.add("focus");
    }), this.$select.addEventListener("blur", () => {
      this.$display.classList.remove("focus");
    }), this.$widget.appendChild(this.$select), this.$widget.appendChild(this.$display), this.$disable = this.$select, this.options(s);
  }
  options(e) {
    return this._values = Array.isArray(e) ? e : Object.values(e), this._names = Array.isArray(e) ? e : Object.keys(e), this.$select.replaceChildren(), this._names.forEach((i) => {
      let t2 = document.createElement("option");
      t2.textContent = i, this.$select.appendChild(t2);
    }), this.updateDisplay(), this;
  }
  updateDisplay() {
    let e = this.getValue(), i = this._values.indexOf(e);
    return this.$select.selectedIndex = i, this.$display.textContent = i === -1 ? e : this._names[i], this;
  }
};
var K = class extends M {
  constructor(e, i, t2) {
    super(e, i, t2, "string"), this.$input = document.createElement("input"), this.$input.setAttribute("type", "text"), this.$input.setAttribute("spellcheck", "false"), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$input.addEventListener("input", () => {
      this.setValue(this.$input.value);
    }), this.$input.addEventListener("keydown", (s) => {
      s.code === "Enter" && this.$input.blur();
    }), this.$input.addEventListener("blur", () => {
      this._callOnFinishChange();
    }), this.$widget.appendChild(this.$input), this.$disable = this.$input, this.updateDisplay();
  }
  updateDisplay() {
    return this.$input.value = this.getValue(), this;
  }
};
var $e = `.lil-gui {
  font-family: var(--font-family);
  font-size: var(--font-size);
  line-height: 1;
  font-weight: normal;
  font-style: normal;
  text-align: left;
  color: var(--text-color);
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
  --background-color: #1f1f1f;
  --text-color: #ebebeb;
  --title-background-color: #111111;
  --title-text-color: #ebebeb;
  --widget-color: #424242;
  --hover-color: #4f4f4f;
  --focus-color: #595959;
  --number-color: #2cc9ff;
  --string-color: #a2db3c;
  --font-size: 11px;
  --input-font-size: 11px;
  --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
  --font-family-mono: Menlo, Monaco, Consolas, "Droid Sans Mono", monospace;
  --padding: 4px;
  --spacing: 4px;
  --widget-height: 20px;
  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);
  --name-width: 45%;
  --slider-knob-width: 2px;
  --slider-input-width: 27%;
  --color-input-width: 27%;
  --slider-input-min-width: 45px;
  --color-input-min-width: 45px;
  --folder-indent: 7px;
  --widget-padding: 0 0 0 3px;
  --widget-border-radius: 2px;
  --checkbox-size: calc(0.75 * var(--widget-height));
  --scrollbar-width: 5px;
}
.lil-gui, .lil-gui * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
.lil-gui.root {
  width: var(--width, 245px);
  display: flex;
  flex-direction: column;
  background: var(--background-color);
}
.lil-gui.root > .title {
  background: var(--title-background-color);
  color: var(--title-text-color);
}
.lil-gui.root > .children {
  overflow-x: hidden;
  overflow-y: auto;
}
.lil-gui.root > .children::-webkit-scrollbar {
  width: var(--scrollbar-width);
  height: var(--scrollbar-width);
  background: var(--background-color);
}
.lil-gui.root > .children::-webkit-scrollbar-thumb {
  border-radius: var(--scrollbar-width);
  background: var(--focus-color);
}
@media (pointer: coarse) {
  .lil-gui.allow-touch-styles, .lil-gui.allow-touch-styles .lil-gui {
    --widget-height: 28px;
    --padding: 6px;
    --spacing: 6px;
    --font-size: 13px;
    --input-font-size: 16px;
    --folder-indent: 10px;
    --scrollbar-width: 7px;
    --slider-input-min-width: 50px;
    --color-input-min-width: 65px;
  }
}
.lil-gui.force-touch-styles, .lil-gui.force-touch-styles .lil-gui {
  --widget-height: 28px;
  --padding: 6px;
  --spacing: 6px;
  --font-size: 13px;
  --input-font-size: 16px;
  --folder-indent: 10px;
  --scrollbar-width: 7px;
  --slider-input-min-width: 50px;
  --color-input-min-width: 65px;
}
.lil-gui.autoPlace {
  max-height: 100%;
  position: fixed;
  top: 0;
  right: 15px;
  z-index: 1001;
}

.lil-gui .controller {
  display: flex;
  align-items: center;
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
}
.lil-gui .controller.disabled {
  opacity: 0.5;
}
.lil-gui .controller.disabled, .lil-gui .controller.disabled * {
  pointer-events: none !important;
}
.lil-gui .controller > .name {
  min-width: var(--name-width);
  flex-shrink: 0;
  white-space: pre;
  padding-right: var(--spacing);
  line-height: var(--widget-height);
}
.lil-gui .controller .widget {
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;
  min-height: var(--widget-height);
}
.lil-gui .controller.string input {
  color: var(--string-color);
}
.lil-gui .controller.boolean {
  cursor: pointer;
}
.lil-gui .controller.color .display {
  width: 100%;
  height: var(--widget-height);
  border-radius: var(--widget-border-radius);
  position: relative;
}
@media (hover: hover) {
  .lil-gui .controller.color .display:hover:before {
    content: " ";
    display: block;
    position: absolute;
    border-radius: var(--widget-border-radius);
    border: 1px solid #fff9;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
.lil-gui .controller.color input[type=color] {
  opacity: 0;
  width: 100%;
  height: 100%;
  cursor: pointer;
}
.lil-gui .controller.color input[type=text] {
  margin-left: var(--spacing);
  font-family: var(--font-family-mono);
  min-width: var(--color-input-min-width);
  width: var(--color-input-width);
  flex-shrink: 0;
}
.lil-gui .controller.option select {
  opacity: 0;
  position: absolute;
  width: 100%;
  max-width: 100%;
}
.lil-gui .controller.option .display {
  position: relative;
  pointer-events: none;
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  line-height: var(--widget-height);
  max-width: 100%;
  overflow: hidden;
  word-break: break-all;
  padding-left: 0.55em;
  padding-right: 1.75em;
  background: var(--widget-color);
}
@media (hover: hover) {
  .lil-gui .controller.option .display.focus {
    background: var(--focus-color);
  }
}
.lil-gui .controller.option .display.active {
  background: var(--focus-color);
}
.lil-gui .controller.option .display:after {
  font-family: "lil-gui";
  content: "↕";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  padding-right: 0.375em;
}
.lil-gui .controller.option .widget,
.lil-gui .controller.option select {
  cursor: pointer;
}
@media (hover: hover) {
  .lil-gui .controller.option .widget:hover .display {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number input {
  color: var(--number-color);
}
.lil-gui .controller.number.hasSlider input {
  margin-left: var(--spacing);
  width: var(--slider-input-width);
  min-width: var(--slider-input-min-width);
  flex-shrink: 0;
}
.lil-gui .controller.number .slider {
  width: 100%;
  height: var(--widget-height);
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
  padding-right: var(--slider-knob-width);
  overflow: hidden;
  cursor: ew-resize;
  touch-action: pan-y;
}
@media (hover: hover) {
  .lil-gui .controller.number .slider:hover {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number .slider.active {
  background: var(--focus-color);
}
.lil-gui .controller.number .slider.active .fill {
  opacity: 0.95;
}
.lil-gui .controller.number .fill {
  height: 100%;
  border-right: var(--slider-knob-width) solid var(--number-color);
  box-sizing: content-box;
}

.lil-gui-dragging .lil-gui {
  --hover-color: var(--widget-color);
}
.lil-gui-dragging * {
  cursor: ew-resize !important;
}

.lil-gui-dragging.lil-gui-vertical * {
  cursor: ns-resize !important;
}

.lil-gui .title {
  height: var(--title-height);
  line-height: calc(var(--title-height) - 4px);
  font-weight: 600;
  padding: 0 var(--padding);
  -webkit-tap-highlight-color: transparent;
  cursor: pointer;
  outline: none;
  text-decoration-skip: objects;
}
.lil-gui .title:before {
  font-family: "lil-gui";
  content: "▾";
  padding-right: 2px;
  display: inline-block;
}
.lil-gui .title:active {
  background: var(--title-background-color);
  opacity: 0.75;
}
@media (hover: hover) {
  body:not(.lil-gui-dragging) .lil-gui .title:hover {
    background: var(--title-background-color);
    opacity: 0.85;
  }
  .lil-gui .title:focus {
    text-decoration: underline var(--focus-color);
  }
}
.lil-gui.root > .title:focus {
  text-decoration: none !important;
}
.lil-gui.closed > .title:before {
  content: "▸";
}
.lil-gui.closed > .children {
  transform: translateY(-7px);
  opacity: 0;
}
.lil-gui.closed:not(.transition) > .children {
  display: none;
}
.lil-gui.transition > .children {
  transition-duration: 300ms;
  transition-property: height, opacity, transform;
  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);
  overflow: hidden;
  pointer-events: none;
}
.lil-gui .children:empty:before {
  content: "Empty";
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
  display: block;
  height: var(--widget-height);
  font-style: italic;
  line-height: var(--widget-height);
  opacity: 0.5;
}
.lil-gui.root > .children > .lil-gui > .title {
  border: 0 solid var(--widget-color);
  border-width: 1px 0;
  transition: border-color 300ms;
}
.lil-gui.root > .children > .lil-gui.closed > .title {
  border-bottom-color: transparent;
}
.lil-gui + .controller {
  border-top: 1px solid var(--widget-color);
  margin-top: 0;
  padding-top: var(--spacing);
}
.lil-gui .lil-gui .lil-gui > .title {
  border: none;
}
.lil-gui .lil-gui .lil-gui > .children {
  border: none;
  margin-left: var(--folder-indent);
  border-left: 2px solid var(--widget-color);
}
.lil-gui .lil-gui .controller {
  border: none;
}

.lil-gui label, .lil-gui input, .lil-gui button {
  -webkit-tap-highlight-color: transparent;
}
.lil-gui input {
  border: 0;
  outline: none;
  font-family: var(--font-family);
  font-size: var(--input-font-size);
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  background: var(--widget-color);
  color: var(--text-color);
  width: 100%;
}
@media (hover: hover) {
  .lil-gui input:hover {
    background: var(--hover-color);
  }
  .lil-gui input:active {
    background: var(--focus-color);
  }
}
.lil-gui input:disabled {
  opacity: 1;
}
.lil-gui input[type=text],
.lil-gui input[type=number] {
  padding: var(--widget-padding);
  -moz-appearance: textfield;
}
.lil-gui input[type=text]:focus,
.lil-gui input[type=number]:focus {
  background: var(--focus-color);
}
.lil-gui input[type=checkbox] {
  appearance: none;
  width: var(--checkbox-size);
  height: var(--checkbox-size);
  border-radius: var(--widget-border-radius);
  text-align: center;
  cursor: pointer;
}
.lil-gui input[type=checkbox]:checked:before {
  font-family: "lil-gui";
  content: "✓";
  font-size: var(--checkbox-size);
  line-height: var(--checkbox-size);
}
@media (hover: hover) {
  .lil-gui input[type=checkbox]:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui button {
  outline: none;
  cursor: pointer;
  font-family: var(--font-family);
  font-size: var(--font-size);
  color: var(--text-color);
  width: 100%;
  height: var(--widget-height);
  text-transform: none;
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
  border: none;
}
@media (hover: hover) {
  .lil-gui button:hover {
    background: var(--hover-color);
  }
  .lil-gui button:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui button:active {
  background: var(--focus-color);
}

@font-face {
  font-family: "lil-gui";
  src: url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff");
}`;
function Se(n3) {
  let e = document.createElement("style");
  e.innerHTML = n3;
  let i = document.querySelector("head link[rel=stylesheet], head style");
  i ? document.head.insertBefore(e, i) : document.head.appendChild(e);
}
var le = false;
var q = class n2 {
  constructor({ parent: e, autoPlace: i = e === void 0, container: t2, width: s, title: o = "Controls", closeFolders: a = false, injectStyles: l = true, touchStyles: h = true } = {}) {
    if (this.parent = e, this.root = e ? e.root : this, this.children = [], this.controllers = [], this.folders = [], this._closed = false, this._hidden = false, this.domElement = document.createElement("div"), this.domElement.classList.add("lil-gui"), this.$title = document.createElement("div"), this.$title.classList.add("title"), this.$title.setAttribute("role", "button"), this.$title.setAttribute("aria-expanded", true), this.$title.setAttribute("tabindex", 0), this.$title.addEventListener("click", () => this.openAnimated(this._closed)), this.$title.addEventListener("keydown", (m) => {
      (m.code === "Enter" || m.code === "Space") && (m.preventDefault(), this.$title.click());
    }), this.$title.addEventListener("touchstart", () => {
    }, { passive: true }), this.$children = document.createElement("div"), this.$children.classList.add("children"), this.domElement.appendChild(this.$title), this.domElement.appendChild(this.$children), this.title(o), this.parent) {
      this.parent.children.push(this), this.parent.folders.push(this), this.parent.$children.appendChild(this.domElement);
      return;
    }
    this.domElement.classList.add("root"), h && this.domElement.classList.add("allow-touch-styles"), !le && l && (Se($e), le = true), t2 ? t2.appendChild(this.domElement) : i && (this.domElement.classList.add("autoPlace"), document.body.appendChild(this.domElement)), s && this.domElement.style.setProperty("--width", s + "px"), this._closeFolders = a;
  }
  add(e, i, t2, s, o) {
    if (Object(t2) === t2) return new Q(this, e, i, t2);
    let a = e[i];
    switch (typeof a) {
      case "number":
        return new Z(this, e, i, t2, s, o);
      case "boolean":
        return new W(this, e, i);
      case "string":
        return new K(this, e, i);
      case "function":
        return new F(this, e, i);
    }
    console.error(`gui.add failed
	property:`, i, `
	object:`, e, `
	value:`, a);
  }
  addColor(e, i, t2 = 1) {
    return new J(this, e, i, t2);
  }
  addFolder(e) {
    let i = new n2({ parent: this, title: e });
    return this.root._closeFolders && i.close(), i;
  }
  load(e, i = true) {
    return e.controllers && this.controllers.forEach((t2) => {
      t2 instanceof F || t2._name in e.controllers && t2.load(e.controllers[t2._name]);
    }), i && e.folders && this.folders.forEach((t2) => {
      t2._title in e.folders && t2.load(e.folders[t2._title]);
    }), this;
  }
  save(e = true) {
    let i = { controllers: {}, folders: {} };
    return this.controllers.forEach((t2) => {
      if (!(t2 instanceof F)) {
        if (t2._name in i.controllers) throw new Error(`Cannot save GUI with duplicate property "${t2._name}"`);
        i.controllers[t2._name] = t2.save();
      }
    }), e && this.folders.forEach((t2) => {
      if (t2._title in i.folders) throw new Error(`Cannot save GUI with duplicate folder "${t2._title}"`);
      i.folders[t2._title] = t2.save();
    }), i;
  }
  open(e = true) {
    return this._setClosed(!e), this.$title.setAttribute("aria-expanded", !this._closed), this.domElement.classList.toggle("closed", this._closed), this;
  }
  close() {
    return this.open(false);
  }
  _setClosed(e) {
    this._closed !== e && (this._closed = e, this._callOnOpenClose(this));
  }
  show(e = true) {
    return this._hidden = !e, this.domElement.style.display = this._hidden ? "none" : "", this;
  }
  hide() {
    return this.show(false);
  }
  openAnimated(e = true) {
    return this._setClosed(!e), this.$title.setAttribute("aria-expanded", !this._closed), requestAnimationFrame(() => {
      let i = this.$children.clientHeight;
      this.$children.style.height = i + "px", this.domElement.classList.add("transition");
      let t2 = (o) => {
        o.target === this.$children && (this.$children.style.height = "", this.domElement.classList.remove("transition"), this.$children.removeEventListener("transitionend", t2));
      };
      this.$children.addEventListener("transitionend", t2);
      let s = e ? this.$children.scrollHeight : 0;
      this.domElement.classList.toggle("closed", !e), requestAnimationFrame(() => {
        this.$children.style.height = s + "px";
      });
    }), this;
  }
  title(e) {
    return this._title = e, this.$title.textContent = e, this;
  }
  reset(e = true) {
    return (e ? this.controllersRecursive() : this.controllers).forEach((t2) => t2.reset()), this;
  }
  onChange(e) {
    return this._onChange = e, this;
  }
  _callOnChange(e) {
    this.parent && this.parent._callOnChange(e), this._onChange !== void 0 && this._onChange.call(this, { object: e.object, property: e.property, value: e.getValue(), controller: e });
  }
  onFinishChange(e) {
    return this._onFinishChange = e, this;
  }
  _callOnFinishChange(e) {
    this.parent && this.parent._callOnFinishChange(e), this._onFinishChange !== void 0 && this._onFinishChange.call(this, { object: e.object, property: e.property, value: e.getValue(), controller: e });
  }
  onOpenClose(e) {
    return this._onOpenClose = e, this;
  }
  _callOnOpenClose(e) {
    this.parent && this.parent._callOnOpenClose(e), this._onOpenClose !== void 0 && this._onOpenClose.call(this, e);
  }
  destroy() {
    this.parent && (this.parent.children.splice(this.parent.children.indexOf(this), 1), this.parent.folders.splice(this.parent.folders.indexOf(this), 1)), this.domElement.parentElement && this.domElement.parentElement.removeChild(this.domElement), Array.from(this.children).forEach((e) => e.destroy());
  }
  controllersRecursive() {
    let e = Array.from(this.controllers);
    return this.folders.forEach((i) => {
      e = e.concat(i.controllersRecursive());
    }), e;
  }
  foldersRecursive() {
    let e = Array.from(this.folders);
    return this.folders.forEach((i) => {
      e = e.concat(i.foldersRecursive());
    }), e;
  }
};
var G = q;
$i();
$i();
var E = (() => {
  let n3 = new Nt();
  return function(i) {
    return n3.set(i), `#${n3.getHexString()}`;
  };
})();
function de(n3) {
  let e;
  for (e of n3) e();
}
function ee(n3, e) {
  let i = window.location.href, t2 = new URL(i), s = new URLSearchParams(t2.search);
  for (let o in n3) if (n3.hasOwnProperty(o)) {
    let a = `${e}.${o}`;
    s.set(a, n3[o]);
  }
  t2.search = s.toString(), history.pushState({ path: t2.toString() }, "", t2.toString());
}
function te(n3, e) {
  let i = new URLSearchParams(window.location.search), t2 = {};
  for (let [s, o] of i) if (s.startsWith(`${n3}.`)) {
    let a = s.slice(n3.length + 1);
    o === "true" || o === "false" ? t2[a] = o === "true" : typeof e?.[a] == "number" ? t2[a] = Number(o) : t2[a] = o;
  }
  return { namespace: n3, params: t2 };
}
var Ie = ["interactive"];
function B(n3, e, i) {
  let t2 = { id: e.id, __type: e.__type }, s = i.addFolder(`${e.type}-${e.id}`);
  for (let o in e) {
    if (o === "visible" && s.add(e, o).onChange((a) => {
      n3.updateState(t2, { [o]: a });
    }), o === "color" || o === "hoverColor") {
      e[o] = E(e[o]), s.addColor(e, o).onChange((a) => {
        n3.updateState(t2, { [o]: a });
      });
      continue;
    }
    if (o === "height") {
      s.add(e, o, 0, 20, 1).onChange((a) => {
        n3.updateState(t2, { [o]: a });
      });
      continue;
    }
    if (o === "texture" && e.texture) {
      s.addFolder("Texture - side").add(e, "texture")?.onChange((l) => {
        n3.updateState(t2, { texture: { url: l } });
      });
      continue;
    }
    if (o === "topTexture" && e.topTexture) {
      s.addFolder("Texture - top").add(e, "topTexture")?.onChange((l) => {
        n3.updateState(t2, { topTexture: { url: l } });
      });
      continue;
    }
    if (o === "opacity") {
      s.add(e, o, 0, 1, 0.1).onChange((a) => {
        n3.updateState(t2, { [o]: a });
      });
      continue;
    }
    if (o === "altitude") {
      s.add(e, o, 0, 100, 1).onChange((a) => {
        n3.updateState(t2, { [o]: a });
      });
      continue;
    }
    Ie.includes(o) && s.add(e, o).onChange((a) => {
      n3.updateState(t2, { [o]: a });
    });
  }
  return e.isInView && (s.add(e, "isInView").listen().disable(), s.add(e, "isInViewCheck")), { cleanup() {
    s.destroy();
  } };
}
$i();
$i();
function Fe() {
  let n3 = [];
  function e(s, o) {
    let a = Object.values(s.getMapData())[0], l = o;
    if (l && Cr.is(l)) {
      let h = a.getByType("enterprise-location")?.find((m) => m.spaces.some((d) => d.id === l.id));
      h && (l = h);
    }
    return l;
  }
  async function i(s, o) {
    return o instanceof $y ? s.Camera.focusOn(o.locations.flatMap((a) => a.spaces), T) : o instanceof da ? s.Camera.focusOn(o.spaces, T) : s.Camera.focusOn(o, T);
  }
  function t2(s, o, { focus: a = false } = {}) {
    if (!window.enableHighlightCard) return () => {
    };
    let l = e(s, o), h = document.createElement("div");
    if (h.style.cssText = `
				position: absolute;
				top: 20px;
				left: 20px;
				background-color: rgba(30, 30, 30, 0.95);
				box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
				border-radius: 12px;
				padding: 24px;
				max-width: 320px;
				z-index: 1000;
				font-family: 'Arial', sans-serif;
				transition: all 0.3s ease;
				color: #e0e0e0;
			`, "name" in l) {
      let d = document.createElement("h3");
      d.textContent = l.name, d.style.cssText = `
				margin: 0 0 16px;
				font-size: 22px;
				font-weight: 600;
				color: #ffffff;
				letter-spacing: -0.5px;
			`, h.appendChild(d);
    }
    if (l instanceof da) {
      if (l.description) {
        let d = document.createElement("p");
        d.textContent = l.description, d.style.cssText = `
					margin: 0 0 16px;
					font-size: 14px;
					color: #b0b0b0;
					line-height: 1.5;
				`, h.appendChild(d);
      }
      if (l.tags && l.tags.length > 0) {
        let d = document.createElement("div");
        d.style.cssText = `
					display: flex;
					flex-wrap: nowrap;
					gap: 8px;
					margin-bottom: 16px;
					overflow-x: hidden;
					max-height: 30px; /* Adjust this value based on your font size and padding */
				`, l.tags.forEach((g) => {
          let r = document.createElement("span");
          r.textContent = g, r.style.cssText = `
						background-color: #3a3a3a;
						color: #e0e0e0;
						padding: 6px 12px;
						border-radius: 16px;
						font-size: 12px;
						font-weight: 500;
						text-transform: uppercase;
						white-space: nowrap;
					`, d.appendChild(r);
        }), h.appendChild(d);
      }
    }
    let m;
    if (!(o instanceof $y)) {
      let d = new G({ autoPlace: false });
      d.domElement.style.cssText = `
					position: relative;
					overflow-y: auto;
					margin-top: 16px;
					border-top: 1px solid #444;
					padding-top: 16px;
				`;
      let g = s.getState(o);
      g && (B(s, { id: o.id, ...g }, d), h.appendChild(d.domElement)), m = d;
    }
    return document.body.appendChild(h), a && i(s, l), () => {
      h.style.opacity = "0", h.style.transform = "translateY(-10px)", setTimeout(() => h.remove(), 300), m?.destroy();
    };
  }
  return { highlightCard: t2, highlight: (s, o, { focus: a = true } = {}) => {
    n3.length > 0 && n3.forEach((h) => s.Markers.remove(h));
    let l = e(s, o);
    if (l instanceof da) a && s.Camera.focusOn(l.spaces, T), n3.push(...l.spaces.map((h) => s.Markers.add(h, `<div style="padding: 15px; background-color: #ffffff; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); max-width: 250px; position: relative;">
							<h3 style="margin: 0 0 10px; color: #333; font-size: 16px; font-weight: 600;">${l.name}</h3>
							${l.description ? `<p style="margin: 0 0 10px; color: #666; font-size: 14px; font-weight: 400;">${l.description}</p>` : ""}
							${l.tags ? l.tags.map((m) => `<span style="display: inline-block; padding: 3px 8px; background-color: #e0f2f1; color: #00796b; border-radius: 12px; font-size: 12px;">${m}</span>`).join(" ") : ""}
							<div style="position: absolute; bottom: -10px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-top: 10px solid #ffffff;"></div>
						</div>`, { rank: "always-visible", placement: "top" })));
    else if (l instanceof $y) {
      a && s.Camera.focusOn(l.locations.flatMap((d) => d.spaces), T);
      let h = /* @__PURE__ */ new Map(), m = /* @__PURE__ */ new Set();
      l.locations.forEach((d) => {
        h.has(d.name) || (d.spaces.forEach((g) => {
          n3.push(s.Markers.add(g, `<div style="padding: 12px; background-color: rgba(0, 153, 51, 0.95); border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.3); transform: translateY(-4px); transition: all 0.3s ease;">
									<span style="font-weight: 600; color: #FFFFFF; font-size: 16px; text-shadow: 1px 1px 2px rgba(0,0,0,0.2);">${d.name}</span>
								</div>`, { rank: "always-visible" }));
        }), h.set(d.name, true));
      }), l.locations.forEach((d) => {
        d.coordinates.forEach((g) => {
          let r = `${g.latitude},${g.longitude}`;
          if (!m.has(r) && !h.has(d.name)) {
            let c = s.Markers.add(g, `<div style="padding: 10px; background-color: rgba(51, 102, 204, 0.9); border-radius: 6px; box-shadow: 0 3px 6px rgba(0,0,0,0.2);">
								<span style="font-weight: 500; color: #FFFFFF; font-size: 16px;">${d.name}</span>
								<br>
								<span style="color: #FFFFFF; font-size: 12px; font-weight: 400;">Node</span>
							</div>`, { rank: "always-visible" });
            m.add(r), n3.push(c);
          }
        });
      });
    }
    return () => {
      n3.forEach((h) => s.Markers.remove(h));
    };
  } };
}
var T = { duration: 300, easing: "ease-in-out" };
var R = Fe();
$i();
var _ = { search: "", results: void 0, options: { places: { fields: { name: true, description: true, link: true, category: true }, limit: 5 }, locations: { fields: { name: true, tag: true, description: true }, limit: 5 }, categories: { fields: { name: true }, limit: 5 } } };
function De(n3) {
  n3.add(_.options.places.fields, "name").name("Places: Name"), n3.add(_.options.places.fields, "description").name("Places: Description"), n3.add(_.options.places.fields, "link").name("Places: Link"), n3.add(_.options.places.fields, "category").name("Places: Category"), n3.add(_.options.places, "limit"), n3.add(_.options.locations.fields, "name").name("Locations: Name"), n3.add(_.options.locations.fields, "tag").name("Locations: Tag"), n3.add(_.options.locations.fields, "description").name("Locations: Description"), n3.add(_.options.places, "limit"), n3.add(_.options.categories.fields, "name").name("Categories: Name");
}
function ce(n3, e, i) {
  let t2 = new Ka(), s = i.addFolder("Search");
  s.open();
  let o = s.add(_, "search").onChange(async (d) => {
    let g = await e.Search.query(d, _.options);
    g && (_.results = g, l(g, t2));
  }), a = document.createElement("div");
  a.style.marginLeft = "10px", o.domElement.parentElement?.appendChild(a);
  let { renderSearch: l, close: h } = Te(n3, e, a, o.$input), m = s.addFolder("Advanced");
  return m.close(), De(m), document.addEventListener("keydown", (d) => {
    (d.metaKey || d.ctrlKey) && d.key === "k" ? (d.preventDefault(), s._closed && s.open(), o.$input.focus()) : d.key === "Escape" && (h(), t2.publish("highlight", void 0));
  }), { pubsub: t2 };
}
function Te(n3, e, i, t2) {
  let s, o;
  t2.addEventListener("input", async (l) => {
    l instanceof InputEvent && (l.inputType === "insertText" || l.inputType === "insertCompositionText") && (clearTimeout(s), s = setTimeout(async () => {
      let h = await e.Search.suggest(t2.value);
      h && h.length > 0 && a(h[0]?.suggestion);
    }, 100));
  });
  function a(l) {
    if (!l) {
      t2.placeholder = "";
      return;
    }
    let h = t2.value;
    t2.value = l, t2.setSelectionRange(h.length, l.length);
  }
  return { renderSearch(l, h) {
    if (l.places.length === 0 && l.enterpriseCategories?.length === 0 && l.enterpriseLocations?.length === 0) {
      i.textContent = "No results found.";
      return;
    }
    o = Oe(i, l, n3, h);
  }, close() {
    o.destroy();
  } };
}
function Oe(n3, e, i, t2) {
  n3.innerHTML = "";
  let s = document.createElement("div");
  Object.assign(s.style, U.dropdownContainer);
  let o = document.createElement("ul");
  o.className = "options-list", Object.assign(o.style, U.optionsList), o.style.display = "block";
  let a = [], l = (r, c) => {
    if (c && c.length > 0) {
      let p = document.createElement("li");
      p.textContent = r, Object.assign(p.style, U.sectionHeader), o.appendChild(p), c.forEach((v, x) => {
        let u = document.createElement("li");
        u.textContent = `${"name" in v.item ? v.item.name : ""} (${v.type})`, Object.assign(u.style, U.option), u.tabIndex = 0, u.addEventListener("focus", () => {
          m(a.indexOf(u));
        }), u.addEventListener("mouseover", () => {
          u.style.backgroundColor = "#f0f0f0";
        }), u.addEventListener("mouseout", () => {
          u.style.backgroundColor = "";
        }), u.addEventListener("click", () => {
        }), u.setAttribute("data-type", r), u.setAttribute("data-index", x.toString()), o.appendChild(u), a.push(u);
      });
    }
  };
  l("enterpriseLocations", e.enterpriseLocations), l("enterpriseCategories", e.enterpriseCategories), l("Places", e.places), s.appendChild(o), n3.appendChild(s);
  let h = [], m = (r) => {
    h.forEach((u) => u()), h = [], a.forEach((u, f) => {
      f === r ? u.style.backgroundColor = "#e0e0e0" : u.style.backgroundColor = "";
    });
    let c = a[r], p = c.getAttribute("data-type"), v = parseInt(c.getAttribute("data-index") || "0", 10);
    if (!p) return;
    let { item: x } = e[p.toLowerCase()][v];
    t2.publish("highlight", x);
  }, d = (r) => {
    !s.contains(r.target) && r.target !== n3 && g();
  };
  document.addEventListener("click", d);
  let g = () => {
    n3.innerHTML = "", document.removeEventListener("click", d);
  };
  return { destroy() {
    n3.innerHTML = "", t2.publish("highlight", void 0);
  } };
}
var U = { dropdownContainer: { position: "absolute", color: "#202020" }, optionsList: { display: "block", zIndex: "1002", position: "relative", maxHeight: "200px", overflowY: "auto", border: "1px solid #ccc", backgroundColor: "#fff", listStyleType: "none", margin: "0", padding: "0" }, sectionHeader: { fontWeight: "bold", padding: "5px", backgroundColor: "#f0f0f0" }, option: { padding: "5px", cursor: "pointer" } };
function he(n3, e, i) {
  i.domElement.id = "interactionPanel";
  let t2 = [], { pubsub: s } = ce(n3, e, i);
  s.on("highlight", (d) => {
    if (d) {
      t2.forEach((r) => r()), t2 = [];
      let g = d instanceof da ? d.spaces[0] : d;
      if (n3.Camera.focusOn(d), g && !Cr.is(g)) return;
      t2.push(R.highlightCard(n3, g, { focus: true }));
    } else t2.forEach((g) => g()), t2 = [];
  });
  let o = i.addFolder("Click 👇").close(), { sub: a } = ze(n3, o);
  a.on("click", (d) => {
    t2.forEach((g) => g()), t2 = [], d.spaces?.[0] && (t2 = [R.highlightCard(n3, d.spaces[0])]);
  });
  let l = i.addFolder("Hover 🚁").close(), { sub: h } = Pe(n3, l), m;
  h.on("hover", (d) => {
    d.spaces?.[0] ? (m?.(), t2.length === 0 && (m = R.highlightCard(n3, d.spaces[0]))) : (m?.(), m = void 0);
  });
}
function ze(n3, e) {
  let i = new Ka(), t2 = { position: "", hoverColor: E(n3.getHoverColor()) }, s = e.add(t2, "position").disable(), o = [];
  function a() {
    o.forEach((h) => h()), o.length = 0;
  }
  let l = 0;
  return n3.on("click", (h) => {
    let { labels: m, coordinate: d } = h;
    a(), i.publish("click", h), clearInterval(l), s.load(JSON.stringify([d.longitude, d.latitude]));
    let g = m?.[0];
    if (g != null) {
      let c = O(n3, g, e);
      if (!c) return;
      o.push(c.destroy), c.labelItemFolder.openAnimated();
    }
    let r = h.spaces?.[0] ?? h.objects?.[0];
    if (r) {
      let c = { ...r, ...n3.getState(r), isInView: false, isInViewCheck: j(n3, r.id) }, { cleanup: p } = B(n3, c, e);
      l = setInterval(() => {
        c.isInView = n3.isInView(g || r);
      }, 500), o.push(p);
    }
  }), { sub: i };
}
function Pe(n3, e) {
  let i = new Ka();
  n3.setHoverColor("#1f3a7a");
  let t2 = { position: "", hoverColor: E(n3.getHoverColor()), intersected: "", type: "", id: "" }, s = e.add(t2, "position").disable();
  e.add(t2, "id").disable().listen(), e.add(t2, "type").disable().listen(), e.addColor(t2, "hoverColor").onChange((l) => {
    n3.setHoverColor(l);
  });
  let o = [];
  function a() {
    o.forEach((l) => l()), o.length = 0;
  }
  return n3.on("hover", (l) => {
    let { coordinate: h, spaces: m, objects: d, markers: g, labels: r } = l;
    a(), i.publish("hover", l), s.load(JSON.stringify([h.longitude, h.latitude]));
    let c = m?.[0] ?? d?.[0] ?? g?.[0] ?? r?.[0];
    if (!c) return;
    let p = n3.getState(c);
    p && (t2.type = p.type, t2.id = c.id);
  }), { sub: i };
}
function j(n3, e) {
  return function() {
    console.log("isInView", n3.isInView(e));
  };
}
function ue(n3, e, i) {
  let t2 = { labels: {}, all() {
    i.Labels.__EXPERIMENTAL__all().forEach((c) => {
      this.labels[c.id] = c;
    }), h();
  }, removeAllLabels() {
    i.Labels.removeAll().forEach((c) => {
      delete this.labels[c.id];
    }), h();
  } }, { addLabel: s, destroy: o } = Be(n3, i);
  n3.add(t2, "all"), n3.add(t2, "removeAllLabels");
  let a = n3.addFolder("Label List");
  n3.close();
  let l = /* @__PURE__ */ new Map(), { rerender: h } = m();
  function m() {
    function r(v) {
      delete t2.labels[v.id], l.get(v.id)?.destroy();
    }
    function c(v) {
      let x = O(i, v, a, { onRemove: (f) => {
        r(f);
      } });
      if (!x) return;
      let { labelItemFolder: u } = x;
      l.set(v.id, u);
    }
    function p() {
      a.destroy(), a = n3.addFolder("Label");
      for (let v in t2.labels) {
        let x = t2.labels[v];
        c(x);
      }
    }
    return { rerender: p, add: c, remove: r };
  }
  n3.domElement.classList.add("list-items");
  let d;
  i.on("click", ({ labels: r, coordinate: c }) => {
    if (!n3._closed) if (r?.[0]) {
      d?.close();
      let p = l.get(r[0].id);
      if (n3.open(), !p) return;
      p?.open(), p?.domElement.scrollIntoView({ block: "start" }), p?.domElement.focus(), d = p;
    } else s(c);
  });
  function g(r) {
    for (let c of r) t2.labels[c.id] = c;
    h();
  }
  return { populatelabels: g, destroy() {
    o();
  } };
}
function He(n3, e, i, t2, s) {
  let { interactive: o, enabled: a, rank: l, anchor: h, dynamicResize: m, zIndex: d, contentHTML: g, lowPriorityPin: r } = t2;
  if (o == null || a == null) throw new Error("incomplete marker state");
  let c = { interactive: o, enabled: a, rank: l || "medium", anchor: Array.isArray(h) ? h.join(", ") : h || "center", dynamicResize: m || false, zIndex: d || 0, contentHTML: g || "", lowPriorityPin: { enabled: r?.enabled ?? true, size: r?.size ?? 8, color: E(r?.color ?? "#666") }, remove() {
    n3.Markers.remove(e), s?.(e), i.destroy();
  }, isInView: j(n3, e.id) };
  i.onChange((v) => {
    let x = { interactive: c.interactive, enabled: c.enabled, rank: c.rank, dynamicResize: c.dynamicResize, contentHTML: c.contentHTML, lowPriorityPin: { enabled: c.lowPriorityPin.enabled, size: c.lowPriorityPin.size, color: c.lowPriorityPin.color } };
    c.rank === "always-visible" && (x.zIndex = c.zIndex), n3.updateState(e, x);
  }), i.add(c, "interactive"), i.add(c, "enabled"), i.add(c, "rank", ["medium", "high", "always-visible", "initial"]).name("rank"), i.add(c, "anchor").name("anchor (read-only)").disable(), i.add(c, "dynamicResize").name("dynamic resize"), c.rank === "always-visible" && i.add(c, "zIndex", 0, 1e3, 1).name("z-index"), i.add(c, "contentHTML").name("content HTML");
  let p = i.addFolder("Low Priority Pin");
  p.add(c.lowPriorityPin, "enabled"), p.add(c.lowPriorityPin, "size", 1, 20, 1), p.addColor(c.lowPriorityPin, "color"), p.close(), i.add(c, "isInView"), i.add(c, "remove");
}
function Ge(n3, e, i, t2, s) {
  let { appearance: o, interactive: a } = t2;
  if (!o || o.margin == null || a == null) throw new Error("incomplte label state");
  let l = { text: e.text, interactive: a, appearance: { ...o, margin: o.margin || 0, pinColor: o.pinColor ? E(o.pinColor) : "black", textColor: o.textColor ? E(o.textColor) : "black" }, remove() {
    n3.Labels.remove(e), s?.(e), i.destroy();
  }, isInView: j(n3, e.id) };
  i.onChange((h) => {
    n3.updateState(e, { appearance: l.appearance, interactive: l.interactive });
  }), i.add(l.appearance, "margin", 0, 20).name("margin"), i.add(l, "text"), i.add(l, "interactive"), i.addColor(l.appearance, "pinColor").name("pin color"), i.addColor(l.appearance, "pinOutlineColor").name("pin outline color"), i.addColor(l.appearance, "textColor").name("text color"), i.addColor(l.appearance, "textOutlineColor").name("text outline color"), i.add(l, "isInView"), i.add(l, "remove");
}
function O(n3, e, i, { onRemove: t2 } = {}) {
  let s = n3.getState(e);
  if (!s) throw new Error(`error getting state for entity: ${e.id}`);
  let o = s.type === mI ? e.text?.substring(0, 12) || "Label" : `Marker ${e.id.toString().substring(0, 8)}`, a = i.addFolder(o);
  if (a.close(), s.type === mI) Ge(n3, e, a, s, t2);
  else if (s.type === fI) He(n3, e, a, s, t2);
  else throw new Error(`unsupported entity type: ${s.type}`);
  return { labelItemFolder: a, destroy() {
    a.destroy();
  } };
}
function Be(n3, e) {
  let i = n3.addFolder("Add"), t2 = { onClick: false, margin: 6, text: "New Label!", interactive: true, marginForegroundColor: E("skyblue"), marginBackgroundColor: E("coral"), textForegroundColor: E("slategray"), textBackgroundColor: E("white") };
  return i.add(t2, "onClick"), i.add(t2, "margin"), i.add(t2, "interactive"), i.add(t2, "text"), { destroy() {
    i.destroy();
  }, addLabel(s) {
    return i._closed || !t2.onClick ? void 0 : e.Labels.add(s, t2.text, { appearance: { margin: t2.margin, pinColor: t2.marginForegroundColor, pinOutlineColor: t2.marginBackgroundColor, textColor: t2.textForegroundColor, textOutlineColor: t2.textBackgroundColor }, interactive: t2.interactive });
  } };
}
var pe = {};
$i();
var ge2 = "camera-ui";
function me(n3, e, i) {
  let t2 = n3.addFolder("Camera 📷").onOpenClose((b) => {
    ee({ opened: !b._closed }, ge2);
  }), { params: s } = te(ge2);
  s.opened || t2.close();
  let o = e.Camera.center.toJSON(), a = document.createElement("div");
  Object.assign(a.style, { display: "none", position: "absolute", left: "0px", zIndex: 999, top: "0px", bottom: "0px", right: "0px", backgroundColor: "aqua", pointerEvents: "none", opacity: 0.5 }), e.container.appendChild(a);
  let l = () => e.getDimensions(), [h, m, d, g] = i?.padding ?? [e.Camera.screenOffsets.top, e.Camera.screenOffsets.right, e.Camera.screenOffsets.bottom, e.Camera.screenOffsets.left], r = { center_lat: o.latitude, center_lon: o.longitude, zoomLevel: e.Camera.zoomLevel, pitch: e.Camera.pitch, bearing: e.Camera.bearing, minZoomLevel: e.Camera.minZoomLevel, maxZoomLevel: e.Camera.maxZoomLevel, inset_type: i?.padding ? "pixel" : e.Camera.screenOffsets.type, inset_top: h, inset_left: g, inset_right: m, inset_bottom: d, animateOnLoad: true, persist: () => {
    ee(t2.save().controllers, "camera"), navigator.clipboard.writeText(window.location.href);
  }, visualizeInset: !!(h || m || d || g), "Focus on click": i?.focusOnClick ?? true, "Focus on current floor": () => {
    e.Camera.focusOn([e.currentFloor], { screenOffsets: { top: 20, left: 20, right: 20, bottom: 20 } });
  } };
  function c() {
    r.inset_type = e.Camera.screenOffsets.type, r.inset_left = e.Camera.screenOffsets.left, r.inset_top = e.Camera.screenOffsets.top, r.inset_right = e.Camera.screenOffsets.right, r.inset_bottom = e.Camera.screenOffsets.bottom;
    let { width: b, height: A } = l();
    r.inset_type === "portion" ? Object.assign(a.style, { left: r.inset_left * b + "px", top: r.inset_top * A + "px", bottom: r.inset_bottom * A + "px", right: r.inset_right * b + "px" }) : Object.assign(a.style, { left: r.inset_left + "px", top: r.inset_top + "px", bottom: r.inset_bottom + "px", right: r.inset_right + "px" });
  }
  t2.add(r, "center_lat").listen().disable(), t2.add(r, "center_lon").listen().disable(), t2.add(r, "zoomLevel", 16, 22, 0.5).listen().disable(), t2.add(r, "pitch").listen().disable(), t2.add(r, "bearing").listen().disable(), t2.add(r, "minZoomLevel", 5, 22, 0.5).onChange((b) => {
    e.Camera.setMinZoomLevel(b);
  }), t2.add(r, "maxZoomLevel", 10, 22, 0.5).onChange((b) => {
    e.Camera.setMaxZoomLevel(b);
  }), t2.add(r, "animateOnLoad"), t2.add(r, "visualizeInset").onChange(ne), ne(r.visualizeInset);
  let p, v, x, u;
  function f() {
    let { width: b, height: A } = l(), X = e.Camera.screenOffsets.type, Y = r.inset_type;
    X !== Y && (Y === "portion" && X === "pixel" ? (r.inset_top = b > 0 ? Math.min(r.inset_top / A, 1) : 0, r.inset_bottom = b > 0 ? Math.min(r.inset_bottom / A, 1) : 0, r.inset_left = A > 0 ? Math.min(r.inset_left / b, 1) : 0, r.inset_right = A > 0 ? Math.min(r.inset_right / b, 1) : 0) : Y === "pixel" && X === "portion" && (r.inset_top = Math.round(r.inset_top * A), r.inset_bottom = Math.round(r.inset_bottom * A), r.inset_left = Math.round(r.inset_left * b), r.inset_right = Math.round(r.inset_right * b))), p && p.destroy(), v && v.destroy(), x && x.destroy(), u && u.destroy(), r.inset_type === "portion" ? (p = t2.add(r, "inset_top", 0, 1, 0.01).onChange(k), v = t2.add(r, "inset_bottom", 0, 1, 0.01).onChange(k), x = t2.add(r, "inset_left", 0, 1, 0.01).onChange(k), u = t2.add(r, "inset_right", 0, 1, 0.01).onChange(k)) : (p = t2.add(r, "inset_top", 0, A, 1).onChange(k), v = t2.add(r, "inset_bottom", 0, A, 1).onChange(k), x = t2.add(r, "inset_left", 0, b, 1).onChange(k), u = t2.add(r, "inset_right", 0, b, 1).onChange(k));
  }
  t2.add(r, "inset_type", ["pixel", "portion"]).onChange(() => {
    f(), k();
  }), f();
  let C = Ue(e);
  t2.add(r, "Focus on click").onChange((b) => {
    b ? e.on("click", C) : e.off("click", C);
  }), r["Focus on click"] && e.on("click", C), t2.add(r, "persist"), t2.add(r, "Focus on current floor");
  let L = (b) => {
    t2._closed || (r.center_lat = b.center.latitude, r.center_lon = b.center.longitude, r.zoomLevel = b.zoomLevel, r.bearing = b.bearing, r.pitch = b.pitch);
  };
  e.on("camera-change", L);
  let { params: z } = te("camera", r);
  if (Object.keys(z).length > 0) {
    let b = z;
    e.Camera.setScreenOffsets({ top: b.inset_top, left: b.inset_left, right: b.inset_right, bottom: b.inset_bottom, type: b.inset_type });
    let A = { pitch: b.pitch, center: new ge(b.center_lat, b.center_lon), bearing: b.bearing, zoomLevel: b.zoomLevel };
    b.animateOnLoad ? e.Camera.animateTo(A) : e.Camera.set(A), t2.load({ controllers: b, folders: {} }), c();
  }
  let we = [() => {
    e.off("camera-change", L);
  }];
  function k() {
    e.Camera.setScreenOffsets({ top: r.inset_top, left: r.inset_left, right: r.inset_right, bottom: r.inset_bottom, type: r.inset_type }), c();
  }
  (r.inset_top || r.inset_right || r.inset_bottom || r.inset_left) && k();
  function ne(b) {
    c(), b ? a.style.display = "block" : a.style.display = "none";
  }
  return () => ({ destroy() {
    t2.destroy(), de(we);
  } });
}
function Ue(n3) {
  return function(i) {
    let { spaces: t2, objects: s } = i, o = t2?.[0] ?? s?.[0];
    o && n3.Camera.focusOn(o);
  };
}
$i();
function fe(n3, e, i) {
  let t2 = { markers: {}, removeAllMarkers() {
    i.Markers.removeAll().forEach((c) => {
      delete this.markers[c.id];
    }), h();
  } }, { addMarker: s, destroy: o } = je(n3, i);
  n3.add(t2, "removeAllMarkers");
  let a = n3.addFolder("Marker List");
  n3.close();
  let l = /* @__PURE__ */ new Map(), { rerender: h } = m();
  function m() {
    function r(v) {
      delete t2.markers[v.id], l.get(v.id)?.destroy();
    }
    function c(v) {
      let x = O(i, v, a, { onRemove: (f) => {
        r(f);
      } });
      if (!x) return;
      let { labelItemFolder: u } = x;
      l.set(v.id, u);
    }
    function p() {
      a.destroy(), a = n3.addFolder("marker");
      for (let v in t2.markers) {
        let x = t2.markers[v];
        c(x);
      }
    }
    return { rerender: p, add: c, remove: r };
  }
  n3.domElement.classList.add("list-items");
  let d;
  i.on("click", ({ markers: r, coordinate: c }) => {
    if (!n3._closed) if (r?.[0]) {
      d?.close();
      let p = l.get(r[0].id);
      if (n3.open(), !p) return;
      p?.open(), p?.domElement.scrollIntoView({ block: "start" }), p?.domElement.focus(), d = p;
    } else s(c);
  });
  function g(r) {
    for (let c of r) t2.markers[c.id] = c;
    h();
  }
  return { populateMarkers: g, destroy() {
    o();
  } };
}
function je(n3, e) {
  let i = n3.addFolder("Add"), t2 = { onClick: false, interactive: true, rank: "medium", anchor: "center", dynamicResize: false, enabled: true, zIndex: 0, lowPriorityPin: { enabled: true, size: 8, color: "#666" }, contentHTML: '<div style="padding: 8px; background: white; border: 2px solid #333; border-radius: 4px;">New Marker</div>' };
  i.add(t2, "onClick"), i.add(t2, "interactive"), i.add(t2, "enabled"), i.add(t2, "rank", ["medium", "high", "always-visible", "initial"]).name("rank"), i.add(t2, "anchor", ["center", "top", "bottom", "left", "right", "top-left", "top-right", "bottom-left", "bottom-right"]).name("anchor"), i.add(t2, "dynamicResize").name("dynamic resize"), i.add(t2, "zIndex", 0, 1e3, 1).name("z-index (always-visible only)"), i.add(t2, "contentHTML").name("content HTML");
  let s = i.addFolder("Low Priority Pin");
  return s.add(t2.lowPriorityPin, "enabled"), s.add(t2.lowPriorityPin, "size", 1, 20, 1), s.addColor(t2.lowPriorityPin, "color"), s.close(), { destroy() {
    i.destroy();
  }, addMarker(o) {
    if (i._closed || !t2.onClick) return;
    let a = { interactive: t2.interactive, enabled: t2.enabled, rank: t2.rank, anchor: t2.anchor, dynamicResize: t2.dynamicResize, lowPriorityPin: { enabled: t2.lowPriorityPin.enabled, size: t2.lowPriorityPin.size, color: t2.lowPriorityPin.color } };
    return t2.rank === "always-visible" && (a.zIndex = t2.zIndex), e.Markers.add(o, t2.contentHTML, a);
  } };
}
$i();
function be(n3, e) {
  let i = n3.addFolder("Walls").close(), t2 = { visible: true, topColor: "#b1fa87", color: "#e8e8e8", texture: { url: "" }, topTexture: { url: "" } };
  i.add(t2, "visible").onChange((a) => {
    e.updateState("exterior-walls", { visible: a });
  }), i.addColor(t2, "topColor").onChange((a) => {
    e.updateState("exterior-walls", { topColor: a });
  }), i.addColor(t2, "color").onChange((a) => {
    e.updateState("exterior-walls", { color: a });
  }), i.addFolder("Texture - side").add(t2.texture, "url").onFinishChange((a) => {
    e.updateState("exterior-walls", { texture: { url: a } });
  }), i.addFolder("Texture - top").add(t2.topTexture, "url").onFinishChange((a) => {
    e.updateState("exterior-walls", { topTexture: { url: a } });
  }), e.updateState("exterior-walls", { topColor: t2.topColor }), e.updateState("exterior-walls", { color: t2.color });
}
$i();
function ve(n3, e, i) {
  n3.close();
  let t2 = { language: i.currentLanguage?.code ?? "en" }, s = i.getByType("enterprise-venue");
  n3.add(t2, "language", s?.languages.map((o) => o.code)).onChange((o) => {
    i.changeLanguage(o);
  });
}
$i();
function ye(n3, e, i) {
  let t2 = n3.addFolder("Debug");
  t2.close();
  let s = e.Debug.state, o = { showPolygonLabelTextAreaMesh: s.showPolygonLabelTextAreaMesh, showCollisionBoxes: s.showCollisionBoxes, showEnvMap: s.showEnvMap };
  t2.add(o, "showPolygonLabelTextAreaMesh").onChange((a) => {
    e.Debug.update({ showPolygonLabelTextAreaMesh: a });
  }).name("Show Flat Label Text Area Mesh"), t2.add(o, "showCollisionBoxes").onChange((a) => {
    e.Debug.update({ showCollisionBoxes: a });
  }).name("Show Collision Boxes"), t2.add(o, "showEnvMap").onChange((a) => {
    e.Debug.update({ showEnvMap: a });
  }).name("Show Environment Map"), e.Debug.update(o);
}
$i();
function xe(n3, e, i) {
  let t2 = n3.addFolder("Text3D").close(), s = { all: () => {
    e.Text3D.labelAll();
  }, removeAll: () => {
    e.Text3D.removeAll();
  } };
  t2.add(s, "all").name("Show All"), t2.add(s, "removeAll").name("Remove All");
}
function Ae(n3, e, i) {
  Xe();
  let t2 = new G({ title: "SDK Controls" });
  t2.domElement.classList.add("mappedin-js-inspector"), he(e, n3, t2), me(t2, e, i?.camera);
  let s = t2.addFolder("Levels").close(), o = t2.addFolder("Scene Controls");
  o.close();
  let a = t2.addFolder("Labels");
  xe(t2, e, n3);
  let l = t2.addFolder("Markers");
  be(t2, e);
  let h = t2.addFolder("misc");
  ye(t2, e, n3), ve(h, e, n3);
  let m = { level: e.currentFloor.id }, { populatelabels: d } = ue(a, n3, e), { populateMarkers: g } = fe(l, n3, e), r = n3.getByType("floor").reduce((p, v) => (p[v.name] = v.id, p), {}), c = s.add(m, "level", r).onChange((p) => {
    e.setFloor(p), m.level = e.currentFloor.id, c.updateDisplay();
  });
  return e.on("floor-change-start", (p) => {
    s.controllers[0].setValue(p.floor.id);
  }), n3.getByType("space").forEach((p) => {
    e.updateState(p, { interactive: true });
  }), n3.getByType("object").forEach((p) => {
    e.updateState(p, { interactive: true });
  }), n3.getByType("object").forEach((p) => {
    e.updateState(p, { interactive: true });
  }), e.setHoverColor("#a2b7e6"), e.Camera.setMaxZoomLevel(20), { populatelabels: d, sceneFolder: o, populateMarkers: g };
}
var Ce = "mappedin-sdk-debug-css";
function Xe() {
  if (document.getElementById(Ce)) return;
  let n3 = document.createElement("style");
  n3.id = Ce, n3.textContent = pe, document.head.appendChild(n3);
}
var ie = class {
  constructor(e, i) {
    t(this, "_enabled", false);
    t(this, "mv");
    t(this, "api");
    t(this, "mapData");
    t(this, "scenegraphVisualizerMounted", false);
    t(this, "storeStateToLocalStorageEnabled", false);
    this.mv = e, this.api = i, this.mapData = this.api.getMapData();
  }
  setMapData(e) {
    this.mapData = e;
  }
  async enable(e = {}) {
    if (this._enabled) return;
    if (this._enabled = true, !this.mapData) throw new Error("Please set mapData before enable debug.");
    let { sceneFolder: i } = Ae(this.mapData, this.mv, e);
    i.onOpenClose((t2) => {
      t2 === i && !t2._closed && !this.scenegraphVisualizerMounted && (this.scenegraphVisualizerMounted = true, bH(this.api.core, i));
    }), this.api.getMapDataInternal()?.spaces.forEach((t2) => {
      this.mv.updateState(t2, { interactive: true });
    });
  }
  get enabled() {
    return this._enabled;
  }
};
export {
  ie as Inspector
};
//# sourceMappingURL=inspector-66PSYVJU-JD44QJWV.js.map
