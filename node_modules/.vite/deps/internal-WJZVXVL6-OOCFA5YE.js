import {
  $y,
  Ny,
  Rr,
  _o,
  da
} from "./chunk-WRTOVFXP.js";
import {
  external_exports,
  k5
} from "./chunk-4WA6YUVK.js";
import "./chunk-QAS2ACFW.js";
import {
  $i
} from "./chunk-X36R2MTZ.js";
import {
  q,
  s,
  t,
  u,
  v,
  w,
  x
} from "./chunk-J7CDIHLL.js";
import "./chunk-PLDDJCW6.js";

// node_modules/@mappedin/mappedin-js/lib/esm/internal-WJZVXVL6.js
var It = q((V, M) => {
  $i();
  var Wt = 200, it = "__lodash_hash_undefined__", Ut = 800, $t = 16, st = 9007199254740991, rt = "[object Arguments]", Gt = "[object Array]", qt = "[object AsyncFunction]", Jt = "[object Boolean]", Ht = "[object Date]", Kt = "[object Error]", ot = "[object Function]", Qt = "[object GeneratorFunction]", Yt = "[object Map]", Zt = "[object Number]", Xt = "[object Null]", at = "[object Object]", en = "[object Proxy]", tn = "[object RegExp]", nn = "[object Set]", sn = "[object String]", rn = "[object Undefined]", on = "[object WeakMap]", an = "[object ArrayBuffer]", cn = "[object DataView]", un = "[object Float32Array]", ln = "[object Float64Array]", dn = "[object Int8Array]", hn = "[object Int16Array]", fn = "[object Int32Array]", pn = "[object Uint8Array]", gn = "[object Uint8ClampedArray]", mn = "[object Uint16Array]", _n = "[object Uint32Array]", yn = /[\\^$.*+?()[\]{}|]/g, bn = /^\[object .+?Constructor\]$/, wn = /^(?:0|[1-9]\d*)$/, _ = {};
  _[un] = _[ln] = _[dn] = _[hn] = _[fn] = _[pn] = _[gn] = _[mn] = _[_n] = true;
  _[rt] = _[Gt] = _[an] = _[Jt] = _[cn] = _[Ht] = _[Kt] = _[ot] = _[Yt] = _[Zt] = _[at] = _[tn] = _[nn] = _[sn] = _[on] = false;
  var ct = typeof global == "object" && global && global.Object === Object && global, Sn = typeof self == "object" && self && self.Object === Object && self, N = ct || Sn || Function("return this")(), ut = typeof V == "object" && V && !V.nodeType && V, P = ut && typeof M == "object" && M && !M.nodeType && M, lt = P && P.exports === ut, ge = lt && ct.process, He = (function() {
    try {
      var t4 = P && P.require && P.require("util").types;
      return t4 || ge && ge.binding && ge.binding("util");
    } catch {
    }
  })(), Ke = He && He.isTypedArray;
  function dt(t4, e, n) {
    switch (n.length) {
      case 0:
        return t4.call(e);
      case 1:
        return t4.call(e, n[0]);
      case 2:
        return t4.call(e, n[0], n[1]);
      case 3:
        return t4.call(e, n[0], n[1], n[2]);
    }
    return t4.apply(e, n);
  }
  function vn(t4, e) {
    for (var n = -1, i = Array(t4); ++n < t4; ) i[n] = e(n);
    return i;
  }
  function xn(t4) {
    return function(e) {
      return t4(e);
    };
  }
  function In(t4, e) {
    return t4?.[e];
  }
  function Tn(t4, e) {
    return function(n) {
      return t4(e(n));
    };
  }
  var zn = Array.prototype, On = Function.prototype, Q = Object.prototype, me = N["__core-js_shared__"], Y = On.toString, x2 = Q.hasOwnProperty, Qe = (function() {
    var t4 = /[^.]+$/.exec(me && me.keys && me.keys.IE_PROTO || "");
    return t4 ? "Symbol(src)_1." + t4 : "";
  })(), ht = Q.toString, Cn = Y.call(Object), An = RegExp("^" + Y.call(x2).replace(yn, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), H = lt ? N.Buffer : void 0, Ye = N.Symbol, Ze = N.Uint8Array, Xe = H ? H.allocUnsafe : void 0, ft = Tn(Object.getPrototypeOf, Object), et = Object.create, Fn = Q.propertyIsEnumerable, Mn = zn.splice, O = Ye ? Ye.toStringTag : void 0, K = (function() {
    try {
      var t4 = xe(Object, "defineProperty");
      return t4({}, "", {}), t4;
    } catch {
    }
  })(), Ln = H ? H.isBuffer : void 0, tt = Math.max, En = Date.now, pt = xe(N, "Map"), B = xe(Object, "create"), jn = /* @__PURE__ */ (function() {
    function t4() {
    }
    return function(e) {
      if (!v2(e)) return {};
      if (et) return et(e);
      t4.prototype = e;
      var n = new t4();
      return t4.prototype = void 0, n;
    };
  })();
  function C(t4) {
    var e = -1, n = t4 == null ? 0 : t4.length;
    for (this.clear(); ++e < n; ) {
      var i = t4[e];
      this.set(i[0], i[1]);
    }
  }
  function Dn() {
    this.__data__ = B ? B(null) : {}, this.size = 0;
  }
  function Rn(t4) {
    var e = this.has(t4) && delete this.__data__[t4];
    return this.size -= e ? 1 : 0, e;
  }
  function Vn(t4) {
    var e = this.__data__;
    if (B) {
      var n = e[t4];
      return n === it ? void 0 : n;
    }
    return x2.call(e, t4) ? e[t4] : void 0;
  }
  function Pn(t4) {
    var e = this.__data__;
    return B ? e[t4] !== void 0 : x2.call(e, t4);
  }
  function Bn(t4, e) {
    var n = this.__data__;
    return this.size += this.has(t4) ? 0 : 1, n[t4] = B && e === void 0 ? it : e, this;
  }
  C.prototype.clear = Dn;
  C.prototype.delete = Rn;
  C.prototype.get = Vn;
  C.prototype.has = Pn;
  C.prototype.set = Bn;
  function I(t4) {
    var e = -1, n = t4 == null ? 0 : t4.length;
    for (this.clear(); ++e < n; ) {
      var i = t4[e];
      this.set(i[0], i[1]);
    }
  }
  function Nn() {
    this.__data__ = [], this.size = 0;
  }
  function kn(t4) {
    var e = this.__data__, n = Z(e, t4);
    if (n < 0) return false;
    var i = e.length - 1;
    return n == i ? e.pop() : Mn.call(e, n, 1), --this.size, true;
  }
  function Wn(t4) {
    var e = this.__data__, n = Z(e, t4);
    return n < 0 ? void 0 : e[n][1];
  }
  function Un(t4) {
    return Z(this.__data__, t4) > -1;
  }
  function $n(t4, e) {
    var n = this.__data__, i = Z(n, t4);
    return i < 0 ? (++this.size, n.push([t4, e])) : n[i][1] = e, this;
  }
  I.prototype.clear = Nn;
  I.prototype.delete = kn;
  I.prototype.get = Wn;
  I.prototype.has = Un;
  I.prototype.set = $n;
  function L(t4) {
    var e = -1, n = t4 == null ? 0 : t4.length;
    for (this.clear(); ++e < n; ) {
      var i = t4[e];
      this.set(i[0], i[1]);
    }
  }
  function Gn() {
    this.size = 0, this.__data__ = { hash: new C(), map: new (pt || I)(), string: new C() };
  }
  function qn(t4) {
    var e = ee(this, t4).delete(t4);
    return this.size -= e ? 1 : 0, e;
  }
  function Jn(t4) {
    return ee(this, t4).get(t4);
  }
  function Hn(t4) {
    return ee(this, t4).has(t4);
  }
  function Kn(t4, e) {
    var n = ee(this, t4), i = n.size;
    return n.set(t4, e), this.size += n.size == i ? 0 : 1, this;
  }
  L.prototype.clear = Gn;
  L.prototype.delete = qn;
  L.prototype.get = Jn;
  L.prototype.has = Hn;
  L.prototype.set = Kn;
  function E(t4) {
    var e = this.__data__ = new I(t4);
    this.size = e.size;
  }
  function Qn() {
    this.__data__ = new I(), this.size = 0;
  }
  function Yn(t4) {
    var e = this.__data__, n = e.delete(t4);
    return this.size = e.size, n;
  }
  function Zn(t4) {
    return this.__data__.get(t4);
  }
  function Xn(t4) {
    return this.__data__.has(t4);
  }
  function ei(t4, e) {
    var n = this.__data__;
    if (n instanceof I) {
      var i = n.__data__;
      if (!pt || i.length < Wt - 1) return i.push([t4, e]), this.size = ++n.size, this;
      n = this.__data__ = new L(i);
    }
    return n.set(t4, e), this.size = n.size, this;
  }
  E.prototype.clear = Qn;
  E.prototype.delete = Yn;
  E.prototype.get = Zn;
  E.prototype.has = Xn;
  E.prototype.set = ei;
  function ti(t4, e) {
    var n = we(t4), i = !n && be(t4), s2 = !n && !i && bt(t4), r = !n && !i && !s2 && St(t4), o = n || i || s2 || r, a = o ? vn(t4.length, String) : [], c = a.length;
    for (var u2 in t4) (e || x2.call(t4, u2)) && !(o && (u2 == "length" || s2 && (u2 == "offset" || u2 == "parent") || r && (u2 == "buffer" || u2 == "byteLength" || u2 == "byteOffset") || _t(u2, c))) && a.push(u2);
    return a;
  }
  function _e(t4, e, n) {
    (n !== void 0 && !te(t4[e], n) || n === void 0 && !(e in t4)) && Se(t4, e, n);
  }
  function ni(t4, e, n) {
    var i = t4[e];
    (!(x2.call(t4, e) && te(i, n)) || n === void 0 && !(e in t4)) && Se(t4, e, n);
  }
  function Z(t4, e) {
    for (var n = t4.length; n--; ) if (te(t4[n][0], e)) return n;
    return -1;
  }
  function Se(t4, e, n) {
    e == "__proto__" && K ? K(t4, e, { configurable: true, enumerable: true, value: n, writable: true }) : t4[e] = n;
  }
  var ii = gi();
  function X(t4) {
    return t4 == null ? t4 === void 0 ? rn : Xt : O && O in Object(t4) ? mi(t4) : vi(t4);
  }
  function nt(t4) {
    return k(t4) && X(t4) == rt;
  }
  function si(t4) {
    if (!v2(t4) || wi(t4)) return false;
    var e = Te(t4) ? An : bn;
    return e.test(zi(t4));
  }
  function ri(t4) {
    return k(t4) && wt(t4.length) && !!_[X(t4)];
  }
  function oi(t4) {
    if (!v2(t4)) return Si(t4);
    var e = yt(t4), n = [];
    for (var i in t4) i == "constructor" && (e || !x2.call(t4, i)) || n.push(i);
    return n;
  }
  function ve(t4, e, n, i, s2) {
    t4 !== e && ii(e, function(r, o) {
      if (s2 || (s2 = new E()), v2(r)) ai(t4, e, o, n, ve, i, s2);
      else {
        var a = i ? i(ye(t4, o), r, o + "", t4, e, s2) : void 0;
        a === void 0 && (a = r), _e(t4, o, a);
      }
    }, vt);
  }
  function ai(t4, e, n, i, s2, r, o) {
    var a = ye(t4, n), c = ye(e, n), u2 = o.get(c);
    if (u2) {
      _e(t4, n, u2);
      return;
    }
    var l = r ? r(a, c, n + "", t4, e, o) : void 0, h = l === void 0;
    if (h) {
      var d = we(c), f = !d && bt(c), g = !d && !f && St(c);
      l = c, d || f || g ? we(a) ? l = a : Oi(a) ? l = hi(a) : f ? (h = false, l = ui(c, true)) : g ? (h = false, l = di(c, true)) : l = [] : Ci(c) || be(c) ? (l = a, be(a) ? l = Ai(a) : (!v2(a) || Te(a)) && (l = _i(c))) : h = false;
    }
    h && (o.set(c, l), s2(l, c, i, r, o), o.delete(c)), _e(t4, n, l);
  }
  function gt(t4, e) {
    return Ii(xi(t4, e, xt), t4 + "");
  }
  var ci = K ? function(t4, e) {
    return K(t4, "toString", { configurable: true, enumerable: false, value: Li(e), writable: true });
  } : xt;
  function ui(t4, e) {
    if (e) return t4.slice();
    var n = t4.length, i = Xe ? Xe(n) : new t4.constructor(n);
    return t4.copy(i), i;
  }
  function li(t4) {
    var e = new t4.constructor(t4.byteLength);
    return new Ze(e).set(new Ze(t4)), e;
  }
  function di(t4, e) {
    var n = e ? li(t4.buffer) : t4.buffer;
    return new t4.constructor(n, t4.byteOffset, t4.length);
  }
  function hi(t4, e) {
    var n = -1, i = t4.length;
    for (e || (e = Array(i)); ++n < i; ) e[n] = t4[n];
    return e;
  }
  function fi(t4, e, n, i) {
    var s2 = !n;
    n || (n = {});
    for (var r = -1, o = e.length; ++r < o; ) {
      var a = e[r], c = i ? i(n[a], t4[a], a, n, t4) : void 0;
      c === void 0 && (c = t4[a]), s2 ? Se(n, a, c) : ni(n, a, c);
    }
    return n;
  }
  function pi(t4) {
    return gt(function(e, n) {
      var i = -1, s2 = n.length, r = s2 > 1 ? n[s2 - 1] : void 0, o = s2 > 2 ? n[2] : void 0;
      for (r = t4.length > 3 && typeof r == "function" ? (s2--, r) : void 0, o && yi(n[0], n[1], o) && (r = s2 < 3 ? void 0 : r, s2 = 1), e = Object(e); ++i < s2; ) {
        var a = n[i];
        a && t4(e, a, i, r);
      }
      return e;
    });
  }
  function gi(t4) {
    return function(e, n, i) {
      for (var s2 = -1, r = Object(e), o = i(e), a = o.length; a--; ) {
        var c = o[t4 ? a : ++s2];
        if (n(r[c], c, r) === false) break;
      }
      return e;
    };
  }
  function mt(t4, e, n, i, s2, r) {
    return v2(t4) && v2(e) && (r.set(e, t4), ve(t4, e, void 0, mt, r), r.delete(e)), t4;
  }
  function ee(t4, e) {
    var n = t4.__data__;
    return bi(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
  }
  function xe(t4, e) {
    var n = In(t4, e);
    return si(n) ? n : void 0;
  }
  function mi(t4) {
    var e = x2.call(t4, O), n = t4[O];
    try {
      t4[O] = void 0;
      var i = true;
    } catch {
    }
    var s2 = ht.call(t4);
    return i && (e ? t4[O] = n : delete t4[O]), s2;
  }
  function _i(t4) {
    return typeof t4.constructor == "function" && !yt(t4) ? jn(ft(t4)) : {};
  }
  function _t(t4, e) {
    var n = typeof t4;
    return e = e ?? st, !!e && (n == "number" || n != "symbol" && wn.test(t4)) && t4 > -1 && t4 % 1 == 0 && t4 < e;
  }
  function yi(t4, e, n) {
    if (!v2(n)) return false;
    var i = typeof e;
    return (i == "number" ? Ie(n) && _t(e, n.length) : i == "string" && e in n) ? te(n[e], t4) : false;
  }
  function bi(t4) {
    var e = typeof t4;
    return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t4 !== "__proto__" : t4 === null;
  }
  function wi(t4) {
    return !!Qe && Qe in t4;
  }
  function yt(t4) {
    var e = t4 && t4.constructor, n = typeof e == "function" && e.prototype || Q;
    return t4 === n;
  }
  function Si(t4) {
    var e = [];
    if (t4 != null) for (var n in Object(t4)) e.push(n);
    return e;
  }
  function vi(t4) {
    return ht.call(t4);
  }
  function xi(t4, e, n) {
    return e = tt(e === void 0 ? t4.length - 1 : e, 0), function() {
      for (var i = arguments, s2 = -1, r = tt(i.length - e, 0), o = Array(r); ++s2 < r; ) o[s2] = i[e + s2];
      s2 = -1;
      for (var a = Array(e + 1); ++s2 < e; ) a[s2] = i[s2];
      return a[e] = n(o), dt(t4, this, a);
    };
  }
  function ye(t4, e) {
    if (!(e === "constructor" && typeof t4[e] == "function") && e != "__proto__") return t4[e];
  }
  var Ii = Ti(ci);
  function Ti(t4) {
    var e = 0, n = 0;
    return function() {
      var i = En(), s2 = $t - (i - n);
      if (n = i, s2 > 0) {
        if (++e >= Ut) return arguments[0];
      } else e = 0;
      return t4.apply(void 0, arguments);
    };
  }
  function zi(t4) {
    if (t4 != null) {
      try {
        return Y.call(t4);
      } catch {
      }
      try {
        return t4 + "";
      } catch {
      }
    }
    return "";
  }
  function te(t4, e) {
    return t4 === e || t4 !== t4 && e !== e;
  }
  var be = nt(/* @__PURE__ */ (function() {
    return arguments;
  })()) ? nt : function(t4) {
    return k(t4) && x2.call(t4, "callee") && !Fn.call(t4, "callee");
  }, we = Array.isArray;
  function Ie(t4) {
    return t4 != null && wt(t4.length) && !Te(t4);
  }
  function Oi(t4) {
    return k(t4) && Ie(t4);
  }
  var bt = Ln || Ei;
  function Te(t4) {
    if (!v2(t4)) return false;
    var e = X(t4);
    return e == ot || e == Qt || e == qt || e == en;
  }
  function wt(t4) {
    return typeof t4 == "number" && t4 > -1 && t4 % 1 == 0 && t4 <= st;
  }
  function v2(t4) {
    var e = typeof t4;
    return t4 != null && (e == "object" || e == "function");
  }
  function k(t4) {
    return t4 != null && typeof t4 == "object";
  }
  function Ci(t4) {
    if (!k(t4) || X(t4) != at) return false;
    var e = ft(t4);
    if (e === null) return true;
    var n = x2.call(e, "constructor") && e.constructor;
    return typeof n == "function" && n instanceof n && Y.call(n) == Cn;
  }
  var St = Ke ? xn(Ke) : ri;
  function Ai(t4) {
    return fi(t4, vt(t4));
  }
  var Fi = gt(function(t4) {
    return t4.push(void 0, mt), dt(Mi, void 0, t4);
  });
  function vt(t4) {
    return Ie(t4) ? ti(t4, true) : oi(t4);
  }
  var Mi = pi(function(t4, e, n, i) {
    ve(t4, e, n, i);
  });
  function Li(t4) {
    return function() {
      return t4;
    };
  }
  function xt(t4) {
    return t4;
  }
  function Ei() {
    return false;
  }
  M.exports = Fi;
});
$i();
$i();
var Mt = "ENTRIES";
var ke = "KEYS";
var We = "VALUES";
var b = "";
var D = class {
  constructor(e, n) {
    let i = e._tree, s2 = Array.from(i.keys());
    this.set = e, this._type = n, this._path = s2.length > 0 ? [{ node: i, keys: s2 }] : [];
  }
  next() {
    let e = this.dive();
    return this.backtrack(), e;
  }
  dive() {
    if (this._path.length === 0) return { done: true, value: void 0 };
    let { node: e, keys: n } = F(this._path);
    if (F(n) === b) return { done: false, value: this.result() };
    let i = e.get(F(n));
    return this._path.push({ node: i, keys: Array.from(i.keys()) }), this.dive();
  }
  backtrack() {
    if (this._path.length === 0) return;
    let e = F(this._path).keys;
    e.pop(), !(e.length > 0) && (this._path.pop(), this.backtrack());
  }
  key() {
    return this.set._prefix + this._path.map(({ keys: e }) => F(e)).filter((e) => e !== b).join("");
  }
  value() {
    return F(this._path).node.get(b);
  }
  result() {
    switch (this._type) {
      case We:
        return this.value();
      case ke:
        return this.key();
      default:
        return [this.key(), this.value()];
    }
  }
  [Symbol.iterator]() {
    return this;
  }
};
var F = (t4) => t4[t4.length - 1];
var Lt = (t4, e, n) => {
  let i = /* @__PURE__ */ new Map();
  if (e === void 0) return i;
  let s2 = e.length + 1, r = s2 + n, o = new Uint8Array(r * s2).fill(n + 1);
  for (let a = 0; a < s2; ++a) o[a] = a;
  for (let a = 1; a < r; ++a) o[a * s2] = a;
  return Ue(t4, e, n, i, o, 1, s2, ""), i;
};
var Ue = (t4, e, n, i, s2, r, o, a) => {
  let c = r * o;
  e: for (let u2 of t4.keys()) if (u2 === b) {
    let l = s2[c - 1];
    l <= n && i.set(a, [t4.get(u2), l]);
  } else {
    let l = r;
    for (let h = 0; h < u2.length; ++h, ++l) {
      let d = u2[h], f = o * l, g = f - o, m = s2[f], p = Math.max(0, l - n - 1), w2 = Math.min(o - 1, l + n);
      for (let S = p; S < w2; ++S) {
        let ie = d !== e[S], se = s2[g + S] + +ie, U = s2[g + S + 1] + 1, T = s2[f + S] + 1, j = s2[f + S + 1] = Math.min(se, U, T);
        j < m && (m = j);
      }
      if (m > n) continue e;
    }
    Ue(t4.get(u2), e, n, i, s2, l, o, a + u2);
  }
};
var R = class t2 {
  constructor(e = /* @__PURE__ */ new Map(), n = "") {
    this._size = void 0, this._tree = e, this._prefix = n;
  }
  atPrefix(e) {
    if (!e.startsWith(this._prefix)) throw new Error("Mismatched prefix");
    let [n, i] = J(this._tree, e.slice(this._prefix.length));
    if (n === void 0) {
      let [s2, r] = fe(i);
      for (let o of s2.keys()) if (o !== b && o.startsWith(r)) {
        let a = /* @__PURE__ */ new Map();
        return a.set(o.slice(r.length), s2.get(o)), new t2(a, e);
      }
    }
    return new t2(n, e);
  }
  clear() {
    this._size = void 0, this._tree.clear();
  }
  delete(e) {
    return this._size = void 0, Et(this._tree, e);
  }
  entries() {
    return new D(this, Mt);
  }
  forEach(e) {
    for (let [n, i] of this) e(n, i, this);
  }
  fuzzyGet(e, n) {
    return Lt(this._tree, e, n);
  }
  get(e) {
    let n = le(this._tree, e);
    return n !== void 0 ? n.get(b) : void 0;
  }
  has(e) {
    let n = le(this._tree, e);
    return n !== void 0 && n.has(b);
  }
  keys() {
    return new D(this, ke);
  }
  set(e, n) {
    if (typeof e != "string") throw new Error("key must be a string");
    return this._size = void 0, oe(this._tree, e).set(b, n), this;
  }
  get size() {
    if (this._size) return this._size;
    this._size = 0;
    let e = this.entries();
    for (; !e.next().done; ) this._size += 1;
    return this._size;
  }
  update(e, n) {
    if (typeof e != "string") throw new Error("key must be a string");
    this._size = void 0;
    let i = oe(this._tree, e);
    return i.set(b, n(i.get(b))), this;
  }
  fetch(e, n) {
    if (typeof e != "string") throw new Error("key must be a string");
    this._size = void 0;
    let i = oe(this._tree, e), s2 = i.get(b);
    return s2 === void 0 && i.set(b, s2 = n()), s2;
  }
  values() {
    return new D(this, We);
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  static from(e) {
    let n = new t2();
    for (let [i, s2] of e) n.set(i, s2);
    return n;
  }
  static fromObject(e) {
    return t2.from(Object.entries(e));
  }
};
var J = (t4, e, n = []) => {
  if (e.length === 0 || t4 == null) return [t4, n];
  for (let i of t4.keys()) if (i !== b && e.startsWith(i)) return n.push([t4, i]), J(t4.get(i), e.slice(i.length), n);
  return n.push([t4, e]), J(void 0, "", n);
};
var le = (t4, e) => {
  if (e.length === 0 || t4 == null) return t4;
  for (let n of t4.keys()) if (n !== b && e.startsWith(n)) return le(t4.get(n), e.slice(n.length));
};
var oe = (t4, e) => {
  let n = e.length;
  e: for (let i = 0; t4 && i < n; ) {
    for (let r of t4.keys()) if (r !== b && e[i] === r[0]) {
      let o = Math.min(n - i, r.length), a = 1;
      for (; a < o && e[i + a] === r[a]; ) ++a;
      let c = t4.get(r);
      if (a === r.length) t4 = c;
      else {
        let u2 = /* @__PURE__ */ new Map();
        u2.set(r.slice(a), c), t4.set(e.slice(i, i + a), u2), t4.delete(r), t4 = u2;
      }
      i += a;
      continue e;
    }
    let s2 = /* @__PURE__ */ new Map();
    return t4.set(e.slice(i), s2), s2;
  }
  return t4;
};
var Et = (t4, e) => {
  let [n, i] = J(t4, e);
  if (n !== void 0) {
    if (n.delete(b), n.size === 0) $e(i);
    else if (n.size === 1) {
      let [s2, r] = n.entries().next().value;
      Ge(i, s2, r);
    }
  }
};
var $e = (t4) => {
  if (t4.length === 0) return;
  let [e, n] = fe(t4);
  if (e.delete(n), e.size === 0) $e(t4.slice(0, -1));
  else if (e.size === 1) {
    let [i, s2] = e.entries().next().value;
    i !== b && Ge(t4.slice(0, -1), i, s2);
  }
};
var Ge = (t4, e, n) => {
  if (t4.length === 0) return;
  let [i, s2] = fe(t4);
  i.set(s2 + e, n), i.delete(s2);
};
var fe = (t4) => t4[t4.length - 1];
var pe = "or";
var qe = "and";
var jt = "and_not";
var z = class t3 {
  constructor(e) {
    if (e?.fields == null) throw new Error('MiniSearch: option "fields" must be provided');
    let n = e.autoVacuum == null || e.autoVacuum === true ? ue : e.autoVacuum;
    this._options = { ...ce, ...e, autoVacuum: n, searchOptions: { ...Re, ...e.searchOptions || {} }, autoSuggestOptions: { ...Bt, ...e.autoSuggestOptions || {} } }, this._index = new R(), this._documentCount = 0, this._documentIds = /* @__PURE__ */ new Map(), this._idToShortId = /* @__PURE__ */ new Map(), this._fieldIds = {}, this._fieldLength = /* @__PURE__ */ new Map(), this._avgFieldLength = [], this._nextId = 0, this._storedFields = /* @__PURE__ */ new Map(), this._dirtCount = 0, this._currentVacuum = null, this._enqueuedVacuum = null, this._enqueuedVacuumConditions = he, this.addFields(this._options.fields);
  }
  add(e) {
    let { extractField: n, stringifyField: i, tokenize: s2, processTerm: r, fields: o, idField: a } = this._options, c = n(e, a);
    if (c == null) throw new Error(`MiniSearch: document does not have ID field "${a}"`);
    if (this._idToShortId.has(c)) throw new Error(`MiniSearch: duplicate ID ${c}`);
    let u2 = this.addDocumentId(c);
    this.saveStoredFields(u2, e);
    for (let l of o) {
      let h = n(e, l);
      if (h == null) continue;
      let d = s2(i(h, l), l), f = this._fieldIds[l], g = new Set(d).size;
      this.addFieldLength(u2, f, this._documentCount - 1, g);
      for (let m of d) {
        let p = r(m, l);
        if (Array.isArray(p)) for (let w2 of p) this.addTerm(f, u2, w2);
        else p && this.addTerm(f, u2, p);
      }
    }
  }
  addAll(e) {
    for (let n of e) this.add(n);
  }
  addAllAsync(e, n = {}) {
    let { chunkSize: i = 10 } = n, s2 = { chunk: [], promise: Promise.resolve() }, { chunk: r, promise: o } = e.reduce(({ chunk: a, promise: c }, u2, l) => (a.push(u2), (l + 1) % i === 0 ? { chunk: [], promise: c.then(() => new Promise((h) => setTimeout(h, 0))).then(() => this.addAll(a)) } : { chunk: a, promise: c }), s2);
    return o.then(() => this.addAll(r));
  }
  remove(e) {
    let { tokenize: n, processTerm: i, extractField: s2, stringifyField: r, fields: o, idField: a } = this._options, c = s2(e, a);
    if (c == null) throw new Error(`MiniSearch: document does not have ID field "${a}"`);
    let u2 = this._idToShortId.get(c);
    if (u2 == null) throw new Error(`MiniSearch: cannot remove document with ID ${c}: it is not in the index`);
    for (let l of o) {
      let h = s2(e, l);
      if (h == null) continue;
      let d = n(r(h, l), l), f = this._fieldIds[l], g = new Set(d).size;
      this.removeFieldLength(u2, f, this._documentCount, g);
      for (let m of d) {
        let p = i(m, l);
        if (Array.isArray(p)) for (let w2 of p) this.removeTerm(f, u2, w2);
        else p && this.removeTerm(f, u2, p);
      }
    }
    this._storedFields.delete(u2), this._documentIds.delete(u2), this._idToShortId.delete(c), this._fieldLength.delete(u2), this._documentCount -= 1;
  }
  removeAll(e) {
    if (e) for (let n of e) this.remove(n);
    else {
      if (arguments.length > 0) throw new Error("Expected documents to be present. Omit the argument to remove all documents.");
      this._index = new R(), this._documentCount = 0, this._documentIds = /* @__PURE__ */ new Map(), this._idToShortId = /* @__PURE__ */ new Map(), this._fieldLength = /* @__PURE__ */ new Map(), this._avgFieldLength = [], this._storedFields = /* @__PURE__ */ new Map(), this._nextId = 0;
    }
  }
  discard(e) {
    let n = this._idToShortId.get(e);
    if (n == null) throw new Error(`MiniSearch: cannot discard document with ID ${e}: it is not in the index`);
    this._idToShortId.delete(e), this._documentIds.delete(n), this._storedFields.delete(n), (this._fieldLength.get(n) || []).forEach((i, s2) => {
      this.removeFieldLength(n, s2, this._documentCount, i);
    }), this._fieldLength.delete(n), this._documentCount -= 1, this._dirtCount += 1, this.maybeAutoVacuum();
  }
  maybeAutoVacuum() {
    if (this._options.autoVacuum === false) return;
    let { minDirtFactor: e, minDirtCount: n, batchSize: i, batchWait: s2 } = this._options.autoVacuum;
    this.conditionalVacuum({ batchSize: i, batchWait: s2 }, { minDirtCount: n, minDirtFactor: e });
  }
  discardAll(e) {
    let n = this._options.autoVacuum;
    try {
      this._options.autoVacuum = false;
      for (let i of e) this.discard(i);
    } finally {
      this._options.autoVacuum = n;
    }
    this.maybeAutoVacuum();
  }
  replace(e) {
    let { idField: n, extractField: i } = this._options, s2 = i(e, n);
    this.discard(s2), this.add(e);
  }
  vacuum(e = {}) {
    return this.conditionalVacuum(e);
  }
  conditionalVacuum(e, n) {
    return this._currentVacuum ? (this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && n, this._enqueuedVacuum != null ? this._enqueuedVacuum : (this._enqueuedVacuum = this._currentVacuum.then(() => {
      let i = this._enqueuedVacuumConditions;
      return this._enqueuedVacuumConditions = he, this.performVacuuming(e, i);
    }), this._enqueuedVacuum)) : this.vacuumConditionsMet(n) === false ? Promise.resolve() : (this._currentVacuum = this.performVacuuming(e), this._currentVacuum);
  }
  async performVacuuming(e, n) {
    let i = this._dirtCount;
    if (this.vacuumConditionsMet(n)) {
      let s2 = e.batchSize || de.batchSize, r = e.batchWait || de.batchWait, o = 1;
      for (let [a, c] of this._index) {
        for (let [u2, l] of c) for (let [h] of l) this._documentIds.has(h) || (l.size <= 1 ? c.delete(u2) : l.delete(h));
        this._index.get(a).size === 0 && this._index.delete(a), o % s2 === 0 && await new Promise((u2) => setTimeout(u2, r)), o += 1;
      }
      this._dirtCount -= i;
    }
    await null, this._currentVacuum = this._enqueuedVacuum, this._enqueuedVacuum = null;
  }
  vacuumConditionsMet(e) {
    if (e == null) return true;
    let { minDirtCount: n, minDirtFactor: i } = e;
    return n = n || ue.minDirtCount, i = i || ue.minDirtFactor, this.dirtCount >= n && this.dirtFactor >= i;
  }
  get isVacuuming() {
    return this._currentVacuum != null;
  }
  get dirtCount() {
    return this._dirtCount;
  }
  get dirtFactor() {
    return this._dirtCount / (1 + this._documentCount + this._dirtCount);
  }
  has(e) {
    return this._idToShortId.has(e);
  }
  getStoredFields(e) {
    let n = this._idToShortId.get(e);
    if (n != null) return this._storedFields.get(n);
  }
  search(e, n = {}) {
    let { searchOptions: i } = this._options, s2 = { ...i, ...n }, r = this.executeQuery(e, n), o = [];
    for (let [a, { score: c, terms: u2, match: l }] of r) {
      let h = u2.length || 1, d = { id: this._documentIds.get(a), score: c * h, terms: Object.keys(l), queryTerms: u2, match: l };
      Object.assign(d, this._storedFields.get(a)), (s2.filter == null || s2.filter(d)) && o.push(d);
    }
    return e === t3.wildcard && s2.boostDocument == null || o.sort(Pe), o;
  }
  autoSuggest(e, n = {}) {
    n = { ...this._options.autoSuggestOptions, ...n };
    let i = /* @__PURE__ */ new Map();
    for (let { score: r, terms: o } of this.search(e, n)) {
      let a = o.join(" "), c = i.get(a);
      c != null ? (c.score += r, c.count += 1) : i.set(a, { score: r, terms: o, count: 1 });
    }
    let s2 = [];
    for (let [r, { score: o, terms: a, count: c }] of i) s2.push({ suggestion: r, terms: a, score: o / c });
    return s2.sort(Pe), s2;
  }
  get documentCount() {
    return this._documentCount;
  }
  get termCount() {
    return this._index.size;
  }
  static loadJSON(e, n) {
    if (n == null) throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");
    return this.loadJS(JSON.parse(e), n);
  }
  static async loadJSONAsync(e, n) {
    if (n == null) throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");
    return this.loadJSAsync(JSON.parse(e), n);
  }
  static getDefault(e) {
    if (ce.hasOwnProperty(e)) return ae(ce, e);
    throw new Error(`MiniSearch: unknown option "${e}"`);
  }
  static loadJS(e, n) {
    let { index: i, documentIds: s2, fieldLength: r, storedFields: o, serializationVersion: a } = e, c = this.instantiateMiniSearch(e, n);
    c._documentIds = G(s2), c._fieldLength = G(r), c._storedFields = G(o);
    for (let [u2, l] of c._documentIds) c._idToShortId.set(l, u2);
    for (let [u2, l] of i) {
      let h = /* @__PURE__ */ new Map();
      for (let d of Object.keys(l)) {
        let f = l[d];
        a === 1 && (f = f.ds), h.set(parseInt(d, 10), G(f));
      }
      c._index.set(u2, h);
    }
    return c;
  }
  static async loadJSAsync(e, n) {
    let { index: i, documentIds: s2, fieldLength: r, storedFields: o, serializationVersion: a } = e, c = this.instantiateMiniSearch(e, n);
    c._documentIds = await q2(s2), c._fieldLength = await q2(r), c._storedFields = await q2(o);
    for (let [l, h] of c._documentIds) c._idToShortId.set(h, l);
    let u2 = 0;
    for (let [l, h] of i) {
      let d = /* @__PURE__ */ new Map();
      for (let f of Object.keys(h)) {
        let g = h[f];
        a === 1 && (g = g.ds), d.set(parseInt(f, 10), await q2(g));
      }
      ++u2 % 1e3 === 0 && await Je(0), c._index.set(l, d);
    }
    return c;
  }
  static instantiateMiniSearch(e, n) {
    let { documentCount: i, nextId: s2, fieldIds: r, averageFieldLength: o, dirtCount: a, serializationVersion: c } = e;
    if (c !== 1 && c !== 2) throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");
    let u2 = new t3(n);
    return u2._documentCount = i, u2._nextId = s2, u2._idToShortId = /* @__PURE__ */ new Map(), u2._fieldIds = r, u2._avgFieldLength = o, u2._dirtCount = a || 0, u2._index = new R(), u2;
  }
  executeQuery(e, n = {}) {
    if (e === t3.wildcard) return this.executeWildcardQuery(n);
    if (typeof e != "string") {
      let d = { ...n, ...e, queries: void 0 }, f = e.queries.map((g) => this.executeQuery(g, d));
      return this.combineResults(f, d.combineWith);
    }
    let { tokenize: i, processTerm: s2, searchOptions: r } = this._options, o = { tokenize: i, processTerm: s2, ...r, ...n }, { tokenize: a, processTerm: c } = o, h = a(e).flatMap((d) => c(d)).filter((d) => !!d).map(Pt(o)).map((d) => this.executeQuerySpec(d, o));
    return this.combineResults(h, o.combineWith);
  }
  executeQuerySpec(e, n) {
    let i = { ...this._options.searchOptions, ...n }, s2 = (i.fields || this._options.fields).reduce((m, p) => ({ ...m, [p]: ae(i.boost, p) || 1 }), {}), { boostDocument: r, weights: o, maxFuzzy: a, bm25: c } = i, { fuzzy: u2, prefix: l } = { ...Re.weights, ...o }, h = this._index.get(e.term), d = this.termResults(e.term, e.term, 1, e.termBoost, h, s2, r, c), f, g;
    if (e.prefix && (f = this._index.atPrefix(e.term)), e.fuzzy) {
      let m = e.fuzzy === true ? 0.2 : e.fuzzy, p = m < 1 ? Math.min(a, Math.round(e.term.length * m)) : m;
      p && (g = this._index.fuzzyGet(e.term, p));
    }
    if (f) for (let [m, p] of f) {
      let w2 = m.length - e.term.length;
      if (!w2) continue;
      g?.delete(m);
      let S = l * m.length / (m.length + 0.3 * w2);
      this.termResults(e.term, m, S, e.termBoost, p, s2, r, c, d);
    }
    if (g) for (let m of g.keys()) {
      let [p, w2] = g.get(m);
      if (!w2) continue;
      let S = u2 * m.length / (m.length + w2);
      this.termResults(e.term, m, S, e.termBoost, p, s2, r, c, d);
    }
    return d;
  }
  executeWildcardQuery(e) {
    let n = /* @__PURE__ */ new Map(), i = { ...this._options.searchOptions, ...e };
    for (let [s2, r] of this._documentIds) {
      let o = i.boostDocument ? i.boostDocument(r, "", this._storedFields.get(s2)) : 1;
      n.set(s2, { score: o, terms: [], match: {} });
    }
    return n;
  }
  combineResults(e, n = pe) {
    if (e.length === 0) return /* @__PURE__ */ new Map();
    let i = n.toLowerCase(), s2 = Dt[i];
    if (!s2) throw new Error(`Invalid combination operator: ${n}`);
    return e.reduce(s2) || /* @__PURE__ */ new Map();
  }
  toJSON() {
    let e = [];
    for (let [n, i] of this._index) {
      let s2 = {};
      for (let [r, o] of i) s2[r] = Object.fromEntries(o);
      e.push([n, s2]);
    }
    return { documentCount: this._documentCount, nextId: this._nextId, documentIds: Object.fromEntries(this._documentIds), fieldIds: this._fieldIds, fieldLength: Object.fromEntries(this._fieldLength), averageFieldLength: this._avgFieldLength, storedFields: Object.fromEntries(this._storedFields), dirtCount: this._dirtCount, index: e, serializationVersion: 2 };
  }
  termResults(e, n, i, s2, r, o, a, c, u2 = /* @__PURE__ */ new Map()) {
    if (r == null) return u2;
    for (let l of Object.keys(o)) {
      let h = o[l], d = this._fieldIds[l], f = r.get(d);
      if (f == null) continue;
      let g = f.size, m = this._avgFieldLength[d];
      for (let p of f.keys()) {
        if (!this._documentIds.has(p)) {
          this.removeTerm(d, p, n), g -= 1;
          continue;
        }
        let w2 = a ? a(this._documentIds.get(p), n, this._storedFields.get(p)) : 1;
        if (!w2) continue;
        let S = f.get(p), ie = this._fieldLength.get(p)[d], se = Vt(S, g, this._documentCount, ie, m, c), U = i * s2 * h * w2 * se, T = u2.get(p);
        if (T) {
          T.score += U, Nt(T.terms, e);
          let j = ae(T.match, n);
          j ? j.push(l) : T.match[n] = [l];
        } else u2.set(p, { score: U, terms: [e], match: { [n]: [l] } });
      }
    }
    return u2;
  }
  addTerm(e, n, i) {
    let s2 = this._index.fetch(i, Be), r = s2.get(e);
    if (r == null) r = /* @__PURE__ */ new Map(), r.set(n, 1), s2.set(e, r);
    else {
      let o = r.get(n);
      r.set(n, (o || 0) + 1);
    }
  }
  removeTerm(e, n, i) {
    if (!this._index.has(i)) {
      this.warnDocumentChanged(n, e, i);
      return;
    }
    let s2 = this._index.fetch(i, Be), r = s2.get(e);
    r == null || r.get(n) == null ? this.warnDocumentChanged(n, e, i) : r.get(n) <= 1 ? r.size <= 1 ? s2.delete(e) : r.delete(n) : r.set(n, r.get(n) - 1), this._index.get(i).size === 0 && this._index.delete(i);
  }
  warnDocumentChanged(e, n, i) {
    for (let s2 of Object.keys(this._fieldIds)) if (this._fieldIds[s2] === n) {
      this._options.logger("warn", `MiniSearch: document with ID ${this._documentIds.get(e)} has changed before removal: term "${i}" was not present in field "${s2}". Removing a document after it has changed can corrupt the index!`, "version_conflict");
      return;
    }
  }
  addDocumentId(e) {
    let n = this._nextId;
    return this._idToShortId.set(e, n), this._documentIds.set(n, e), this._documentCount += 1, this._nextId += 1, n;
  }
  addFields(e) {
    for (let n = 0; n < e.length; n++) this._fieldIds[e[n]] = n;
  }
  addFieldLength(e, n, i, s2) {
    let r = this._fieldLength.get(e);
    r == null && this._fieldLength.set(e, r = []), r[n] = s2;
    let a = (this._avgFieldLength[n] || 0) * i + s2;
    this._avgFieldLength[n] = a / (i + 1);
  }
  removeFieldLength(e, n, i, s2) {
    if (i === 1) {
      this._avgFieldLength[n] = 0;
      return;
    }
    let r = this._avgFieldLength[n] * i - s2;
    this._avgFieldLength[n] = r / (i - 1);
  }
  saveStoredFields(e, n) {
    let { storeFields: i, extractField: s2 } = this._options;
    if (i == null || i.length === 0) return;
    let r = this._storedFields.get(e);
    r == null && this._storedFields.set(e, r = {});
    for (let o of i) {
      let a = s2(n, o);
      a !== void 0 && (r[o] = a);
    }
  }
};
z.wildcard = Symbol("*");
var ae = (t4, e) => Object.prototype.hasOwnProperty.call(t4, e) ? t4[e] : void 0;
var Dt = { [pe]: (t4, e) => {
  for (let n of e.keys()) {
    let i = t4.get(n);
    if (i == null) t4.set(n, e.get(n));
    else {
      let { score: s2, terms: r, match: o } = e.get(n);
      i.score = i.score + s2, i.match = Object.assign(i.match, o), Ve(i.terms, r);
    }
  }
  return t4;
}, [qe]: (t4, e) => {
  let n = /* @__PURE__ */ new Map();
  for (let i of e.keys()) {
    let s2 = t4.get(i);
    if (s2 == null) continue;
    let { score: r, terms: o, match: a } = e.get(i);
    Ve(s2.terms, o), n.set(i, { score: s2.score + r, terms: s2.terms, match: Object.assign(s2.match, a) });
  }
  return n;
}, [jt]: (t4, e) => {
  for (let n of e.keys()) t4.delete(n);
  return t4;
} };
var Rt = { k: 1.2, b: 0.7, d: 0.5 };
var Vt = (t4, e, n, i, s2, r) => {
  let { k: o, b: a, d: c } = r;
  return Math.log(1 + (n - e + 0.5) / (e + 0.5)) * (c + t4 * (o + 1) / (t4 + o * (1 - a + a * i / s2)));
};
var Pt = (t4) => (e, n, i) => {
  let s2 = typeof t4.fuzzy == "function" ? t4.fuzzy(e, n, i) : t4.fuzzy || false, r = typeof t4.prefix == "function" ? t4.prefix(e, n, i) : t4.prefix === true, o = typeof t4.boostTerm == "function" ? t4.boostTerm(e, n, i) : 1;
  return { term: e, fuzzy: s2, prefix: r, termBoost: o };
};
var ce = { idField: "id", extractField: (t4, e) => t4[e], stringifyField: (t4, e) => t4.toString(), tokenize: (t4) => t4.split(kt), processTerm: (t4) => t4.toLowerCase(), fields: void 0, searchOptions: void 0, storeFields: [], logger: (t4, e) => {
  typeof console?.[t4] == "function" && console[t4](e);
}, autoVacuum: true };
var Re = { combineWith: pe, prefix: false, fuzzy: false, maxFuzzy: 6, boost: {}, weights: { fuzzy: 0.45, prefix: 0.375 }, bm25: Rt };
var Bt = { combineWith: qe, prefix: (t4, e, n) => e === n.length - 1 };
var de = { batchSize: 1e3, batchWait: 10 };
var he = { minDirtFactor: 0.1, minDirtCount: 20 };
var ue = { ...de, ...he };
var Nt = (t4, e) => {
  t4.includes(e) || t4.push(e);
};
var Ve = (t4, e) => {
  for (let n of e) t4.includes(n) || t4.push(n);
};
var Pe = ({ score: t4 }, { score: e }) => e - t4;
var Be = () => /* @__PURE__ */ new Map();
var G = (t4) => {
  let e = /* @__PURE__ */ new Map();
  for (let n of Object.keys(t4)) e.set(parseInt(n, 10), t4[n]);
  return e;
};
var q2 = async (t4) => {
  let e = /* @__PURE__ */ new Map(), n = 0;
  for (let i of Object.keys(t4)) e.set(parseInt(i, 10), t4[i]), ++n % 1e3 === 0 && await Je(0);
  return e;
};
var Je = (t4) => new Promise((e) => setTimeout(e, t4));
var kt = /[\n\r\p{Z}\p{P}]+/u;
var Ot = s(It(), 1);
var W;
var ne;
var Ct;
var Tt = class {
  constructor(e) {
    v(this, ne);
    t(this, "mapData");
    t(this, "indexes");
    t(this, "ready");
    v(this, W);
    this.mapData = e, this.indexes = Ri(e), this.ready = this.populate(), w(this, W, k5(x(this, ne, Ct).bind(this), 2e3));
  }
  async populate() {
    let { places: e, enterpriseLocations: n, enterpriseCategories: i } = this.indexes, s2 = this.mapData, r = [];
    return e.removeAll(), r = r.concat([e.addAllAsync(s2.getByType("space")), e.addAllAsync(s2.getByType("point-of-interest")), e.addAllAsync(s2.getByType("object")), e.addAllAsync(s2.getByType("connection")), e.addAllAsync(s2.getByType("floor")), e.addAllAsync(s2.getByType("door")), e.addAllAsync(s2.getByType("annotation")), e.addAllAsync(s2.getByType("area"))]), n && (n?.removeAll(), r.push(n.addAllAsync(s2.getByType("enterprise-location")))), i && (i?.removeAll(), r.push(i.addAllAsync(s2.getByType("enterprise-category")))), Promise.all(r);
  }
  async search(e, n = {}) {
    await this.ready, Vi.parse(n);
    let i = (0, Ot.default)({}, n, Di), s2 = this.indexes.places.search(e, { fields: Object.keys(i.places.fields).filter((c) => i.places.fields[c]) });
    i.places.limit && (s2 = s2.slice(0, i.places.limit));
    let r = this.indexes.enterpriseLocations?.search(e, { fields: Object.keys(i.enterpriseLocations.fields).filter((c) => i.enterpriseLocations.fields[c]) });
    r && i.enterpriseLocations.limit && (r = r.slice(0, i.enterpriseLocations.limit));
    let o = this.indexes.enterpriseCategories?.search(e, { fields: Object.keys(i.enterpriseCategories.fields).filter((c) => i.enterpriseCategories.fields[c]) });
    o && i.enterpriseCategories.limit && (o = o.slice(0, i.enterpriseCategories.limit));
    let a = ji(this.mapData, { placesResult: s2, locationsResult: r, categoriesResult: o });
    return u(this, W).call(this, e), a;
  }
  async suggest(e, n = {}) {
    await this.ready, Pi.parse(n);
    let i = [], { places: { enabled: s2 = true } = {}, enterpriseLocations: { enabled: r = true } = {} } = n;
    return r && this.indexes.enterpriseLocations && this.indexes.enterpriseLocations.autoSuggest(e, { fields: ["name", "tags"], combineWith: "AND", prefix: true, boost: { name: 2, tags: 1 } }).forEach((o) => i.push(o)), s2 && this.indexes.places.autoSuggest(e, { fields: ["name"], combineWith: "AND", prefix: true }).forEach((o) => i.push(o)), i.sort((o, a) => a.score - o.score), this.mapData.Analytics.capture("$query-suggest", { query: e, suggestions: i.map((o) => o.suggestion) }), i;
  }
};
W = /* @__PURE__ */ new WeakMap(), ne = /* @__PURE__ */ new WeakSet(), Ct = function(e) {
  this.mapData.Analytics.capture("$query-search", { query: e });
};
function ji(t4, { placesResult: e, locationsResult: n, categoriesResult: i }) {
  let s2 = e.reduce((a, { id: c, match: u2, score: l, __type: h }) => {
    let d = t4.getById(h, c);
    return d != null && !_o.is(d) && !Ny.is(d) && !Rr.is(d) && !da.is(d) && !$y.is(d) && a.push({ type: d.__type, match: u2, score: l, item: d }), a;
  }, []), r;
  if (n) {
    r = [];
    for (let { id: a, match: c, score: u2 } of n) {
      let l = t4.getById("enterprise-location", a);
      l && r.push({ type: l.__type, match: c, score: u2, item: l });
    }
  }
  let o;
  if (i) {
    o = [];
    for (let { id: a, match: c, score: u2 } of i) {
      let l = t4.getById("enterprise-category", a);
      l && o.push({ type: l.__type, match: c, score: u2, item: l });
    }
  }
  return { places: s2, enterpriseLocations: r, enterpriseCategories: o };
}
var Di = { places: { fields: { name: true, description: true } }, enterpriseCategories: { fields: { name: true, description: false, "locations.name": true } }, enterpriseLocations: { fields: { name: true, tags: true, description: true } } };
function ze(t4) {
  return t4.normalize("NFD").replace(/[\u0300-\u036f|\u2019|\u0027|\']/g, "").toLowerCase();
}
function Ri(t4) {
  let e = new z({ fields: ["name", "description"], storeFields: ["id", "__type"], searchOptions: { fuzzy: 0.2, prefix: true, boost: { name: 2 }, combineWith: "AND" }, extractField: (o, a) => {
    let c = o[a];
    return typeof c == "string" ? ze(c) : o[a];
  }, processTerm: (o) => Bi.has(o) ? "" : o.toLowerCase() }), n = t4.getByType("enterprise-location"), i;
  n && (i = new z({ fields: ["name", "tags", "description"], storeFields: ["id", "__type"], searchOptions: { combineWith: "OR", prefix: true, fuzzy: 0.2, boost: { name: 3, tags: 2, description: 1 } }, extractField: (o, a) => Array.isArray(o[a]) ? o[a].join(" ") : typeof o[a] == "string" ? ze(o[a]) : o[a] }));
  let s2 = t4.getByType("enterprise-category"), r;
  return s2 && (r = new z({ fields: ["name", "description", "locations.name"], storeFields: ["id", "__type"], extractField(o, a) {
    return a === "locations.name" ? o.locations.reduce((u2, l) => u2 + ` ${zt} ` + l.name, "") + ` ${zt}` : typeof o[a] == "string" ? ze(o[a]) : o[a];
  }, searchOptions: { combineWith: "OR", prefix: true, fuzzy: 0.2, boost: { name: 2, "locations.name": 2 } } })), { enterpriseCategories: r, enterpriseLocations: i, places: e };
}
var Vi = external_exports.object({ places: external_exports.object({ fields: external_exports.object({ name: external_exports.boolean().optional(), description: external_exports.boolean().optional() }).optional(), limit: external_exports.number().positive().optional() }).optional(), enterpriseCategories: external_exports.object({ fields: external_exports.object({ name: external_exports.boolean().optional(), description: external_exports.boolean().optional(), "locations.name": external_exports.boolean().optional() }).optional(), limit: external_exports.number().positive().optional() }).optional(), enterpriseLocations: external_exports.object({ fields: external_exports.object({ name: external_exports.boolean().optional(), tags: external_exports.boolean().optional(), description: external_exports.boolean().optional() }).optional(), limit: external_exports.number().positive().optional() }).optional() });
var Pi = external_exports.object({ places: external_exports.object({ enabled: external_exports.boolean().optional() }).optional(), enterpriseLocations: external_exports.object({ enabled: external_exports.boolean().optional() }).optional() });
var Bi = /* @__PURE__ */ new Set(["the", "an", "and", "or", "of", "in", "on", "at", "to", "from", "with", "by", "for"]);
var zt = "";
export {
  Tt as InternalSearch,
  ze as removeAccents
};
//# sourceMappingURL=internal-WJZVXVL6-OOCFA5YE.js.map
