{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/lodash.defaultsdeep@4.6.1/node_modules/lodash.defaultsdeep/index.js", "../../@mappedin/mappedin-js/src/search/internal.ts", "../../node_modules/.pnpm/minisearch@7.2.0/node_modules/minisearch/src/SearchableMap/TreeIterator.ts", "../../node_modules/.pnpm/minisearch@7.2.0/node_modules/minisearch/src/SearchableMap/fuzzySearch.ts", "../../node_modules/.pnpm/minisearch@7.2.0/node_modules/minisearch/src/SearchableMap/SearchableMap.ts", "../../node_modules/.pnpm/minisearch@7.2.0/node_modules/minisearch/src/MiniSearch.ts"],
  "sourcesContent": ["/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeMax = Math.max,\n    nativeNow = Date.now;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack);\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    var isArr = isArray(srcValue),\n        isBuff = !isArr && isBuffer(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      }\n      else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      }\n      else {\n        newValue = [];\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n * objects into destination objects that are passed thru.\n *\n * @private\n * @param {*} objValue The destination value.\n * @param {*} srcValue The source value.\n * @param {string} key The key of the property to merge.\n * @param {Object} object The parent object of `objValue`.\n * @param {Object} source The parent object of `srcValue`.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n * @returns {*} Returns the value to assign.\n */\nfunction customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n  if (isObject(objValue) && isObject(srcValue)) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, objValue);\n    baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n    stack['delete'](srcValue);\n  }\n  return objValue;\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction safeGet(object, key) {\n  if (key === 'constructor' && typeof object[key] === 'function') {\n    return;\n  }\n\n  if (key == '__proto__') {\n    return;\n  }\n\n  return object[key];\n}\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\n/**\n * This method is like `_.defaults` except that it recursively assigns\n * default properties.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 3.10.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaults\n * @example\n *\n * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n * // => { 'a': { 'b': 2, 'c': 3 } }\n */\nvar defaultsDeep = baseRest(function(args) {\n  args.push(undefined, customDefaultsMerge);\n  return apply(mergeWith, undefined, args);\n});\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\n/**\n * This method is like `_.merge` except that it accepts `customizer` which\n * is invoked to produce the merged values of the destination and source\n * properties. If `customizer` returns `undefined`, merging is handled by the\n * method instead. The `customizer` is invoked with six arguments:\n * (objValue, srcValue, key, object, source, stack).\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} sources The source objects.\n * @param {Function} customizer The function to customize assigned values.\n * @returns {Object} Returns `object`.\n * @example\n *\n * function customizer(objValue, srcValue) {\n *   if (_.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * }\n *\n * var object = { 'a': [1], 'b': [2] };\n * var other = { 'a': [3], 'b': [4] };\n *\n * _.mergeWith(object, other, customizer);\n * // => { 'a': [1, 3], 'b': [2, 4] }\n */\nvar mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n  baseMerge(object, source, srcIndex, customizer);\n});\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = defaultsDeep;\n", "import type { SearchResult as MiniSearchResult, Suggestion, MatchInfo } from 'minisearch';\nimport MiniSearch from 'minisearch';\nimport type { Places } from '../map-data-objects';\nimport { EnterpriseLocation, EnterpriseCategory, Facade, FloorStack, Node } from '../map-data-objects';\nimport type MapData from '../map-data';\nimport defaultsDeep from 'lodash.defaultsdeep';\nimport { z } from 'zod';\nimport { debounce } from '@packages/internal/common';\nimport type { RequiredDeep } from 'type-fest';\n\nexport class InternalSearch {\n\tprivate mapData: MapData;\n\tprivate indexes: {\n\t\tplaces: MiniSearch<Places>;\n\t\tenterpriseLocations?: MiniSearch<EnterpriseLocation>;\n\t\tenterpriseCategories?: MiniSearch<EnterpriseCategory>;\n\t};\n\tprivate ready: Promise<any>;\n\n\tconstructor(mapData: MapData) {\n\t\tthis.mapData = mapData;\n\t\tthis.indexes = buildIndexes(mapData);\n\t\tthis.ready = this.populate();\n\t\tthis.#trackSearchDebounced = debounce(this.#trackSearch.bind(this), 2000);\n\t}\n\t#trackSearchDebounced: (term: string) => void;\n\n\t/**\n\t * Populates the search indexes with the map data.\n\t * @returns A promise that resolves when the indexes are populated.\n\t */\n\tasync populate() {\n\t\tconst {\n\t\t\tplaces: placesIndex,\n\t\t\tenterpriseLocations: locationsIndex,\n\t\t\tenterpriseCategories: categoriesIndex,\n\t\t} = this.indexes;\n\t\tconst mapData = this.mapData;\n\t\tlet promises: Promise<any>[] = [];\n\n\t\tplacesIndex.removeAll();\n\t\tpromises = promises.concat([\n\t\t\tplacesIndex.addAllAsync(mapData.getByType('space')),\n\t\t\tplacesIndex.addAllAsync(mapData.getByType('point-of-interest')),\n\t\t\tplacesIndex.addAllAsync(mapData.getByType('object')),\n\t\t\tplacesIndex.addAllAsync(mapData.getByType('connection')),\n\t\t\tplacesIndex.addAllAsync(mapData.getByType('floor')),\n\t\t\tplacesIndex.addAllAsync(mapData.getByType('door')),\n\t\t\tplacesIndex.addAllAsync(mapData.getByType('annotation')),\n\t\t\tplacesIndex.addAllAsync(mapData.getByType('area')),\n\t\t]);\n\n\t\tif (locationsIndex) {\n\t\t\tlocationsIndex?.removeAll();\n\t\t\tpromises.push(locationsIndex.addAllAsync(mapData.getByType('enterprise-location')));\n\t\t}\n\n\t\tif (categoriesIndex) {\n\t\t\tcategoriesIndex?.removeAll();\n\t\t\tpromises.push(categoriesIndex.addAllAsync(mapData.getByType('enterprise-category')));\n\t\t}\n\n\t\treturn Promise.all(promises);\n\t}\n\n\tasync search(term: string, options: SearchOptions = {}): Promise<SearchResult> {\n\t\tawait this.ready;\n\t\tsearchOptionsSchema.parse(options);\n\t\tconst _options: RequiredDeep<SearchOptions> = defaultsDeep({}, options, DEFAULT_CONFIG);\n\n\t\tlet places = this.indexes.places.search(term, {\n\t\t\tfields: Object.keys(_options.places.fields).filter(key => _options.places.fields[key]),\n\t\t});\n\t\tif (_options.places.limit) {\n\t\t\tplaces = places.slice(0, _options.places.limit);\n\t\t}\n\n\t\tlet locations = this.indexes.enterpriseLocations?.search(term, {\n\t\t\tfields: Object.keys(_options.enterpriseLocations.fields).filter(key => _options.enterpriseLocations.fields[key]),\n\t\t});\n\t\tif (locations && _options.enterpriseLocations.limit) {\n\t\t\tlocations = locations.slice(0, _options.enterpriseLocations.limit);\n\t\t}\n\n\t\tlet categories = this.indexes.enterpriseCategories?.search(term, {\n\t\t\tfields: Object.keys(_options.enterpriseCategories.fields).filter(\n\t\t\t\tkey => _options.enterpriseCategories.fields[key],\n\t\t\t),\n\t\t});\n\t\tif (categories && _options.enterpriseCategories.limit) {\n\t\t\tcategories = categories.slice(0, _options.enterpriseCategories.limit);\n\t\t}\n\n\t\tconst result = processSearchResult(this.mapData, {\n\t\t\tplacesResult: places,\n\t\t\tlocationsResult: locations,\n\t\t\tcategoriesResult: categories,\n\t\t});\n\n\t\tthis.#trackSearchDebounced(term);\n\n\t\treturn result;\n\t}\n\n\t#trackSearch(term: string) {\n\t\tthis.mapData.Analytics.capture('$query-search', {\n\t\t\tquery: term,\n\t\t});\n\t}\n\n\tasync suggest(term: string, options: SuggestOptions = {}): Promise<Suggestion[]> {\n\t\tawait this.ready;\n\t\tsuggestOptionsSchema.parse(options);\n\t\tconst suggestions: Suggestion[] = [];\n\n\t\tconst {\n\t\t\tplaces: { enabled: includePlaces = true } = {},\n\t\t\tenterpriseLocations: { enabled: includeLocations = true } = {},\n\t\t} = options;\n\n\t\tif (includeLocations && this.indexes.enterpriseLocations) {\n\t\t\tthis.indexes.enterpriseLocations\n\t\t\t\t.autoSuggest(term, {\n\t\t\t\t\tfields: ['name', 'tags'],\n\t\t\t\t\tcombineWith: 'AND',\n\t\t\t\t\tprefix: true,\n\t\t\t\t\tboost: {\n\t\t\t\t\t\tname: 2,\n\t\t\t\t\t\ttags: 1,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\t.forEach(s => suggestions.push(s));\n\t\t}\n\n\t\tif (includePlaces) {\n\t\t\tthis.indexes.places\n\t\t\t\t.autoSuggest(term, {\n\t\t\t\t\tfields: ['name'],\n\t\t\t\t\tcombineWith: 'AND',\n\t\t\t\t\tprefix: true,\n\t\t\t\t})\n\t\t\t\t.forEach(s => suggestions.push(s));\n\t\t}\n\n\t\tsuggestions.sort((a, b) => b.score - a.score);\n\n\t\tthis.mapData.Analytics.capture('$query-suggest', {\n\t\t\tquery: term,\n\t\t\tsuggestions: suggestions.map(s => s.suggestion),\n\t\t});\n\n\t\t// Sort suggestions by score in descending order\n\t\treturn suggestions;\n\t}\n}\n\nfunction processSearchResult(\n\tmapData: MapData,\n\t{\n\t\tplacesResult,\n\t\tlocationsResult,\n\t\tcategoriesResult,\n\t}: {\n\t\tplacesResult: MiniSearchResult[];\n\t\tlocationsResult?: MiniSearchResult[];\n\t\tcategoriesResult?: MiniSearchResult[];\n\t},\n): SearchResult {\n\tconst places = placesResult.reduce((acc, { id, match, score, __type }) => {\n\t\tconst item = mapData.getById(__type, id);\n\t\tif (\n\t\t\titem != null &&\n\t\t\t!Node.is(item) &&\n\t\t\t!FloorStack.is(item) &&\n\t\t\t!Facade.is(item) &&\n\t\t\t!EnterpriseLocation.is(item) &&\n\t\t\t!EnterpriseCategory.is(item)\n\t\t) {\n\t\t\tacc.push({ type: item.__type, match, score, item });\n\t\t}\n\n\t\treturn acc;\n\t}, [] as SearchResultItem<Places>[]);\n\n\tlet locations: SearchResultItem<EnterpriseLocation>[] | undefined;\n\tif (locationsResult) {\n\t\tlocations = [];\n\t\tfor (const { id, match, score } of locationsResult) {\n\t\t\tconst item = mapData.getById('enterprise-location', id);\n\t\t\tif (item) {\n\t\t\t\tlocations.push({ type: item.__type, match, score, item });\n\t\t\t}\n\t\t}\n\t}\n\n\tlet categories: SearchResultItem<EnterpriseCategory>[] | undefined;\n\tif (categoriesResult) {\n\t\tcategories = [];\n\t\tfor (const { id, match, score } of categoriesResult) {\n\t\t\tconst item = mapData.getById('enterprise-category', id);\n\t\t\tif (item) {\n\t\t\t\tcategories.push({ type: item.__type, match, score, item });\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tplaces,\n\t\tenterpriseLocations: locations,\n\t\tenterpriseCategories: categories,\n\t};\n}\n\nexport type SearchResultItem<T extends Places | EnterpriseLocation | EnterpriseCategory> = {\n\ttype: T['__type'];\n\tmatch: MiniSearchResult['match'];\n\tscore: number;\n\titem: T;\n};\n\n/**\n * @interface\n */\nexport type SearchResultEnterpriseCategory = SearchResultItem<EnterpriseCategory>;\n\n/**\n * @interface\n */\nexport type SearchResultEnterpriseLocations = SearchResultItem<EnterpriseLocation>;\n\n/**\n * @interface\n */\nexport type SearchResultPlaces = SearchResultItem<Places>;\n\n/**\n * Search results\n */\nexport type SearchResult = {\n\t/**\n\t * Places search results\n\t */\n\tplaces: SearchResultPlaces[];\n\t/**\n\t * Enterprise Locations search results\n\t */\n\tenterpriseLocations?: SearchResultEnterpriseLocations[];\n\t/**\n\t * Enterprise Categories search results\n\t */\n\tenterpriseCategories?: SearchResultEnterpriseCategory[];\n};\n\nconst DEFAULT_CONFIG: Readonly<SearchOptions> = {\n\tplaces: {\n\t\tfields: {\n\t\t\tname: true,\n\t\t\tdescription: true,\n\t\t},\n\t},\n\tenterpriseCategories: {\n\t\tfields: {\n\t\t\tname: true,\n\t\t\tdescription: false,\n\t\t\t'locations.name': true,\n\t\t},\n\t},\n\tenterpriseLocations: {\n\t\tfields: {\n\t\t\tname: true,\n\t\t\ttags: true,\n\t\t\tdescription: true,\n\t\t},\n\t},\n};\n\nexport function removeAccents(it: string) {\n\tconst normalizedString = it\n\t\t.normalize('NFD')\n\t\t// eslint-disable-next-line no-useless-escape\n\t\t.replace(/[\\u0300-\\u036f|\\u2019|\\u0027|\\']/g, '')\n\t\t.toLowerCase();\n\n\treturn normalizedString;\n}\n\nfunction buildIndexes(mapData: MapData) {\n\tconst placesIndex = new MiniSearch({\n\t\tfields: ['name', 'description'],\n\t\tstoreFields: ['id', '__type'],\n\t\tsearchOptions: {\n\t\t\tfuzzy: 0.2,\n\t\t\tprefix: true,\n\t\t\tboost: {\n\t\t\t\tname: 2,\n\t\t\t},\n\t\t\tcombineWith: 'AND',\n\t\t},\n\t\textractField: (document, fieldName) => {\n\t\t\tconst value = document[fieldName];\n\t\t\tif (typeof value === 'string') {\n\t\t\t\treturn removeAccents(value);\n\t\t\t}\n\n\t\t\treturn document[fieldName];\n\t\t},\n\t\tprocessTerm: term => (STOP_WORDS.has(term) ? '' : term.toLowerCase()),\n\t});\n\n\tconst locations = mapData.getByType('enterprise-location');\n\tlet locationsIndex: MiniSearch<EnterpriseLocation> | undefined;\n\tif (locations) {\n\t\tlocationsIndex = new MiniSearch({\n\t\t\tfields: ['name', 'tags', 'description'],\n\t\t\tstoreFields: ['id', '__type'],\n\t\t\tsearchOptions: {\n\t\t\t\tcombineWith: 'OR',\n\t\t\t\tprefix: true,\n\t\t\t\tfuzzy: 0.2,\n\t\t\t\tboost: {\n\t\t\t\t\t// we want to boost the name over tags\n\t\t\t\t\tname: 3,\n\t\t\t\t\ttags: 2,\n\t\t\t\t\tdescription: 1,\n\t\t\t\t},\n\t\t\t},\n\t\t\textractField: (document, fieldName) => {\n\t\t\t\tif (Array.isArray(document[fieldName])) {\n\t\t\t\t\treturn document[fieldName].join(' ');\n\t\t\t\t} else if (typeof document[fieldName] === 'string') {\n\t\t\t\t\treturn removeAccents(document[fieldName]);\n\t\t\t\t}\n\n\t\t\t\treturn document[fieldName];\n\t\t\t},\n\t\t});\n\t}\n\n\tconst categories = mapData.getByType('enterprise-category');\n\tlet categoriesIndex: MiniSearch<EnterpriseCategory> | undefined;\n\tif (categories) {\n\t\tcategoriesIndex = new MiniSearch({\n\t\t\tfields: ['name', 'description', 'locations.name'],\n\t\t\tstoreFields: ['id', '__type'],\n\t\t\textractField(document, fieldName) {\n\t\t\t\tif (fieldName === 'locations.name') {\n\t\t\t\t\tconst locations = document['locations'];\n\n\t\t\t\t\treturn locations.reduce((r, t) => r + ` ${DELIMITER} ` + t.name, '') + ` ${DELIMITER}`;\n\t\t\t\t}\n\n\t\t\t\treturn typeof document[fieldName] === 'string' ? removeAccents(document[fieldName]) : document[fieldName];\n\t\t\t},\n\t\t\tsearchOptions: {\n\t\t\t\tcombineWith: 'OR',\n\t\t\t\tprefix: true,\n\t\t\t\tfuzzy: 0.2,\n\t\t\t\tboost: {\n\t\t\t\t\tname: 2,\n\t\t\t\t\t'locations.name': 2,\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\treturn {\n\t\tenterpriseCategories: categoriesIndex,\n\t\tenterpriseLocations: locationsIndex,\n\t\tplaces: placesIndex,\n\t};\n}\n\nconst searchOptionsSchema = z.object({\n\t/**\n\t * Options for searching places.\n\t * @property {Object} [fields] - Fields to search in places.\n\t * @property {boolean} [name] - Whether to search in the name field of places.\n\t * @property {boolean} [description] - Whether to search in the description field of places.\n\t * @property {number} [limit] - Maximum number of place results to return.\n\t */\n\tplaces: z\n\t\t.object({\n\t\t\t/**\n\t\t\t * Fields to search in places.\n\t\t\t * @property {boolean} [name] - Whether to search in the name field of places.\n\t\t\t * @property {boolean} [description] - Whether to search in the description field of places.\n\t\t\t */\n\t\t\tfields: z\n\t\t\t\t.object({\n\t\t\t\t\t/** Enable searching by place name */\n\t\t\t\t\tname: z.boolean().optional(),\n\t\t\t\t\t/** Enable searching by place description */\n\t\t\t\t\tdescription: z.boolean().optional(),\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/** Maximum number of place results to return */\n\t\t\tlimit: z.number().positive().optional(),\n\t\t})\n\t\t.optional(),\n\t/**\n\t * Options for searching categories.\n\t * @property {Object} [fields] - Fields to search in categories.\n\t * @property {boolean} [name] - Whether to search in the name field of categories.\n\t * @property {boolean} [description] - Whether to search in the description field of categories.\n\t * @property {boolean} ['locations.name'] - Whether to search in the locations' names of categories.\n\t * @property {number} [limit] - Maximum number of category results to return.\n\t */\n\tenterpriseCategories: z\n\t\t.object({\n\t\t\t/**\n\t\t\t * Fields to search in categories.\n\t\t\t * @property {boolean} [name] - Whether to search in the name field of categories.\n\t\t\t * @property {boolean} [description] - Whether to search in the description field of categories.\n\t\t\t * @property {boolean} ['locations.name'] - Whether to search in the locations' names of categories.\n\t\t\t */\n\t\t\tfields: z\n\t\t\t\t.object({\n\t\t\t\t\t/** Enable searching by category name */\n\t\t\t\t\tname: z.boolean().optional(),\n\t\t\t\t\t/** Enable searching by category description */\n\t\t\t\t\tdescription: z.boolean().optional(),\n\t\t\t\t\t/** Enable searching by names of locations within the category */\n\t\t\t\t\t'locations.name': z.boolean().optional(),\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/** Maximum number of category results to return */\n\t\t\tlimit: z.number().positive().optional(),\n\t\t})\n\t\t.optional(),\n\t/**\n\t * Options for searching locations.\n\t * @property {Object} [fields] - Fields to search in locations.\n\t * @property {boolean} [name] - Whether to search in the name field of locations.\n\t * @property {boolean} [tags] - Whether to search in the tags field of locations.\n\t * @property {boolean} [description] - Whether to search in the description field of locations.\n\t * @property {number} [limit] - Maximum number of location results to return.\n\t */\n\tenterpriseLocations: z\n\t\t.object({\n\t\t\t/**\n\t\t\t * Fields to search in locations.\n\t\t\t * @property {boolean} [name] - Whether to search in the name field of locations.\n\t\t\t * @property {boolean} [tags] - Whether to search in the tags field of locations.\n\t\t\t * @property {boolean} [description] - Whether to search in the description field of locations.\n\t\t\t */\n\t\t\tfields: z\n\t\t\t\t.object({\n\t\t\t\t\t/** Enable searching by location name */\n\t\t\t\t\tname: z.boolean().optional(),\n\t\t\t\t\t/** Enable searching by location tags */\n\t\t\t\t\ttags: z.boolean().optional(),\n\t\t\t\t\t/** Enable searching by location description */\n\t\t\t\t\tdescription: z.boolean().optional(),\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/** Maximum number of location results to return */\n\t\t\tlimit: z.number().positive().optional(),\n\t\t})\n\t\t.optional(),\n});\nconst suggestOptionsSchema = z.object({\n\t/**\n\t * Options for searching places.\n\t * @property {boolean} [enabled] - Whether to search in places.\n\t */\n\tplaces: z\n\t\t.object({\n\t\t\t/** Enable searching by place name */\n\t\t\tenabled: z.boolean().optional(),\n\t\t})\n\t\t.optional(),\n\t/**\n\t * Options for searching locations.\n\t * @property {boolean} [enabled] - Whether to search in locations.\n\t */\n\tenterpriseLocations: z\n\t\t.object({\n\t\t\t/** Enable searching by location name */\n\t\t\tenabled: z.boolean().optional(),\n\t\t})\n\t\t.optional(),\n});\n\n/**\n * @interface\n */\nexport type SearchOptions = z.infer<typeof searchOptionsSchema>;\n/**\n * @interface\n */\nexport type SuggestOptions = z.infer<typeof suggestOptionsSchema>;\n/**\n *TODO:  handle translation\n */\nconst STOP_WORDS = new Set(['the', 'an', 'and', 'or', 'of', 'in', 'on', 'at', 'to', 'from', 'with', 'by', 'for']);\nconst DELIMITER = '\\u0001';\n\nexport { Suggestion, MatchInfo };\n", "import type { RadixTree, Entry, LeafType } from './types'\n\n/** @ignore */\nconst ENTRIES = 'ENTRIES'\n\n/** @ignore */\nconst KEYS = 'KEYS'\n\n/** @ignore */\nconst VALUES = 'VALUES'\n\n/** @ignore */\nconst LEAF = '' as LeafType\n\ninterface Iterators<T> {\n  ENTRIES: Entry<T>\n  KEYS: string\n  VALUES: T\n}\n\ntype Kind<T> = keyof Iterators<T>\ntype Result<T, K extends keyof Iterators<T>> = Iterators<T>[K]\n\ntype IteratorPath<T> = {\n  node: RadixTree<T>,\n  keys: string[]\n}[]\n\nexport type IterableSet<T> = {\n  _tree: RadixTree<T>,\n  _prefix: string\n}\n\n/**\n * @private\n */\nclass TreeIterator<T, K extends Kind<T>> implements Iterator<Result<T, K>> {\n  set: IterableSet<T>\n  _type: K\n  _path: IteratorPath<T>\n\n  constructor (set: IterableSet<T>, type: K) {\n    const node = set._tree\n    const keys = Array.from(node.keys())\n    this.set = set\n    this._type = type\n    this._path = keys.length > 0 ? [{ node, keys }] : []\n  }\n\n  next (): IteratorResult<Result<T, K>> {\n    const value = this.dive()\n    this.backtrack()\n    return value\n  }\n\n  dive (): IteratorResult<Result<T, K>> {\n    if (this._path.length === 0) { return { done: true, value: undefined } }\n    const { node, keys } = last(this._path)!\n    if (last(keys) === LEAF) { return { done: false, value: this.result() } }\n\n    const child = node.get(last(keys)!)!\n    this._path.push({ node: child, keys: Array.from(child.keys()) })\n    return this.dive()\n  }\n\n  backtrack (): void {\n    if (this._path.length === 0) { return }\n    const keys = last(this._path)!.keys\n    keys.pop()\n    if (keys.length > 0) { return }\n    this._path.pop()\n    this.backtrack()\n  }\n\n  key (): string {\n    return this.set._prefix + this._path\n      .map(({ keys }) => last(keys))\n      .filter(key => key !== LEAF)\n      .join('')\n  }\n\n  value (): T {\n    return last(this._path)!.node.get(LEAF)!\n  }\n\n  result (): Result<T, K> {\n    switch (this._type) {\n      case VALUES: return this.value() as Result<T, K>\n      case KEYS: return this.key() as Result<T, K>\n      default: return [this.key(), this.value()] as Result<T, K>\n    }\n  }\n\n  [Symbol.iterator] () {\n    return this\n  }\n}\n\nconst last = <T>(array: T[]): T | undefined => {\n  return array[array.length - 1]\n}\n\nexport { TreeIterator, ENTRIES, KEYS, VALUES, LEAF }\n", "/* eslint-disable no-labels */\nimport { LEAF } from './TreeIterator'\nimport type { RadixTree } from './types'\n\nexport type FuzzyResult<T> = [T, number]\n\nexport type FuzzyResults<T> = Map<string, FuzzyResult<T>>\n\n/**\n * @ignore\n */\nexport const fuzzySearch = <T = any>(node: RadixTree<T>, query: string, maxDistance: number): FuzzyResults<T> => {\n  const results: FuzzyResults<T> = new Map()\n  if (query === undefined) return results\n\n  // Number of columns in the Levenshtein matrix.\n  const n = query.length + 1\n\n  // Matching terms can never be longer than N + maxDistance.\n  const m = n + maxDistance\n\n  // Fill first matrix row and column with numbers: 0 1 2 3 ...\n  const matrix = new Uint8Array(m * n).fill(maxDistance + 1)\n  for (let j = 0; j < n; ++j) matrix[j] = j\n  for (let i = 1; i < m; ++i) matrix[i * n] = i\n\n  recurse(\n    node,\n    query,\n    maxDistance,\n    results,\n    matrix,\n    1,\n    n,\n    ''\n  )\n\n  return results\n}\n\n// Modified version of http://stevehanov.ca/blog/?id=114\n\n// This builds a Levenshtein matrix for a given query and continuously updates\n// it for nodes in the radix tree that fall within the given maximum edit\n// distance. Keeping the same matrix around is beneficial especially for larger\n// edit distances.\n//\n//           k   a   t   e   <-- query\n//       0   1   2   3   4\n//   c   1   1   2   3   4\n//   a   2   2   1   2   3\n//   t   3   3   2   1  [2]  <-- edit distance\n//   ^\n//   ^ term in radix tree, rows are added and removed as needed\n\nconst recurse = <T = any>(\n  node: RadixTree<T>,\n  query: string,\n  maxDistance: number,\n  results: FuzzyResults<T>,\n  matrix: Uint8Array,\n  m: number,\n  n: number,\n  prefix: string\n): void => {\n  const offset = m * n\n\n  key: for (const key of node.keys()) {\n    if (key === LEAF) {\n      // We've reached a leaf node. Check if the edit distance acceptable and\n      // store the result if it is.\n      const distance = matrix[offset - 1]\n      if (distance <= maxDistance) {\n        results.set(prefix, [node.get(key)!, distance])\n      }\n    } else {\n      // Iterate over all characters in the key. Update the Levenshtein matrix\n      // and check if the minimum distance in the last row is still within the\n      // maximum edit distance. If it is, we can recurse over all child nodes.\n      let i = m\n      for (let pos = 0; pos < key.length; ++pos, ++i) {\n        const char = key[pos]\n        const thisRowOffset = n * i\n        const prevRowOffset = thisRowOffset - n\n\n        // Set the first column based on the previous row, and initialize the\n        // minimum distance in the current row.\n        let minDistance = matrix[thisRowOffset]\n\n        const jmin = Math.max(0, i - maxDistance - 1)\n        const jmax = Math.min(n - 1, i + maxDistance)\n\n        // Iterate over remaining columns (characters in the query).\n        for (let j = jmin; j < jmax; ++j) {\n          const different = char !== query[j]\n\n          // It might make sense to only read the matrix positions used for\n          // deletion/insertion if the characters are different. But we want to\n          // avoid conditional reads for performance reasons.\n          const rpl = matrix[prevRowOffset + j] + +different\n          const del = matrix[prevRowOffset + j + 1] + 1\n          const ins = matrix[thisRowOffset + j] + 1\n\n          const dist = matrix[thisRowOffset + j + 1] = Math.min(rpl, del, ins)\n\n          if (dist < minDistance) minDistance = dist\n        }\n\n        // Because distance will never decrease, we can stop. There will be no\n        // matching child nodes.\n        if (minDistance > maxDistance) {\n          continue key\n        }\n      }\n\n      recurse(\n        node.get(key)!,\n        query,\n        maxDistance,\n        results,\n        matrix,\n        i,\n        n,\n        prefix + key\n      )\n    }\n  }\n}\n\nexport default fuzzySearch\n", "/* eslint-disable no-labels */\nimport { TreeIterator, ENTRIES, KEYS, VALUES, LEAF } from './TreeIterator'\nimport fuzzySearch, { type FuzzyResults } from './fuzzySearch'\nimport type { RadixTree, Entry, Path } from './types'\n\n/**\n * A class implementing the same interface as a standard JavaScript\n * [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n * with string keys, but adding support for efficiently searching entries with\n * prefix or fuzzy search. This class is used internally by {@link MiniSearch}\n * as the inverted index data structure. The implementation is a radix tree\n * (compressed prefix tree).\n *\n * Since this class can be of general utility beyond _MiniSearch_, it is\n * exported by the `minisearch` package and can be imported (or required) as\n * `minisearch/SearchableMap`.\n *\n * @typeParam T  The type of the values stored in the map.\n */\nexport default class SearchableMap<T = any> {\n  /**\n   * @internal\n   */\n  _tree: RadixTree<T>\n\n  /**\n   * @internal\n   */\n  _prefix: string\n\n  private _size: number | undefined = undefined\n\n  /**\n   * The constructor is normally called without arguments, creating an empty\n   * map. In order to create a {@link SearchableMap} from an iterable or from an\n   * object, check {@link SearchableMap.from} and {@link\n   * SearchableMap.fromObject}.\n   *\n   * The constructor arguments are for internal use, when creating derived\n   * mutable views of a map at a prefix.\n   */\n  constructor (tree: RadixTree<T> = new Map(), prefix = '') {\n    this._tree = tree\n    this._prefix = prefix\n  }\n\n  /**\n   * Creates and returns a mutable view of this {@link SearchableMap},\n   * containing only entries that share the given prefix.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * let map = new SearchableMap()\n   * map.set(\"unicorn\", 1)\n   * map.set(\"universe\", 2)\n   * map.set(\"university\", 3)\n   * map.set(\"unique\", 4)\n   * map.set(\"hello\", 5)\n   *\n   * let uni = map.atPrefix(\"uni\")\n   * uni.get(\"unique\") // => 4\n   * uni.get(\"unicorn\") // => 1\n   * uni.get(\"hello\") // => undefined\n   *\n   * let univer = map.atPrefix(\"univer\")\n   * univer.get(\"unique\") // => undefined\n   * univer.get(\"universe\") // => 2\n   * univer.get(\"university\") // => 3\n   * ```\n   *\n   * @param prefix  The prefix\n   * @return A {@link SearchableMap} representing a mutable view of the original\n   * Map at the given prefix\n   */\n  atPrefix (prefix: string): SearchableMap<T> {\n    if (!prefix.startsWith(this._prefix)) { throw new Error('Mismatched prefix') }\n\n    const [node, path] = trackDown(this._tree, prefix.slice(this._prefix.length))\n\n    if (node === undefined) {\n      const [parentNode, key] = last(path)\n\n      for (const k of parentNode!.keys()) {\n        if (k !== LEAF && k.startsWith(key)) {\n          const node = new Map()\n          node.set(k.slice(key.length), parentNode!.get(k)!)\n          return new SearchableMap(node, prefix)\n        }\n      }\n    }\n\n    return new SearchableMap<T>(node, prefix)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear\n   */\n  clear (): void {\n    this._size = undefined\n    this._tree.clear()\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete\n   * @param key  Key to delete\n   */\n  delete (key: string): void {\n    this._size = undefined\n    return remove(this._tree, key)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries\n   * @return An iterator iterating through `[key, value]` entries.\n   */\n  entries () {\n    return new TreeIterator(this, ENTRIES)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach\n   * @param fn  Iteration function\n   */\n  forEach (fn: (key: string, value: T, map: SearchableMap) => void): void {\n    for (const [key, value] of this) {\n      fn(key, value, this)\n    }\n  }\n\n  /**\n   * Returns a Map of all the entries that have a key within the given edit\n   * distance from the search key. The keys of the returned Map are the matching\n   * keys, while the values are two-element arrays where the first element is\n   * the value associated to the key, and the second is the edit distance of the\n   * key to the search key.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * let map = new SearchableMap()\n   * map.set('hello', 'world')\n   * map.set('hell', 'yeah')\n   * map.set('ciao', 'mondo')\n   *\n   * // Get all entries that match the key 'hallo' with a maximum edit distance of 2\n   * map.fuzzyGet('hallo', 2)\n   * // => Map(2) { 'hello' => ['world', 1], 'hell' => ['yeah', 2] }\n   *\n   * // In the example, the \"hello\" key has value \"world\" and edit distance of 1\n   * // (change \"e\" to \"a\"), the key \"hell\" has value \"yeah\" and edit distance of 2\n   * // (change \"e\" to \"a\", delete \"o\")\n   * ```\n   *\n   * @param key  The search key\n   * @param maxEditDistance  The maximum edit distance (Levenshtein)\n   * @return A Map of the matching keys to their value and edit distance\n   */\n  fuzzyGet (key: string, maxEditDistance: number): FuzzyResults<T> {\n    return fuzzySearch<T>(this._tree, key, maxEditDistance)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get\n   * @param key  Key to get\n   * @return Value associated to the key, or `undefined` if the key is not\n   * found.\n   */\n  get (key: string): T | undefined {\n    const node = lookup<T>(this._tree, key)\n    return node !== undefined ? node.get(LEAF) : undefined\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has\n   * @param key  Key\n   * @return True if the key is in the map, false otherwise\n   */\n  has (key: string): boolean {\n    const node = lookup(this._tree, key)\n    return node !== undefined && node.has(LEAF)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys\n   * @return An `Iterable` iterating through keys\n   */\n  keys () {\n    return new TreeIterator(this, KEYS)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set\n   * @param key  Key to set\n   * @param value  Value to associate to the key\n   * @return The {@link SearchableMap} itself, to allow chaining\n   */\n  set (key: string, value: T): SearchableMap<T> {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    this._size = undefined\n    const node = createPath(this._tree, key)\n    node.set(LEAF, value)\n    return this\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size\n   */\n  get size (): number {\n    if (this._size) { return this._size }\n    /** @ignore */\n    this._size = 0\n\n    const iter = this.entries()\n    while (!iter.next().done) this._size! += 1\n\n    return this._size\n  }\n\n  /**\n   * Updates the value at the given key using the provided function. The function\n   * is called with the current value at the key, and its return value is used as\n   * the new value to be set.\n   *\n   * ### Example:\n   *\n   * ```javascript\n   * // Increment the current value by one\n   * searchableMap.update('somekey', (currentValue) => currentValue == null ? 0 : currentValue + 1)\n   * ```\n   *\n   * If the value at the given key is or will be an object, it might not require\n   * re-assignment. In that case it is better to use `fetch()`, because it is\n   * faster.\n   *\n   * @param key  The key to update\n   * @param fn  The function used to compute the new value from the current one\n   * @return The {@link SearchableMap} itself, to allow chaining\n   */\n  update (key: string, fn: (value: T | undefined) => T): SearchableMap<T> {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    this._size = undefined\n    const node = createPath(this._tree, key)\n    node.set(LEAF, fn(node.get(LEAF)))\n    return this\n  }\n\n  /**\n   * Fetches the value of the given key. If the value does not exist, calls the\n   * given function to create a new value, which is inserted at the given key\n   * and subsequently returned.\n   *\n   * ### Example:\n   *\n   * ```javascript\n   * const map = searchableMap.fetch('somekey', () => new Map())\n   * map.set('foo', 'bar')\n   * ```\n   *\n   * @param key  The key to update\n   * @param initial  A function that creates a new value if the key does not exist\n   * @return The existing or new value at the given key\n   */\n  fetch (key: string, initial: () => T): T {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    this._size = undefined\n    const node = createPath(this._tree, key)\n\n    let value = node.get(LEAF)\n    if (value === undefined) {\n      node.set(LEAF, value = initial())\n    }\n\n    return value\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values\n   * @return An `Iterable` iterating through values.\n   */\n  values () {\n    return new TreeIterator(this, VALUES)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator\n   */\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n\n  /**\n   * Creates a {@link SearchableMap} from an `Iterable` of entries\n   *\n   * @param entries  Entries to be inserted in the {@link SearchableMap}\n   * @return A new {@link SearchableMap} with the given entries\n   */\n  static from<T = any> (entries: Iterable<Entry<T>> | Entry<T>[]) {\n    const tree = new SearchableMap()\n    for (const [key, value] of entries) {\n      tree.set(key, value)\n    }\n    return tree\n  }\n\n  /**\n   * Creates a {@link SearchableMap} from the iterable properties of a JavaScript object\n   *\n   * @param object  Object of entries for the {@link SearchableMap}\n   * @return A new {@link SearchableMap} with the given entries\n   */\n  static fromObject<T = any> (object: { [key: string]: T }) {\n    return SearchableMap.from<T>(Object.entries(object))\n  }\n}\n\nconst trackDown = <T = any>(tree: RadixTree<T> | undefined, key: string, path: Path<T> = []): [RadixTree<T> | undefined, Path<T>] => {\n  if (key.length === 0 || tree == null) { return [tree, path] }\n\n  for (const k of tree.keys()) {\n    if (k !== LEAF && key.startsWith(k)) {\n      path.push([tree, k]) // performance: update in place\n      return trackDown(tree.get(k)!, key.slice(k.length), path)\n    }\n  }\n\n  path.push([tree, key]) // performance: update in place\n  return trackDown(undefined, '', path)\n}\n\nconst lookup = <T = any>(tree: RadixTree<T>, key: string): RadixTree<T> | undefined => {\n  if (key.length === 0 || tree == null) { return tree }\n\n  for (const k of tree.keys()) {\n    if (k !== LEAF && key.startsWith(k)) {\n      return lookup(tree.get(k)!, key.slice(k.length))\n    }\n  }\n}\n\n// Create a path in the radix tree for the given key, and returns the deepest\n// node. This function is in the hot path for indexing. It avoids unnecessary\n// string operations and recursion for performance.\nconst createPath = <T = any>(node: RadixTree<T>, key: string): RadixTree<T> => {\n  const keyLength = key.length\n\n  outer: for (let pos = 0; node && pos < keyLength;) {\n    for (const k of node.keys()) {\n      // Check whether this key is a candidate: the first characters must match.\n      if (k !== LEAF && key[pos] === k[0]) {\n        const len = Math.min(keyLength - pos, k.length)\n\n        // Advance offset to the point where key and k no longer match.\n        let offset = 1\n        while (offset < len && key[pos + offset] === k[offset]) ++offset\n\n        const child = node.get(k)!\n        if (offset === k.length) {\n          // The existing key is shorter than the key we need to create.\n          node = child\n        } else {\n          // Partial match: we need to insert an intermediate node to contain\n          // both the existing subtree and the new node.\n          const intermediate = new Map()\n          intermediate.set(k.slice(offset), child)\n          node.set(key.slice(pos, pos + offset), intermediate)\n          node.delete(k)\n          node = intermediate\n        }\n\n        pos += offset\n        continue outer\n      }\n    }\n\n    // Create a final child node to contain the final suffix of the key.\n    const child = new Map()\n    node.set(key.slice(pos), child)\n    return child\n  }\n\n  return node\n}\n\nconst remove = <T = any>(tree: RadixTree<T>, key: string): void => {\n  const [node, path] = trackDown(tree, key)\n  if (node === undefined) { return }\n  node.delete(LEAF)\n\n  if (node.size === 0) {\n    cleanup(path)\n  } else if (node.size === 1) {\n    const [key, value] = node.entries().next().value!\n    merge(path, key as string, value as RadixTree<T>)\n  }\n}\n\nconst cleanup = <T = any>(path: Path<T>): void => {\n  if (path.length === 0) { return }\n\n  const [node, key] = last(path)\n  node!.delete(key)\n\n  if (node!.size === 0) {\n    cleanup(path.slice(0, -1))\n  } else if (node!.size === 1) {\n    const [key, value] = node!.entries().next().value!\n    if (key !== LEAF) {\n      merge(path.slice(0, -1), key as string, value as RadixTree<T>)\n    }\n  }\n}\n\nconst merge = <T = any>(path: Path<T>, key: string, value: RadixTree<T>): void => {\n  if (path.length === 0) { return }\n\n  const [node, nodeKey] = last(path)\n  node!.set(nodeKey + key, value)\n  node!.delete(nodeKey)\n}\n\nconst last = <T = any>(array: T[]): T => {\n  return array[array.length - 1]\n}\n", "import SearchableMap from './SearchableMap/SearchableMap'\n\nexport type LowercaseCombinationOperator = 'or' | 'and' | 'and_not'\nexport type CombinationOperator = LowercaseCombinationOperator | Uppercase<LowercaseCombinationOperator> | Capitalize<LowercaseCombinationOperator>\n\nconst OR: LowercaseCombinationOperator = 'or'\nconst AND: LowercaseCombinationOperator = 'and'\nconst AND_NOT: LowercaseCombinationOperator = 'and_not'\n\n/**\n * Search options to customize the search behavior.\n */\nexport type SearchOptions = {\n  /**\n   * Names of the fields to search in. If omitted, all fields are searched.\n   */\n  fields?: string[],\n\n  /**\n   * Function used to filter search results, for example on the basis of stored\n   * fields. It takes as argument each search result and should return a boolean\n   * to indicate if the result should be kept or not.\n   */\n  filter?: (result: SearchResult) => boolean,\n\n  /**\n   * Key-value object of field names to boosting values. By default, fields are\n   * assigned a boosting factor of 1. If one assigns to a field a boosting value\n   * of 2, a result that matches the query in that field is assigned a score\n   * twice as high as a result matching the query in another field, all else\n   * being equal.\n   */\n  boost?: { [fieldName: string]: number },\n\n  /**\n   * Function to calculate a boost factor for each term.\n   *\n   * This function, if provided, is called for each query term (as split by\n   * `tokenize` and processed by `processTerm`). The arguments passed to the\n   * function are the query term, the positional index of the term in the query,\n   * and the array of all query terms. It is expected to return a numeric boost\n   * factor for the term. A factor lower than 1 reduces the importance of the\n   * term, a factor greater than 1 increases it. A factor of exactly 1 is\n   * neutral, and does not affect the term's importance.\n   */\n  boostTerm?: (term: string, i: number, terms: string[]) => number,\n\n  /**\n   * Relative weights to assign to prefix search results and fuzzy search\n   * results. Exact matches are assigned a weight of 1.\n   */\n  weights?: { fuzzy: number, prefix: number },\n\n  /**\n   * Function to calculate a boost factor for documents. It takes as arguments\n   * the document ID, and a term that matches the search in that document, and\n   * the value of the stored fields for the document (if any).  It should return\n   * a boosting factor: a number higher than 1 increases the computed score, a\n   * number lower than 1 decreases the score, and a falsy value skips the search\n   * result completely.\n   */\n  boostDocument?: (documentId: any, term: string, storedFields?: Record<string, unknown>) => number,\n\n  /**\n   * Controls whether to perform prefix search. It can be a simple boolean, or a\n   * function.\n   *\n   * If a boolean is passed, prefix search is performed if true.\n   *\n   * If a function is passed, it is called upon search with a search term, the\n   * positional index of that search term in the tokenized search query, and the\n   * tokenized search query. The function should return a boolean to indicate\n   * whether to perform prefix search for that search term.\n   */\n  prefix?: boolean | ((term: string, index: number, terms: string[]) => boolean),\n\n  /**\n   * Controls whether to perform fuzzy search. It can be a simple boolean, or a\n   * number, or a function.\n   *\n   * If a boolean is given, fuzzy search with a default fuzziness parameter is\n   * performed if true.\n   *\n   * If a number higher or equal to 1 is given, fuzzy search is performed, with\n   * a maximum edit distance (Levenshtein) equal to the number.\n   *\n   * If a number between 0 and 1 is given, fuzzy search is performed within a\n   * maximum edit distance corresponding to that fraction of the term length,\n   * approximated to the nearest integer. For example, 0.2 would mean an edit\n   * distance of 20% of the term length, so 1 character in a 5-characters term.\n   * The calculated fuzziness value is limited by the `maxFuzzy` option, to\n   * prevent slowdown for very long queries.\n   *\n   * If a function is passed, the function is called upon search with a search\n   * term, a positional index of that term in the tokenized search query, and\n   * the tokenized search query. It should return a boolean or a number, with\n   * the meaning documented above.\n   */\n  fuzzy?: boolean | number | ((term: string, index: number, terms: string[]) => boolean | number),\n\n  /**\n   * Controls the maximum fuzziness when using a fractional fuzzy value. This is\n   * set to 6 by default. Very high edit distances usually don't produce\n   * meaningful results, but can excessively impact search performance.\n   */\n  maxFuzzy?: number,\n\n  /**\n   * The operand to combine partial results for each term. By default it is\n   * \"OR\", so results matching _any_ of the search terms are returned by a\n   * search. If \"AND\" is given, only results matching _all_ the search terms are\n   * returned by a search.\n   */\n  combineWith?: CombinationOperator,\n\n  /**\n   * Function to tokenize the search query. By default, the same tokenizer used\n   * for indexing is used also for search.\n   *\n   * @remarks This function is called after `extractField` extracts a truthy\n   * value from a field. This function is then expected to split the extracted\n   * `text` document into tokens (more commonly referred to as \"terms\" in this\n   * context). The resulting split might be simple, like for example on word\n   * boundaries, or it might be more complex, taking into account certain\n   * encoding, or parsing needs, or even just special cases. Think about how one\n   * might need to go about indexing the term \"short-term\". You would likely\n   * want to treat this case specially, and return two terms instead, `[\n   * \"short\", \"term\" ]`.\n   *\n   * Or, you could let such a case be handled by the `processTerm` function,\n   * which is designed to turn each token/term into whole terms or sub-terms. In\n   * any case, the purpose of this function is to split apart the provided\n   * `text` document into parts that can be processed by the `processTerm`\n   * function.\n   */\n  tokenize?: (text: string) => string[],\n\n  /**\n   * Function to process or normalize terms in the search query. By default, the\n   * same term processor used for indexing is used also for search.\n   *\n   * @remarks\n   * During the document indexing phase, the first step is to call the\n   * `extractField` function to fetch the requested value/field from the\n   * document. This is then passed off to the `tokenize` function, which will\n   * break apart each value into \"terms\". These terms are then individually\n   * passed through this function to compute each term individually. A term\n   * might for example be something like \"lbs\", in which case one would likely\n   * want to return `[ \"lbs\", \"lb\", \"pound\", \"pounds\" ]`. You may also return\n   * just a single string, or a falsy value if you would like to skip indexing\n   * entirely for a specific term.\n   *\n   * Truthy return value(s) are then fed to the indexer as positive matches for\n   * this document. In our example above, all four of the `[ \"lbs\", \"lb\",\n   * \"pound\", \"pounds\" ]` terms would be added to the indexing engine, matching\n   * against the current document being computed.\n   *\n   * *Note: Whatever values are returned from this function will receive no\n   * further processing before being indexed. This means for example, if you\n   * include whitespace at the beginning or end of a word, it will also be\n   * indexed that way, with the included whitespace.*\n   */\n  processTerm?: (term: string) => string | string[] | null | undefined | false\n\n  /**\n   * BM25+ algorithm parameters. Customizing these is almost never necessary,\n   * and finetuning them requires an understanding of the BM25 scoring model. In\n   * most cases, it is best to omit this option to use defaults, and instead use\n   * boosting to tweak scoring for specific use cases.\n   */\n  bm25?: BM25Params\n}\n\ntype SearchOptionsWithDefaults = SearchOptions & {\n  boost: { [fieldName: string]: number },\n\n  weights: { fuzzy: number, prefix: number },\n\n  prefix: boolean | ((term: string, index: number, terms: string[]) => boolean),\n\n  fuzzy: boolean | number | ((term: string, index: number, terms: string[]) => boolean | number),\n\n  maxFuzzy: number,\n\n  combineWith: CombinationOperator\n\n  bm25: BM25Params\n}\n\n/**\n * Configuration options passed to the {@link MiniSearch} constructor\n *\n * @typeParam T  The type of documents being indexed.\n */\nexport type Options<T = any> = {\n   /**\n    * Names of the document fields to be indexed.\n    */\n  fields: string[],\n\n   /**\n    * Name of the ID field, uniquely identifying a document.\n    */\n  idField?: string,\n\n   /**\n    * Names of fields to store, so that search results would include them. By\n    * default none, so results would only contain the id field.\n    */\n  storeFields?: string[],\n\n   /**\n    * Function used to extract the value of each field in documents. By default,\n    * the documents are assumed to be plain objects with field names as keys,\n    * but by specifying a custom `extractField` function one can completely\n    * customize how the fields are extracted.\n    *\n    * The function takes as arguments the document, and the name of the field to\n    * extract from it. It should return the field value as a string.\n    *\n    * @remarks\n    * The returned string is fed into the `tokenize` function to split it up\n    * into tokens.\n    */\n  extractField?: (document: T, fieldName: string) => any,\n\n  /**\n   * Function used to turn field values into strings for indexing\n   *\n   * The function takes as arguments the field value, and the name of the field\n   * to stringify, so that its logic can be customized on specific fields. By\n   * default, it simply calls `toString()` on the field value (which in many\n   * cases is already a string).\n   *\n   * ### Example:\n   *\n   * ```javascript\n   * // Custom stringifier that formats dates as \"Tuesday, September 16, 2025\"\n   * const miniSearch = new MiniSearch({\n   *   fields: ['title', 'date'],\n   *   stringifyField: ((fieldValue, _fieldName) => {\n   *     if (fieldValue instanceof Date) {\n   *       return fieldValue.toLocaleDateString('en-US', {\n   *         weekday: 'long',\n   *         year: 'numeric',\n   *         month: 'long',\n   *         day: 'numeric'\n   *       })\n   *     } else {\n   *      return fieldValue.toString()\n   *     }\n   *   }\n   * })\n   * ```\n   */\n  stringifyField?: (fieldValue: any, fieldName: string) => string,\n\n   /**\n    * Function used to split a field value into individual terms to be indexed.\n    * The default tokenizer separates terms by space or punctuation, but a\n    * custom tokenizer can be provided for custom logic.\n    *\n    * The function takes as arguments string to tokenize, and the name of the\n    * field it comes from. It should return the terms as an array of strings.\n    * When used for tokenizing a search query instead of a document field, the\n    * `fieldName` is undefined.\n    *\n    * @remarks\n    * This function is called after `extractField` extracts a truthy value from a\n    * field. This function is then expected to split the extracted `text` document\n    * into tokens (more commonly referred to as \"terms\" in this context). The resulting\n    * split might be simple, like for example on word boundaries, or it might be more\n    * complex, taking into account certain encoding, or parsing needs, or even just\n    * special cases. Think about how one might need to go about indexing the term\n    * \"short-term\". You would likely want to treat this case specially, and return two\n    * terms instead, `[ \"short\", \"term\" ]`.\n    *\n    * Or, you could let such a case be handled by the `processTerm` function,\n    * which is designed to turn each token/term into whole terms or sub-terms. In any\n    * case, the purpose of this function is to split apart the provided `text` document\n    * into parts that can be processed by the `processTerm` function.\n    */\n  tokenize?: (text: string, fieldName?: string) => string[],\n\n   /**\n    * Function used to process a term before indexing or search. This can be\n    * used for normalization (such as stemming). By default, terms are\n    * downcased, and otherwise no other normalization is performed.\n    *\n    * The function takes as arguments a term to process, and the name of the\n    * field it comes from. It should return the processed term as a string, or a\n    * falsy value to reject the term entirely.\n    *\n    * It can also return an array of strings, in which case each string in the\n    * returned array is indexed as a separate term.\n    *\n    * @remarks\n    * During the document indexing phase, the first step is to call the `extractField`\n    * function to fetch the requested value/field from the document. This is then\n    * passed off to the `tokenizer`, which will break apart each value into \"terms\".\n    * These terms are then individually passed through the `processTerm` function\n    * to compute each term individually. A term might for example be something\n    * like \"lbs\", in which case one would likely want to return\n    * `[ \"lbs\", \"lb\", \"pound\", \"pounds\" ]`. You may also return a single string value,\n    * or a falsy value if you would like to skip indexing entirely for a specific term.\n    *\n    * Truthy return value(s) are then fed to the indexer as positive matches for this\n    * document. In our example above, all four of the `[ \"lbs\", \"lb\", \"pound\", \"pounds\" ]`\n    * terms would be added to the indexing engine, matching against the current document\n    * being computed.\n    *\n    * *Note: Whatever values are returned from this function will receive no further\n    * processing before being indexed. This means for example, if you include whitespace\n    * at the beginning or end of a word, it will also be indexed that way, with the\n    * included whitespace.*\n    */\n  processTerm?: (term: string, fieldName?: string) => string | string[] | null | undefined | false,\n\n  /**\n   * Function called to log messages. Arguments are a log level ('debug',\n   * 'info', 'warn', or 'error'), a log message, and an optional string code\n   * that identifies the reason for the log.\n   *\n   * The default implementation uses `console`, if defined.\n   */\n  logger?: (level: LogLevel, message: string, code?: string) => void\n\n  /**\n   * If `true` (the default), vacuuming is performed automatically as soon as\n   * {@link MiniSearch#discard} is called a certain number of times, cleaning up\n   * obsolete references from the index. If `false`, no automatic vacuuming is\n   * performed. Custom settings controlling auto vacuuming thresholds, as well\n   * as batching behavior, can be passed as an object (see the {@link\n   * AutoVacuumOptions} type).\n   */\n  autoVacuum?: boolean | AutoVacuumOptions\n\n   /**\n    * Default search options (see the {@link SearchOptions} type and the {@link\n    * MiniSearch#search} method for details)\n    */\n  searchOptions?: SearchOptions,\n\n   /**\n    * Default auto suggest options (see the {@link SearchOptions} type and the\n    * {@link MiniSearch#autoSuggest} method for details)\n    */\n  autoSuggestOptions?: SearchOptions\n}\n\ntype OptionsWithDefaults<T = any> = Options<T> & {\n  storeFields: string[]\n\n  idField: string\n\n  extractField: (document: T, fieldName: string) => any\n\n  stringifyField: (fieldValue: any, fieldName: string) => string\n\n  tokenize: (text: string, fieldName: string) => string[]\n\n  processTerm: (term: string, fieldName: string) => string | string[] | null | undefined | false\n\n  logger: (level: LogLevel, message: string, code?: string) => void\n\n  autoVacuum: false | AutoVacuumOptions\n\n  searchOptions: SearchOptionsWithDefaults\n\n  autoSuggestOptions: SearchOptions\n}\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error'\n\n/**\n * The type of auto-suggestions\n */\nexport type Suggestion = {\n  /**\n   * The suggestion\n   */\n  suggestion: string,\n\n  /**\n   * Suggestion as an array of terms\n   */\n  terms: string[],\n\n  /**\n   * Score for the suggestion\n   */\n  score: number\n}\n\n/**\n * Match information for a search result. It is a key-value object where keys\n * are terms that matched, and values are the list of fields that the term was\n * found in.\n */\nexport type MatchInfo = {\n  [term: string]: string[]\n}\n\n/**\n * Type of the search results. Each search result indicates the document ID, the\n * terms that matched, the match information, the score, and all the stored\n * fields.\n */\nexport type SearchResult = {\n  /**\n   * The document ID\n   */\n  id: any,\n\n  /**\n   * List of document terms that matched. For example, if a prefix search for\n   * `\"moto\"` matches `\"motorcycle\"`, `terms` will contain `\"motorcycle\"`.\n   */\n  terms: string[],\n\n  /**\n   * List of query terms that matched. For example, if a prefix search for\n   * `\"moto\"` matches `\"motorcycle\"`, `queryTerms` will contain `\"moto\"`.\n   */\n  queryTerms: string[],\n\n  /**\n   * Score of the search results\n   */\n  score: number,\n\n  /**\n   * Match information, see {@link MatchInfo}\n   */\n  match: MatchInfo,\n\n  /**\n   * Stored fields\n   */\n  [key: string]: any\n}\n\n/**\n * @ignore\n */\nexport type AsPlainObject = {\n  documentCount: number,\n  nextId: number,\n  documentIds: { [shortId: string]: any }\n  fieldIds: { [fieldName: string]: number }\n  fieldLength: { [shortId: string]: number[] }\n  averageFieldLength: number[],\n  storedFields: { [shortId: string]: any }\n  dirtCount?: number,\n  index: [string, { [fieldId: string]: SerializedIndexEntry }][]\n  serializationVersion: number\n}\n\nexport type QueryCombination = SearchOptions & { queries: Query[] }\n\n/**\n * Wildcard query, used to match all terms\n */\nexport type Wildcard = typeof MiniSearch.wildcard\n\n/**\n * Search query expression, either a query string or an expression tree\n * combining several queries with a combination of AND or OR.\n */\nexport type Query = QueryCombination | string | Wildcard\n\n/**\n * Options to control vacuuming behavior.\n *\n * Vacuuming cleans up document references made obsolete by {@link\n * MiniSearch.discard} from the index. On large indexes, vacuuming is\n * potentially costly, because it has to traverse the whole inverted index.\n * Therefore, in order to dilute this cost so it does not negatively affects the\n * application, vacuuming is performed in batches, with a delay between each\n * batch. These options are used to configure the batch size and the delay\n * between batches.\n */\nexport type VacuumOptions = {\n  /**\n   * Size of each vacuuming batch (the number of terms in the index that will be\n   * traversed in each batch). Defaults to 1000.\n   */\n  batchSize?: number,\n\n  /**\n   * Wait time between each vacuuming batch in milliseconds. Defaults to 10.\n   */\n  batchWait?: number\n}\n\n/**\n * Sets minimum thresholds for `dirtCount` and `dirtFactor` that trigger an\n * automatic vacuuming.\n */\nexport type VacuumConditions = {\n  /**\n   * Minimum `dirtCount` (number of discarded documents since the last vacuuming)\n   * under which auto vacuum is not triggered. It defaults to 20.\n   */\n  minDirtCount?: number\n\n  /**\n   * Minimum `dirtFactor` (proportion of discarded documents over the total)\n   * under which auto vacuum is not triggered. It defaults to 0.1.\n   */\n  minDirtFactor?: number,\n}\n\n/**\n * Options to control auto vacuum behavior. When discarding a document with\n * {@link MiniSearch#discard}, a vacuuming operation is automatically started if\n * the `dirtCount` and `dirtFactor` are above the `minDirtCount` and\n * `minDirtFactor` thresholds defined by this configuration. See {@link\n * VacuumConditions} for details on these.\n *\n * Also, `batchSize` and `batchWait` can be specified, controlling batching\n * behavior (see {@link VacuumOptions}).\n */\nexport type AutoVacuumOptions = VacuumOptions & VacuumConditions\n\ntype QuerySpec = {\n  prefix: boolean,\n  fuzzy: number | boolean,\n  term: string,\n  termBoost: number\n}\n\ntype DocumentTermFreqs = Map<number, number>\ntype FieldTermData = Map<number, DocumentTermFreqs>\n\ninterface RawResultValue {\n  // Intermediate score, before applying the final score based on number of\n  // matched terms.\n  score: number,\n\n  // Set of all query terms that were matched. They may not be present in the\n  // text exactly in the case of prefix/fuzzy matches. We must check for\n  // uniqueness before adding a new term. This is much faster than using a set,\n  // because the number of elements is relatively small.\n  terms: string[],\n\n  // All terms that were found in the content, including the fields in which\n  // they were present. This object will be provided as part of the final search\n  // results.\n  match: MatchInfo,\n}\n\ntype RawResult = Map<number, RawResultValue>\n\n/**\n * {@link MiniSearch} is the main entrypoint class, implementing a full-text\n * search engine in memory.\n *\n * @typeParam T  The type of the documents being indexed.\n *\n * ### Basic example:\n *\n * ```javascript\n * const documents = [\n *   {\n *     id: 1,\n *     title: 'Moby Dick',\n *     text: 'Call me Ishmael. Some years ago...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 2,\n *     title: 'Zen and the Art of Motorcycle Maintenance',\n *     text: 'I can see by my watch...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 3,\n *     title: 'Neuromancer',\n *     text: 'The sky above the port was...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 4,\n *     title: 'Zen and the Art of Archery',\n *     text: 'At first sight it must seem...',\n *     category: 'non-fiction'\n *   },\n *   // ...and more\n * ]\n *\n * // Create a search engine that indexes the 'title' and 'text' fields for\n * // full-text search. Search results will include 'title' and 'category' (plus the\n * // id field, that is always stored and returned)\n * const miniSearch = new MiniSearch({\n *   fields: ['title', 'text'],\n *   storeFields: ['title', 'category']\n * })\n *\n * // Add documents to the index\n * miniSearch.addAll(documents)\n *\n * // Search for documents:\n * let results = miniSearch.search('zen art motorcycle')\n * // => [\n * //   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258 },\n * //   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629 }\n * // ]\n * ```\n */\nexport default class MiniSearch<T = any> {\n  protected _options: OptionsWithDefaults<T>\n  protected _index: SearchableMap<FieldTermData>\n  protected _documentCount: number\n  protected _documentIds: Map<number, any>\n  protected _idToShortId: Map<any, number>\n  protected _fieldIds: { [key: string]: number }\n  protected _fieldLength: Map<number, number[]>\n  protected _avgFieldLength: number[]\n  protected _nextId: number\n  protected _storedFields: Map<number, Record<string, unknown>>\n  protected _dirtCount: number\n  private _currentVacuum: Promise<void> | null\n  private _enqueuedVacuum: Promise<void> | null\n  private _enqueuedVacuumConditions: VacuumConditions | undefined\n\n  /**\n   * The special wildcard symbol that can be passed to {@link MiniSearch#search}\n   * to match all documents\n   */\n  static readonly wildcard: unique symbol = Symbol('*')\n\n  /**\n   * @param options  Configuration options\n   *\n   * ### Examples:\n   *\n   * ```javascript\n   * // Create a search engine that indexes the 'title' and 'text' fields of your\n   * // documents:\n   * const miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n   * ```\n   *\n   * ### ID Field:\n   *\n   * ```javascript\n   * // Your documents are assumed to include a unique 'id' field, but if you want\n   * // to use a different field for document identification, you can set the\n   * // 'idField' option:\n   * const miniSearch = new MiniSearch({ idField: 'key', fields: ['title', 'text'] })\n   * ```\n   *\n   * ### Options and defaults:\n   *\n   * ```javascript\n   * // The full set of options (here with their default value) is:\n   * const miniSearch = new MiniSearch({\n   *   // idField: field that uniquely identifies a document\n   *   idField: 'id',\n   *\n   *   // extractField: function used to get the value of a field in a document.\n   *   // By default, it assumes the document is a flat object with field names as\n   *   // property keys and field values as string property values, but custom logic\n   *   // can be implemented by setting this option to a custom extractor function.\n   *   extractField: (document, fieldName) => document[fieldName],\n   *\n   *   // tokenize: function used to split fields into individual terms. By\n   *   // default, it is also used to tokenize search queries, unless a specific\n   *   // `tokenize` search option is supplied. When tokenizing an indexed field,\n   *   // the field name is passed as the second argument.\n   *   tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),\n   *\n   *   // processTerm: function used to process each tokenized term before\n   *   // indexing. It can be used for stemming and normalization. Return a falsy\n   *   // value in order to discard a term. By default, it is also used to process\n   *   // search queries, unless a specific `processTerm` option is supplied as a\n   *   // search option. When processing a term from a indexed field, the field\n   *   // name is passed as the second argument.\n   *   processTerm: (term, _fieldName) => term.toLowerCase(),\n   *\n   *   // searchOptions: default search options, see the `search` method for\n   *   // details\n   *   searchOptions: undefined,\n   *\n   *   // fields: document fields to be indexed. Mandatory, but not set by default\n   *   fields: undefined\n   *\n   *   // storeFields: document fields to be stored and returned as part of the\n   *   // search results.\n   *   storeFields: []\n   * })\n   * ```\n   */\n  constructor (options: Options<T>) {\n    if (options?.fields == null) {\n      throw new Error('MiniSearch: option \"fields\" must be provided')\n    }\n\n    const autoVacuum = (options.autoVacuum == null || options.autoVacuum === true) ? defaultAutoVacuumOptions : options.autoVacuum\n\n    this._options = {\n      ...defaultOptions,\n      ...options,\n      autoVacuum,\n      searchOptions: { ...defaultSearchOptions, ...(options.searchOptions || {}) },\n      autoSuggestOptions: { ...defaultAutoSuggestOptions, ...(options.autoSuggestOptions || {}) }\n    }\n\n    this._index = new SearchableMap()\n\n    this._documentCount = 0\n\n    this._documentIds = new Map()\n\n    this._idToShortId = new Map()\n\n    // Fields are defined during initialization, don't change, are few in\n    // number, rarely need iterating over, and have string keys. Therefore in\n    // this case an object is a better candidate than a Map to store the mapping\n    // from field key to ID.\n    this._fieldIds = {}\n\n    this._fieldLength = new Map()\n\n    this._avgFieldLength = []\n\n    this._nextId = 0\n\n    this._storedFields = new Map()\n\n    this._dirtCount = 0\n\n    this._currentVacuum = null\n\n    this._enqueuedVacuum = null\n    this._enqueuedVacuumConditions = defaultVacuumConditions\n\n    this.addFields(this._options.fields)\n  }\n\n  /**\n   * Adds a document to the index\n   *\n   * @param document  The document to be indexed\n   */\n  add (document: T): void {\n    const { extractField, stringifyField, tokenize, processTerm, fields, idField } = this._options\n    const id = extractField(document, idField)\n    if (id == null) {\n      throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`)\n    }\n\n    if (this._idToShortId.has(id)) {\n      throw new Error(`MiniSearch: duplicate ID ${id}`)\n    }\n\n    const shortDocumentId = this.addDocumentId(id)\n    this.saveStoredFields(shortDocumentId, document)\n\n    for (const field of fields) {\n      const fieldValue = extractField(document, field)\n      if (fieldValue == null) continue\n\n      const tokens = tokenize(stringifyField(fieldValue, field), field)\n      const fieldId = this._fieldIds[field]\n\n      const uniqueTerms = new Set(tokens).size\n      this.addFieldLength(shortDocumentId, fieldId, this._documentCount - 1, uniqueTerms)\n\n      for (const term of tokens) {\n        const processedTerm = processTerm(term, field)\n        if (Array.isArray(processedTerm)) {\n          for (const t of processedTerm) {\n            this.addTerm(fieldId, shortDocumentId, t)\n          }\n        } else if (processedTerm) {\n          this.addTerm(fieldId, shortDocumentId, processedTerm)\n        }\n      }\n    }\n  }\n\n  /**\n   * Adds all the given documents to the index\n   *\n   * @param documents  An array of documents to be indexed\n   */\n  addAll (documents: readonly T[]): void {\n    for (const document of documents) this.add(document)\n  }\n\n  /**\n   * Adds all the given documents to the index asynchronously.\n   *\n   * Returns a promise that resolves (to `undefined`) when the indexing is done.\n   * This method is useful when index many documents, to avoid blocking the main\n   * thread. The indexing is performed asynchronously and in chunks.\n   *\n   * @param documents  An array of documents to be indexed\n   * @param options  Configuration options\n   * @return A promise resolving to `undefined` when the indexing is done\n   */\n  addAllAsync (documents: readonly T[], options: { chunkSize?: number } = {}): Promise<void> {\n    const { chunkSize = 10 } = options\n    const acc: { chunk: T[], promise: Promise<void> } = { chunk: [], promise: Promise.resolve() }\n\n    const { chunk, promise } = documents.reduce(({ chunk, promise }, document: T, i: number) => {\n      chunk.push(document)\n      if ((i + 1) % chunkSize === 0) {\n        return {\n          chunk: [],\n          promise: promise\n            .then(() => new Promise(resolve => setTimeout(resolve, 0)))\n            .then(() => this.addAll(chunk))\n        }\n      } else {\n        return { chunk, promise }\n      }\n    }, acc)\n\n    return promise.then(() => this.addAll(chunk))\n  }\n\n  /**\n   * Removes the given document from the index.\n   *\n   * The document to remove must NOT have changed between indexing and removal,\n   * otherwise the index will be corrupted.\n   *\n   * This method requires passing the full document to be removed (not just the\n   * ID), and immediately removes the document from the inverted index, allowing\n   * memory to be released. A convenient alternative is {@link\n   * MiniSearch#discard}, which needs only the document ID, and has the same\n   * visible effect, but delays cleaning up the index until the next vacuuming.\n   *\n   * @param document  The document to be removed\n   */\n  remove (document: T): void {\n    const { tokenize, processTerm, extractField, stringifyField, fields, idField } = this._options\n    const id = extractField(document, idField)\n\n    if (id == null) {\n      throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`)\n    }\n\n    const shortId = this._idToShortId.get(id)\n\n    if (shortId == null) {\n      throw new Error(`MiniSearch: cannot remove document with ID ${id}: it is not in the index`)\n    }\n\n    for (const field of fields) {\n      const fieldValue = extractField(document, field)\n      if (fieldValue == null) continue\n\n      const tokens = tokenize(stringifyField(fieldValue, field), field)\n      const fieldId = this._fieldIds[field]\n\n      const uniqueTerms = new Set(tokens).size\n      this.removeFieldLength(shortId, fieldId, this._documentCount, uniqueTerms)\n\n      for (const term of tokens) {\n        const processedTerm = processTerm(term, field)\n        if (Array.isArray(processedTerm)) {\n          for (const t of processedTerm) {\n            this.removeTerm(fieldId, shortId, t)\n          }\n        } else if (processedTerm) {\n          this.removeTerm(fieldId, shortId, processedTerm)\n        }\n      }\n    }\n\n    this._storedFields.delete(shortId)\n    this._documentIds.delete(shortId)\n    this._idToShortId.delete(id)\n    this._fieldLength.delete(shortId)\n    this._documentCount -= 1\n  }\n\n  /**\n   * Removes all the given documents from the index. If called with no arguments,\n   * it removes _all_ documents from the index.\n   *\n   * @param documents  The documents to be removed. If this argument is omitted,\n   * all documents are removed. Note that, for removing all documents, it is\n   * more efficient to call this method with no arguments than to pass all\n   * documents.\n   */\n  removeAll (documents?: readonly T[]): void {\n    if (documents) {\n      for (const document of documents) this.remove(document)\n    } else if (arguments.length > 0) {\n      throw new Error('Expected documents to be present. Omit the argument to remove all documents.')\n    } else {\n      this._index = new SearchableMap()\n      this._documentCount = 0\n      this._documentIds = new Map()\n      this._idToShortId = new Map()\n      this._fieldLength = new Map()\n      this._avgFieldLength = []\n      this._storedFields = new Map()\n      this._nextId = 0\n    }\n  }\n\n  /**\n   * Discards the document with the given ID, so it won't appear in search results\n   *\n   * It has the same visible effect of {@link MiniSearch.remove} (both cause the\n   * document to stop appearing in searches), but a different effect on the\n   * internal data structures:\n   *\n   *   - {@link MiniSearch#remove} requires passing the full document to be\n   *   removed as argument, and removes it from the inverted index immediately.\n   *\n   *   - {@link MiniSearch#discard} instead only needs the document ID, and\n   *   works by marking the current version of the document as discarded, so it\n   *   is immediately ignored by searches. This is faster and more convenient\n   *   than {@link MiniSearch#remove}, but the index is not immediately\n   *   modified. To take care of that, vacuuming is performed after a certain\n   *   number of documents are discarded, cleaning up the index and allowing\n   *   memory to be released.\n   *\n   * After discarding a document, it is possible to re-add a new version, and\n   * only the new version will appear in searches. In other words, discarding\n   * and re-adding a document works exactly like removing and re-adding it. The\n   * {@link MiniSearch.replace} method can also be used to replace a document\n   * with a new version.\n   *\n   * #### Details about vacuuming\n   *\n   * Repetite calls to this method would leave obsolete document references in\n   * the index, invisible to searches. Two mechanisms take care of cleaning up:\n   * clean up during search, and vacuuming.\n   *\n   *   - Upon search, whenever a discarded ID is found (and ignored for the\n   *   results), references to the discarded document are removed from the\n   *   inverted index entries for the search terms. This ensures that subsequent\n   *   searches for the same terms do not need to skip these obsolete references\n   *   again.\n   *\n   *   - In addition, vacuuming is performed automatically by default (see the\n   *   `autoVacuum` field in {@link Options}) after a certain number of\n   *   documents are discarded. Vacuuming traverses all terms in the index,\n   *   cleaning up all references to discarded documents. Vacuuming can also be\n   *   triggered manually by calling {@link MiniSearch#vacuum}.\n   *\n   * @param id  The ID of the document to be discarded\n   */\n  discard (id: any): void {\n    const shortId = this._idToShortId.get(id)\n\n    if (shortId == null) {\n      throw new Error(`MiniSearch: cannot discard document with ID ${id}: it is not in the index`)\n    }\n\n    this._idToShortId.delete(id)\n    this._documentIds.delete(shortId)\n    this._storedFields.delete(shortId)\n\n    ;(this._fieldLength.get(shortId) || []).forEach((fieldLength, fieldId) => {\n      this.removeFieldLength(shortId, fieldId, this._documentCount, fieldLength)\n    })\n\n    this._fieldLength.delete(shortId)\n\n    this._documentCount -= 1\n    this._dirtCount += 1\n\n    this.maybeAutoVacuum()\n  }\n\n  private maybeAutoVacuum (): void {\n    if (this._options.autoVacuum === false) { return }\n\n    const { minDirtFactor, minDirtCount, batchSize, batchWait } = this._options.autoVacuum\n    this.conditionalVacuum({ batchSize, batchWait }, { minDirtCount, minDirtFactor })\n  }\n\n  /**\n   * Discards the documents with the given IDs, so they won't appear in search\n   * results\n   *\n   * It is equivalent to calling {@link MiniSearch#discard} for all the given\n   * IDs, but with the optimization of triggering at most one automatic\n   * vacuuming at the end.\n   *\n   * Note: to remove all documents from the index, it is faster and more\n   * convenient to call {@link MiniSearch.removeAll} with no argument, instead\n   * of passing all IDs to this method.\n   */\n  discardAll (ids: readonly any[]): void {\n    const autoVacuum = this._options.autoVacuum\n\n    try {\n      this._options.autoVacuum = false\n\n      for (const id of ids) {\n        this.discard(id)\n      }\n    } finally {\n      this._options.autoVacuum = autoVacuum\n    }\n\n    this.maybeAutoVacuum()\n  }\n\n  /**\n   * It replaces an existing document with the given updated version\n   *\n   * It works by discarding the current version and adding the updated one, so\n   * it is functionally equivalent to calling {@link MiniSearch#discard}\n   * followed by {@link MiniSearch#add}. The ID of the updated document should\n   * be the same as the original one.\n   *\n   * Since it uses {@link MiniSearch#discard} internally, this method relies on\n   * vacuuming to clean up obsolete document references from the index, allowing\n   * memory to be released (see {@link MiniSearch#discard}).\n   *\n   * @param updatedDocument  The updated document to replace the old version\n   * with\n   */\n  replace (updatedDocument: T): void {\n    const { idField, extractField } = this._options\n    const id = extractField(updatedDocument, idField)\n\n    this.discard(id)\n    this.add(updatedDocument)\n  }\n\n  /**\n   * Triggers a manual vacuuming, cleaning up references to discarded documents\n   * from the inverted index\n   *\n   * Vacuuming is only useful for applications that use the {@link\n   * MiniSearch#discard} or {@link MiniSearch#replace} methods.\n   *\n   * By default, vacuuming is performed automatically when needed (controlled by\n   * the `autoVacuum` field in {@link Options}), so there is usually no need to\n   * call this method, unless one wants to make sure to perform vacuuming at a\n   * specific moment.\n   *\n   * Vacuuming traverses all terms in the inverted index in batches, and cleans\n   * up references to discarded documents from the posting list, allowing memory\n   * to be released.\n   *\n   * The method takes an optional object as argument with the following keys:\n   *\n   *   - `batchSize`: the size of each batch (1000 by default)\n   *\n   *   - `batchWait`: the number of milliseconds to wait between batches (10 by\n   *   default)\n   *\n   * On large indexes, vacuuming could have a non-negligible cost: batching\n   * avoids blocking the thread for long, diluting this cost so that it is not\n   * negatively affecting the application. Nonetheless, this method should only\n   * be called when necessary, and relying on automatic vacuuming is usually\n   * better.\n   *\n   * It returns a promise that resolves (to undefined) when the clean up is\n   * completed. If vacuuming is already ongoing at the time this method is\n   * called, a new one is enqueued immediately after the ongoing one, and a\n   * corresponding promise is returned. However, no more than one vacuuming is\n   * enqueued on top of the ongoing one, even if this method is called more\n   * times (enqueuing multiple ones would be useless).\n   *\n   * @param options  Configuration options for the batch size and delay. See\n   * {@link VacuumOptions}.\n   */\n  vacuum (options: VacuumOptions = {}): Promise<void> {\n    return this.conditionalVacuum(options)\n  }\n\n  private conditionalVacuum (options: VacuumOptions, conditions?: VacuumConditions): Promise<void> {\n    // If a vacuum is already ongoing, schedule another as soon as it finishes,\n    // unless there's already one enqueued. If one was already enqueued, do not\n    // enqueue another on top, but make sure that the conditions are the\n    // broadest.\n    if (this._currentVacuum) {\n      this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && conditions\n      if (this._enqueuedVacuum != null) { return this._enqueuedVacuum }\n\n      this._enqueuedVacuum = this._currentVacuum.then(() => {\n        const conditions = this._enqueuedVacuumConditions\n        this._enqueuedVacuumConditions = defaultVacuumConditions\n        return this.performVacuuming(options, conditions)\n      })\n      return this._enqueuedVacuum\n    }\n\n    if (this.vacuumConditionsMet(conditions) === false) { return Promise.resolve() }\n\n    this._currentVacuum = this.performVacuuming(options)\n    return this._currentVacuum\n  }\n\n  private async performVacuuming (options: VacuumOptions, conditions?: VacuumConditions): Promise<void> {\n    const initialDirtCount = this._dirtCount\n\n    if (this.vacuumConditionsMet(conditions)) {\n      const batchSize = options.batchSize || defaultVacuumOptions.batchSize\n      const batchWait = options.batchWait || defaultVacuumOptions.batchWait\n      let i = 1\n\n      for (const [term, fieldsData] of this._index) {\n        for (const [fieldId, fieldIndex] of fieldsData) {\n          for (const [shortId] of fieldIndex) {\n            if (this._documentIds.has(shortId)) { continue }\n\n            if (fieldIndex.size <= 1) {\n              fieldsData.delete(fieldId)\n            } else {\n              fieldIndex.delete(shortId)\n            }\n          }\n        }\n\n        if (this._index.get(term)!.size === 0) {\n          this._index.delete(term)\n        }\n\n        if (i % batchSize === 0) {\n          await new Promise((resolve) => setTimeout(resolve, batchWait))\n        }\n\n        i += 1\n      }\n\n      this._dirtCount -= initialDirtCount\n    }\n\n    // Make the next lines always async, so they execute after this function returns\n    await null\n\n    this._currentVacuum = this._enqueuedVacuum\n    this._enqueuedVacuum = null\n  }\n\n  private vacuumConditionsMet (conditions?: VacuumConditions) {\n    if (conditions == null) { return true }\n\n    let { minDirtCount, minDirtFactor } = conditions\n    minDirtCount = minDirtCount || defaultAutoVacuumOptions.minDirtCount\n    minDirtFactor = minDirtFactor || defaultAutoVacuumOptions.minDirtFactor\n\n    return this.dirtCount >= minDirtCount && this.dirtFactor >= minDirtFactor\n  }\n\n  /**\n   * Is `true` if a vacuuming operation is ongoing, `false` otherwise\n   */\n  get isVacuuming (): boolean {\n    return this._currentVacuum != null\n  }\n\n  /**\n   * The number of documents discarded since the most recent vacuuming\n   */\n  get dirtCount (): number {\n    return this._dirtCount\n  }\n\n  /**\n   * A number between 0 and 1 giving an indication about the proportion of\n   * documents that are discarded, and can therefore be cleaned up by vacuuming.\n   * A value close to 0 means that the index is relatively clean, while a higher\n   * value means that the index is relatively dirty, and vacuuming could release\n   * memory.\n   */\n  get dirtFactor (): number {\n    return this._dirtCount / (1 + this._documentCount + this._dirtCount)\n  }\n\n  /**\n   * Returns `true` if a document with the given ID is present in the index and\n   * available for search, `false` otherwise\n   *\n   * @param id  The document ID\n   */\n  has (id: any): boolean {\n    return this._idToShortId.has(id)\n  }\n\n  /**\n   * Returns the stored fields (as configured in the `storeFields` constructor\n   * option) for the given document ID. Returns `undefined` if the document is\n   * not present in the index.\n   *\n   * @param id  The document ID\n   */\n  getStoredFields (id: any): Record<string, unknown> | undefined {\n    const shortId = this._idToShortId.get(id)\n\n    if (shortId == null) { return undefined }\n\n    return this._storedFields.get(shortId)\n  }\n\n  /**\n   * Search for documents matching the given search query.\n   *\n   * The result is a list of scored document IDs matching the query, sorted by\n   * descending score, and each including data about which terms were matched and\n   * in which fields.\n   *\n   * ### Basic usage:\n   *\n   * ```javascript\n   * // Search for \"zen art motorcycle\" with default options: terms have to match\n   * // exactly, and individual terms are joined with OR\n   * miniSearch.search('zen art motorcycle')\n   * // => [ { id: 2, score: 2.77258, match: { ... } }, { id: 4, score: 1.38629, match: { ... } } ]\n   * ```\n   *\n   * ### Restrict search to specific fields:\n   *\n   * ```javascript\n   * // Search only in the 'title' field\n   * miniSearch.search('zen', { fields: ['title'] })\n   * ```\n   *\n   * ### Field boosting:\n   *\n   * ```javascript\n   * // Boost a field\n   * miniSearch.search('zen', { boost: { title: 2 } })\n   * ```\n   *\n   * ### Prefix search:\n   *\n   * ```javascript\n   * // Search for \"moto\" with prefix search (it will match documents\n   * // containing terms that start with \"moto\" or \"neuro\")\n   * miniSearch.search('moto neuro', { prefix: true })\n   * ```\n   *\n   * ### Fuzzy search:\n   *\n   * ```javascript\n   * // Search for \"ismael\" with fuzzy search (it will match documents containing\n   * // terms similar to \"ismael\", with a maximum edit distance of 0.2 term.length\n   * // (rounded to nearest integer)\n   * miniSearch.search('ismael', { fuzzy: 0.2 })\n   * ```\n   *\n   * ### Combining strategies:\n   *\n   * ```javascript\n   * // Mix of exact match, prefix search, and fuzzy search\n   * miniSearch.search('ismael mob', {\n   *  prefix: true,\n   *  fuzzy: 0.2\n   * })\n   * ```\n   *\n   * ### Advanced prefix and fuzzy search:\n   *\n   * ```javascript\n   * // Perform fuzzy and prefix search depending on the search term. Here\n   * // performing prefix and fuzzy search only on terms longer than 3 characters\n   * miniSearch.search('ismael mob', {\n   *  prefix: term => term.length > 3\n   *  fuzzy: term => term.length > 3 ? 0.2 : null\n   * })\n   * ```\n   *\n   * ### Combine with AND:\n   *\n   * ```javascript\n   * // Combine search terms with AND (to match only documents that contain both\n   * // \"motorcycle\" and \"art\")\n   * miniSearch.search('motorcycle art', { combineWith: 'AND' })\n   * ```\n   *\n   * ### Combine with AND_NOT:\n   *\n   * There is also an AND_NOT combinator, that finds documents that match the\n   * first term, but do not match any of the other terms. This combinator is\n   * rarely useful with simple queries, and is meant to be used with advanced\n   * query combinations (see later for more details).\n   *\n   * ### Filtering results:\n   *\n   * ```javascript\n   * // Filter only results in the 'fiction' category (assuming that 'category'\n   * // is a stored field)\n   * miniSearch.search('motorcycle art', {\n   *   filter: (result) => result.category === 'fiction'\n   * })\n   * ```\n   *\n   * ### Wildcard query\n   *\n   * Searching for an empty string (assuming the default tokenizer) returns no\n   * results. Sometimes though, one needs to match all documents, like in a\n   * \"wildcard\" search. This is possible by passing the special value\n   * {@link MiniSearch.wildcard} as the query:\n   *\n   * ```javascript\n   * // Return search results for all documents\n   * miniSearch.search(MiniSearch.wildcard)\n   * ```\n   *\n   * Note that search options such as `filter` and `boostDocument` are still\n   * applied, influencing which results are returned, and their order:\n   *\n   * ```javascript\n   * // Return search results for all documents in the 'fiction' category\n   * miniSearch.search(MiniSearch.wildcard, {\n   *   filter: (result) => result.category === 'fiction'\n   * })\n   * ```\n   *\n   * ### Advanced combination of queries:\n   *\n   * It is possible to combine different subqueries with OR, AND, and AND_NOT,\n   * and even with different search options, by passing a query expression\n   * tree object as the first argument, instead of a string.\n   *\n   * ```javascript\n   * // Search for documents that contain \"zen\" and (\"motorcycle\" or \"archery\")\n   * miniSearch.search({\n   *   combineWith: 'AND',\n   *   queries: [\n   *     'zen',\n   *     {\n   *       combineWith: 'OR',\n   *       queries: ['motorcycle', 'archery']\n   *     }\n   *   ]\n   * })\n   *\n   * // Search for documents that contain (\"apple\" or \"pear\") but not \"juice\" and\n   * // not \"tree\"\n   * miniSearch.search({\n   *   combineWith: 'AND_NOT',\n   *   queries: [\n   *     {\n   *       combineWith: 'OR',\n   *       queries: ['apple', 'pear']\n   *     },\n   *     'juice',\n   *     'tree'\n   *   ]\n   * })\n   * ```\n   *\n   * Each node in the expression tree can be either a string, or an object that\n   * supports all {@link SearchOptions} fields, plus a `queries` array field for\n   * subqueries.\n   *\n   * Note that, while this can become complicated to do by hand for complex or\n   * deeply nested queries, it provides a formalized expression tree API for\n   * external libraries that implement a parser for custom query languages.\n   *\n   * @param query  Search query\n   * @param searchOptions  Search options. Each option, if not given, defaults to the corresponding value of `searchOptions` given to the constructor, or to the library default.\n   */\n  search (query: Query, searchOptions: SearchOptions = {}): SearchResult[] {\n    const { searchOptions: globalSearchOptions } = this._options\n    const searchOptionsWithDefaults: SearchOptionsWithDefaults = { ...globalSearchOptions, ...searchOptions }\n\n    const rawResults = this.executeQuery(query, searchOptions)\n    const results = []\n\n    for (const [docId, { score, terms, match }] of rawResults) {\n      // terms are the matched query terms, which will be returned to the user\n      // as queryTerms. The quality is calculated based on them, as opposed to\n      // the matched terms in the document (which can be different due to\n      // prefix and fuzzy match)\n      const quality = terms.length || 1\n\n      const result = {\n        id: this._documentIds.get(docId),\n        score: score * quality,\n        terms: Object.keys(match),\n        queryTerms: terms,\n        match\n      }\n\n      Object.assign(result, this._storedFields.get(docId))\n      if (searchOptionsWithDefaults.filter == null || searchOptionsWithDefaults.filter(result)) {\n        results.push(result)\n      }\n    }\n\n    // If it's a wildcard query, and no document boost is applied, skip sorting\n    // the results, as all results have the same score of 1\n    if (query === MiniSearch.wildcard && searchOptionsWithDefaults.boostDocument == null) {\n      return results\n    }\n\n    results.sort(byScore)\n    return results\n  }\n\n  /**\n   * Provide suggestions for the given search query\n   *\n   * The result is a list of suggested modified search queries, derived from the\n   * given search query, each with a relevance score, sorted by descending score.\n   *\n   * By default, it uses the same options used for search, except that by\n   * default it performs prefix search on the last term of the query, and\n   * combine terms with `'AND'` (requiring all query terms to match). Custom\n   * options can be passed as a second argument. Defaults can be changed upon\n   * calling the {@link MiniSearch} constructor, by passing a\n   * `autoSuggestOptions` option.\n   *\n   * ### Basic usage:\n   *\n   * ```javascript\n   * // Get suggestions for 'neuro':\n   * miniSearch.autoSuggest('neuro')\n   * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 0.46240 } ]\n   * ```\n   *\n   * ### Multiple words:\n   *\n   * ```javascript\n   * // Get suggestions for 'zen ar':\n   * miniSearch.autoSuggest('zen ar')\n   * // => [\n   * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n   * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n   * // ]\n   * ```\n   *\n   * ### Fuzzy suggestions:\n   *\n   * ```javascript\n   * // Correct spelling mistakes using fuzzy search:\n   * miniSearch.autoSuggest('neromancer', { fuzzy: 0.2 })\n   * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]\n   * ```\n   *\n   * ### Filtering:\n   *\n   * ```javascript\n   * // Get suggestions for 'zen ar', but only within the 'fiction' category\n   * // (assuming that 'category' is a stored field):\n   * miniSearch.autoSuggest('zen ar', {\n   *   filter: (result) => result.category === 'fiction'\n   * })\n   * // => [\n   * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n   * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n   * // ]\n   * ```\n   *\n   * @param queryString  Query string to be expanded into suggestions\n   * @param options  Search options. The supported options and default values\n   * are the same as for the {@link MiniSearch#search} method, except that by\n   * default prefix search is performed on the last term in the query, and terms\n   * are combined with `'AND'`.\n   * @return  A sorted array of suggestions sorted by relevance score.\n   */\n  autoSuggest (queryString: string, options: SearchOptions = {}): Suggestion[] {\n    options = { ...this._options.autoSuggestOptions, ...options }\n\n    const suggestions: Map<string, Omit<Suggestion, 'suggestion'> & { count: number }> = new Map()\n\n    for (const { score, terms } of this.search(queryString, options)) {\n      const phrase = terms.join(' ')\n      const suggestion = suggestions.get(phrase)\n      if (suggestion != null) {\n        suggestion.score += score\n        suggestion.count += 1\n      } else {\n        suggestions.set(phrase, { score, terms, count: 1 })\n      }\n    }\n\n    const results = []\n    for (const [suggestion, { score, terms, count }] of suggestions) {\n      results.push({ suggestion, terms, score: score / count })\n    }\n\n    results.sort(byScore)\n    return results\n  }\n\n  /**\n   * Total number of documents available to search\n   */\n  get documentCount (): number {\n    return this._documentCount\n  }\n\n  /**\n   * Number of terms in the index\n   */\n  get termCount (): number {\n    return this._index.size\n  }\n\n  /**\n   * Deserializes a JSON index (serialized with `JSON.stringify(miniSearch)`)\n   * and instantiates a MiniSearch instance. It should be given the same options\n   * originally used when serializing the index.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * // If the index was serialized with:\n   * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n   * miniSearch.addAll(documents)\n   *\n   * const json = JSON.stringify(miniSearch)\n   * // It can later be deserialized like this:\n   * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n   * ```\n   *\n   * @param json  JSON-serialized index\n   * @param options  configuration options, same as the constructor\n   * @return An instance of MiniSearch deserialized from the given JSON.\n   */\n  static loadJSON<T = any> (json: string, options: Options<T>): MiniSearch<T> {\n    if (options == null) {\n      throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index')\n    }\n    return this.loadJS(JSON.parse(json), options)\n  }\n\n  /**\n   * Async equivalent of {@link MiniSearch.loadJSON}\n   *\n   * This function is an alternative to {@link MiniSearch.loadJSON} that returns\n   * a promise, and loads the index in batches, leaving pauses between them to avoid\n   * blocking the main thread. It tends to be slower than the synchronous\n   * version, but does not block the main thread, so it can be a better choice\n   * when deserializing very large indexes.\n   *\n   * @param json  JSON-serialized index\n   * @param options  configuration options, same as the constructor\n   * @return A Promise that will resolve to an instance of MiniSearch deserialized from the given JSON.\n   */\n  static async loadJSONAsync<T = any> (json: string, options: Options<T>): Promise<MiniSearch<T>> {\n    if (options == null) {\n      throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index')\n    }\n    return this.loadJSAsync(JSON.parse(json), options)\n  }\n\n  /**\n   * Returns the default value of an option. It will throw an error if no option\n   * with the given name exists.\n   *\n   * @param optionName  Name of the option\n   * @return The default value of the given option\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * // Get default tokenizer\n   * MiniSearch.getDefault('tokenize')\n   *\n   * // Get default term processor\n   * MiniSearch.getDefault('processTerm')\n   *\n   * // Unknown options will throw an error\n   * MiniSearch.getDefault('notExisting')\n   * // => throws 'MiniSearch: unknown option \"notExisting\"'\n   * ```\n   */\n  static getDefault (optionName: string): any {\n    if (defaultOptions.hasOwnProperty(optionName)) {\n      return getOwnProperty(defaultOptions, optionName)\n    } else {\n      throw new Error(`MiniSearch: unknown option \"${optionName}\"`)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  static loadJS<T = any> (js: AsPlainObject, options: Options<T>): MiniSearch<T> {\n    const {\n      index,\n      documentIds,\n      fieldLength,\n      storedFields,\n      serializationVersion\n    } = js\n\n    const miniSearch = this.instantiateMiniSearch(js, options)\n\n    miniSearch._documentIds = objectToNumericMap(documentIds)\n    miniSearch._fieldLength = objectToNumericMap(fieldLength)\n    miniSearch._storedFields = objectToNumericMap(storedFields)\n\n    for (const [shortId, id] of miniSearch._documentIds) {\n      miniSearch._idToShortId.set(id, shortId)\n    }\n\n    for (const [term, data] of index) {\n      const dataMap = new Map() as FieldTermData\n\n      for (const fieldId of Object.keys(data)) {\n        let indexEntry = data[fieldId]\n\n        // Version 1 used to nest the index entry inside a field called ds\n        if (serializationVersion === 1) {\n          indexEntry = indexEntry.ds as unknown as SerializedIndexEntry\n        }\n\n        dataMap.set(parseInt(fieldId, 10), objectToNumericMap(indexEntry) as DocumentTermFreqs)\n      }\n\n      miniSearch._index.set(term, dataMap)\n    }\n\n    return miniSearch\n  }\n\n  /**\n   * @ignore\n   */\n  static async loadJSAsync<T = any> (js: AsPlainObject, options: Options<T>): Promise<MiniSearch<T>> {\n    const {\n      index,\n      documentIds,\n      fieldLength,\n      storedFields,\n      serializationVersion\n    } = js\n\n    const miniSearch = this.instantiateMiniSearch(js, options)\n\n    miniSearch._documentIds = await objectToNumericMapAsync(documentIds)\n    miniSearch._fieldLength = await objectToNumericMapAsync(fieldLength)\n    miniSearch._storedFields = await objectToNumericMapAsync(storedFields)\n\n    for (const [shortId, id] of miniSearch._documentIds) {\n      miniSearch._idToShortId.set(id, shortId)\n    }\n\n    let count = 0\n    for (const [term, data] of index) {\n      const dataMap = new Map() as FieldTermData\n\n      for (const fieldId of Object.keys(data)) {\n        let indexEntry = data[fieldId]\n\n        // Version 1 used to nest the index entry inside a field called ds\n        if (serializationVersion === 1) {\n          indexEntry = indexEntry.ds as unknown as SerializedIndexEntry\n        }\n\n        dataMap.set(parseInt(fieldId, 10), await objectToNumericMapAsync(indexEntry) as DocumentTermFreqs)\n      }\n\n      if (++count % 1000 === 0) await wait(0)\n      miniSearch._index.set(term, dataMap)\n    }\n\n    return miniSearch\n  }\n\n  /**\n   * @ignore\n   */\n  private static instantiateMiniSearch<T = any> (js: AsPlainObject, options: Options<T>): MiniSearch<T> {\n    const {\n      documentCount,\n      nextId,\n      fieldIds,\n      averageFieldLength,\n      dirtCount,\n      serializationVersion\n    } = js\n\n    if (serializationVersion !== 1 && serializationVersion !== 2) {\n      throw new Error('MiniSearch: cannot deserialize an index created with an incompatible version')\n    }\n\n    const miniSearch = new MiniSearch(options)\n\n    miniSearch._documentCount = documentCount\n    miniSearch._nextId = nextId\n    miniSearch._idToShortId = new Map<any, number>()\n    miniSearch._fieldIds = fieldIds\n    miniSearch._avgFieldLength = averageFieldLength\n    miniSearch._dirtCount = dirtCount || 0\n    miniSearch._index = new SearchableMap()\n\n    return miniSearch\n  }\n\n  /**\n   * @ignore\n   */\n  private executeQuery (query: Query, searchOptions: SearchOptions = {}): RawResult {\n    if (query === MiniSearch.wildcard) {\n      return this.executeWildcardQuery(searchOptions)\n    }\n\n    if (typeof query !== 'string') {\n      const options = { ...searchOptions, ...query, queries: undefined }\n      const results = query.queries.map((subquery) => this.executeQuery(subquery, options))\n      return this.combineResults(results, options.combineWith)\n    }\n\n    const { tokenize, processTerm, searchOptions: globalSearchOptions } = this._options\n    const options = { tokenize, processTerm, ...globalSearchOptions, ...searchOptions }\n    const { tokenize: searchTokenize, processTerm: searchProcessTerm } = options\n    const terms = searchTokenize(query)\n      .flatMap((term: string) => searchProcessTerm(term))\n      .filter((term) => !!term) as string[]\n    const queries: QuerySpec[] = terms.map(termToQuerySpec(options))\n    const results = queries.map(query => this.executeQuerySpec(query, options))\n\n    return this.combineResults(results, options.combineWith)\n  }\n\n  /**\n   * @ignore\n   */\n  private executeQuerySpec (query: QuerySpec, searchOptions: SearchOptions): RawResult {\n    const options: SearchOptionsWithDefaults = { ...this._options.searchOptions, ...searchOptions }\n\n    const boosts = (options.fields || this._options.fields).reduce((boosts, field) =>\n      ({ ...boosts, [field]: getOwnProperty(options.boost, field) || 1 }), {})\n\n    const {\n      boostDocument,\n      weights,\n      maxFuzzy,\n      bm25: bm25params\n    } = options\n\n    const { fuzzy: fuzzyWeight, prefix: prefixWeight } = { ...defaultSearchOptions.weights, ...weights }\n\n    const data = this._index.get(query.term)\n    const results = this.termResults(query.term, query.term, 1, query.termBoost, data, boosts, boostDocument, bm25params)\n\n    let prefixMatches\n    let fuzzyMatches\n\n    if (query.prefix) {\n      prefixMatches = this._index.atPrefix(query.term)\n    }\n\n    if (query.fuzzy) {\n      const fuzzy = (query.fuzzy === true) ? 0.2 : query.fuzzy\n      const maxDistance = fuzzy < 1 ? Math.min(maxFuzzy, Math.round(query.term.length * fuzzy)) : fuzzy\n      if (maxDistance) fuzzyMatches = this._index.fuzzyGet(query.term, maxDistance)\n    }\n\n    if (prefixMatches) {\n      for (const [term, data] of prefixMatches) {\n        const distance = term.length - query.term.length\n        if (!distance) { continue } // Skip exact match.\n\n        // Delete the term from fuzzy results (if present) if it is also a\n        // prefix result. This entry will always be scored as a prefix result.\n        fuzzyMatches?.delete(term)\n\n        // Weight gradually approaches 0 as distance goes to infinity, with the\n        // weight for the hypothetical distance 0 being equal to prefixWeight.\n        // The rate of change is much lower than that of fuzzy matches to\n        // account for the fact that prefix matches stay more relevant than\n        // fuzzy matches for longer distances.\n        const weight = prefixWeight * term.length / (term.length + 0.3 * distance)\n        this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results)\n      }\n    }\n\n    if (fuzzyMatches) {\n      for (const term of fuzzyMatches.keys()) {\n        const [data, distance] = fuzzyMatches.get(term)!\n        if (!distance) { continue } // Skip exact match.\n\n        // Weight gradually approaches 0 as distance goes to infinity, with the\n        // weight for the hypothetical distance 0 being equal to fuzzyWeight.\n        const weight = fuzzyWeight * term.length / (term.length + distance)\n        this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results)\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * @ignore\n   */\n  private executeWildcardQuery (searchOptions: SearchOptions): RawResult {\n    const results = new Map() as RawResult\n    const options: SearchOptionsWithDefaults = { ...this._options.searchOptions, ...searchOptions }\n\n    for (const [shortId, id] of this._documentIds) {\n      const score = options.boostDocument ? options.boostDocument(id, '', this._storedFields.get(shortId)) : 1\n      results.set(shortId, {\n        score,\n        terms: [],\n        match: {}\n      })\n    }\n\n    return results\n  }\n\n  /**\n   * @ignore\n   */\n  private combineResults (results: RawResult[], combineWith: CombinationOperator = OR): RawResult {\n    if (results.length === 0) { return new Map() }\n    const operator = combineWith.toLowerCase()\n    const combinator = (combinators as Record<string, CombinatorFunction>)[operator]\n\n    if (!combinator) {\n      throw new Error(`Invalid combination operator: ${combineWith}`)\n    }\n\n    return results.reduce(combinator) || new Map()\n  }\n\n  /**\n   * Allows serialization of the index to JSON, to possibly store it and later\n   * deserialize it with {@link MiniSearch.loadJSON}.\n   *\n   * Normally one does not directly call this method, but rather call the\n   * standard JavaScript `JSON.stringify()` passing the {@link MiniSearch}\n   * instance, and JavaScript will internally call this method. Upon\n   * deserialization, one must pass to {@link MiniSearch.loadJSON} the same\n   * options used to create the original instance that was serialized.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * // Serialize the index:\n   * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n   * miniSearch.addAll(documents)\n   * const json = JSON.stringify(miniSearch)\n   *\n   * // Later, to deserialize it:\n   * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n   * ```\n   *\n   * @return A plain-object serializable representation of the search index.\n   */\n  toJSON (): AsPlainObject {\n    const index: [string, { [key: string]: SerializedIndexEntry }][] = []\n\n    for (const [term, fieldIndex] of this._index) {\n      const data: { [key: string]: SerializedIndexEntry } = {}\n\n      for (const [fieldId, freqs] of fieldIndex) {\n        data[fieldId] = Object.fromEntries(freqs)\n      }\n\n      index.push([term, data])\n    }\n\n    return {\n      documentCount: this._documentCount,\n      nextId: this._nextId,\n      documentIds: Object.fromEntries(this._documentIds),\n      fieldIds: this._fieldIds,\n      fieldLength: Object.fromEntries(this._fieldLength),\n      averageFieldLength: this._avgFieldLength,\n      storedFields: Object.fromEntries(this._storedFields),\n      dirtCount: this._dirtCount,\n      index,\n      serializationVersion: 2\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private termResults (\n    sourceTerm: string,\n    derivedTerm: string,\n    termWeight: number,\n    termBoost: number,\n    fieldTermData: FieldTermData | undefined,\n    fieldBoosts: { [field: string]: number },\n    boostDocumentFn: ((id: any, term: string, storedFields?: Record<string, unknown>) => number) | undefined,\n    bm25params: BM25Params,\n    results: RawResult = new Map()\n  ): RawResult {\n    if (fieldTermData == null) return results\n\n    for (const field of Object.keys(fieldBoosts)) {\n      const fieldBoost = fieldBoosts[field]\n      const fieldId = this._fieldIds[field]\n\n      const fieldTermFreqs = fieldTermData.get(fieldId)\n      if (fieldTermFreqs == null) continue\n\n      let matchingFields = fieldTermFreqs.size\n      const avgFieldLength = this._avgFieldLength[fieldId]\n\n      for (const docId of fieldTermFreqs.keys()) {\n        if (!this._documentIds.has(docId)) {\n          this.removeTerm(fieldId, docId, derivedTerm)\n          matchingFields -= 1\n          continue\n        }\n\n        const docBoost = boostDocumentFn ? boostDocumentFn(this._documentIds.get(docId), derivedTerm, this._storedFields.get(docId)) : 1\n        if (!docBoost) continue\n\n        const termFreq = fieldTermFreqs.get(docId)!\n        const fieldLength = this._fieldLength.get(docId)![fieldId]\n\n        // NOTE: The total number of fields is set to the number of documents\n        // `this._documentCount`. It could also make sense to use the number of\n        // documents where the current field is non-blank as a normalization\n        // factor. This will make a difference in scoring if the field is rarely\n        // present. This is currently not supported, and may require further\n        // analysis to see if it is a valid use case.\n        const rawScore = calcBM25Score(termFreq, matchingFields, this._documentCount, fieldLength, avgFieldLength, bm25params)\n        const weightedScore = termWeight * termBoost * fieldBoost * docBoost * rawScore\n\n        const result = results.get(docId)\n        if (result) {\n          result.score += weightedScore\n          assignUniqueTerm(result.terms, sourceTerm)\n          const match = getOwnProperty(result.match, derivedTerm)\n          if (match) {\n            match.push(field)\n          } else {\n            result.match[derivedTerm] = [field]\n          }\n        } else {\n          results.set(docId, {\n            score: weightedScore,\n            terms: [sourceTerm],\n            match: { [derivedTerm]: [field] }\n          })\n        }\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * @ignore\n   */\n  private addTerm (fieldId: number, documentId: number, term: string): void {\n    const indexData = this._index.fetch(term, createMap)\n\n    let fieldIndex = indexData.get(fieldId)\n    if (fieldIndex == null) {\n      fieldIndex = new Map()\n      fieldIndex.set(documentId, 1)\n      indexData.set(fieldId, fieldIndex)\n    } else {\n      const docs = fieldIndex.get(documentId)\n      fieldIndex.set(documentId, (docs || 0) + 1)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private removeTerm (fieldId: number, documentId: number, term: string): void {\n    if (!this._index.has(term)) {\n      this.warnDocumentChanged(documentId, fieldId, term)\n      return\n    }\n\n    const indexData = this._index.fetch(term, createMap)\n\n    const fieldIndex = indexData.get(fieldId)\n    if (fieldIndex == null || fieldIndex.get(documentId) == null) {\n      this.warnDocumentChanged(documentId, fieldId, term)\n    } else if (fieldIndex.get(documentId)! <= 1) {\n      if (fieldIndex.size <= 1) {\n        indexData.delete(fieldId)\n      } else {\n        fieldIndex.delete(documentId)\n      }\n    } else {\n      fieldIndex.set(documentId, fieldIndex.get(documentId)! - 1)\n    }\n\n    if (this._index.get(term)!.size === 0) {\n      this._index.delete(term)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private warnDocumentChanged (shortDocumentId: number, fieldId: number, term: string): void {\n    for (const fieldName of Object.keys(this._fieldIds)) {\n      if (this._fieldIds[fieldName] === fieldId) {\n        this._options.logger('warn', `MiniSearch: document with ID ${this._documentIds.get(shortDocumentId)} has changed before removal: term \"${term}\" was not present in field \"${fieldName}\". Removing a document after it has changed can corrupt the index!`, 'version_conflict')\n        return\n      }\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private addDocumentId (documentId: any): number {\n    const shortDocumentId = this._nextId\n    this._idToShortId.set(documentId, shortDocumentId)\n    this._documentIds.set(shortDocumentId, documentId)\n    this._documentCount += 1\n    this._nextId += 1\n    return shortDocumentId\n  }\n\n  /**\n   * @ignore\n   */\n  private addFields (fields: string[]): void {\n    for (let i = 0; i < fields.length; i++) {\n      this._fieldIds[fields[i]] = i\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private addFieldLength (documentId: number, fieldId: number, count: number, length: number): void {\n    let fieldLengths = this._fieldLength.get(documentId)\n    if (fieldLengths == null) this._fieldLength.set(documentId, fieldLengths = [])\n    fieldLengths[fieldId] = length\n\n    const averageFieldLength = this._avgFieldLength[fieldId] || 0\n    const totalFieldLength = (averageFieldLength * count) + length\n    this._avgFieldLength[fieldId] = totalFieldLength / (count + 1)\n  }\n\n  /**\n   * @ignore\n   */\n  private removeFieldLength (documentId: number, fieldId: number, count: number, length: number): void {\n    if (count === 1) {\n      this._avgFieldLength[fieldId] = 0\n      return\n    }\n    const totalFieldLength = (this._avgFieldLength[fieldId] * count) - length\n    this._avgFieldLength[fieldId] = totalFieldLength / (count - 1)\n  }\n\n  /**\n   * @ignore\n   */\n  private saveStoredFields (documentId: number, doc: T): void {\n    const { storeFields, extractField } = this._options\n    if (storeFields == null || storeFields.length === 0) { return }\n\n    let documentFields = this._storedFields.get(documentId)\n    if (documentFields == null) this._storedFields.set(documentId, documentFields = {})\n\n    for (const fieldName of storeFields) {\n      const fieldValue = extractField(doc, fieldName)\n      if (fieldValue !== undefined) documentFields[fieldName] = fieldValue\n    }\n  }\n}\n\nconst getOwnProperty = (object: any, property: string) =>\n  Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined\n\ntype CombinatorFunction = (a: RawResult, b: RawResult) => RawResult\n\nconst combinators: Record<LowercaseCombinationOperator, CombinatorFunction> = {\n  [OR]: (a: RawResult, b: RawResult) => {\n    for (const docId of b.keys()) {\n      const existing = a.get(docId)\n      if (existing == null) {\n        a.set(docId, b.get(docId)!)\n      } else {\n        const { score, terms, match } = b.get(docId)!\n        existing.score = existing.score + score\n        existing.match = Object.assign(existing.match, match)\n        assignUniqueTerms(existing.terms, terms)\n      }\n    }\n\n    return a\n  },\n  [AND]: (a: RawResult, b: RawResult) => {\n    const combined = new Map()\n\n    for (const docId of b.keys()) {\n      const existing = a.get(docId)\n      if (existing == null) continue\n\n      const { score, terms, match } = b.get(docId)!\n      assignUniqueTerms(existing.terms, terms)\n      combined.set(docId, {\n        score: existing.score + score,\n        terms: existing.terms,\n        match: Object.assign(existing.match, match)\n      })\n    }\n\n    return combined\n  },\n  [AND_NOT]: (a: RawResult, b: RawResult) => {\n    for (const docId of b.keys()) a.delete(docId)\n    return a\n  }\n}\n\n/**\n * Parameters of the BM25+ scoring algorithm. Customizing these is almost never\n * necessary, and finetuning them requires an understanding of the BM25 scoring\n * model.\n *\n * Some information about BM25 (and BM25+) can be found at these links:\n *\n *   - https://en.wikipedia.org/wiki/Okapi_BM25\n *   - https://opensourceconnections.com/blog/2015/10/16/bm25-the-next-generation-of-lucene-relevation/\n */\nexport type BM25Params = {\n  /** Term frequency saturation point.\n   *\n   * Recommended values are between `1.2` and `2`. Higher values increase the\n   * difference in score between documents with higher and lower term\n   * frequencies. Setting this to `0` or a negative value is invalid. Defaults\n   * to `1.2`\n   */\n  k: number,\n\n  /**\n   * Length normalization impact.\n   *\n   * Recommended values are around `0.75`. Higher values increase the weight\n   * that field length has on scoring. Setting this to `0` (not recommended)\n   * means that the field length has no effect on scoring. Negative values are\n   * invalid. Defaults to `0.7`.\n   */\n  b: number,\n\n  /**\n   * BM25+ frequency normalization lower bound (usually called \u03B4).\n   *\n   * Recommended values are between `0.5` and `1`. Increasing this parameter\n   * increases the minimum relevance of one occurrence of a search term\n   * regardless of its (possibly very long) field length. Negative values are\n   * invalid. Defaults to `0.5`.\n   */\n  d: number\n}\n\nconst defaultBM25params: BM25Params = { k: 1.2, b: 0.7, d: 0.5 }\n\nconst calcBM25Score = (\n  termFreq: number,\n  matchingCount: number,\n  totalCount: number,\n  fieldLength: number,\n  avgFieldLength: number,\n  bm25params: BM25Params\n): number => {\n  const { k, b, d } = bm25params\n  const invDocFreq = Math.log(1 + (totalCount - matchingCount + 0.5) / (matchingCount + 0.5))\n  return invDocFreq * (d + termFreq * (k + 1) / (termFreq + k * (1 - b + b * fieldLength / avgFieldLength)))\n}\n\nconst termToQuerySpec = (options: SearchOptions) => (term: string, i: number, terms: string[]): QuerySpec => {\n  const fuzzy = (typeof options.fuzzy === 'function')\n    ? options.fuzzy(term, i, terms)\n    : (options.fuzzy || false)\n  const prefix = (typeof options.prefix === 'function')\n    ? options.prefix(term, i, terms)\n    : (options.prefix === true)\n  const termBoost = (typeof options.boostTerm === 'function')\n    ? options.boostTerm(term, i, terms)\n    : 1\n  return { term, fuzzy, prefix, termBoost }\n}\n\nconst defaultOptions = {\n  idField: 'id',\n  extractField: (document: any, fieldName: string) => document[fieldName],\n  stringifyField: (fieldValue: any, fieldName: string) => fieldValue.toString(),\n  tokenize: (text: string) => text.split(SPACE_OR_PUNCTUATION),\n  processTerm: (term: string) => term.toLowerCase(),\n  fields: undefined,\n  searchOptions: undefined,\n  storeFields: [],\n  logger: (level: LogLevel, message: string): void => {\n    if (typeof console?.[level] === 'function') console[level](message)\n  },\n  autoVacuum: true\n}\n\nconst defaultSearchOptions = {\n  combineWith: OR,\n  prefix: false,\n  fuzzy: false,\n  maxFuzzy: 6,\n  boost: {},\n  weights: { fuzzy: 0.45, prefix: 0.375 },\n  bm25: defaultBM25params\n}\n\nconst defaultAutoSuggestOptions = {\n  combineWith: AND,\n  prefix: (term: string, i: number, terms: string[]): boolean =>\n    i === terms.length - 1\n}\n\nconst defaultVacuumOptions = { batchSize: 1000, batchWait: 10 }\nconst defaultVacuumConditions = { minDirtFactor: 0.1, minDirtCount: 20 }\n\nconst defaultAutoVacuumOptions = { ...defaultVacuumOptions, ...defaultVacuumConditions }\n\nconst assignUniqueTerm = (target: string[], term: string): void => {\n  // Avoid adding duplicate terms.\n  if (!target.includes(term)) target.push(term)\n}\n\nconst assignUniqueTerms = (target: string[], source: readonly string[]): void => {\n  for (const term of source) {\n    // Avoid adding duplicate terms.\n    if (!target.includes(term)) target.push(term)\n  }\n}\n\ntype Scored = { score: number }\nconst byScore = ({ score: a }: Scored, { score: b }: Scored) => b - a\n\nconst createMap = () => new Map()\n\ninterface SerializedIndexEntry {\n  [key: string]: number\n}\n\nconst objectToNumericMap = <T>(object: { [key: string]: T }): Map<number, T> => {\n  const map = new Map()\n\n  for (const key of Object.keys(object)) {\n    map.set(parseInt(key, 10), object[key])\n  }\n\n  return map\n}\n\nconst objectToNumericMapAsync = async <T>(object: { [key: string]: T }): Promise<Map<number, T>> => {\n  const map = new Map()\n\n  let count = 0\n  for (const key of Object.keys(object)) {\n    map.set(parseInt(key, 10), object[key])\n    if (++count % 1000 === 0) {\n      await wait(0)\n    }\n  }\n\n  return map\n}\n\nconst wait = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))\n\n// This regular expression matches any Unicode space, newline, or punctuation\n// character\nconst SPACE_OR_PUNCTUATION = /[\\n\\r\\p{Z}\\p{P}]+/u\n"],
  "mappings": "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",
  "names": ["require_lodash", "__commonJSMin", "exports", "module", "init_define_process", "LARGE_ARRAY_SIZE", "HASH_UNDEFINED", "HOT_COUNT", "HOT_SPAN", "MAX_SAFE_INTEGER", "argsTag", "arrayTag", "asyncTag", "boolTag", "dateTag", "errorTag", "funcTag", "genTag", "mapTag", "numberTag", "nullTag", "objectTag", "proxyTag", "regexpTag", "setTag", "stringTag", "undefinedTag", "weakMapTag", "arrayBufferTag", "dataViewTag", "float32Tag", "float64Tag", "int8Tag", "int16Tag", "int32Tag", "uint8Tag", "uint8ClampedTag", "uint16Tag", "uint32Tag", "reRegExpChar", "reIsHostCtor", "reIsUint", "typedArrayTags", "freeGlobal", "freeSelf", "root", "freeExports", "freeModule", "moduleExports", "freeProcess", "nodeUtil", "types", "nodeIsTypedArray", "apply", "func", "thisArg", "args", "baseTimes", "n", "iteratee", "index", "result", "baseUnary", "value", "getValue", "object", "key", "overArg", "transform", "arg", "arrayProto", "funcProto", "objectProto", "coreJsData", "funcToString", "hasOwnProperty", "maskSrcKey", "uid", "nativeObjectToString", "objectCtorString", "reIsNative", "Buffer", "Symbol", "Uint8Array", "allocUnsafe", "getPrototype", "objectCreate", "propertyIsEnumerable", "splice", "symToStringTag", "defineProperty", "getNative", "nativeIsBuffer", "nativeMax", "nativeNow", "Map", "nativeCreate", "baseCreate", "proto", "isObject", "Hash", "entries", "length", "entry", "hashClear", "hashDelete", "hashGet", "data", "hashHas", "hashSet", "ListCache", "listCacheClear", "listCacheDelete", "assocIndexOf", "lastIndex", "listCacheGet", "listCacheHas", "listCacheSet", "MapCache", "mapCacheClear", "mapCacheDelete", "getMapData", "mapCacheGet", "mapCacheHas", "mapCacheSet", "size", "Stack", "stackClear", "stackDelete", "stackGet", "stackHas", "stackSet", "pairs", "arrayLikeKeys", "inherited", "isArr", "isArray", "isArg", "isArguments", "isBuff", "isBuffer", "isType", "isTypedArray", "skipIndexes", "isIndex", "assignMergeValue", "eq", "baseAssignValue", "assignValue", "objValue", "array", "baseFor", "createBaseFor", "baseGetTag", "getRawTag", "objectToString", "baseIsArguments", "isObjectLike", "baseIsNative", "isMasked", "pattern", "isFunction", "toSource", "baseIsTypedArray", "isLength", "baseKeysIn", "nativeKeysIn", "isProto", "isPrototype", "baseMerge", "source", "srcIndex", "customizer", "stack", "srcValue", "baseMergeDeep", "newValue", "safeGet", "keysIn", "mergeFunc", "stacked", "isCommon", "isTyped", "isArrayLikeObject", "copyArray", "cloneBuffer", "cloneTypedArray", "isPlainObject", "toPlainObject", "initCloneObject", "baseRest", "start", "setToString", "overRest", "identity", "baseSetToString", "string", "constant", "buffer", "isDeep", "cloneArrayBuffer", "arrayBuffer", "typedArray", "copyObject", "props", "isNew", "createAssigner", "assigner", "sources", "guard", "isIterateeCall", "fromRight", "keysFunc", "iterable", "customDefaultsMerge", "map", "isKeyable", "isOwn", "tag", "unmasked", "type", "isArrayLike", "Ctor", "otherArgs", "shortOut", "count", "lastCalled", "stamp", "remaining", "other", "stubFalse", "defaultsDeep", "mergeWith", "ENTRIES", "KEYS", "VALUES", "LEAF", "TreeIterator", "set", "node", "keys", "last", "child", "fuzzySearch", "query", "maxDistance", "results", "m", "matrix", "j", "i", "recurse", "prefix", "offset", "distance", "pos", "char", "thisRowOffset", "prevRowOffset", "minDistance", "jmin", "jmax", "different", "rpl", "del", "ins", "dist", "SearchableMap", "_SearchableMap", "tree", "path", "trackDown", "parentNode", "k", "remove", "fn", "maxEditDistance", "lookup", "createPath", "iter", "initial", "keyLength", "outer", "len", "intermediate", "cleanup", "merge", "nodeKey", "OR", "AND", "AND_NOT", "MiniSearch", "_MiniSearch", "options", "autoVacuum", "defaultAutoVacuumOptions", "defaultOptions", "defaultSearchOptions", "defaultAutoSuggestOptions", "defaultVacuumConditions", "document", "extractField", "stringifyField", "tokenize", "processTerm", "fields", "idField", "id", "shortDocumentId", "field", "fieldValue", "tokens", "fieldId", "uniqueTerms", "term", "processedTerm", "t", "documents", "chunkSize", "acc", "chunk", "promise", "resolve", "shortId", "fieldLength", "minDirtFactor", "minDirtCount", "batchSize", "batchWait", "ids", "updatedDocument", "conditions", "initialDirtCount", "defaultVacuumOptions", "fieldsData", "fieldIndex", "searchOptions", "globalSearchOptions", "searchOptionsWithDefaults", "rawResults", "docId", "score", "terms", "match", "quality", "byScore", "queryString", "suggestions", "phrase", "suggestion", "json", "optionName", "getOwnProperty", "js", "documentIds", "storedFields", "serializationVersion", "miniSearch", "objectToNumericMap", "dataMap", "indexEntry", "objectToNumericMapAsync", "wait", "documentCount", "nextId", "fieldIds", "averageFieldLength", "dirtCount", "subquery", "searchTokenize", "searchProcessTerm", "termToQuerySpec", "boosts", "boostDocument", "weights", "maxFuzzy", "bm25params", "fuzzyWeight", "prefixWeight", "prefixMatches", "fuzzyMatches", "fuzzy", "weight", "combineWith", "operator", "combinator", "combinators", "freqs", "sourceTerm", "derivedTerm", "termWeight", "termBoost", "fieldTermData", "fieldBoosts", "boostDocumentFn", "fieldBoost", "fieldTermFreqs", "matchingFields", "avgFieldLength", "docBoost", "termFreq", "rawScore", "calcBM25Score", "weightedScore", "assignUniqueTerm", "documentId", "indexData", "createMap", "docs", "fieldName", "fieldLengths", "totalFieldLength", "doc", "storeFields", "documentFields", "property", "a", "b", "existing", "assignUniqueTerms", "combined", "defaultBM25params", "matchingCount", "totalCount", "d", "text", "SPACE_OR_PUNCTUATION", "level", "message", "target", "ms", "import_lodash", "_trackSearchDebounced", "_InternalSearch_instances", "trackSearch_fn", "InternalSearch", "mapData", "__privateAdd", "__publicField", "buildIndexes", "__privateSet", "debounce", "__privateMethod", "placesIndex", "locationsIndex", "categoriesIndex", "promises", "searchOptionsSchema", "_options", "DEFAULT_CONFIG", "places", "locations", "categories", "processSearchResult", "__privateGet", "suggestOptionsSchema", "includePlaces", "includeLocations", "s", "placesResult", "locationsResult", "categoriesResult", "__type", "item", "node_default", "floor_stack_default", "facade_default", "location_default", "category_default", "removeAccents", "it", "STOP_WORDS", "r", "DELIMITER", "z"]
}
