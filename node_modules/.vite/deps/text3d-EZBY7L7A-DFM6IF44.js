import {
  FM,
  qu
} from "./chunk-4WA6YUVK.js";
import "./chunk-QAS2ACFW.js";
import {
  $i,
  $r,
  Ae,
  C,
  Fe,
  Ie,
  Jt,
  Kr,
  Ls,
  Nt,
  On,
  Ot,
  Pe,
  Te,
  Vt,
  at,
  au,
  id,
  kt,
  ln,
  ps,
  qh,
  tn,
  ve,
  vs,
  yc,
  yd,
  yl
} from "./chunk-X36R2MTZ.js";
import "./chunk-J7CDIHLL.js";
import "./chunk-PLDDJCW6.js";

// node_modules/@mappedin/mappedin-js/lib/esm/text3d-EZBY7L7A.js
$i();
$i();
$i();
function da() {
  var c2 = /* @__PURE__ */ Object.create(null);
  function r(t, e) {
    var n = t.id, o = t.name, a = t.dependencies;
    a === void 0 && (a = []);
    var i = t.init;
    i === void 0 && (i = function() {
    });
    var s = t.getTransferables;
    if (s === void 0 && (s = null), !c2[n]) try {
      a = a.map(function(u) {
        return u && u.isWorkerModule && (r(u, function(d) {
          if (d instanceof Error) throw d;
        }), u = c2[u.id].value), u;
      }), i = f("<" + o + ">.init", i), s && (s = f("<" + o + ">.getTransferables", s));
      var l = null;
      typeof i == "function" ? l = i.apply(void 0, a) : console.error("worker module init function failed to rehydrate"), c2[n] = { id: n, value: l, getTransferables: s }, e(l);
    } catch (u) {
      u && u.noLog || console.error(u), e(u);
    }
  }
  function h(t, e) {
    var n, o = t.id, a = t.args;
    (!c2[o] || typeof c2[o].value != "function") && e(new Error("Worker module " + o + ": not found or its 'init' did not return a function"));
    try {
      var i = (n = c2[o]).value.apply(n, a);
      i && typeof i.then == "function" ? i.then(s, function(l) {
        return e(l instanceof Error ? l : new Error("" + l));
      }) : s(i);
    } catch (l) {
      e(l);
    }
    function s(l) {
      try {
        var u = c2[o].getTransferables && c2[o].getTransferables(l);
        (!u || !Array.isArray(u) || !u.length) && (u = void 0), e(l, u);
      } catch (d) {
        console.error(d), e(d);
      }
    }
  }
  function f(t, e) {
    var n = void 0;
    self.troikaDefine = function(a) {
      return n = a;
    };
    var o = URL.createObjectURL(new Blob(["/** " + t.replace(/\*/g, "") + ` **/

troikaDefine(
` + e + `
)`], { type: "application/javascript" }));
    try {
      importScripts(o);
    } catch (a) {
      console.error(a);
    }
    return URL.revokeObjectURL(o), delete self.troikaDefine, n;
  }
  self.addEventListener("message", function(t) {
    var e = t.data, n = e.messageId, o = e.action, a = e.data;
    try {
      o === "registerModule" && r(a, function(i) {
        i instanceof Error ? postMessage({ messageId: n, success: false, error: i.message }) : postMessage({ messageId: n, success: true, result: { isCallable: typeof i == "function" } });
      }), o === "callModule" && h(a, function(i, s) {
        i instanceof Error ? postMessage({ messageId: n, success: false, error: i.message }) : postMessage({ messageId: n, success: true, result: i }, s || void 0);
      });
    } catch (i) {
      postMessage({ messageId: n, success: false, error: i.stack });
    }
  });
}
function va(c2) {
  var r = function() {
    for (var h = [], f = arguments.length; f--; ) h[f] = arguments[f];
    return r._getInitResult().then(function(t) {
      if (typeof t == "function") return t.apply(void 0, h);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return r._getInitResult = function() {
    var h = c2.dependencies, f = c2.init;
    h = Array.isArray(h) ? h.map(function(e) {
      return e && (e = e.onMainThread || e, e._getInitResult && (e = e._getInitResult())), e;
    }) : [];
    var t = Promise.all(h).then(function(e) {
      return f.apply(null, e);
    });
    return r._getInitResult = function() {
      return t;
    }, t;
  }, r;
}
var Mn = function() {
  var c2 = false;
  if (typeof window < "u" && typeof window.document < "u") try {
    var r = new Worker(URL.createObjectURL(new Blob([""], { type: "application/javascript" })));
    r.terminate(), c2 = true;
  } catch (h) {
    typeof yc < "u" && yc.env.NODE_ENV === "test" || console.log("Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + h.message + "]");
  }
  return Mn = function() {
    return c2;
  }, c2;
};
var pa = 0;
var ga = 0;
var wr = false;
var Dt = /* @__PURE__ */ Object.create(null);
var Ct = /* @__PURE__ */ Object.create(null);
var Fr = /* @__PURE__ */ Object.create(null);
function it(c2) {
  if ((!c2 || typeof c2.init != "function") && !wr) throw new Error("requires `options.init` function");
  var r = c2.dependencies, h = c2.init, f = c2.getTransferables, t = c2.workerId, e = va(c2);
  t == null && (t = "#default");
  var n = "workerModule" + ++pa, o = c2.name || n, a = null;
  r = r && r.map(function(s) {
    return typeof s == "function" && !s.workerModuleData && (wr = true, s = it({ workerId: t, name: "<" + o + "> function dependency: " + s.name, init: `function(){return (
` + Jt2(s) + `
)}` }), wr = false), s && s.workerModuleData && (s = s.workerModuleData), s;
  });
  function i() {
    for (var s = [], l = arguments.length; l--; ) s[l] = arguments[l];
    if (!Mn()) return e.apply(void 0, s);
    if (!a) {
      a = Fn(t, "registerModule", i.workerModuleData);
      var u = function() {
        a = null, Ct[t].delete(u);
      };
      (Ct[t] || (Ct[t] = /* @__PURE__ */ new Set())).add(u);
    }
    return a.then(function(d) {
      var p = d.isCallable;
      if (p) return Fn(t, "callModule", { id: n, args: s });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return i.workerModuleData = { isWorkerModule: true, id: n, name: o, dependencies: r, init: Jt2(h), getTransferables: f && Jt2(f) }, i.onMainThread = e, i;
}
function An(c2) {
  Ct[c2] && Ct[c2].forEach(function(r) {
    r();
  }), Dt[c2] && (Dt[c2].terminate(), delete Dt[c2]);
}
function Jt2(c2) {
  var r = c2.toString();
  return !/^function/.test(r) && /^\w+\s*\(/.test(r) && (r = "function " + r), r;
}
function ma(c2) {
  var r = Dt[c2];
  if (!r) {
    var h = Jt2(da);
    r = Dt[c2] = new Worker(URL.createObjectURL(new Blob(["/** Worker Module Bootstrap: " + c2.replace(/\*/g, "") + ` **/

;(` + h + ")()"], { type: "application/javascript" }))), r.onmessage = function(f) {
      var t = f.data, e = t.messageId, n = Fr[e];
      if (!n) throw new Error("WorkerModule response with empty or unknown messageId");
      delete Fr[e], n(t);
    };
  }
  return r;
}
function Fn(c2, r, h) {
  return new Promise(function(f, t) {
    var e = ++ga;
    Fr[e] = function(n) {
      n.success ? f(n.result) : t(new Error("Error in worker " + r + " call: " + n.error));
    }, ma(c2).postMessage({ messageId: e, action: r, data: h });
  });
}
$i();
function Mr() {
  var c2 = (function(r) {
    function h(G, E, v, x, S, A, k, z) {
      var C2 = 1 - k;
      z.x = C2 * C2 * G + 2 * C2 * k * v + k * k * S, z.y = C2 * C2 * E + 2 * C2 * k * x + k * k * A;
    }
    function f(G, E, v, x, S, A, k, z, C2, P) {
      var H = 1 - C2;
      P.x = H * H * H * G + 3 * H * H * C2 * v + 3 * H * C2 * C2 * S + C2 * C2 * C2 * k, P.y = H * H * H * E + 3 * H * H * C2 * x + 3 * H * C2 * C2 * A + C2 * C2 * C2 * z;
    }
    function t(G, E) {
      for (var v = /([MLQCZ])([^MLQCZ]*)/g, x, S, A, k, z; x = v.exec(G); ) {
        var C2 = x[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(P) {
          return parseFloat(P);
        });
        switch (x[1]) {
          case "M":
            k = S = C2[0], z = A = C2[1];
            break;
          case "L":
            (C2[0] !== k || C2[1] !== z) && E("L", k, z, k = C2[0], z = C2[1]);
            break;
          case "Q": {
            E("Q", k, z, k = C2[2], z = C2[3], C2[0], C2[1]);
            break;
          }
          case "C": {
            E("C", k, z, k = C2[4], z = C2[5], C2[0], C2[1], C2[2], C2[3]);
            break;
          }
          case "Z":
            (k !== S || z !== A) && E("L", k, z, S, A);
            break;
        }
      }
    }
    function e(G, E, v) {
      v === void 0 && (v = 16);
      var x = { x: 0, y: 0 };
      t(G, function(S, A, k, z, C2, P, H, $, X) {
        switch (S) {
          case "L":
            E(A, k, z, C2);
            break;
          case "Q": {
            for (var N = A, pe = k, ue = 1; ue < v; ue++) h(A, k, P, H, z, C2, ue / (v - 1), x), E(N, pe, x.x, x.y), N = x.x, pe = x.y;
            break;
          }
          case "C": {
            for (var Z = A, ee = k, se = 1; se < v; se++) f(A, k, P, H, $, X, z, C2, se / (v - 1), x), E(Z, ee, x.x, x.y), Z = x.x, ee = x.y;
            break;
          }
        }
      });
    }
    var n = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", o = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", a = /* @__PURE__ */ new WeakMap(), i = { premultipliedAlpha: false, preserveDrawingBuffer: true, antialias: false, depth: false };
    function s(G, E) {
      var v = G.getContext ? G.getContext("webgl", i) : G, x = a.get(v);
      if (!x) {
        let H = function(Z) {
          var ee = A[Z];
          if (!ee && (ee = A[Z] = v.getExtension(Z), !ee)) throw new Error(Z + " not supported");
          return ee;
        }, $ = function(Z, ee) {
          var se = v.createShader(ee);
          return v.shaderSource(se, Z), v.compileShader(se), se;
        }, X = function(Z, ee, se, j) {
          if (!k[Z]) {
            var te = {}, q = {}, L = v.createProgram();
            v.attachShader(L, $(ee, v.VERTEX_SHADER)), v.attachShader(L, $(se, v.FRAGMENT_SHADER)), v.linkProgram(L), k[Z] = { program: L, transaction: function(K) {
              v.useProgram(L), K({ setUniform: function(Y, be) {
                for (var re = [], ae = arguments.length - 2; ae-- > 0; ) re[ae] = arguments[ae + 2];
                var fe = q[be] || (q[be] = v.getUniformLocation(L, be));
                v["uniform" + Y].apply(v, [fe].concat(re));
              }, setAttribute: function(Y, be, re, ae, fe) {
                var de = te[Y];
                de || (de = te[Y] = { buf: v.createBuffer(), loc: v.getAttribLocation(L, Y), data: null }), v.bindBuffer(v.ARRAY_BUFFER, de.buf), v.vertexAttribPointer(de.loc, be, v.FLOAT, false, 0, 0), v.enableVertexAttribArray(de.loc), S ? v.vertexAttribDivisor(de.loc, ae) : H("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(de.loc, ae), fe !== de.data && (v.bufferData(v.ARRAY_BUFFER, fe, re), de.data = fe);
              } });
            } };
          }
          k[Z].transaction(j);
        }, N = function(Z, ee) {
          C2++;
          try {
            v.activeTexture(v.TEXTURE0 + C2);
            var se = z[Z];
            se || (se = z[Z] = v.createTexture(), v.bindTexture(v.TEXTURE_2D, se), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_MIN_FILTER, v.NEAREST), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_MAG_FILTER, v.NEAREST)), v.bindTexture(v.TEXTURE_2D, se), ee(se, C2);
          } finally {
            C2--;
          }
        }, pe = function(Z, ee, se) {
          var j = v.createFramebuffer();
          P.push(j), v.bindFramebuffer(v.FRAMEBUFFER, j), v.activeTexture(v.TEXTURE0 + ee), v.bindTexture(v.TEXTURE_2D, Z), v.framebufferTexture2D(v.FRAMEBUFFER, v.COLOR_ATTACHMENT0, v.TEXTURE_2D, Z, 0);
          try {
            se(j);
          } finally {
            v.deleteFramebuffer(j), v.bindFramebuffer(v.FRAMEBUFFER, P[--P.length - 1] || null);
          }
        }, ue = function() {
          A = {}, k = {}, z = {}, C2 = -1, P.length = 0;
        };
        var S = typeof WebGL2RenderingContext < "u" && v instanceof WebGL2RenderingContext, A = {}, k = {}, z = {}, C2 = -1, P = [];
        v.canvas.addEventListener("webglcontextlost", function(Z) {
          ue(), Z.preventDefault();
        }, false), a.set(v, x = { gl: v, isWebGL2: S, getExtension: H, withProgram: X, withTexture: N, withTextureFramebuffer: pe, handleContextLoss: ue });
      }
      E(x);
    }
    function l(G, E, v, x, S, A, k, z) {
      k === void 0 && (k = 15), z === void 0 && (z = null), s(G, function(C2) {
        var P = C2.gl, H = C2.withProgram, $ = C2.withTexture;
        $("copy", function(X, N) {
          P.texImage2D(P.TEXTURE_2D, 0, P.RGBA, S, A, 0, P.RGBA, P.UNSIGNED_BYTE, E), H("copy", n, o, function(pe) {
            var ue = pe.setUniform, Z = pe.setAttribute;
            Z("aUV", 2, P.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), ue("1i", "image", N), P.bindFramebuffer(P.FRAMEBUFFER, z || null), P.disable(P.BLEND), P.colorMask(k & 8, k & 4, k & 2, k & 1), P.viewport(v, x, S, A), P.scissor(v, x, S, A), P.drawArrays(P.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function u(G, E, v) {
      var x = G.width, S = G.height;
      s(G, function(A) {
        var k = A.gl, z = new Uint8Array(x * S * 4);
        k.readPixels(0, 0, x, S, k.RGBA, k.UNSIGNED_BYTE, z), G.width = E, G.height = v, l(k, z, 0, 0, x, S);
      });
    }
    var d = Object.freeze({ __proto__: null, withWebGLContext: s, renderImageData: l, resizeWebGLCanvasWithoutClearing: u });
    function p(G, E, v, x, S, A) {
      A === void 0 && (A = 1);
      var k = new Uint8Array(G * E), z = x[2] - x[0], C2 = x[3] - x[1], P = [];
      e(v, function(Z, ee, se, j) {
        P.push({ x1: Z, y1: ee, x2: se, y2: j, minX: Math.min(Z, se), minY: Math.min(ee, j), maxX: Math.max(Z, se), maxY: Math.max(ee, j) });
      }), P.sort(function(Z, ee) {
        return Z.maxX - ee.maxX;
      });
      for (var H = 0; H < G; H++) for (var $ = 0; $ < E; $++) {
        var X = pe(x[0] + z * (H + 0.5) / G, x[1] + C2 * ($ + 0.5) / E), N = Math.pow(1 - Math.abs(X) / S, A) / 2;
        X < 0 && (N = 1 - N), N = Math.max(0, Math.min(255, Math.round(N * 255))), k[$ * G + H] = N;
      }
      return k;
      function pe(Z, ee) {
        for (var se = 1 / 0, j = 1 / 0, te = P.length; te--; ) {
          var q = P[te];
          if (q.maxX + j <= Z) break;
          if (Z + j > q.minX && ee - j < q.maxY && ee + j > q.minY) {
            var L = B(Z, ee, q.x1, q.y1, q.x2, q.y2);
            L < se && (se = L, j = Math.sqrt(se));
          }
        }
        return ue(Z, ee) && (j = -j), j;
      }
      function ue(Z, ee) {
        for (var se = 0, j = P.length; j--; ) {
          var te = P[j];
          if (te.maxX <= Z) break;
          var q = te.y1 > ee != te.y2 > ee && Z < (te.x2 - te.x1) * (ee - te.y1) / (te.y2 - te.y1) + te.x1;
          q && (se += te.y1 < te.y2 ? 1 : -1);
        }
        return se !== 0;
      }
    }
    function g(G, E, v, x, S, A, k, z, C2, P) {
      A === void 0 && (A = 1), z === void 0 && (z = 0), C2 === void 0 && (C2 = 0), P === void 0 && (P = 0), m(G, E, v, x, S, A, k, null, z, C2, P);
    }
    function m(G, E, v, x, S, A, k, z, C2, P, H) {
      A === void 0 && (A = 1), C2 === void 0 && (C2 = 0), P === void 0 && (P = 0), H === void 0 && (H = 0);
      for (var $ = p(G, E, v, x, S, A), X = new Uint8Array($.length * 4), N = 0; N < $.length; N++) X[N * 4 + H] = $[N];
      l(k, X, C2, P, G, E, 1 << 3 - H, z);
    }
    function B(G, E, v, x, S, A) {
      var k = S - v, z = A - x, C2 = k * k + z * z, P = C2 ? Math.max(0, Math.min(1, ((G - v) * k + (E - x) * z) / C2)) : 0, H = G - (v + P * k), $ = E - (x + P * z);
      return H * H + $ * $;
    }
    var U = Object.freeze({ __proto__: null, generate: p, generateIntoCanvas: g, generateIntoFramebuffer: m }), _ = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", T = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", w = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", D = new Float32Array([0, 0, 2, 0, 0, 2]), b = null, M = false, W = {}, O = /* @__PURE__ */ new WeakMap();
    function J(G) {
      if (!M && !V(G)) throw new Error("WebGL generation not supported");
    }
    function y(G, E, v, x, S, A, k) {
      if (A === void 0 && (A = 1), k === void 0 && (k = null), !k && (k = b, !k)) {
        var z = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
        if (!z) throw new Error("OffscreenCanvas or DOM canvas not supported");
        k = b = z.getContext("webgl", { depth: false });
      }
      J(k);
      var C2 = new Uint8Array(G * E * 4);
      s(k, function(X) {
        var N = X.gl, pe = X.withTexture, ue = X.withTextureFramebuffer;
        pe("readable", function(Z, ee) {
          N.texImage2D(N.TEXTURE_2D, 0, N.RGBA, G, E, 0, N.RGBA, N.UNSIGNED_BYTE, null), ue(Z, ee, function(se) {
            F(G, E, v, x, S, A, N, se, 0, 0, 0), N.readPixels(0, 0, G, E, N.RGBA, N.UNSIGNED_BYTE, C2);
          });
        });
      });
      for (var P = new Uint8Array(G * E), H = 0, $ = 0; H < C2.length; H += 4) P[$++] = C2[H];
      return P;
    }
    function R(G, E, v, x, S, A, k, z, C2, P) {
      A === void 0 && (A = 1), z === void 0 && (z = 0), C2 === void 0 && (C2 = 0), P === void 0 && (P = 0), F(G, E, v, x, S, A, k, null, z, C2, P);
    }
    function F(G, E, v, x, S, A, k, z, C2, P, H) {
      A === void 0 && (A = 1), C2 === void 0 && (C2 = 0), P === void 0 && (P = 0), H === void 0 && (H = 0), J(k);
      var $ = [];
      e(v, function(X, N, pe, ue) {
        $.push(X, N, pe, ue);
      }), $ = new Float32Array($), s(k, function(X) {
        var N = X.gl, pe = X.isWebGL2, ue = X.getExtension, Z = X.withProgram, ee = X.withTexture, se = X.withTextureFramebuffer, j = X.handleContextLoss;
        if (ee("rawDistances", function(te, q) {
          (G !== te._lastWidth || E !== te._lastHeight) && N.texImage2D(N.TEXTURE_2D, 0, N.RGBA, te._lastWidth = G, te._lastHeight = E, 0, N.RGBA, N.UNSIGNED_BYTE, null), Z("main", _, T, function(L) {
            var he = L.setAttribute, K = L.setUniform, ne = !pe && ue("ANGLE_instanced_arrays"), Y = !pe && ue("EXT_blend_minmax");
            he("aUV", 2, N.STATIC_DRAW, 0, D), he("aLineSegment", 4, N.DYNAMIC_DRAW, 1, $), K.apply(void 0, ["4f", "uGlyphBounds"].concat(x)), K("1f", "uMaxDistance", S), K("1f", "uExponent", A), se(te, q, function(be) {
              N.enable(N.BLEND), N.colorMask(true, true, true, true), N.viewport(0, 0, G, E), N.scissor(0, 0, G, E), N.blendFunc(N.ONE, N.ONE), N.blendEquationSeparate(N.FUNC_ADD, pe ? N.MAX : Y.MAX_EXT), N.clear(N.COLOR_BUFFER_BIT), pe ? N.drawArraysInstanced(N.TRIANGLES, 0, 3, $.length / 4) : ne.drawArraysInstancedANGLE(N.TRIANGLES, 0, 3, $.length / 4);
            });
          }), Z("post", n, w, function(L) {
            L.setAttribute("aUV", 2, N.STATIC_DRAW, 0, D), L.setUniform("1i", "tex", q), N.bindFramebuffer(N.FRAMEBUFFER, z), N.disable(N.BLEND), N.colorMask(H === 0, H === 1, H === 2, H === 3), N.viewport(C2, P, G, E), N.scissor(C2, P, G, E), N.drawArrays(N.TRIANGLES, 0, 3);
          });
        }), N.isContextLost()) throw j(), new Error("webgl context lost");
      });
    }
    function V(G) {
      var E = !G || G === b ? W : G.canvas || G, v = O.get(E);
      if (v === void 0) {
        M = true;
        var x = null;
        try {
          var S = [97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106, 97], A = y(4, 4, "M8,8L16,8L24,24L16,24Z", [0, 0, 32, 32], 24, 1, G);
          v = A && S.length === A.length && A.every(function(k, z) {
            return k === S[z];
          }), v || (x = "bad trial run results", console.info(S, A));
        } catch (k) {
          v = false, x = k.message;
        }
        x && console.warn("WebGL SDF generation not supported:", x), M = false, O.set(E, v);
      }
      return v;
    }
    var I = Object.freeze({ __proto__: null, generate: y, generateIntoCanvas: R, generateIntoFramebuffer: F, isSupported: V });
    function Q(G, E, v, x, S, A) {
      S === void 0 && (S = Math.max(x[2] - x[0], x[3] - x[1]) / 2), A === void 0 && (A = 1);
      try {
        return y.apply(I, arguments);
      } catch (k) {
        return console.info("WebGL SDF generation failed, falling back to JS", k), p.apply(U, arguments);
      }
    }
    function ie(G, E, v, x, S, A, k, z, C2, P) {
      S === void 0 && (S = Math.max(x[2] - x[0], x[3] - x[1]) / 2), A === void 0 && (A = 1), z === void 0 && (z = 0), C2 === void 0 && (C2 = 0), P === void 0 && (P = 0);
      try {
        return R.apply(I, arguments);
      } catch (H) {
        return console.info("WebGL SDF generation failed, falling back to JS", H), g.apply(U, arguments);
      }
    }
    return r.forEachPathCommand = t, r.generate = Q, r.generateIntoCanvas = ie, r.javascript = U, r.pathToLineSegments = e, r.webgl = I, r.webglUtils = d, Object.defineProperty(r, "__esModule", { value: true }), r;
  })({});
  return c2;
}
$i();
function ya() {
  var c2 = (function(r) {
    var h = { R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73", EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9", ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2", ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj", AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u", CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b", B: "a,3,f+2,2v,690", S: "9,2,k", WS: "c,k,4f4,1vk+a,u,1j,335", ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i", BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1", NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n", AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d", LRO: "6ct", RLO: "6cu", LRE: "6cq", RLE: "6cr", PDF: "6cs", LRI: "6ee", RLI: "6ef", FSI: "6eg", PDI: "6eh" }, f = {}, t = {};
    f.L = 1, t[1] = "L", Object.keys(h).forEach(function(j, te) {
      f[j] = 1 << te + 1, t[f[j]] = j;
    }), Object.freeze(f);
    var e = f.LRI | f.RLI | f.FSI, n = f.L | f.R | f.AL, o = f.B | f.S | f.WS | f.ON | f.FSI | f.LRI | f.RLI | f.PDI, a = f.BN | f.RLE | f.LRE | f.RLO | f.LRO | f.PDF, i = f.S | f.WS | f.B | e | f.PDI | a, s = null;
    function l() {
      if (!s) {
        s = /* @__PURE__ */ new Map();
        var j = function(q) {
          if (h.hasOwnProperty(q)) {
            var L = 0;
            h[q].split(",").forEach(function(he) {
              var K = he.split("+"), ne = K[0], Y = K[1];
              ne = parseInt(ne, 36), Y = Y ? parseInt(Y, 36) : 0, s.set(L += ne, f[q]);
              for (var be = 0; be < Y; be++) s.set(++L, f[q]);
            });
          }
        };
        for (var te in h) j(te);
      }
    }
    function u(j) {
      return l(), s.get(j.codePointAt(0)) || f.L;
    }
    function d(j) {
      return t[u(j)];
    }
    var p = { pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1", canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye" };
    function g(j, te) {
      var q = 36, L = 0, he = /* @__PURE__ */ new Map(), K = te && /* @__PURE__ */ new Map(), ne;
      return j.split(",").forEach(function Y(be) {
        if (be.indexOf("+") !== -1) for (var re = +be; re--; ) Y(ne);
        else {
          ne = be;
          var ae = be.split(">"), fe = ae[0], de = ae[1];
          fe = String.fromCodePoint(L += parseInt(fe, q)), de = String.fromCodePoint(L += parseInt(de, q)), he.set(fe, de), te && K.set(de, fe);
        }
      }), { map: he, reverseMap: K };
    }
    var m, B, U;
    function _() {
      if (!m) {
        var j = g(p.pairs, true), te = j.map, q = j.reverseMap;
        m = te, B = q, U = g(p.canonical, false).map;
      }
    }
    function T(j) {
      return _(), m.get(j) || null;
    }
    function w(j) {
      return _(), B.get(j) || null;
    }
    function D(j) {
      return _(), U.get(j) || null;
    }
    var b = f.L, M = f.R, W = f.EN, O = f.ES, J = f.ET, y = f.AN, R = f.CS, F = f.B, V = f.S, I = f.ON, Q = f.BN, ie = f.NSM, G = f.AL, E = f.LRO, v = f.RLO, x = f.LRE, S = f.RLE, A = f.PDF, k = f.LRI, z = f.RLI, C2 = f.FSI, P = f.PDI;
    function H(j, te) {
      for (var q = 125, L = new Uint32Array(j.length), he = 0; he < j.length; he++) L[he] = u(j[he]);
      var K = /* @__PURE__ */ new Map();
      function ne(Ge, Ve) {
        var Pe2 = L[Ge];
        L[Ge] = Ve, K.set(Pe2, K.get(Pe2) - 1), Pe2 & o && K.set(o, K.get(o) - 1), K.set(Ve, (K.get(Ve) || 0) + 1), Ve & o && K.set(o, (K.get(o) || 0) + 1);
      }
      for (var Y = new Uint8Array(j.length), be = /* @__PURE__ */ new Map(), re = [], ae = null, fe = 0; fe < j.length; fe++) ae || re.push(ae = { start: fe, end: j.length - 1, level: te === "rtl" ? 1 : te === "ltr" ? 0 : fn(fe, false) }), L[fe] & F && (ae.end = fe, ae = null);
      for (var de = S | x | v | E | e | P | A | F, ke = function(Ge) {
        return Ge + (Ge & 1 ? 1 : 2);
      }, Ae2 = function(Ge) {
        return Ge + (Ge & 1 ? 2 : 1);
      }, ge = 0; ge < re.length; ge++) {
        ae = re[ge];
        var me = [{ _level: ae.level, _override: 0, _isolate: 0 }], le = void 0, Ue = 0, Se = 0, Le = 0;
        K.clear();
        for (var _e = ae.start; _e <= ae.end; _e++) {
          var ce = L[_e];
          if (le = me[me.length - 1], K.set(ce, (K.get(ce) || 0) + 1), ce & o && K.set(o, (K.get(o) || 0) + 1), ce & de) if (ce & (S | x)) {
            Y[_e] = le._level;
            var xe = (ce === S ? Ae2 : ke)(le._level);
            xe <= q && !Ue && !Se ? me.push({ _level: xe, _override: 0, _isolate: 0 }) : Ue || Se++;
          } else if (ce & (v | E)) {
            Y[_e] = le._level;
            var Qe = (ce === v ? Ae2 : ke)(le._level);
            Qe <= q && !Ue && !Se ? me.push({ _level: Qe, _override: ce & v ? M : b, _isolate: 0 }) : Ue || Se++;
          } else if (ce & e) {
            ce & C2 && (ce = fn(_e + 1, true) === 1 ? z : k), Y[_e] = le._level, le._override && ne(_e, le._override);
            var Te2 = (ce === z ? Ae2 : ke)(le._level);
            Te2 <= q && Ue === 0 && Se === 0 ? (Le++, me.push({ _level: Te2, _override: 0, _isolate: 1, _isolInitIndex: _e })) : Ue++;
          } else if (ce & P) {
            if (Ue > 0) Ue--;
            else if (Le > 0) {
              for (Se = 0; !me[me.length - 1]._isolate; ) me.pop();
              var ye = me[me.length - 1]._isolInitIndex;
              ye != null && (be.set(ye, _e), be.set(_e, ye)), me.pop(), Le--;
            }
            le = me[me.length - 1], Y[_e] = le._level, le._override && ne(_e, le._override);
          } else ce & A ? (Ue === 0 && (Se > 0 ? Se-- : !le._isolate && me.length > 1 && (me.pop(), le = me[me.length - 1])), Y[_e] = le._level) : ce & F && (Y[_e] = ae.level);
          else Y[_e] = le._level, le._override && ce !== Q && ne(_e, le._override);
        }
        for (var De = [], we = null, ve2 = ae.start; ve2 <= ae.end; ve2++) {
          var Fe2 = L[ve2];
          if (!(Fe2 & a)) {
            var Oe = Y[ve2], Be = Fe2 & e, Ce = Fe2 === P;
            we && Oe === we._level ? (we._end = ve2, we._endsWithIsolInit = Be) : De.push(we = { _start: ve2, _end: ve2, _level: Oe, _startsWithPDI: Ce, _endsWithIsolInit: Be });
          }
        }
        for (var We = [], qe = 0; qe < De.length; qe++) {
          var Ye = De[qe];
          if (!Ye._startsWithPDI || Ye._startsWithPDI && !be.has(Ye._start)) {
            for (var $e = [we = Ye], nt = void 0; we && we._endsWithIsolInit && (nt = be.get(we._end)) != null; ) for (var Je = qe + 1; Je < De.length; Je++) if (De[Je]._start === nt) {
              $e.push(we = De[Je]);
              break;
            }
            for (var Re = [], at2 = 0; at2 < $e.length; at2++) for (var Nr = $e[at2], tr = Nr._start; tr <= Nr._end; tr++) Re.push(tr);
            for (var sa = Y[Re[0]], Vr = ae.level, Ot2 = Re[0] - 1; Ot2 >= 0; Ot2--) if (!(L[Ot2] & a)) {
              Vr = Y[Ot2];
              break;
            }
            var rr = Re[Re.length - 1], la = Y[rr], jr = ae.level;
            if (!(L[rr] & e)) {
              for (var Rt = rr + 1; Rt <= ae.end; Rt++) if (!(L[Rt] & a)) {
                jr = Y[Rt];
                break;
              }
            }
            We.push({ _seqIndices: Re, _sosType: Math.max(Vr, sa) % 2 ? M : b, _eosType: Math.max(jr, la) % 2 ? M : b });
          }
        }
        for (var nr = 0; nr < We.length; nr++) {
          var ar = We[nr], oe = ar._seqIndices, mt = ar._sosType, fa = ar._eosType, ft = Y[oe[0]] & 1 ? M : b;
          if (K.get(ie)) for (var Lt = 0; Lt < oe.length; Lt++) {
            var Xr = oe[Lt];
            if (L[Xr] & ie) {
              for (var or = mt, Gt = Lt - 1; Gt >= 0; Gt--) if (!(L[oe[Gt]] & a)) {
                or = L[oe[Gt]];
                break;
              }
              ne(Xr, or & (e | P) ? I : or);
            }
          }
          if (K.get(W)) for (var Pt = 0; Pt < oe.length; Pt++) {
            var Hr = oe[Pt];
            if (L[Hr] & W) for (var It = Pt - 1; It >= -1; It--) {
              var Yr = It === -1 ? mt : L[oe[It]];
              if (Yr & n) {
                Yr === G && ne(Hr, y);
                break;
              }
            }
          }
          if (K.get(G)) for (var ir = 0; ir < oe.length; ir++) {
            var Jr = oe[ir];
            L[Jr] & G && ne(Jr, M);
          }
          if (K.get(O) || K.get(R)) for (var yt = 1; yt < oe.length - 1; yt++) {
            var sr = oe[yt];
            if (L[sr] & (O | R)) {
              for (var ut = 0, lr = 0, fr = yt - 1; fr >= 0 && (ut = L[oe[fr]], !!(ut & a)); fr--) ;
              for (var ur = yt + 1; ur < oe.length && (lr = L[oe[ur]], !!(lr & a)); ur++) ;
              ut === lr && (L[sr] === O ? ut === W : ut & (W | y)) && ne(sr, ut);
            }
          }
          if (K.get(W)) for (var je = 0; je < oe.length; je++) {
            var ua = oe[je];
            if (L[ua] & W) {
              for (var zt = je - 1; zt >= 0 && L[oe[zt]] & (J | a); zt--) ne(oe[zt], W);
              for (je++; je < oe.length && L[oe[je]] & (J | a | W); je++) L[oe[je]] !== W && ne(oe[je], W);
            }
          }
          if (K.get(J) || K.get(O) || K.get(R)) for (var bt = 0; bt < oe.length; bt++) {
            var Kr2 = oe[bt];
            if (L[Kr2] & (J | O | R)) {
              ne(Kr2, I);
              for (var Wt = bt - 1; Wt >= 0 && L[oe[Wt]] & a; Wt--) ne(oe[Wt], I);
              for (var Nt2 = bt + 1; Nt2 < oe.length && L[oe[Nt2]] & a; Nt2++) ne(oe[Nt2], I);
            }
          }
          if (K.get(W)) for (var cr = 0, Zr = mt; cr < oe.length; cr++) {
            var Qr = oe[cr], hr = L[Qr];
            hr & W ? Zr === b && ne(Qr, b) : hr & n && (Zr = hr);
          }
          if (K.get(o)) {
            var xt = M | W | y, qr = xt | b, Vt2 = [];
            {
              for (var ct = [], ht = 0; ht < oe.length; ht++) if (L[oe[ht]] & o) {
                var Tt = j[oe[ht]], $r2 = void 0;
                if (T(Tt) !== null) if (ct.length < 63) ct.push({ char: Tt, seqIndex: ht });
                else break;
                else if (($r2 = w(Tt)) !== null) for (var kt2 = ct.length - 1; kt2 >= 0; kt2--) {
                  var dr = ct[kt2].char;
                  if (dr === $r2 || dr === w(D(Tt)) || T(D(dr)) === Tt) {
                    Vt2.push([ct[kt2].seqIndex, ht]), ct.length = kt2;
                    break;
                  }
                }
              }
              Vt2.sort(function(Ge, Ve) {
                return Ge[0] - Ve[0];
              });
            }
            for (var vr = 0; vr < Vt2.length; vr++) {
              for (var en = Vt2[vr], jt = en[0], pr = en[1], tn2 = false, Ne = 0, gr = jt + 1; gr < pr; gr++) {
                var rn = oe[gr];
                if (L[rn] & qr) {
                  tn2 = true;
                  var nn = L[rn] & xt ? M : b;
                  if (nn === ft) {
                    Ne = nn;
                    break;
                  }
                }
              }
              if (tn2 && !Ne) {
                Ne = mt;
                for (var mr = jt - 1; mr >= 0; mr--) {
                  var an = oe[mr];
                  if (L[an] & qr) {
                    var on = L[an] & xt ? M : b;
                    on !== ft ? Ne = on : Ne = ft;
                    break;
                  }
                }
              }
              if (Ne) {
                if (L[oe[jt]] = L[oe[pr]] = Ne, Ne !== ft) {
                  for (var _t = jt + 1; _t < oe.length; _t++) if (!(L[oe[_t]] & a)) {
                    u(j[oe[_t]]) & ie && (L[oe[_t]] = Ne);
                    break;
                  }
                }
                if (Ne !== ft) {
                  for (var Ut = pr + 1; Ut < oe.length; Ut++) if (!(L[oe[Ut]] & a)) {
                    u(j[oe[Ut]]) & ie && (L[oe[Ut]] = Ne);
                    break;
                  }
                }
              }
            }
            for (var et = 0; et < oe.length; et++) if (L[oe[et]] & o) {
              for (var sn = et, yr = et, br = mt, St = et - 1; St >= 0; St--) if (L[oe[St]] & a) sn = St;
              else {
                br = L[oe[St]] & xt ? M : b;
                break;
              }
              for (var ln2 = fa, wt = et + 1; wt < oe.length; wt++) if (L[oe[wt]] & (o | a)) yr = wt;
              else {
                ln2 = L[oe[wt]] & xt ? M : b;
                break;
              }
              for (var xr = sn; xr <= yr; xr++) L[oe[xr]] = br === ln2 ? br : ft;
              et = yr;
            }
          }
        }
        for (var ze = ae.start; ze <= ae.end; ze++) {
          var ca = Y[ze], Xt = L[ze];
          if (ca & 1 ? Xt & (b | W | y) && Y[ze]++ : Xt & M ? Y[ze]++ : Xt & (y | W) && (Y[ze] += 2), Xt & a && (Y[ze] = ze === 0 ? ae.level : Y[ze - 1]), ze === ae.end || u(j[ze]) & (V | F)) for (var Ht = ze; Ht >= 0 && u(j[Ht]) & i; Ht--) Y[Ht] = ae.level;
        }
      }
      return { levels: Y, paragraphs: re };
      function fn(Ge, Ve) {
        for (var Pe2 = Ge; Pe2 < j.length; Pe2++) {
          var tt = L[Pe2];
          if (tt & (M | G)) return 1;
          if (tt & (F | b) || Ve && tt === P) return 0;
          if (tt & e) {
            var un = ha(Pe2);
            Pe2 = un === -1 ? j.length : un;
          }
        }
        return 0;
      }
      function ha(Ge) {
        for (var Ve = 1, Pe2 = Ge + 1; Pe2 < j.length; Pe2++) {
          var tt = L[Pe2];
          if (tt & F) break;
          if (tt & P) {
            if (--Ve === 0) return Pe2;
          } else tt & e && Ve++;
        }
        return -1;
      }
    }
    var $ = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", X;
    function N() {
      if (!X) {
        var j = g($, true), te = j.map, q = j.reverseMap;
        q.forEach(function(L, he) {
          te.set(he, L);
        }), X = te;
      }
    }
    function pe(j) {
      return N(), X.get(j) || null;
    }
    function ue(j, te, q, L) {
      var he = j.length;
      q = Math.max(0, q == null ? 0 : +q), L = Math.min(he - 1, L == null ? he - 1 : +L);
      for (var K = /* @__PURE__ */ new Map(), ne = q; ne <= L; ne++) if (te[ne] & 1) {
        var Y = pe(j[ne]);
        Y !== null && K.set(ne, Y);
      }
      return K;
    }
    function Z(j, te, q, L) {
      var he = j.length;
      q = Math.max(0, q == null ? 0 : +q), L = Math.min(he - 1, L == null ? he - 1 : +L);
      var K = [];
      return te.paragraphs.forEach(function(ne) {
        var Y = Math.max(q, ne.start), be = Math.min(L, ne.end);
        if (Y < be) {
          for (var re = te.levels.slice(Y, be + 1), ae = be; ae >= Y && u(j[ae]) & i; ae--) re[ae] = ne.level;
          for (var fe = ne.level, de = 1 / 0, ke = 0; ke < re.length; ke++) {
            var Ae2 = re[ke];
            Ae2 > fe && (fe = Ae2), Ae2 < de && (de = Ae2 | 1);
          }
          for (var ge = fe; ge >= de; ge--) for (var me = 0; me < re.length; me++) if (re[me] >= ge) {
            for (var le = me; me + 1 < re.length && re[me + 1] >= ge; ) me++;
            me > le && K.push([le + Y, me + Y]);
          }
        }
      }), K;
    }
    function ee(j, te, q, L) {
      var he = se(j, te, q, L), K = [].concat(j);
      return he.forEach(function(ne, Y) {
        K[Y] = (te.levels[ne] & 1 ? pe(j[ne]) : null) || j[ne];
      }), K.join("");
    }
    function se(j, te, q, L) {
      for (var he = Z(j, te, q, L), K = [], ne = 0; ne < j.length; ne++) K[ne] = ne;
      return he.forEach(function(Y) {
        for (var be = Y[0], re = Y[1], ae = K.slice(be, re + 1), fe = ae.length; fe--; ) K[re - fe] = ae[fe];
      }), K;
    }
    return r.closingToOpeningBracket = w, r.getBidiCharType = u, r.getBidiCharTypeName = d, r.getCanonicalBracket = D, r.getEmbeddingLevels = H, r.getMirroredCharacter = pe, r.getMirroredCharactersMap = ue, r.getReorderSegments = Z, r.getReorderedIndices = se, r.getReorderedString = ee, r.openingToClosingBracket = T, Object.defineProperty(r, "__esModule", { value: true }), r;
  })({});
  return c2;
}
var Dn = ya;
$i();
var Dr = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function Ar(c2) {
  let r = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function h(f, t) {
    let e = Vt[t];
    return e ? Ar(e) : f;
  }
  return c2.replace(r, h);
}
var Ee = [];
for (let c2 = 0; c2 < 256; c2++) Ee[c2] = (c2 < 16 ? "0" : "") + c2.toString(16);
function ba() {
  let c2 = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0, h = Math.random() * 4294967295 | 0, f = Math.random() * 4294967295 | 0;
  return (Ee[c2 & 255] + Ee[c2 >> 8 & 255] + Ee[c2 >> 16 & 255] + Ee[c2 >> 24 & 255] + "-" + Ee[r & 255] + Ee[r >> 8 & 255] + "-" + Ee[r >> 16 & 15 | 64] + Ee[r >> 24 & 255] + "-" + Ee[h & 63 | 128] + Ee[h >> 8 & 255] + "-" + Ee[h >> 16 & 255] + Ee[h >> 24 & 255] + Ee[f & 255] + Ee[f >> 8 & 255] + Ee[f >> 16 & 255] + Ee[f >> 24 & 255]).toUpperCase();
}
var st = Object.assign || function() {
  let c2 = arguments[0];
  for (let r = 1, h = arguments.length; r < h; r++) {
    let f = arguments[r];
    if (f) for (let t in f) Object.prototype.hasOwnProperty.call(f, t) && (c2[t] = f[t]);
  }
  return c2;
};
var xa = Date.now();
var Cn = /* @__PURE__ */ new WeakMap();
var En = /* @__PURE__ */ new Map();
var Ta = 1e10;
function dt(c2, r) {
  let h = Sa(r), f = Cn.get(c2);
  if (f || Cn.set(c2, f = /* @__PURE__ */ Object.create(null)), f[h]) return new f[h]();
  let t = `_onBeforeCompile${h}`, e = function(i, s) {
    c2.onBeforeCompile.call(this, i, s);
    let l = this.customProgramCacheKey() + "|" + i.vertexShader + "|" + i.fragmentShader, u = En[l];
    if (!u) {
      let d = ka(this, i, r, h);
      u = En[l] = d;
    }
    i.vertexShader = u.vertexShader, i.fragmentShader = u.fragmentShader, st(i.uniforms, this.uniforms), r.timeUniform && (i.uniforms[r.timeUniform] = { get value() {
      return Date.now() - xa;
    } }), this[t] && this[t](i);
  }, n = function() {
    return o(r.chained ? c2 : c2.clone());
  }, o = function(i) {
    let s = Object.create(i, a);
    return Object.defineProperty(s, "baseMaterial", { value: c2 }), Object.defineProperty(s, "id", { value: Ta++ }), s.uuid = ba(), s.uniforms = st({}, i.uniforms, r.uniforms), s.defines = st({}, i.defines, r.defines), s.defines[`TROIKA_DERIVED_MATERIAL_${h}`] = "", s.extensions = st({}, i.extensions, r.extensions), s._listeners = void 0, s;
  }, a = { constructor: { value: n }, isDerivedMaterial: { value: true }, type: { get: () => c2.type, set: (i) => {
    c2.type = i;
  } }, isDerivedFrom: { writable: true, configurable: true, value: function(i) {
    let s = this.baseMaterial;
    return i === s || s.isDerivedMaterial && s.isDerivedFrom(i) || false;
  } }, customProgramCacheKey: { writable: true, configurable: true, value: function() {
    return c2.customProgramCacheKey() + "|" + h;
  } }, onBeforeCompile: { get() {
    return e;
  }, set(i) {
    this[t] = i;
  } }, copy: { writable: true, configurable: true, value: function(i) {
    return c2.copy.call(this, i), !c2.isShaderMaterial && !c2.isDerivedMaterial && (st(this.extensions, i.extensions), st(this.defines, i.defines), st(this.uniforms, au.clone(i.uniforms))), this;
  } }, clone: { writable: true, configurable: true, value: function() {
    let i = new c2.constructor();
    return o(i).copy(this);
  } }, getDepthMaterial: { writable: true, configurable: true, value: function() {
    let i = this._depthMaterial;
    return i || (i = this._depthMaterial = dt(c2.isDerivedMaterial ? c2.getDepthMaterial() : new $r({ depthPacking: qh }), r), i.defines.IS_DEPTH_MATERIAL = "", i.uniforms = this.uniforms), i;
  } }, getDistanceMaterial: { writable: true, configurable: true, value: function() {
    let i = this._distanceMaterial;
    return i || (i = this._distanceMaterial = dt(c2.isDerivedMaterial ? c2.getDistanceMaterial() : new Kr(), r), i.defines.IS_DISTANCE_MATERIAL = "", i.uniforms = this.uniforms), i;
  } }, dispose: { writable: true, configurable: true, value() {
    let { _depthMaterial: i, _distanceMaterial: s } = this;
    i && i.dispose(), s && s.dispose(), c2.dispose.call(this);
  } } };
  return f[h] = n, new n();
}
function ka(c2, { vertexShader: r, fragmentShader: h }, f, t) {
  let { vertexDefs: e, vertexMainIntro: n, vertexMainOutro: o, vertexTransform: a, fragmentDefs: i, fragmentMainIntro: s, fragmentMainOutro: l, fragmentColorTransform: u, customRewriter: d, timeUniform: p } = f;
  if (e = e || "", n = n || "", o = o || "", i = i || "", s = s || "", l = l || "", (a || d) && (r = Ar(r)), (u || d) && (h = h.replace(/^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm, `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`), h = Ar(h)), d) {
    let g = d({ vertexShader: r, fragmentShader: h });
    r = g.vertexShader, h = g.fragmentShader;
  }
  if (u) {
    let g = [];
    h = h.replace(/^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm, (m) => (g.push(m), "")), l = `${u}
${g.join(`
`)}
${l}`;
  }
  if (p) {
    let g = `
uniform float ${p};
`;
    e = g + e, i = g + i;
  }
  return a && (r = `vec3 troika_position_${t};
vec3 troika_normal_${t};
vec2 troika_uv_${t};
${r}
`, e = `${e}
void troikaVertexTransform${t}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${a}
}
`, n = `
troika_position_${t} = vec3(position);
troika_normal_${t} = vec3(normal);
troika_uv_${t} = vec2(uv);
troikaVertexTransform${t}(troika_position_${t}, troika_normal_${t}, troika_uv_${t});
${n}
`, r = r.replace(/\b(position|normal|uv)\b/g, (g, m, B, U) => /\battribute\s+vec[23]\s+$/.test(U.substr(0, B)) ? m : `troika_${m}_${t}`), c2.map && c2.map.channel > 0 || (r = r.replace(/\bMAP_UV\b/g, `troika_uv_${t}`))), r = Bn(r, t, e, n, o), h = Bn(h, t, i, s, l), { vertexShader: r, fragmentShader: h };
}
function Bn(c2, r, h, f, t) {
  return (f || t || h) && (c2 = c2.replace(Dr, `
${h}
void troikaOrigMain${r}() {`), c2 += `
void main() {
  ${f}
  troikaOrigMain${r}();
  ${t}
}`), c2;
}
function _a(c2, r) {
  return c2 === "uniforms" ? void 0 : typeof r == "function" ? r.toString() : r;
}
var Ua = 0;
var On2 = /* @__PURE__ */ new Map();
function Sa(c2) {
  let r = JSON.stringify(c2, _a), h = On2.get(r);
  return h == null && On2.set(r, h = ++Ua), h;
}
function wa() {
  return typeof window > "u" && (self.window = self), (function(c2) {
    var r = { parse: function(t) {
      var e = r._bin, n = new Uint8Array(t);
      if (e.readASCII(n, 0, 4) == "ttcf") {
        var o = 4;
        e.readUshort(n, o), o += 2, e.readUshort(n, o), o += 2;
        var a = e.readUint(n, o);
        o += 4;
        for (var i = [], s = 0; s < a; s++) {
          var l = e.readUint(n, o);
          o += 4, i.push(r._readFont(n, l));
        }
        return i;
      }
      return [r._readFont(n, 0)];
    }, _readFont: function(t, e) {
      var n = r._bin, o = e;
      n.readFixed(t, e), e += 4;
      var a = n.readUshort(t, e);
      e += 2, n.readUshort(t, e), e += 2, n.readUshort(t, e), e += 2, n.readUshort(t, e), e += 2;
      for (var i = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], s = { _data: t, _offset: o }, l = {}, u = 0; u < a; u++) {
        var d = n.readASCII(t, e, 4);
        e += 4, n.readUint(t, e), e += 4;
        var p = n.readUint(t, e);
        e += 4;
        var g = n.readUint(t, e);
        e += 4, l[d] = { offset: p, length: g };
      }
      for (u = 0; u < i.length; u++) {
        var m = i[u];
        l[m] && (s[m.trim()] = r[m.trim()].parse(t, l[m].offset, l[m].length, s));
      }
      return s;
    }, _tabOffset: function(t, e, n) {
      for (var o = r._bin, a = o.readUshort(t, n + 4), i = n + 12, s = 0; s < a; s++) {
        var l = o.readASCII(t, i, 4);
        i += 4, o.readUint(t, i), i += 4;
        var u = o.readUint(t, i);
        if (i += 4, o.readUint(t, i), i += 4, l == e) return u;
      }
      return 0;
    } };
    r._bin = { readFixed: function(t, e) {
      return (t[e] << 8 | t[e + 1]) + (t[e + 2] << 8 | t[e + 3]) / 65540;
    }, readF2dot14: function(t, e) {
      return r._bin.readShort(t, e) / 16384;
    }, readInt: function(t, e) {
      return r._bin._view(t).getInt32(e);
    }, readInt8: function(t, e) {
      return r._bin._view(t).getInt8(e);
    }, readShort: function(t, e) {
      return r._bin._view(t).getInt16(e);
    }, readUshort: function(t, e) {
      return r._bin._view(t).getUint16(e);
    }, readUshorts: function(t, e, n) {
      for (var o = [], a = 0; a < n; a++) o.push(r._bin.readUshort(t, e + 2 * a));
      return o;
    }, readUint: function(t, e) {
      return r._bin._view(t).getUint32(e);
    }, readUint64: function(t, e) {
      return 4294967296 * r._bin.readUint(t, e) + r._bin.readUint(t, e + 4);
    }, readASCII: function(t, e, n) {
      for (var o = "", a = 0; a < n; a++) o += String.fromCharCode(t[e + a]);
      return o;
    }, readUnicode: function(t, e, n) {
      for (var o = "", a = 0; a < n; a++) {
        var i = t[e++] << 8 | t[e++];
        o += String.fromCharCode(i);
      }
      return o;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(t, e, n) {
      var o = r._bin._tdec;
      return o && e == 0 && n == t.length ? o.decode(t) : r._bin.readASCII(t, e, n);
    }, readBytes: function(t, e, n) {
      for (var o = [], a = 0; a < n; a++) o.push(t[e + a]);
      return o;
    }, readASCIIArray: function(t, e, n) {
      for (var o = [], a = 0; a < n; a++) o.push(String.fromCharCode(t[e + a]));
      return o;
    }, _view: function(t) {
      return t._dataView || (t._dataView = t.buffer ? new DataView(t.buffer, t.byteOffset, t.byteLength) : new DataView(new Uint8Array(t).buffer));
    } }, r._lctf = {}, r._lctf.parse = function(t, e, n, o, a) {
      var i = r._bin, s = {}, l = e;
      i.readFixed(t, e), e += 4;
      var u = i.readUshort(t, e);
      e += 2;
      var d = i.readUshort(t, e);
      e += 2;
      var p = i.readUshort(t, e);
      return e += 2, s.scriptList = r._lctf.readScriptList(t, l + u), s.featureList = r._lctf.readFeatureList(t, l + d), s.lookupList = r._lctf.readLookupList(t, l + p, a), s;
    }, r._lctf.readLookupList = function(t, e, n) {
      var o = r._bin, a = e, i = [], s = o.readUshort(t, e);
      e += 2;
      for (var l = 0; l < s; l++) {
        var u = o.readUshort(t, e);
        e += 2;
        var d = r._lctf.readLookupTable(t, a + u, n);
        i.push(d);
      }
      return i;
    }, r._lctf.readLookupTable = function(t, e, n) {
      var o = r._bin, a = e, i = { tabs: [] };
      i.ltype = o.readUshort(t, e), e += 2, i.flag = o.readUshort(t, e), e += 2;
      var s = o.readUshort(t, e);
      e += 2;
      for (var l = i.ltype, u = 0; u < s; u++) {
        var d = o.readUshort(t, e);
        e += 2;
        var p = n(t, l, a + d, i);
        i.tabs.push(p);
      }
      return i;
    }, r._lctf.numOfOnes = function(t) {
      for (var e = 0, n = 0; n < 32; n++) (t >>> n & 1) != 0 && e++;
      return e;
    }, r._lctf.readClassDef = function(t, e) {
      var n = r._bin, o = [], a = n.readUshort(t, e);
      if (e += 2, a == 1) {
        var i = n.readUshort(t, e);
        e += 2;
        var s = n.readUshort(t, e);
        e += 2;
        for (var l = 0; l < s; l++) o.push(i + l), o.push(i + l), o.push(n.readUshort(t, e)), e += 2;
      }
      if (a == 2) {
        var u = n.readUshort(t, e);
        for (e += 2, l = 0; l < u; l++) o.push(n.readUshort(t, e)), e += 2, o.push(n.readUshort(t, e)), e += 2, o.push(n.readUshort(t, e)), e += 2;
      }
      return o;
    }, r._lctf.getInterval = function(t, e) {
      for (var n = 0; n < t.length; n += 3) {
        var o = t[n], a = t[n + 1];
        if (t[n + 2], o <= e && e <= a) return n;
      }
      return -1;
    }, r._lctf.readCoverage = function(t, e) {
      var n = r._bin, o = {};
      o.fmt = n.readUshort(t, e), e += 2;
      var a = n.readUshort(t, e);
      return e += 2, o.fmt == 1 && (o.tab = n.readUshorts(t, e, a)), o.fmt == 2 && (o.tab = n.readUshorts(t, e, 3 * a)), o;
    }, r._lctf.coverageIndex = function(t, e) {
      var n = t.tab;
      if (t.fmt == 1) return n.indexOf(e);
      if (t.fmt == 2) {
        var o = r._lctf.getInterval(n, e);
        if (o != -1) return n[o + 2] + (e - n[o]);
      }
      return -1;
    }, r._lctf.readFeatureList = function(t, e) {
      var n = r._bin, o = e, a = [], i = n.readUshort(t, e);
      e += 2;
      for (var s = 0; s < i; s++) {
        var l = n.readASCII(t, e, 4);
        e += 4;
        var u = n.readUshort(t, e);
        e += 2;
        var d = r._lctf.readFeatureTable(t, o + u);
        d.tag = l.trim(), a.push(d);
      }
      return a;
    }, r._lctf.readFeatureTable = function(t, e) {
      var n = r._bin, o = e, a = {}, i = n.readUshort(t, e);
      e += 2, i > 0 && (a.featureParams = o + i);
      var s = n.readUshort(t, e);
      e += 2, a.tab = [];
      for (var l = 0; l < s; l++) a.tab.push(n.readUshort(t, e + 2 * l));
      return a;
    }, r._lctf.readScriptList = function(t, e) {
      var n = r._bin, o = e, a = {}, i = n.readUshort(t, e);
      e += 2;
      for (var s = 0; s < i; s++) {
        var l = n.readASCII(t, e, 4);
        e += 4;
        var u = n.readUshort(t, e);
        e += 2, a[l.trim()] = r._lctf.readScriptTable(t, o + u);
      }
      return a;
    }, r._lctf.readScriptTable = function(t, e) {
      var n = r._bin, o = e, a = {}, i = n.readUshort(t, e);
      e += 2, i > 0 && (a.default = r._lctf.readLangSysTable(t, o + i));
      var s = n.readUshort(t, e);
      e += 2;
      for (var l = 0; l < s; l++) {
        var u = n.readASCII(t, e, 4);
        e += 4;
        var d = n.readUshort(t, e);
        e += 2, a[u.trim()] = r._lctf.readLangSysTable(t, o + d);
      }
      return a;
    }, r._lctf.readLangSysTable = function(t, e) {
      var n = r._bin, o = {};
      n.readUshort(t, e), e += 2, o.reqFeature = n.readUshort(t, e), e += 2;
      var a = n.readUshort(t, e);
      return e += 2, o.features = n.readUshorts(t, e, a), o;
    }, r.CFF = {}, r.CFF.parse = function(t, e, n) {
      var o = r._bin;
      (t = new Uint8Array(t.buffer, e, n))[e = 0], t[++e], t[++e], t[++e], e++;
      var a = [];
      e = r.CFF.readIndex(t, e, a);
      for (var i = [], s = 0; s < a.length - 1; s++) i.push(o.readASCII(t, e + a[s], a[s + 1] - a[s]));
      e += a[a.length - 1];
      var l = [];
      e = r.CFF.readIndex(t, e, l);
      var u = [];
      for (s = 0; s < l.length - 1; s++) u.push(r.CFF.readDict(t, e + l[s], e + l[s + 1]));
      e += l[l.length - 1];
      var d = u[0], p = [];
      e = r.CFF.readIndex(t, e, p);
      var g = [];
      for (s = 0; s < p.length - 1; s++) g.push(o.readASCII(t, e + p[s], p[s + 1] - p[s]));
      if (e += p[p.length - 1], r.CFF.readSubrs(t, e, d), d.CharStrings) {
        e = d.CharStrings, p = [], e = r.CFF.readIndex(t, e, p);
        var m = [];
        for (s = 0; s < p.length - 1; s++) m.push(o.readBytes(t, e + p[s], p[s + 1] - p[s]));
        d.CharStrings = m;
      }
      if (d.ROS) {
        e = d.FDArray;
        var B = [];
        for (e = r.CFF.readIndex(t, e, B), d.FDArray = [], s = 0; s < B.length - 1; s++) {
          var U = r.CFF.readDict(t, e + B[s], e + B[s + 1]);
          r.CFF._readFDict(t, U, g), d.FDArray.push(U);
        }
        e += B[B.length - 1], e = d.FDSelect, d.FDSelect = [];
        var _ = t[e];
        if (e++, _ != 3) throw _;
        var T = o.readUshort(t, e);
        for (e += 2, s = 0; s < T + 1; s++) d.FDSelect.push(o.readUshort(t, e), t[e + 2]), e += 3;
      }
      return d.Encoding && (d.Encoding = r.CFF.readEncoding(t, d.Encoding, d.CharStrings.length)), d.charset && (d.charset = r.CFF.readCharset(t, d.charset, d.CharStrings.length)), r.CFF._readFDict(t, d, g), d;
    }, r.CFF._readFDict = function(t, e, n) {
      var o;
      for (var a in e.Private && (o = e.Private[1], e.Private = r.CFF.readDict(t, o, o + e.Private[0]), e.Private.Subrs && r.CFF.readSubrs(t, o + e.Private.Subrs, e.Private)), e) ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(a) != -1 && (e[a] = n[e[a] - 426 + 35]);
    }, r.CFF.readSubrs = function(t, e, n) {
      var o = r._bin, a = [];
      e = r.CFF.readIndex(t, e, a);
      var i, s = a.length;
      i = s < 1240 ? 107 : s < 33900 ? 1131 : 32768, n.Bias = i, n.Subrs = [];
      for (var l = 0; l < a.length - 1; l++) n.Subrs.push(o.readBytes(t, e + a[l], a[l + 1] - a[l]));
    }, r.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], r.CFF.glyphByUnicode = function(t, e) {
      for (var n = 0; n < t.charset.length; n++) if (t.charset[n] == e) return n;
      return -1;
    }, r.CFF.glyphBySE = function(t, e) {
      return e < 0 || e > 255 ? -1 : r.CFF.glyphByUnicode(t, r.CFF.tableSE[e]);
    }, r.CFF.readEncoding = function(t, e, n) {
      r._bin;
      var o = [".notdef"], a = t[e];
      if (e++, a != 0) throw "error: unknown encoding format: " + a;
      var i = t[e];
      e++;
      for (var s = 0; s < i; s++) o.push(t[e + s]);
      return o;
    }, r.CFF.readCharset = function(t, e, n) {
      var o = r._bin, a = [".notdef"], i = t[e];
      if (e++, i == 0) for (var s = 0; s < n; s++) {
        var l = o.readUshort(t, e);
        e += 2, a.push(l);
      }
      else {
        if (i != 1 && i != 2) throw "error: format: " + i;
        for (; a.length < n; ) {
          l = o.readUshort(t, e), e += 2;
          var u = 0;
          for (i == 1 ? (u = t[e], e++) : (u = o.readUshort(t, e), e += 2), s = 0; s <= u; s++) a.push(l), l++;
        }
      }
      return a;
    }, r.CFF.readIndex = function(t, e, n) {
      var o = r._bin, a = o.readUshort(t, e) + 1, i = t[e += 2];
      if (e++, i == 1) for (var s = 0; s < a; s++) n.push(t[e + s]);
      else if (i == 2) for (s = 0; s < a; s++) n.push(o.readUshort(t, e + 2 * s));
      else if (i == 3) for (s = 0; s < a; s++) n.push(16777215 & o.readUint(t, e + 3 * s - 1));
      else if (a != 1) throw "unsupported offset size: " + i + ", count: " + a;
      return (e += a * i) - 1;
    }, r.CFF.getCharString = function(t, e, n) {
      var o = r._bin, a = t[e], i = t[e + 1];
      t[e + 2], t[e + 3], t[e + 4];
      var s = 1, l = null, u = null;
      a <= 20 && (l = a, s = 1), a == 12 && (l = 100 * a + i, s = 2), 21 <= a && a <= 27 && (l = a, s = 1), a == 28 && (u = o.readShort(t, e + 1), s = 3), 29 <= a && a <= 31 && (l = a, s = 1), 32 <= a && a <= 246 && (u = a - 139, s = 1), 247 <= a && a <= 250 && (u = 256 * (a - 247) + i + 108, s = 2), 251 <= a && a <= 254 && (u = 256 * -(a - 251) - i - 108, s = 2), a == 255 && (u = o.readInt(t, e + 1) / 65535, s = 5), n.val = u ?? "o" + l, n.size = s;
    }, r.CFF.readCharString = function(t, e, n) {
      for (var o = e + n, a = r._bin, i = []; e < o; ) {
        var s = t[e], l = t[e + 1];
        t[e + 2], t[e + 3], t[e + 4];
        var u = 1, d = null, p = null;
        s <= 20 && (d = s, u = 1), s == 12 && (d = 100 * s + l, u = 2), s != 19 && s != 20 || (d = s, u = 2), 21 <= s && s <= 27 && (d = s, u = 1), s == 28 && (p = a.readShort(t, e + 1), u = 3), 29 <= s && s <= 31 && (d = s, u = 1), 32 <= s && s <= 246 && (p = s - 139, u = 1), 247 <= s && s <= 250 && (p = 256 * (s - 247) + l + 108, u = 2), 251 <= s && s <= 254 && (p = 256 * -(s - 251) - l - 108, u = 2), s == 255 && (p = a.readInt(t, e + 1) / 65535, u = 5), i.push(p ?? "o" + d), e += u;
      }
      return i;
    }, r.CFF.readDict = function(t, e, n) {
      for (var o = r._bin, a = {}, i = []; e < n; ) {
        var s = t[e], l = t[e + 1];
        t[e + 2], t[e + 3], t[e + 4];
        var u = 1, d = null, p = null;
        if (s == 28 && (p = o.readShort(t, e + 1), u = 3), s == 29 && (p = o.readInt(t, e + 1), u = 5), 32 <= s && s <= 246 && (p = s - 139, u = 1), 247 <= s && s <= 250 && (p = 256 * (s - 247) + l + 108, u = 2), 251 <= s && s <= 254 && (p = 256 * -(s - 251) - l - 108, u = 2), s == 255) throw p = o.readInt(t, e + 1) / 65535, u = 5, "unknown number";
        if (s == 30) {
          var g = [];
          for (u = 1; ; ) {
            var m = t[e + u];
            u++;
            var B = m >> 4, U = 15 & m;
            if (B != 15 && g.push(B), U != 15 && g.push(U), U == 15) break;
          }
          for (var _ = "", T = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], w = 0; w < g.length; w++) _ += T[g[w]];
          p = parseFloat(_);
        }
        s <= 21 && (d = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][s], u = 1, s == 12 && (d = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][l], u = 2)), d != null ? (a[d] = i.length == 1 ? i[0] : i, i = []) : i.push(p), e += u;
      }
      return a;
    }, r.cmap = {}, r.cmap.parse = function(t, e, n) {
      t = new Uint8Array(t.buffer, e, n), e = 0;
      var o = r._bin, a = {};
      o.readUshort(t, e), e += 2;
      var i = o.readUshort(t, e);
      e += 2;
      var s = [];
      a.tables = [];
      for (var l = 0; l < i; l++) {
        var u = o.readUshort(t, e);
        e += 2;
        var d = o.readUshort(t, e);
        e += 2;
        var p = o.readUint(t, e);
        e += 4;
        var g = "p" + u + "e" + d, m = s.indexOf(p);
        if (m == -1) {
          var B;
          m = a.tables.length, s.push(p);
          var U = o.readUshort(t, p);
          U == 0 ? B = r.cmap.parse0(t, p) : U == 4 ? B = r.cmap.parse4(t, p) : U == 6 ? B = r.cmap.parse6(t, p) : U == 12 ? B = r.cmap.parse12(t, p) : console.debug("unknown format: " + U, u, d, p), a.tables.push(B);
        }
        if (a[g] != null) throw "multiple tables for one platform+encoding";
        a[g] = m;
      }
      return a;
    }, r.cmap.parse0 = function(t, e) {
      var n = r._bin, o = {};
      o.format = n.readUshort(t, e), e += 2;
      var a = n.readUshort(t, e);
      e += 2, n.readUshort(t, e), e += 2, o.map = [];
      for (var i = 0; i < a - 6; i++) o.map.push(t[e + i]);
      return o;
    }, r.cmap.parse4 = function(t, e) {
      var n = r._bin, o = e, a = {};
      a.format = n.readUshort(t, e), e += 2;
      var i = n.readUshort(t, e);
      e += 2, n.readUshort(t, e), e += 2;
      var s = n.readUshort(t, e);
      e += 2;
      var l = s / 2;
      a.searchRange = n.readUshort(t, e), e += 2, a.entrySelector = n.readUshort(t, e), e += 2, a.rangeShift = n.readUshort(t, e), e += 2, a.endCount = n.readUshorts(t, e, l), e += 2 * l, e += 2, a.startCount = n.readUshorts(t, e, l), e += 2 * l, a.idDelta = [];
      for (var u = 0; u < l; u++) a.idDelta.push(n.readShort(t, e)), e += 2;
      for (a.idRangeOffset = n.readUshorts(t, e, l), e += 2 * l, a.glyphIdArray = []; e < o + i; ) a.glyphIdArray.push(n.readUshort(t, e)), e += 2;
      return a;
    }, r.cmap.parse6 = function(t, e) {
      var n = r._bin, o = {};
      o.format = n.readUshort(t, e), e += 2, n.readUshort(t, e), e += 2, n.readUshort(t, e), e += 2, o.firstCode = n.readUshort(t, e), e += 2;
      var a = n.readUshort(t, e);
      e += 2, o.glyphIdArray = [];
      for (var i = 0; i < a; i++) o.glyphIdArray.push(n.readUshort(t, e)), e += 2;
      return o;
    }, r.cmap.parse12 = function(t, e) {
      var n = r._bin, o = {};
      o.format = n.readUshort(t, e), e += 2, e += 2, n.readUint(t, e), e += 4, n.readUint(t, e), e += 4;
      var a = n.readUint(t, e);
      e += 4, o.groups = [];
      for (var i = 0; i < a; i++) {
        var s = e + 12 * i, l = n.readUint(t, s + 0), u = n.readUint(t, s + 4), d = n.readUint(t, s + 8);
        o.groups.push([l, u, d]);
      }
      return o;
    }, r.glyf = {}, r.glyf.parse = function(t, e, n, o) {
      for (var a = [], i = 0; i < o.maxp.numGlyphs; i++) a.push(null);
      return a;
    }, r.glyf._parseGlyf = function(t, e) {
      var n = r._bin, o = t._data, a = r._tabOffset(o, "glyf", t._offset) + t.loca[e];
      if (t.loca[e] == t.loca[e + 1]) return null;
      var i = {};
      if (i.noc = n.readShort(o, a), a += 2, i.xMin = n.readShort(o, a), a += 2, i.yMin = n.readShort(o, a), a += 2, i.xMax = n.readShort(o, a), a += 2, i.yMax = n.readShort(o, a), a += 2, i.xMin >= i.xMax || i.yMin >= i.yMax) return null;
      if (i.noc > 0) {
        i.endPts = [];
        for (var s = 0; s < i.noc; s++) i.endPts.push(n.readUshort(o, a)), a += 2;
        var l = n.readUshort(o, a);
        if (a += 2, o.length - a < l) return null;
        i.instructions = n.readBytes(o, a, l), a += l;
        var u = i.endPts[i.noc - 1] + 1;
        for (i.flags = [], s = 0; s < u; s++) {
          var d = o[a];
          if (a++, i.flags.push(d), (8 & d) != 0) {
            var p = o[a];
            a++;
            for (var g = 0; g < p; g++) i.flags.push(d), s++;
          }
        }
        for (i.xs = [], s = 0; s < u; s++) {
          var m = (2 & i.flags[s]) != 0, B = (16 & i.flags[s]) != 0;
          m ? (i.xs.push(B ? o[a] : -o[a]), a++) : B ? i.xs.push(0) : (i.xs.push(n.readShort(o, a)), a += 2);
        }
        for (i.ys = [], s = 0; s < u; s++) m = (4 & i.flags[s]) != 0, B = (32 & i.flags[s]) != 0, m ? (i.ys.push(B ? o[a] : -o[a]), a++) : B ? i.ys.push(0) : (i.ys.push(n.readShort(o, a)), a += 2);
        var U = 0, _ = 0;
        for (s = 0; s < u; s++) U += i.xs[s], _ += i.ys[s], i.xs[s] = U, i.ys[s] = _;
      } else {
        var T;
        i.parts = [];
        do {
          T = n.readUshort(o, a), a += 2;
          var w = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (i.parts.push(w), w.glyphIndex = n.readUshort(o, a), a += 2, 1 & T) {
            var D = n.readShort(o, a);
            a += 2;
            var b = n.readShort(o, a);
            a += 2;
          } else D = n.readInt8(o, a), a++, b = n.readInt8(o, a), a++;
          2 & T ? (w.m.tx = D, w.m.ty = b) : (w.p1 = D, w.p2 = b), 8 & T ? (w.m.a = w.m.d = n.readF2dot14(o, a), a += 2) : 64 & T ? (w.m.a = n.readF2dot14(o, a), a += 2, w.m.d = n.readF2dot14(o, a), a += 2) : 128 & T && (w.m.a = n.readF2dot14(o, a), a += 2, w.m.b = n.readF2dot14(o, a), a += 2, w.m.c = n.readF2dot14(o, a), a += 2, w.m.d = n.readF2dot14(o, a), a += 2);
        } while (32 & T);
        if (256 & T) {
          var M = n.readUshort(o, a);
          for (a += 2, i.instr = [], s = 0; s < M; s++) i.instr.push(o[a]), a++;
        }
      }
      return i;
    }, r.GDEF = {}, r.GDEF.parse = function(t, e, n, o) {
      var a = e;
      e += 4;
      var i = r._bin.readUshort(t, e);
      return { glyphClassDef: i === 0 ? null : r._lctf.readClassDef(t, a + i) };
    }, r.GPOS = {}, r.GPOS.parse = function(t, e, n, o) {
      return r._lctf.parse(t, e, n, o, r.GPOS.subt);
    }, r.GPOS.subt = function(t, e, n, o) {
      var a = r._bin, i = n, s = {};
      if (s.fmt = a.readUshort(t, n), n += 2, e == 1 || e == 2 || e == 3 || e == 7 || e == 8 && s.fmt <= 2) {
        var l = a.readUshort(t, n);
        n += 2, s.coverage = r._lctf.readCoverage(t, l + i);
      }
      if (e == 1 && s.fmt == 1) {
        var u = a.readUshort(t, n);
        n += 2, u != 0 && (s.pos = r.GPOS.readValueRecord(t, n, u));
      } else if (e == 2 && s.fmt >= 1 && s.fmt <= 2) {
        u = a.readUshort(t, n), n += 2;
        var d = a.readUshort(t, n);
        n += 2;
        var p = r._lctf.numOfOnes(u), g = r._lctf.numOfOnes(d);
        if (s.fmt == 1) {
          s.pairsets = [];
          var m = a.readUshort(t, n);
          n += 2;
          for (var B = 0; B < m; B++) {
            var U = i + a.readUshort(t, n);
            n += 2;
            var _ = a.readUshort(t, U);
            U += 2;
            for (var T = [], w = 0; w < _; w++) {
              var D = a.readUshort(t, U);
              U += 2, u != 0 && (y = r.GPOS.readValueRecord(t, U, u), U += 2 * p), d != 0 && (R = r.GPOS.readValueRecord(t, U, d), U += 2 * g), T.push({ gid2: D, val1: y, val2: R });
            }
            s.pairsets.push(T);
          }
        }
        if (s.fmt == 2) {
          var b = a.readUshort(t, n);
          n += 2;
          var M = a.readUshort(t, n);
          n += 2;
          var W = a.readUshort(t, n);
          n += 2;
          var O = a.readUshort(t, n);
          for (n += 2, s.classDef1 = r._lctf.readClassDef(t, i + b), s.classDef2 = r._lctf.readClassDef(t, i + M), s.matrix = [], B = 0; B < W; B++) {
            var J = [];
            for (w = 0; w < O; w++) {
              var y = null, R = null;
              u != 0 && (y = r.GPOS.readValueRecord(t, n, u), n += 2 * p), d != 0 && (R = r.GPOS.readValueRecord(t, n, d), n += 2 * g), J.push({ val1: y, val2: R });
            }
            s.matrix.push(J);
          }
        }
      } else if (e == 4 && s.fmt == 1) s.markCoverage = r._lctf.readCoverage(t, a.readUshort(t, n) + i), s.baseCoverage = r._lctf.readCoverage(t, a.readUshort(t, n + 2) + i), s.markClassCount = a.readUshort(t, n + 4), s.markArray = r.GPOS.readMarkArray(t, a.readUshort(t, n + 6) + i), s.baseArray = r.GPOS.readBaseArray(t, a.readUshort(t, n + 8) + i, s.markClassCount);
      else if (e == 6 && s.fmt == 1) s.mark1Coverage = r._lctf.readCoverage(t, a.readUshort(t, n) + i), s.mark2Coverage = r._lctf.readCoverage(t, a.readUshort(t, n + 2) + i), s.markClassCount = a.readUshort(t, n + 4), s.mark1Array = r.GPOS.readMarkArray(t, a.readUshort(t, n + 6) + i), s.mark2Array = r.GPOS.readBaseArray(t, a.readUshort(t, n + 8) + i, s.markClassCount);
      else {
        if (e == 9 && s.fmt == 1) {
          var F = a.readUshort(t, n);
          n += 2;
          var V = a.readUint(t, n);
          if (n += 4, o.ltype == 9) o.ltype = F;
          else if (o.ltype != F) throw "invalid extension substitution";
          return r.GPOS.subt(t, o.ltype, i + V);
        }
        console.debug("unsupported GPOS table LookupType", e, "format", s.fmt);
      }
      return s;
    }, r.GPOS.readValueRecord = function(t, e, n) {
      var o = r._bin, a = [];
      return a.push(1 & n ? o.readShort(t, e) : 0), e += 1 & n ? 2 : 0, a.push(2 & n ? o.readShort(t, e) : 0), e += 2 & n ? 2 : 0, a.push(4 & n ? o.readShort(t, e) : 0), e += 4 & n ? 2 : 0, a.push(8 & n ? o.readShort(t, e) : 0), e += 8 & n ? 2 : 0, a;
    }, r.GPOS.readBaseArray = function(t, e, n) {
      var o = r._bin, a = [], i = e, s = o.readUshort(t, e);
      e += 2;
      for (var l = 0; l < s; l++) {
        for (var u = [], d = 0; d < n; d++) u.push(r.GPOS.readAnchorRecord(t, i + o.readUshort(t, e))), e += 2;
        a.push(u);
      }
      return a;
    }, r.GPOS.readMarkArray = function(t, e) {
      var n = r._bin, o = [], a = e, i = n.readUshort(t, e);
      e += 2;
      for (var s = 0; s < i; s++) {
        var l = r.GPOS.readAnchorRecord(t, n.readUshort(t, e + 2) + a);
        l.markClass = n.readUshort(t, e), o.push(l), e += 4;
      }
      return o;
    }, r.GPOS.readAnchorRecord = function(t, e) {
      var n = r._bin, o = {};
      return o.fmt = n.readUshort(t, e), o.x = n.readShort(t, e + 2), o.y = n.readShort(t, e + 4), o;
    }, r.GSUB = {}, r.GSUB.parse = function(t, e, n, o) {
      return r._lctf.parse(t, e, n, o, r.GSUB.subt);
    }, r.GSUB.subt = function(t, e, n, o) {
      var a = r._bin, i = n, s = {};
      if (s.fmt = a.readUshort(t, n), n += 2, e != 1 && e != 2 && e != 4 && e != 5 && e != 6) return null;
      if (e == 1 || e == 2 || e == 4 || e == 5 && s.fmt <= 2 || e == 6 && s.fmt <= 2) {
        var l = a.readUshort(t, n);
        n += 2, s.coverage = r._lctf.readCoverage(t, i + l);
      }
      if (e == 1 && s.fmt >= 1 && s.fmt <= 2) {
        if (s.fmt == 1) s.delta = a.readShort(t, n), n += 2;
        else if (s.fmt == 2) {
          var u = a.readUshort(t, n);
          n += 2, s.newg = a.readUshorts(t, n, u), n += 2 * s.newg.length;
        }
      } else if (e == 2 && s.fmt == 1) {
        u = a.readUshort(t, n), n += 2, s.seqs = [];
        for (var d = 0; d < u; d++) {
          var p = a.readUshort(t, n) + i;
          n += 2;
          var g = a.readUshort(t, p);
          s.seqs.push(a.readUshorts(t, p + 2, g));
        }
      } else if (e == 4) for (s.vals = [], u = a.readUshort(t, n), n += 2, d = 0; d < u; d++) {
        var m = a.readUshort(t, n);
        n += 2, s.vals.push(r.GSUB.readLigatureSet(t, i + m));
      }
      else if (e == 5 && s.fmt == 2) {
        if (s.fmt == 2) {
          var B = a.readUshort(t, n);
          n += 2, s.cDef = r._lctf.readClassDef(t, i + B), s.scset = [];
          var U = a.readUshort(t, n);
          for (n += 2, d = 0; d < U; d++) {
            var _ = a.readUshort(t, n);
            n += 2, s.scset.push(_ == 0 ? null : r.GSUB.readSubClassSet(t, i + _));
          }
        }
      } else if (e == 6 && s.fmt == 3) {
        if (s.fmt == 3) {
          for (d = 0; d < 3; d++) {
            u = a.readUshort(t, n), n += 2;
            for (var T = [], w = 0; w < u; w++) T.push(r._lctf.readCoverage(t, i + a.readUshort(t, n + 2 * w)));
            n += 2 * u, d == 0 && (s.backCvg = T), d == 1 && (s.inptCvg = T), d == 2 && (s.ahedCvg = T);
          }
          u = a.readUshort(t, n), n += 2, s.lookupRec = r.GSUB.readSubstLookupRecords(t, n, u);
        }
      } else {
        if (e == 7 && s.fmt == 1) {
          var D = a.readUshort(t, n);
          n += 2;
          var b = a.readUint(t, n);
          if (n += 4, o.ltype == 9) o.ltype = D;
          else if (o.ltype != D) throw "invalid extension substitution";
          return r.GSUB.subt(t, o.ltype, i + b);
        }
        console.debug("unsupported GSUB table LookupType", e, "format", s.fmt);
      }
      return s;
    }, r.GSUB.readSubClassSet = function(t, e) {
      var n = r._bin.readUshort, o = e, a = [], i = n(t, e);
      e += 2;
      for (var s = 0; s < i; s++) {
        var l = n(t, e);
        e += 2, a.push(r.GSUB.readSubClassRule(t, o + l));
      }
      return a;
    }, r.GSUB.readSubClassRule = function(t, e) {
      var n = r._bin.readUshort, o = {}, a = n(t, e), i = n(t, e += 2);
      e += 2, o.input = [];
      for (var s = 0; s < a - 1; s++) o.input.push(n(t, e)), e += 2;
      return o.substLookupRecords = r.GSUB.readSubstLookupRecords(t, e, i), o;
    }, r.GSUB.readSubstLookupRecords = function(t, e, n) {
      for (var o = r._bin.readUshort, a = [], i = 0; i < n; i++) a.push(o(t, e), o(t, e + 2)), e += 4;
      return a;
    }, r.GSUB.readChainSubClassSet = function(t, e) {
      var n = r._bin, o = e, a = [], i = n.readUshort(t, e);
      e += 2;
      for (var s = 0; s < i; s++) {
        var l = n.readUshort(t, e);
        e += 2, a.push(r.GSUB.readChainSubClassRule(t, o + l));
      }
      return a;
    }, r.GSUB.readChainSubClassRule = function(t, e) {
      for (var n = r._bin, o = {}, a = ["backtrack", "input", "lookahead"], i = 0; i < a.length; i++) {
        var s = n.readUshort(t, e);
        e += 2, i == 1 && s--, o[a[i]] = n.readUshorts(t, e, s), e += 2 * o[a[i]].length;
      }
      return s = n.readUshort(t, e), e += 2, o.subst = n.readUshorts(t, e, 2 * s), e += 2 * o.subst.length, o;
    }, r.GSUB.readLigatureSet = function(t, e) {
      var n = r._bin, o = e, a = [], i = n.readUshort(t, e);
      e += 2;
      for (var s = 0; s < i; s++) {
        var l = n.readUshort(t, e);
        e += 2, a.push(r.GSUB.readLigature(t, o + l));
      }
      return a;
    }, r.GSUB.readLigature = function(t, e) {
      var n = r._bin, o = { chain: [] };
      o.nglyph = n.readUshort(t, e), e += 2;
      var a = n.readUshort(t, e);
      e += 2;
      for (var i = 0; i < a - 1; i++) o.chain.push(n.readUshort(t, e)), e += 2;
      return o;
    }, r.head = {}, r.head.parse = function(t, e, n) {
      var o = r._bin, a = {};
      return o.readFixed(t, e), e += 4, a.fontRevision = o.readFixed(t, e), e += 4, o.readUint(t, e), e += 4, o.readUint(t, e), e += 4, a.flags = o.readUshort(t, e), e += 2, a.unitsPerEm = o.readUshort(t, e), e += 2, a.created = o.readUint64(t, e), e += 8, a.modified = o.readUint64(t, e), e += 8, a.xMin = o.readShort(t, e), e += 2, a.yMin = o.readShort(t, e), e += 2, a.xMax = o.readShort(t, e), e += 2, a.yMax = o.readShort(t, e), e += 2, a.macStyle = o.readUshort(t, e), e += 2, a.lowestRecPPEM = o.readUshort(t, e), e += 2, a.fontDirectionHint = o.readShort(t, e), e += 2, a.indexToLocFormat = o.readShort(t, e), e += 2, a.glyphDataFormat = o.readShort(t, e), e += 2, a;
    }, r.hhea = {}, r.hhea.parse = function(t, e, n) {
      var o = r._bin, a = {};
      return o.readFixed(t, e), e += 4, a.ascender = o.readShort(t, e), e += 2, a.descender = o.readShort(t, e), e += 2, a.lineGap = o.readShort(t, e), e += 2, a.advanceWidthMax = o.readUshort(t, e), e += 2, a.minLeftSideBearing = o.readShort(t, e), e += 2, a.minRightSideBearing = o.readShort(t, e), e += 2, a.xMaxExtent = o.readShort(t, e), e += 2, a.caretSlopeRise = o.readShort(t, e), e += 2, a.caretSlopeRun = o.readShort(t, e), e += 2, a.caretOffset = o.readShort(t, e), e += 2, e += 8, a.metricDataFormat = o.readShort(t, e), e += 2, a.numberOfHMetrics = o.readUshort(t, e), e += 2, a;
    }, r.hmtx = {}, r.hmtx.parse = function(t, e, n, o) {
      for (var a = r._bin, i = { aWidth: [], lsBearing: [] }, s = 0, l = 0, u = 0; u < o.maxp.numGlyphs; u++) u < o.hhea.numberOfHMetrics && (s = a.readUshort(t, e), e += 2, l = a.readShort(t, e), e += 2), i.aWidth.push(s), i.lsBearing.push(l);
      return i;
    }, r.kern = {}, r.kern.parse = function(t, e, n, o) {
      var a = r._bin, i = a.readUshort(t, e);
      if (e += 2, i == 1) return r.kern.parseV1(t, e - 2, n, o);
      var s = a.readUshort(t, e);
      e += 2;
      for (var l = { glyph1: [], rval: [] }, u = 0; u < s; u++) {
        e += 2, n = a.readUshort(t, e), e += 2;
        var d = a.readUshort(t, e);
        e += 2;
        var p = d >>> 8;
        if ((p &= 15) != 0) throw "unknown kern table format: " + p;
        e = r.kern.readFormat0(t, e, l);
      }
      return l;
    }, r.kern.parseV1 = function(t, e, n, o) {
      var a = r._bin;
      a.readFixed(t, e), e += 4;
      var i = a.readUint(t, e);
      e += 4;
      for (var s = { glyph1: [], rval: [] }, l = 0; l < i; l++) {
        a.readUint(t, e), e += 4;
        var u = a.readUshort(t, e);
        e += 2, a.readUshort(t, e), e += 2;
        var d = u >>> 8;
        if ((d &= 15) != 0) throw "unknown kern table format: " + d;
        e = r.kern.readFormat0(t, e, s);
      }
      return s;
    }, r.kern.readFormat0 = function(t, e, n) {
      var o = r._bin, a = -1, i = o.readUshort(t, e);
      e += 2, o.readUshort(t, e), e += 2, o.readUshort(t, e), e += 2, o.readUshort(t, e), e += 2;
      for (var s = 0; s < i; s++) {
        var l = o.readUshort(t, e);
        e += 2;
        var u = o.readUshort(t, e);
        e += 2;
        var d = o.readShort(t, e);
        e += 2, l != a && (n.glyph1.push(l), n.rval.push({ glyph2: [], vals: [] }));
        var p = n.rval[n.rval.length - 1];
        p.glyph2.push(u), p.vals.push(d), a = l;
      }
      return e;
    }, r.loca = {}, r.loca.parse = function(t, e, n, o) {
      var a = r._bin, i = [], s = o.head.indexToLocFormat, l = o.maxp.numGlyphs + 1;
      if (s == 0) for (var u = 0; u < l; u++) i.push(a.readUshort(t, e + (u << 1)) << 1);
      if (s == 1) for (u = 0; u < l; u++) i.push(a.readUint(t, e + (u << 2)));
      return i;
    }, r.maxp = {}, r.maxp.parse = function(t, e, n) {
      var o = r._bin, a = {}, i = o.readUint(t, e);
      return e += 4, a.numGlyphs = o.readUshort(t, e), e += 2, i == 65536 && (a.maxPoints = o.readUshort(t, e), e += 2, a.maxContours = o.readUshort(t, e), e += 2, a.maxCompositePoints = o.readUshort(t, e), e += 2, a.maxCompositeContours = o.readUshort(t, e), e += 2, a.maxZones = o.readUshort(t, e), e += 2, a.maxTwilightPoints = o.readUshort(t, e), e += 2, a.maxStorage = o.readUshort(t, e), e += 2, a.maxFunctionDefs = o.readUshort(t, e), e += 2, a.maxInstructionDefs = o.readUshort(t, e), e += 2, a.maxStackElements = o.readUshort(t, e), e += 2, a.maxSizeOfInstructions = o.readUshort(t, e), e += 2, a.maxComponentElements = o.readUshort(t, e), e += 2, a.maxComponentDepth = o.readUshort(t, e), e += 2), a;
    }, r.name = {}, r.name.parse = function(t, e, n) {
      var o = r._bin, a = {};
      o.readUshort(t, e), e += 2;
      var i = o.readUshort(t, e);
      e += 2, o.readUshort(t, e);
      for (var s, l = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], u = e += 2, d = 0; d < i; d++) {
        var p = o.readUshort(t, e);
        e += 2;
        var g = o.readUshort(t, e);
        e += 2;
        var m = o.readUshort(t, e);
        e += 2;
        var B = o.readUshort(t, e);
        e += 2;
        var U = o.readUshort(t, e);
        e += 2;
        var _ = o.readUshort(t, e);
        e += 2;
        var T, w = l[B], D = u + 12 * i + _;
        if (p == 0) T = o.readUnicode(t, D, U / 2);
        else if (p == 3 && g == 0) T = o.readUnicode(t, D, U / 2);
        else if (g == 0) T = o.readASCII(t, D, U);
        else if (g == 1) T = o.readUnicode(t, D, U / 2);
        else if (g == 3) T = o.readUnicode(t, D, U / 2);
        else {
          if (p != 1) throw "unknown encoding " + g + ", platformID: " + p;
          T = o.readASCII(t, D, U), console.debug("reading unknown MAC encoding " + g + " as ASCII");
        }
        var b = "p" + p + "," + m.toString(16);
        a[b] == null && (a[b] = {}), a[b][w !== void 0 ? w : B] = T, a[b]._lang = m;
      }
      for (var M in a) if (a[M].postScriptName != null && a[M]._lang == 1033) return a[M];
      for (var M in a) if (a[M].postScriptName != null && a[M]._lang == 0) return a[M];
      for (var M in a) if (a[M].postScriptName != null && a[M]._lang == 3084) return a[M];
      for (var M in a) if (a[M].postScriptName != null) return a[M];
      for (var M in a) {
        s = M;
        break;
      }
      return console.debug("returning name table with languageID " + a[s]._lang), a[s];
    }, r["OS/2"] = {}, r["OS/2"].parse = function(t, e, n) {
      var o = r._bin.readUshort(t, e);
      e += 2;
      var a = {};
      if (o == 0) r["OS/2"].version0(t, e, a);
      else if (o == 1) r["OS/2"].version1(t, e, a);
      else if (o == 2 || o == 3 || o == 4) r["OS/2"].version2(t, e, a);
      else {
        if (o != 5) throw "unknown OS/2 table version: " + o;
        r["OS/2"].version5(t, e, a);
      }
      return a;
    }, r["OS/2"].version0 = function(t, e, n) {
      var o = r._bin;
      return n.xAvgCharWidth = o.readShort(t, e), e += 2, n.usWeightClass = o.readUshort(t, e), e += 2, n.usWidthClass = o.readUshort(t, e), e += 2, n.fsType = o.readUshort(t, e), e += 2, n.ySubscriptXSize = o.readShort(t, e), e += 2, n.ySubscriptYSize = o.readShort(t, e), e += 2, n.ySubscriptXOffset = o.readShort(t, e), e += 2, n.ySubscriptYOffset = o.readShort(t, e), e += 2, n.ySuperscriptXSize = o.readShort(t, e), e += 2, n.ySuperscriptYSize = o.readShort(t, e), e += 2, n.ySuperscriptXOffset = o.readShort(t, e), e += 2, n.ySuperscriptYOffset = o.readShort(t, e), e += 2, n.yStrikeoutSize = o.readShort(t, e), e += 2, n.yStrikeoutPosition = o.readShort(t, e), e += 2, n.sFamilyClass = o.readShort(t, e), e += 2, n.panose = o.readBytes(t, e, 10), e += 10, n.ulUnicodeRange1 = o.readUint(t, e), e += 4, n.ulUnicodeRange2 = o.readUint(t, e), e += 4, n.ulUnicodeRange3 = o.readUint(t, e), e += 4, n.ulUnicodeRange4 = o.readUint(t, e), e += 4, n.achVendID = [o.readInt8(t, e), o.readInt8(t, e + 1), o.readInt8(t, e + 2), o.readInt8(t, e + 3)], e += 4, n.fsSelection = o.readUshort(t, e), e += 2, n.usFirstCharIndex = o.readUshort(t, e), e += 2, n.usLastCharIndex = o.readUshort(t, e), e += 2, n.sTypoAscender = o.readShort(t, e), e += 2, n.sTypoDescender = o.readShort(t, e), e += 2, n.sTypoLineGap = o.readShort(t, e), e += 2, n.usWinAscent = o.readUshort(t, e), e += 2, n.usWinDescent = o.readUshort(t, e), e += 2;
    }, r["OS/2"].version1 = function(t, e, n) {
      var o = r._bin;
      return e = r["OS/2"].version0(t, e, n), n.ulCodePageRange1 = o.readUint(t, e), e += 4, n.ulCodePageRange2 = o.readUint(t, e), e += 4;
    }, r["OS/2"].version2 = function(t, e, n) {
      var o = r._bin;
      return e = r["OS/2"].version1(t, e, n), n.sxHeight = o.readShort(t, e), e += 2, n.sCapHeight = o.readShort(t, e), e += 2, n.usDefault = o.readUshort(t, e), e += 2, n.usBreak = o.readUshort(t, e), e += 2, n.usMaxContext = o.readUshort(t, e), e += 2;
    }, r["OS/2"].version5 = function(t, e, n) {
      var o = r._bin;
      return e = r["OS/2"].version2(t, e, n), n.usLowerOpticalPointSize = o.readUshort(t, e), e += 2, n.usUpperOpticalPointSize = o.readUshort(t, e), e += 2;
    }, r.post = {}, r.post.parse = function(t, e, n) {
      var o = r._bin, a = {};
      return a.version = o.readFixed(t, e), e += 4, a.italicAngle = o.readFixed(t, e), e += 4, a.underlinePosition = o.readShort(t, e), e += 2, a.underlineThickness = o.readShort(t, e), e += 2, a;
    }, r == null && (r = {}), r.U == null && (r.U = {}), r.U.codeToGlyph = function(t, e) {
      var n = t.cmap, o = -1;
      if (n.p0e4 != null ? o = n.p0e4 : n.p3e1 != null ? o = n.p3e1 : n.p1e0 != null ? o = n.p1e0 : n.p0e3 != null && (o = n.p0e3), o == -1) throw "no familiar platform and encoding!";
      var a = n.tables[o];
      if (a.format == 0) return e >= a.map.length ? 0 : a.map[e];
      if (a.format == 4) {
        for (var i = -1, s = 0; s < a.endCount.length; s++) if (e <= a.endCount[s]) {
          i = s;
          break;
        }
        return i == -1 || a.startCount[i] > e ? 0 : 65535 & (a.idRangeOffset[i] != 0 ? a.glyphIdArray[e - a.startCount[i] + (a.idRangeOffset[i] >> 1) - (a.idRangeOffset.length - i)] : e + a.idDelta[i]);
      }
      if (a.format == 12) {
        if (e > a.groups[a.groups.length - 1][1]) return 0;
        for (s = 0; s < a.groups.length; s++) {
          var l = a.groups[s];
          if (l[0] <= e && e <= l[1]) return l[2] + (e - l[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + a.format;
    }, r.U.glyphToPath = function(t, e) {
      var n = { cmds: [], crds: [] };
      if (t.SVG && t.SVG.entries[e]) {
        var o = t.SVG.entries[e];
        return o == null ? n : (typeof o == "string" && (o = r.SVG.toPath(o), t.SVG.entries[e] = o), o);
      }
      if (t.CFF) {
        var a = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: false, width: t.CFF.Private ? t.CFF.Private.defaultWidthX : 0, open: false }, i = t.CFF, s = t.CFF.Private;
        if (i.ROS) {
          for (var l = 0; i.FDSelect[l + 2] <= e; ) l += 2;
          s = i.FDArray[i.FDSelect[l + 1]].Private;
        }
        r.U._drawCFF(t.CFF.CharStrings[e], a, i, s, n);
      } else t.glyf && r.U._drawGlyf(e, t, n);
      return n;
    }, r.U._drawGlyf = function(t, e, n) {
      var o = e.glyf[t];
      o == null && (o = e.glyf[t] = r.glyf._parseGlyf(e, t)), o != null && (o.noc > -1 ? r.U._simpleGlyph(o, n) : r.U._compoGlyph(o, e, n));
    }, r.U._simpleGlyph = function(t, e) {
      for (var n = 0; n < t.noc; n++) {
        for (var o = n == 0 ? 0 : t.endPts[n - 1] + 1, a = t.endPts[n], i = o; i <= a; i++) {
          var s = i == o ? a : i - 1, l = i == a ? o : i + 1, u = 1 & t.flags[i], d = 1 & t.flags[s], p = 1 & t.flags[l], g = t.xs[i], m = t.ys[i];
          if (i == o) if (u) {
            if (!d) {
              r.U.P.moveTo(e, g, m);
              continue;
            }
            r.U.P.moveTo(e, t.xs[s], t.ys[s]);
          } else d ? r.U.P.moveTo(e, t.xs[s], t.ys[s]) : r.U.P.moveTo(e, (t.xs[s] + g) / 2, (t.ys[s] + m) / 2);
          u ? d && r.U.P.lineTo(e, g, m) : p ? r.U.P.qcurveTo(e, g, m, t.xs[l], t.ys[l]) : r.U.P.qcurveTo(e, g, m, (g + t.xs[l]) / 2, (m + t.ys[l]) / 2);
        }
        r.U.P.closePath(e);
      }
    }, r.U._compoGlyph = function(t, e, n) {
      for (var o = 0; o < t.parts.length; o++) {
        var a = { cmds: [], crds: [] }, i = t.parts[o];
        r.U._drawGlyf(i.glyphIndex, e, a);
        for (var s = i.m, l = 0; l < a.crds.length; l += 2) {
          var u = a.crds[l], d = a.crds[l + 1];
          n.crds.push(u * s.a + d * s.b + s.tx), n.crds.push(u * s.c + d * s.d + s.ty);
        }
        for (l = 0; l < a.cmds.length; l++) n.cmds.push(a.cmds[l]);
      }
    }, r.U._getGlyphClass = function(t, e) {
      var n = r._lctf.getInterval(e, t);
      return n == -1 ? 0 : e[n + 2];
    }, r.U._applySubs = function(t, e, n, o) {
      for (var a = t.length - e - 1, i = 0; i < n.tabs.length; i++) if (n.tabs[i] != null) {
        var s, l = n.tabs[i];
        if (!l.coverage || (s = r._lctf.coverageIndex(l.coverage, t[e])) != -1) {
          if (n.ltype == 1) t[e], l.fmt == 1 ? t[e] = t[e] + l.delta : t[e] = l.newg[s];
          else if (n.ltype == 4) for (var u = l.vals[s], d = 0; d < u.length; d++) {
            var p = u[d], g = p.chain.length;
            if (!(g > a)) {
              for (var m = true, B = 0, U = 0; U < g; U++) {
                for (; t[e + B + (1 + U)] == -1; ) B++;
                p.chain[U] != t[e + B + (1 + U)] && (m = false);
              }
              if (m) {
                for (t[e] = p.nglyph, U = 0; U < g + B; U++) t[e + U + 1] = -1;
                break;
              }
            }
          }
          else if (n.ltype == 5 && l.fmt == 2) for (var _ = r._lctf.getInterval(l.cDef, t[e]), T = l.cDef[_ + 2], w = l.scset[T], D = 0; D < w.length; D++) {
            var b = w[D], M = b.input;
            if (!(M.length > a)) {
              for (m = true, U = 0; U < M.length; U++) {
                var W = r._lctf.getInterval(l.cDef, t[e + 1 + U]);
                if (_ == -1 && l.cDef[W + 2] != M[U]) {
                  m = false;
                  break;
                }
              }
              if (m) {
                var O = b.substLookupRecords;
                for (d = 0; d < O.length; d += 2) O[d], O[d + 1];
              }
            }
          }
          else if (n.ltype == 6 && l.fmt == 3) {
            if (!r.U._glsCovered(t, l.backCvg, e - l.backCvg.length) || !r.U._glsCovered(t, l.inptCvg, e) || !r.U._glsCovered(t, l.ahedCvg, e + l.inptCvg.length)) continue;
            var J = l.lookupRec;
            for (D = 0; D < J.length; D += 2) {
              _ = J[D];
              var y = o[J[D + 1]];
              r.U._applySubs(t, e + _, y, o);
            }
          }
        }
      }
    }, r.U._glsCovered = function(t, e, n) {
      for (var o = 0; o < e.length; o++) if (r._lctf.coverageIndex(e[o], t[n + o]) == -1) return false;
      return true;
    }, r.U.glyphsToPath = function(t, e, n) {
      for (var o = { cmds: [], crds: [] }, a = 0, i = 0; i < e.length; i++) {
        var s = e[i];
        if (s != -1) {
          for (var l = i < e.length - 1 && e[i + 1] != -1 ? e[i + 1] : 0, u = r.U.glyphToPath(t, s), d = 0; d < u.crds.length; d += 2) o.crds.push(u.crds[d] + a), o.crds.push(u.crds[d + 1]);
          for (n && o.cmds.push(n), d = 0; d < u.cmds.length; d++) o.cmds.push(u.cmds[d]);
          n && o.cmds.push("X"), a += t.hmtx.aWidth[s], i < e.length - 1 && (a += r.U.getPairAdjustment(t, s, l));
        }
      }
      return o;
    }, r.U.P = {}, r.U.P.moveTo = function(t, e, n) {
      t.cmds.push("M"), t.crds.push(e, n);
    }, r.U.P.lineTo = function(t, e, n) {
      t.cmds.push("L"), t.crds.push(e, n);
    }, r.U.P.curveTo = function(t, e, n, o, a, i, s) {
      t.cmds.push("C"), t.crds.push(e, n, o, a, i, s);
    }, r.U.P.qcurveTo = function(t, e, n, o, a) {
      t.cmds.push("Q"), t.crds.push(e, n, o, a);
    }, r.U.P.closePath = function(t) {
      t.cmds.push("Z");
    }, r.U._drawCFF = function(t, e, n, o, a) {
      for (var i = e.stack, s = e.nStems, l = e.haveWidth, u = e.width, d = e.open, p = 0, g = e.x, m = e.y, B = 0, U = 0, _ = 0, T = 0, w = 0, D = 0, b = 0, M = 0, W = 0, O = 0, J = { val: 0, size: 0 }; p < t.length; ) {
        r.CFF.getCharString(t, p, J);
        var y = J.val;
        if (p += J.size, y == "o1" || y == "o18") i.length % 2 != 0 && !l && (u = i.shift() + o.nominalWidthX), s += i.length >> 1, i.length = 0, l = true;
        else if (y == "o3" || y == "o23") i.length % 2 != 0 && !l && (u = i.shift() + o.nominalWidthX), s += i.length >> 1, i.length = 0, l = true;
        else if (y == "o4") i.length > 1 && !l && (u = i.shift() + o.nominalWidthX, l = true), d && r.U.P.closePath(a), m += i.pop(), r.U.P.moveTo(a, g, m), d = true;
        else if (y == "o5") for (; i.length > 0; ) g += i.shift(), m += i.shift(), r.U.P.lineTo(a, g, m);
        else if (y == "o6" || y == "o7") for (var R = i.length, F = y == "o6", V = 0; V < R; V++) {
          var I = i.shift();
          F ? g += I : m += I, F = !F, r.U.P.lineTo(a, g, m);
        }
        else if (y == "o8" || y == "o24") {
          R = i.length;
          for (var Q = 0; Q + 6 <= R; ) B = g + i.shift(), U = m + i.shift(), _ = B + i.shift(), T = U + i.shift(), g = _ + i.shift(), m = T + i.shift(), r.U.P.curveTo(a, B, U, _, T, g, m), Q += 6;
          y == "o24" && (g += i.shift(), m += i.shift(), r.U.P.lineTo(a, g, m));
        } else {
          if (y == "o11") break;
          if (y == "o1234" || y == "o1235" || y == "o1236" || y == "o1237") y == "o1234" && (U = m, _ = (B = g + i.shift()) + i.shift(), O = T = U + i.shift(), D = T, M = m, g = (b = (w = (W = _ + i.shift()) + i.shift()) + i.shift()) + i.shift(), r.U.P.curveTo(a, B, U, _, T, W, O), r.U.P.curveTo(a, w, D, b, M, g, m)), y == "o1235" && (B = g + i.shift(), U = m + i.shift(), _ = B + i.shift(), T = U + i.shift(), W = _ + i.shift(), O = T + i.shift(), w = W + i.shift(), D = O + i.shift(), b = w + i.shift(), M = D + i.shift(), g = b + i.shift(), m = M + i.shift(), i.shift(), r.U.P.curveTo(a, B, U, _, T, W, O), r.U.P.curveTo(a, w, D, b, M, g, m)), y == "o1236" && (B = g + i.shift(), U = m + i.shift(), _ = B + i.shift(), O = T = U + i.shift(), D = T, b = (w = (W = _ + i.shift()) + i.shift()) + i.shift(), M = D + i.shift(), g = b + i.shift(), r.U.P.curveTo(a, B, U, _, T, W, O), r.U.P.curveTo(a, w, D, b, M, g, m)), y == "o1237" && (B = g + i.shift(), U = m + i.shift(), _ = B + i.shift(), T = U + i.shift(), W = _ + i.shift(), O = T + i.shift(), w = W + i.shift(), D = O + i.shift(), b = w + i.shift(), M = D + i.shift(), Math.abs(b - g) > Math.abs(M - m) ? g = b + i.shift() : m = M + i.shift(), r.U.P.curveTo(a, B, U, _, T, W, O), r.U.P.curveTo(a, w, D, b, M, g, m));
          else if (y == "o14") {
            if (i.length > 0 && !l && (u = i.shift() + n.nominalWidthX, l = true), i.length == 4) {
              var ie = i.shift(), G = i.shift(), E = i.shift(), v = i.shift(), x = r.CFF.glyphBySE(n, E), S = r.CFF.glyphBySE(n, v);
              r.U._drawCFF(n.CharStrings[x], e, n, o, a), e.x = ie, e.y = G, r.U._drawCFF(n.CharStrings[S], e, n, o, a);
            }
            d && (r.U.P.closePath(a), d = false);
          } else if (y == "o19" || y == "o20") i.length % 2 != 0 && !l && (u = i.shift() + o.nominalWidthX), s += i.length >> 1, i.length = 0, l = true, p += s + 7 >> 3;
          else if (y == "o21") i.length > 2 && !l && (u = i.shift() + o.nominalWidthX, l = true), m += i.pop(), g += i.pop(), d && r.U.P.closePath(a), r.U.P.moveTo(a, g, m), d = true;
          else if (y == "o22") i.length > 1 && !l && (u = i.shift() + o.nominalWidthX, l = true), g += i.pop(), d && r.U.P.closePath(a), r.U.P.moveTo(a, g, m), d = true;
          else if (y == "o25") {
            for (; i.length > 6; ) g += i.shift(), m += i.shift(), r.U.P.lineTo(a, g, m);
            B = g + i.shift(), U = m + i.shift(), _ = B + i.shift(), T = U + i.shift(), g = _ + i.shift(), m = T + i.shift(), r.U.P.curveTo(a, B, U, _, T, g, m);
          } else if (y == "o26") for (i.length % 2 && (g += i.shift()); i.length > 0; ) B = g, U = m + i.shift(), g = _ = B + i.shift(), m = (T = U + i.shift()) + i.shift(), r.U.P.curveTo(a, B, U, _, T, g, m);
          else if (y == "o27") for (i.length % 2 && (m += i.shift()); i.length > 0; ) U = m, _ = (B = g + i.shift()) + i.shift(), T = U + i.shift(), g = _ + i.shift(), m = T, r.U.P.curveTo(a, B, U, _, T, g, m);
          else if (y == "o10" || y == "o29") {
            var A = y == "o10" ? o : n;
            if (i.length == 0) console.debug("error: empty stack");
            else {
              var k = i.pop(), z = A.Subrs[k + A.Bias];
              e.x = g, e.y = m, e.nStems = s, e.haveWidth = l, e.width = u, e.open = d, r.U._drawCFF(z, e, n, o, a), g = e.x, m = e.y, s = e.nStems, l = e.haveWidth, u = e.width, d = e.open;
            }
          } else if (y == "o30" || y == "o31") {
            var C2 = i.length, P = (Q = 0, y == "o31");
            for (Q += C2 - (R = -3 & C2); Q < R; ) P ? (U = m, _ = (B = g + i.shift()) + i.shift(), m = (T = U + i.shift()) + i.shift(), R - Q == 5 ? (g = _ + i.shift(), Q++) : g = _, P = false) : (B = g, U = m + i.shift(), _ = B + i.shift(), T = U + i.shift(), g = _ + i.shift(), R - Q == 5 ? (m = T + i.shift(), Q++) : m = T, P = true), r.U.P.curveTo(a, B, U, _, T, g, m), Q += 4;
          } else {
            if ((y + "").charAt(0) == "o") throw console.debug("Unknown operation: " + y, t), y;
            i.push(y);
          }
        }
      }
      e.x = g, e.y = m, e.nStems = s, e.haveWidth = l, e.width = u, e.open = d;
    };
    var h = r, f = { Typr: h };
    return c2.Typr = h, c2.default = f, Object.defineProperty(c2, "__esModule", { value: true }), c2;
  })({}).Typr;
}
function Fa() {
  return (function(c2) {
    var r = Uint8Array, h = Uint16Array, f = Uint32Array, t = new r([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), e = new r([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), n = new r([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), o = function(y, R) {
      for (var F = new h(31), V = 0; V < 31; ++V) F[V] = R += 1 << y[V - 1];
      var I = new f(F[30]);
      for (V = 1; V < 30; ++V) for (var Q = F[V]; Q < F[V + 1]; ++Q) I[Q] = Q - F[V] << 5 | V;
      return [F, I];
    }, a = o(t, 2), i = a[0], s = a[1];
    i[28] = 258, s[258] = 28;
    for (var l = o(e, 0)[0], u = new h(32768), d = 0; d < 32768; ++d) {
      var p = (43690 & d) >>> 1 | (21845 & d) << 1;
      p = (61680 & (p = (52428 & p) >>> 2 | (13107 & p) << 2)) >>> 4 | (3855 & p) << 4, u[d] = ((65280 & p) >>> 8 | (255 & p) << 8) >>> 1;
    }
    var g = function(y, R, F) {
      for (var V = y.length, I = 0, Q = new h(R); I < V; ++I) ++Q[y[I] - 1];
      var ie, G = new h(R);
      for (I = 0; I < R; ++I) G[I] = G[I - 1] + Q[I - 1] << 1;
      if (F) {
        ie = new h(1 << R);
        var E = 15 - R;
        for (I = 0; I < V; ++I) if (y[I]) for (var v = I << 4 | y[I], x = R - y[I], S = G[y[I] - 1]++ << x, A = S | (1 << x) - 1; S <= A; ++S) ie[u[S] >>> E] = v;
      } else for (ie = new h(V), I = 0; I < V; ++I) y[I] && (ie[I] = u[G[y[I] - 1]++] >>> 15 - y[I]);
      return ie;
    }, m = new r(288);
    for (d = 0; d < 144; ++d) m[d] = 8;
    for (d = 144; d < 256; ++d) m[d] = 9;
    for (d = 256; d < 280; ++d) m[d] = 7;
    for (d = 280; d < 288; ++d) m[d] = 8;
    var B = new r(32);
    for (d = 0; d < 32; ++d) B[d] = 5;
    var U = g(m, 9, 1), _ = g(B, 5, 1), T = function(y) {
      for (var R = y[0], F = 1; F < y.length; ++F) y[F] > R && (R = y[F]);
      return R;
    }, w = function(y, R, F) {
      var V = R / 8 | 0;
      return (y[V] | y[V + 1] << 8) >> (7 & R) & F;
    }, D = function(y, R) {
      var F = R / 8 | 0;
      return (y[F] | y[F + 1] << 8 | y[F + 2] << 16) >> (7 & R);
    }, b = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], M = function(y, R, F) {
      var V = new Error(R || b[y]);
      if (V.code = y, Error.captureStackTrace && Error.captureStackTrace(V, M), !F) throw V;
      return V;
    }, W = function(y, R, F) {
      var V = y.length;
      if (!V || F && !F.l && V < 5) return R || new r(0);
      var I = !R || F, Q = !F || F.i;
      F || (F = {}), R || (R = new r(3 * V));
      var ie, G = function(le) {
        var Ue = R.length;
        if (le > Ue) {
          var Se = new r(Math.max(2 * Ue, le));
          Se.set(R), R = Se;
        }
      }, E = F.f || 0, v = F.p || 0, x = F.b || 0, S = F.l, A = F.d, k = F.m, z = F.n, C2 = 8 * V;
      do {
        if (!S) {
          F.f = E = w(y, v, 1);
          var P = w(y, v + 1, 3);
          if (v += 3, !P) {
            var H = y[(q = ((ie = v) / 8 | 0) + (7 & ie && 1) + 4) - 4] | y[q - 3] << 8, $ = q + H;
            if ($ > V) {
              Q && M(0);
              break;
            }
            I && G(x + H), R.set(y.subarray(q, $), x), F.b = x += H, F.p = v = 8 * $;
            continue;
          }
          if (P == 1) S = U, A = _, k = 9, z = 5;
          else if (P == 2) {
            var X = w(y, v, 31) + 257, N = w(y, v + 10, 15) + 4, pe = X + w(y, v + 5, 31) + 1;
            v += 14;
            for (var ue = new r(pe), Z = new r(19), ee = 0; ee < N; ++ee) Z[n[ee]] = w(y, v + 3 * ee, 7);
            v += 3 * N;
            var se = T(Z), j = (1 << se) - 1, te = g(Z, se, 1);
            for (ee = 0; ee < pe; ) {
              var q, L = te[w(y, v, j)];
              if (v += 15 & L, (q = L >>> 4) < 16) ue[ee++] = q;
              else {
                var he = 0, K = 0;
                for (q == 16 ? (K = 3 + w(y, v, 3), v += 2, he = ue[ee - 1]) : q == 17 ? (K = 3 + w(y, v, 7), v += 3) : q == 18 && (K = 11 + w(y, v, 127), v += 7); K--; ) ue[ee++] = he;
              }
            }
            var ne = ue.subarray(0, X), Y = ue.subarray(X);
            k = T(ne), z = T(Y), S = g(ne, k, 1), A = g(Y, z, 1);
          } else M(1);
          if (v > C2) {
            Q && M(0);
            break;
          }
        }
        I && G(x + 131072);
        for (var be = (1 << k) - 1, re = (1 << z) - 1, ae = v; ; ae = v) {
          var fe = (he = S[D(y, v) & be]) >>> 4;
          if ((v += 15 & he) > C2) {
            Q && M(0);
            break;
          }
          if (he || M(2), fe < 256) R[x++] = fe;
          else {
            if (fe == 256) {
              ae = v, S = null;
              break;
            }
            var de = fe - 254;
            if (fe > 264) {
              var ke = t[ee = fe - 257];
              de = w(y, v, (1 << ke) - 1) + i[ee], v += ke;
            }
            var Ae2 = A[D(y, v) & re], ge = Ae2 >>> 4;
            if (Ae2 || M(3), v += 15 & Ae2, Y = l[ge], ge > 3 && (ke = e[ge], Y += D(y, v) & (1 << ke) - 1, v += ke), v > C2) {
              Q && M(0);
              break;
            }
            I && G(x + 131072);
            for (var me = x + de; x < me; x += 4) R[x] = R[x - Y], R[x + 1] = R[x + 1 - Y], R[x + 2] = R[x + 2 - Y], R[x + 3] = R[x + 3 - Y];
            x = me;
          }
        }
        F.l = S, F.p = ae, F.b = x, S && (E = 1, F.m = k, F.d = A, F.n = z);
      } while (!E);
      return x == R.length ? R : (function(le, Ue, Se) {
        (Ue == null || Ue < 0) && (Ue = 0), (Se == null || Se > le.length) && (Se = le.length);
        var Le = new (le instanceof h ? h : le instanceof f ? f : r)(Se - Ue);
        return Le.set(le.subarray(Ue, Se)), Le;
      })(R, 0, x);
    }, O = new r(0), J = typeof TextDecoder < "u" && new TextDecoder();
    try {
      J.decode(O, { stream: true });
    } catch {
    }
    return c2.convert_streams = function(y) {
      var R = new DataView(y), F = 0;
      function V() {
        var X = R.getUint16(F);
        return F += 2, X;
      }
      function I() {
        var X = R.getUint32(F);
        return F += 4, X;
      }
      function Q(X) {
        H.setUint16($, X), $ += 2;
      }
      function ie(X) {
        H.setUint32($, X), $ += 4;
      }
      for (var G = { signature: I(), flavor: I(), length: I(), numTables: V(), reserved: V(), totalSfntSize: I(), majorVersion: V(), minorVersion: V(), metaOffset: I(), metaLength: I(), metaOrigLength: I(), privOffset: I(), privLength: I() }, E = 0; Math.pow(2, E) <= G.numTables; ) E++;
      E--;
      for (var v = 16 * Math.pow(2, E), x = 16 * G.numTables - v, S = 12, A = [], k = 0; k < G.numTables; k++) A.push({ tag: I(), offset: I(), compLength: I(), origLength: I(), origChecksum: I() }), S += 16;
      var z, C2 = new Uint8Array(12 + 16 * A.length + A.reduce(function(X, N) {
        return X + N.origLength + 4;
      }, 0)), P = C2.buffer, H = new DataView(P), $ = 0;
      return ie(G.flavor), Q(G.numTables), Q(v), Q(E), Q(x), A.forEach(function(X) {
        ie(X.tag), ie(X.origChecksum), ie(S), ie(X.origLength), X.outOffset = S, (S += X.origLength) % 4 != 0 && (S += 4 - S % 4);
      }), A.forEach(function(X) {
        var N, pe = y.slice(X.offset, X.offset + X.compLength);
        if (X.compLength != X.origLength) {
          var ue = new Uint8Array(X.origLength);
          N = new Uint8Array(pe, 2), W(N, ue);
        } else ue = new Uint8Array(pe);
        C2.set(ue, X.outOffset);
        var Z = 0;
        (S = X.outOffset + X.origLength) % 4 != 0 && (Z = 4 - S % 4), C2.set(new Uint8Array(Z).buffer, X.outOffset + X.origLength), z = S + Z;
      }), P.slice(0, z);
    }, Object.defineProperty(c2, "__esModule", { value: true }), c2;
  })({}).convert_streams;
}
function Ma(c2, r) {
  let h = { M: 2, L: 2, Q: 4, C: 6, Z: 0 }, f = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, t = 1, e = 2, n = 4, o = 8, a = 16, i = 32, s;
  function l(b) {
    if (!s) {
      let M = { R: e, L: t, D: n, C: a, U: i, T: o };
      s = /* @__PURE__ */ new Map();
      for (let W in f) {
        let O = 0;
        f[W].split(",").forEach((J) => {
          let [y, R] = J.split("+");
          y = parseInt(y, 36), R = R ? parseInt(R, 36) : 0, s.set(O += y, M[W]);
          for (let F = R; F--; ) s.set(++O, M[W]);
        });
      }
    }
    return s.get(b) || i;
  }
  let u = 1, d = 2, p = 3, g = 4, m = [null, "isol", "init", "fina", "medi"];
  function B(b) {
    let M = new Uint8Array(b.length), W = i, O = u, J = -1;
    for (let y = 0; y < b.length; y++) {
      let R = b.codePointAt(y), F = l(R) | 0, V = u;
      F & o || (W & (t | n | a) ? F & (e | n | a) ? (V = p, (O === u || O === p) && M[J]++) : F & (t | i) && (O === d || O === g) && M[J]-- : W & (e | i) && (O === d || O === g) && M[J]--, O = M[y] = V, W = F, J = y, R > 65535 && y++);
    }
    return M;
  }
  function U(b, M) {
    let W = [];
    for (let J = 0; J < M.length; J++) {
      let y = M.codePointAt(J);
      y > 65535 && J++, W.push(c2.U.codeToGlyph(b, y));
    }
    let O = b.GSUB;
    if (O) {
      let { lookupList: J, featureList: y } = O, R, F = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/, V = [];
      y.forEach((I) => {
        if (F.test(I.tag)) for (let Q = 0; Q < I.tab.length; Q++) {
          if (V[I.tab[Q]]) continue;
          V[I.tab[Q]] = true;
          let ie = J[I.tab[Q]], G = /^(isol|init|fina|medi)$/.test(I.tag);
          G && !R && (R = B(M));
          for (let E = 0; E < W.length; E++) (!R || !G || m[R[E]] === I.tag) && c2.U._applySubs(W, E, ie, J);
        }
      });
    }
    return W;
  }
  function _(b, M) {
    let W = new Int16Array(M.length * 3), O = 0;
    for (; O < M.length; O++) {
      let F = M[O];
      if (F === -1) continue;
      W[O * 3 + 2] = b.hmtx.aWidth[F];
      let V = b.GPOS;
      if (V) {
        let I = V.lookupList;
        for (let Q = 0; Q < I.length; Q++) {
          let ie = I[Q];
          for (let G = 0; G < ie.tabs.length; G++) {
            let E = ie.tabs[G];
            if (ie.ltype === 1) {
              if (c2._lctf.coverageIndex(E.coverage, F) !== -1 && E.pos) {
                R(E.pos, O);
                break;
              }
            } else if (ie.ltype === 2) {
              let v = null, x = J();
              if (x !== -1) {
                let S = c2._lctf.coverageIndex(E.coverage, M[x]);
                if (S !== -1) {
                  if (E.fmt === 1) {
                    let A = E.pairsets[S];
                    for (let k = 0; k < A.length; k++) A[k].gid2 === F && (v = A[k]);
                  } else if (E.fmt === 2) {
                    let A = c2.U._getGlyphClass(M[x], E.classDef1), k = c2.U._getGlyphClass(F, E.classDef2);
                    v = E.matrix[A][k];
                  }
                  if (v) {
                    v.val1 && R(v.val1, x), v.val2 && R(v.val2, O);
                    break;
                  }
                }
              }
            } else if (ie.ltype === 4) {
              let v = c2._lctf.coverageIndex(E.markCoverage, F);
              if (v !== -1) {
                let x = J(y), S = x === -1 ? -1 : c2._lctf.coverageIndex(E.baseCoverage, M[x]);
                if (S !== -1) {
                  let A = E.markArray[v], k = E.baseArray[S][A.markClass];
                  W[O * 3] = k.x - A.x + W[x * 3] - W[x * 3 + 2], W[O * 3 + 1] = k.y - A.y + W[x * 3 + 1];
                  break;
                }
              }
            } else if (ie.ltype === 6) {
              let v = c2._lctf.coverageIndex(E.mark1Coverage, F);
              if (v !== -1) {
                let x = J();
                if (x !== -1) {
                  let S = M[x];
                  if (T(b, S) === 3) {
                    let A = c2._lctf.coverageIndex(E.mark2Coverage, S);
                    if (A !== -1) {
                      let k = E.mark1Array[v], z = E.mark2Array[A][k.markClass];
                      W[O * 3] = z.x - k.x + W[x * 3] - W[x * 3 + 2], W[O * 3 + 1] = z.y - k.y + W[x * 3 + 1];
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (b.kern && !b.cff) {
        let I = J();
        if (I !== -1) {
          let Q = b.kern.glyph1.indexOf(M[I]);
          if (Q !== -1) {
            let ie = b.kern.rval[Q].glyph2.indexOf(F);
            ie !== -1 && (W[I * 3 + 2] += b.kern.rval[Q].vals[ie]);
          }
        }
      }
    }
    return W;
    function J(F) {
      for (let V = O - 1; V >= 0; V--) if (M[V] !== -1 && (!F || F(M[V]))) return V;
      return -1;
    }
    function y(F) {
      return T(b, F) === 1;
    }
    function R(F, V) {
      for (let I = 0; I < 3; I++) W[V * 3 + I] += F[I] || 0;
    }
  }
  function T(b, M) {
    let W = b.GDEF && b.GDEF.glyphClassDef;
    return W ? c2.U._getGlyphClass(M, W) : 0;
  }
  function w(...b) {
    for (let M = 0; M < b.length; M++) if (typeof b[M] == "number") return b[M];
  }
  function D(b) {
    let M = /* @__PURE__ */ Object.create(null), W = b["OS/2"], O = b.hhea, J = b.head.unitsPerEm, y = w(W && W.sTypoAscender, O && O.ascender, J), R = { unitsPerEm: J, ascender: y, descender: w(W && W.sTypoDescender, O && O.descender, 0), capHeight: w(W && W.sCapHeight, y), xHeight: w(W && W.sxHeight, y), lineGap: w(W && W.sTypoLineGap, O && O.lineGap), supportsCodePoint(F) {
      return c2.U.codeToGlyph(b, F) > 0;
    }, forEachGlyph(F, V, I, Q) {
      let ie = 0, G = 1 / R.unitsPerEm * V, E = U(b, F), v = 0, x = _(b, E);
      return E.forEach((S, A) => {
        if (S !== -1) {
          let k = M[S];
          if (!k) {
            let { cmds: z, crds: C2 } = c2.U.glyphToPath(b, S), P = "", H = 0;
            for (let ue = 0, Z = z.length; ue < Z; ue++) {
              let ee = h[z[ue]];
              P += z[ue];
              for (let se = 1; se <= ee; se++) P += (se > 1 ? "," : "") + C2[H++];
            }
            let $, X, N, pe;
            if (C2.length) {
              $ = X = 1 / 0, N = pe = -1 / 0;
              for (let ue = 0, Z = C2.length; ue < Z; ue += 2) {
                let ee = C2[ue], se = C2[ue + 1];
                ee < $ && ($ = ee), se < X && (X = se), ee > N && (N = ee), se > pe && (pe = se);
              }
            } else $ = N = X = pe = 0;
            k = M[S] = { index: S, advanceWidth: b.hmtx.aWidth[S], xMin: $, yMin: X, xMax: N, yMax: pe, path: P };
          }
          Q.call(null, k, ie + x[A * 3] * G, x[A * 3 + 1] * G, v), ie += x[A * 3 + 2] * G, I && (ie += I * V);
        }
        v += F.codePointAt(v) > 65535 ? 2 : 1;
      }), ie;
    } };
    return R;
  }
  return function(M) {
    let W = new Uint8Array(M, 0, 4), O = c2._bin.readASCII(W, 0, 4);
    if (O === "wOFF") M = r(M);
    else if (O === "wOF2") throw new Error("woff2 fonts not supported");
    return D(c2.parse(M)[0]);
  };
}
var Aa = it({ name: "Typr Font Parser", dependencies: [wa, Fa, Ma], init(c2, r, h) {
  let f = c2(), t = r();
  return h(f, t);
} });
function Da() {
  return (function(c2) {
    var r = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    r.prototype.add = function(_) {
      var T = _ >> 5;
      this.buckets.set(T, (this.buckets.get(T) || 0) | 1 << (31 & _));
    }, r.prototype.has = function(_) {
      var T = this.buckets.get(_ >> 5);
      return T !== void 0 && (T & 1 << (31 & _)) != 0;
    }, r.prototype.serialize = function() {
      var _ = [];
      return this.buckets.forEach(function(T, w) {
        _.push((+w).toString(36) + ":" + T.toString(36));
      }), _.join(",");
    }, r.prototype.deserialize = function(_) {
      var T = this;
      this.buckets.clear(), _.split(",").forEach(function(w) {
        var D = w.split(":");
        T.buckets.set(parseInt(D[0], 36), parseInt(D[1], 36));
      });
    };
    var h = Math.pow(2, 8), f = h - 1, t = ~f;
    function e(_) {
      var T = (function(D) {
        return D & t;
      })(_).toString(16), w = (function(D) {
        return (D & t) + h - 1;
      })(_).toString(16);
      return "codepoint-index/plane" + (_ >> 16) + "/" + T + "-" + w + ".json";
    }
    function n(_, T) {
      var w = _ & f, D = T.codePointAt(w / 6 | 0);
      return ((D = (D || 48) - 48) & 1 << w % 6) != 0;
    }
    function o(_, T) {
      var w;
      (w = _, w.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(D) {
        return D.split("-").map(function(b) {
          return parseInt(b.trim(), 16);
        });
      })).forEach(function(D) {
        var b = D[0], M = D[1];
        M === void 0 && (M = b), T(b, M);
      });
    }
    function a(_, T) {
      o(_, function(w, D) {
        for (var b = w; b <= D; b++) T(b);
      });
    }
    var i = {}, s = {}, l = /* @__PURE__ */ new WeakMap(), u = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function d(_) {
      var T = l.get(_);
      return T || (T = new r(), a(_.ranges, function(w) {
        return T.add(w);
      }), l.set(_, T)), T;
    }
    var p, g = /* @__PURE__ */ new Map();
    function m(_, T, w) {
      return _[T] ? T : _[w] ? w : (function(D) {
        for (var b in D) return b;
      })(_);
    }
    function B(_, T) {
      var w = T;
      if (!_.includes(w)) {
        w = 1 / 0;
        for (var D = 0; D < _.length; D++) Math.abs(_[D] - T) < Math.abs(w - T) && (w = _[D]);
      }
      return w;
    }
    function U(_) {
      return p || (p = /* @__PURE__ */ new Set(), a("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(T) {
        p.add(T);
      })), p.has(_);
    }
    return c2.CodePointSet = r, c2.clearCache = function() {
      i = {}, s = {};
    }, c2.getFontsForString = function(_, T) {
      T === void 0 && (T = {});
      var w, D = T.lang;
      D === void 0 && (D = new RegExp("\\p{Script=Hangul}", "u").test(w = _) ? "ko" : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(w) ? "ja" : "en");
      var b = T.category;
      b === void 0 && (b = "sans-serif");
      var M = T.style;
      M === void 0 && (M = "normal");
      var W = T.weight;
      W === void 0 && (W = 400);
      var O = (T.dataUrl || u).replace(/\/$/g, ""), J = /* @__PURE__ */ new Map(), y = new Uint8Array(_.length), R = {}, F = {}, V = new Array(_.length), I = /* @__PURE__ */ new Map(), Q = false;
      function ie(v) {
        var x = g.get(v);
        return x || (x = fetch(O + "/" + v).then(function(S) {
          if (!S.ok) throw new Error(S.statusText);
          return S.json().then(function(A) {
            if (!Array.isArray(A) || A[0] !== 1) throw new Error("Incorrect schema version; need 1, got " + A[0]);
            return A[1];
          });
        }).catch(function(S) {
          if (O !== u) return Q || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + O + '", trying default CDN. ' + S.message), Q = true), O = u, g.delete(v), ie(v);
          throw S;
        }), g.set(v, x)), x;
      }
      for (var G = function(v) {
        var x = _.codePointAt(v), S = e(x);
        V[v] = S, i[S] || I.has(S) || I.set(S, ie(S).then(function(A) {
          i[S] = A;
        })), x > 65535 && (v++, E = v);
      }, E = 0; E < _.length; E++) G(E);
      return Promise.all(I.values()).then(function() {
        I.clear();
        for (var v = function(S) {
          var A = _.codePointAt(S), k = null, z = i[V[S]], C2 = void 0;
          for (var P in z) {
            var H = F[P];
            if (H === void 0 && (H = F[P] = new RegExp(P).test(D || "en")), H) {
              for (var $ in C2 = P, z[P]) if (n(A, z[P][$])) {
                k = $;
                break;
              }
              break;
            }
          }
          if (!k) {
            e: for (var X in z) if (X !== C2) {
              for (var N in z[X]) if (n(A, z[X][N])) {
                k = N;
                break e;
              }
            }
          }
          k || (console.debug("No font coverage for U+" + A.toString(16)), k = "latin"), V[S] = k, s[k] || I.has(k) || I.set(k, ie("font-meta/" + k + ".json").then(function(pe) {
            s[k] = pe;
          })), A > 65535 && (S++, x = S);
        }, x = 0; x < _.length; x++) v(x);
        return Promise.all(I.values());
      }).then(function() {
        for (var v, x = null, S = 0; S < _.length; S++) {
          var A = _.codePointAt(S);
          if (x && (U(A) || d(x).has(A))) y[S] = y[S - 1];
          else {
            x = s[V[S]];
            var k = R[x.id];
            if (!k) {
              var z = x.typeforms, C2 = m(z, b, "sans-serif"), P = m(z[C2], M, "normal"), H = B((v = z[C2]) === null || v === void 0 ? void 0 : v[P], W);
              k = R[x.id] = O + "/font-files/" + x.id + "/" + C2 + "." + P + "." + H + ".woff";
            }
            var $ = J.get(k);
            $ == null && ($ = J.size, J.set(k, $)), y[S] = $;
          }
          A > 65535 && (S++, y[S] = y[S - 1]);
        }
        return { fontUrls: Array.from(J.keys()), chars: y };
      });
    }, Object.defineProperty(c2, "__esModule", { value: true }), c2;
  })({});
}
function Ca(c2, r) {
  let h = /* @__PURE__ */ Object.create(null), f = /* @__PURE__ */ Object.create(null);
  function t(n, o) {
    let a = (i) => {
      console.error(`Failure loading font ${n}`, i);
    };
    try {
      let i = new XMLHttpRequest();
      i.open("get", n, true), i.responseType = "arraybuffer", i.onload = function() {
        if (i.status >= 400) a(new Error(i.statusText));
        else if (i.status > 0) try {
          let s = c2(i.response);
          s.src = n, o(s);
        } catch (s) {
          a(s);
        }
      }, i.onerror = a, i.send();
    } catch (i) {
      a(i);
    }
  }
  function e(n, o) {
    let a = h[n];
    a ? o(a) : f[n] ? f[n].push(o) : (f[n] = [o], t(n, (i) => {
      i.src = n, h[n] = i, f[n].forEach((s) => s(i)), delete f[n];
    }));
  }
  return function(n, o, { lang: a, fonts: i = [], style: s = "normal", weight: l = "normal", unicodeFontsURL: u } = {}) {
    let d = new Uint8Array(n.length), p = [];
    n.length || U();
    let g = /* @__PURE__ */ new Map(), m = [];
    if (s !== "italic" && (s = "normal"), typeof l != "number" && (l = l === "bold" ? 700 : 400), i && !Array.isArray(i) && (i = [i]), i = i.slice().filter((T) => !T.lang || T.lang.test(a)).reverse(), i.length) {
      let b = 0;
      (function M(W = 0) {
        for (let O = W, J = n.length; O < J; O++) {
          let y = n.codePointAt(O);
          if (b === 1 && p[d[O - 1]].supportsCodePoint(y) || O > 0 && /\s/.test(n[O])) d[O] = d[O - 1], b === 2 && (m[m.length - 1][1] = O);
          else for (let R = d[O], F = i.length; R <= F; R++) if (R === F) {
            let V = b === 2 ? m[m.length - 1] : m[m.length] = [O, O];
            V[1] = O, b = 2;
          } else {
            d[O] = R;
            let { src: V, unicodeRange: I } = i[R];
            if (!I || _(y, I)) {
              let Q = h[V];
              if (!Q) {
                e(V, () => {
                  M(O);
                });
                return;
              }
              if (Q.supportsCodePoint(y)) {
                let ie = g.get(Q);
                typeof ie != "number" && (ie = p.length, p.push(Q), g.set(Q, ie)), d[O] = ie, b = 1;
                break;
              }
            }
          }
          y > 65535 && O + 1 < J && (d[O + 1] = d[O], O++, b === 2 && (m[m.length - 1][1] = O));
        }
        B();
      })();
    } else m.push([0, n.length - 1]), B();
    function B() {
      if (m.length) {
        let T = m.map((w) => n.substring(w[0], w[1] + 1)).join(`
`);
        r.getFontsForString(T, { lang: a || void 0, style: s, weight: l, dataUrl: u }).then(({ fontUrls: w, chars: D }) => {
          let b = p.length, M = 0;
          m.forEach((O) => {
            for (let J = 0, y = O[1] - O[0]; J <= y; J++) d[O[0] + J] = D[M++] + b;
            M++;
          });
          let W = 0;
          w.forEach((O, J) => {
            e(O, (y) => {
              p[J + b] = y, ++W === w.length && U();
            });
          });
        });
      } else U();
    }
    function U() {
      o({ chars: d, fonts: p });
    }
    function _(T, w) {
      for (let D = 0; D < w.length; D++) {
        let [b, M = b] = w[D];
        if (b <= T && T <= M) return true;
      }
      return false;
    }
  };
}
var Ea = it({ name: "FontResolver", dependencies: [Ca, Aa, Da], init(c2, r, h) {
  return c2(r, h());
} });
function Ba(c2, r) {
  let f = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, t = "[^\\S\\u00A0]", e = new RegExp(`${t}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function n({ text: p, lang: g, fonts: m, style: B, weight: U, preResolvedFonts: _, unicodeFontsURL: T }, w) {
    let D = ({ chars: b, fonts: M }) => {
      let W, O, J = [];
      for (let y = 0; y < b.length; y++) b[y] !== O ? (O = b[y], J.push(W = { start: y, end: y, fontObj: M[b[y]] })) : W.end = y;
      w(J);
    };
    _ ? D(_) : c2(p, D, { lang: g, fonts: m, style: B, weight: U, unicodeFontsURL: T });
  }
  function o({ text: p = "", font: g, lang: m, sdfGlyphSize: B = 64, fontSize: U = 400, fontWeight: _ = 1, fontStyle: T = "normal", letterSpacing: w = 0, lineHeight: D = "normal", maxWidth: b = 1 / 0, direction: M, textAlign: W = "left", textIndent: O = 0, whiteSpace: J = "normal", overflowWrap: y = "normal", anchorX: R = 0, anchorY: F = 0, metricsOnly: V = false, unicodeFontsURL: I, preResolvedFonts: Q = null, includeCaretPositions: ie = false, chunkedBoundsSize: G = 8192, colorRanges: E = null }, v) {
    let x = l(), S = { fontLoad: 0, typesetting: 0 };
    p.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), p = p.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), U = +U, w = +w, b = +b, D = D || "normal", O = +O, n({ text: p, lang: m, style: T, weight: _, fonts: typeof g == "string" ? [{ src: g }] : g, unicodeFontsURL: I, preResolvedFonts: Q }, (A) => {
      S.fontLoad = l() - x;
      let k = isFinite(b), z = null, C2 = null, P = null, H = null, $ = null, X = null, N = null, pe = null, ue = 0, Z = 0, ee = J !== "nowrap", se = /* @__PURE__ */ new Map(), j = l(), te = O, q = 0, L = new u(), he = [L];
      A.forEach((re) => {
        let { fontObj: ae } = re, { ascender: fe, descender: de, unitsPerEm: ke, lineGap: Ae2, capHeight: ge, xHeight: me } = ae, le = se.get(ae);
        if (!le) {
          let ce = U / ke, xe = D === "normal" ? (fe - de + Ae2) * ce : D * U, Qe = (xe - (fe - de) * ce) / 2, Te2 = Math.min(xe, (fe - de) * ce), ye = (fe + de) / 2 * ce + Te2 / 2;
          le = { index: se.size, src: ae.src, fontObj: ae, fontSizeMult: ce, unitsPerEm: ke, ascender: fe * ce, descender: de * ce, capHeight: ge * ce, xHeight: me * ce, lineHeight: xe, baseline: -Qe - fe * ce, caretTop: ye, caretBottom: ye - Te2 }, se.set(ae, le);
        }
        let { fontSizeMult: Ue } = le, Se = p.slice(re.start, re.end + 1), Le, _e;
        ae.forEachGlyph(Se, U, w, (ce, xe, Qe, Te2) => {
          xe += q, Te2 += re.start, Le = xe, _e = ce;
          let ye = p.charAt(Te2), De = ce.advanceWidth * Ue, we = L.count, ve2;
          if ("isEmpty" in ce || (ce.isWhitespace = !!ye && new RegExp(t).test(ye), ce.canBreakAfter = !!ye && e.test(ye), ce.isEmpty = ce.xMin === ce.xMax || ce.yMin === ce.yMax || f.test(ye)), !ce.isWhitespace && !ce.isEmpty && Z++, ee && k && !ce.isWhitespace && xe + De + te > b && we) {
            if (L.glyphAt(we - 1).glyphObj.canBreakAfter) ve2 = new u(), te = -xe;
            else for (let Oe = we; Oe--; ) if (Oe === 0 && y === "break-word") {
              ve2 = new u(), te = -xe;
              break;
            } else if (L.glyphAt(Oe).glyphObj.canBreakAfter) {
              ve2 = L.splitAt(Oe + 1);
              let Be = ve2.glyphAt(0).x;
              te -= Be;
              for (let Ce = ve2.count; Ce--; ) ve2.glyphAt(Ce).x -= Be;
              break;
            }
            ve2 && (L.isSoftWrapped = true, L = ve2, he.push(L), ue = b);
          }
          let Fe2 = L.glyphAt(L.count);
          Fe2.glyphObj = ce, Fe2.x = xe + te, Fe2.y = Qe, Fe2.width = De, Fe2.charIndex = Te2, Fe2.fontData = le, ye === `
` && (L = new u(), he.push(L), te = -(xe + De + w * U) + O);
        }), q = Le + _e.advanceWidth * Ue + w * U;
      });
      let K = 0;
      he.forEach((re) => {
        let ae = true;
        for (let fe = re.count; fe--; ) {
          let de = re.glyphAt(fe);
          ae && !de.glyphObj.isWhitespace && (re.width = de.x + de.width, re.width > ue && (ue = re.width), ae = false);
          let { lineHeight: ke, capHeight: Ae2, xHeight: ge, baseline: me } = de.fontData;
          ke > re.lineHeight && (re.lineHeight = ke);
          let le = me - re.baseline;
          le < 0 && (re.baseline += le, re.cap += le, re.ex += le), re.cap = Math.max(re.cap, re.baseline + Ae2), re.ex = Math.max(re.ex, re.baseline + ge);
        }
        re.baseline -= K, re.cap -= K, re.ex -= K, K += re.lineHeight;
      });
      let ne = 0, Y = 0;
      if (R && (typeof R == "number" ? ne = -R : typeof R == "string" && (ne = -ue * (R === "left" ? 0 : R === "center" ? 0.5 : R === "right" ? 1 : i(R)))), F && (typeof F == "number" ? Y = -F : typeof F == "string" && (Y = F === "top" ? 0 : F === "top-baseline" ? -he[0].baseline : F === "top-cap" ? -he[0].cap : F === "top-ex" ? -he[0].ex : F === "middle" ? K / 2 : F === "bottom" ? K : F === "bottom-baseline" ? -he[he.length - 1].baseline : i(F) * K)), !V) {
        let re = r.getEmbeddingLevels(p, M);
        z = new Uint16Array(Z), C2 = new Uint8Array(Z), P = new Float32Array(Z * 2), H = {}, N = [1 / 0, 1 / 0, -1 / 0, -1 / 0], pe = [], ie && (X = new Float32Array(p.length * 4)), E && ($ = new Uint8Array(Z * 3));
        let ae = 0, fe = -1, de = -1, ke, Ae2;
        if (he.forEach((ge, me) => {
          let { count: le, width: Ue } = ge;
          if (le > 0) {
            let Se = 0;
            for (let Te2 = le; Te2-- && ge.glyphAt(Te2).glyphObj.isWhitespace; ) Se++;
            let Le = 0, _e = 0;
            if (W === "center") Le = (ue - Ue) / 2;
            else if (W === "right") Le = ue - Ue;
            else if (W === "justify" && ge.isSoftWrapped) {
              let Te2 = 0;
              for (let ye = le - Se; ye--; ) ge.glyphAt(ye).glyphObj.isWhitespace && Te2++;
              _e = (ue - Ue) / Te2;
            }
            if (_e || Le) {
              let Te2 = 0;
              for (let ye = 0; ye < le; ye++) {
                let De = ge.glyphAt(ye), we = De.glyphObj;
                De.x += Le + Te2, _e !== 0 && we.isWhitespace && ye < le - Se && (Te2 += _e, De.width += _e);
              }
            }
            let ce = r.getReorderSegments(p, re, ge.glyphAt(0).charIndex, ge.glyphAt(ge.count - 1).charIndex);
            for (let Te2 = 0; Te2 < ce.length; Te2++) {
              let [ye, De] = ce[Te2], we = 1 / 0, ve2 = -1 / 0;
              for (let Fe2 = 0; Fe2 < le; Fe2++) if (ge.glyphAt(Fe2).charIndex >= ye) {
                let Oe = Fe2, Be = Fe2;
                for (; Be < le; Be++) {
                  let Ce = ge.glyphAt(Be);
                  if (Ce.charIndex > De) break;
                  Be < le - Se && (we = Math.min(we, Ce.x), ve2 = Math.max(ve2, Ce.x + Ce.width));
                }
                for (let Ce = Oe; Ce < Be; Ce++) {
                  let We = ge.glyphAt(Ce);
                  We.x = ve2 - (We.x + We.width - we);
                }
                break;
              }
            }
            let xe, Qe = (Te2) => xe = Te2;
            for (let Te2 = 0; Te2 < le; Te2++) {
              let ye = ge.glyphAt(Te2);
              xe = ye.glyphObj;
              let De = xe.index, we = re.levels[ye.charIndex] & 1;
              if (we) {
                let ve2 = r.getMirroredCharacter(p[ye.charIndex]);
                ve2 && ye.fontData.fontObj.forEachGlyph(ve2, 0, 0, Qe);
              }
              if (ie) {
                let { charIndex: ve2, fontData: Fe2 } = ye, Oe = ye.x + ne, Be = ye.x + ye.width + ne;
                X[ve2 * 4] = we ? Be : Oe, X[ve2 * 4 + 1] = we ? Oe : Be, X[ve2 * 4 + 2] = ge.baseline + Fe2.caretBottom + Y, X[ve2 * 4 + 3] = ge.baseline + Fe2.caretTop + Y;
                let Ce = ve2 - fe;
                Ce > 1 && s(X, fe, Ce), fe = ve2;
              }
              if (E) {
                let { charIndex: ve2 } = ye;
                for (; ve2 > de; ) de++, E.hasOwnProperty(de) && (Ae2 = E[de]);
              }
              if (!xe.isWhitespace && !xe.isEmpty) {
                let ve2 = ae++, { fontSizeMult: Fe2, src: Oe, index: Be } = ye.fontData, Ce = H[Oe] || (H[Oe] = {});
                Ce[De] || (Ce[De] = { path: xe.path, pathBounds: [xe.xMin, xe.yMin, xe.xMax, xe.yMax] });
                let We = ye.x + ne, qe = ye.y + ge.baseline + Y;
                P[ve2 * 2] = We, P[ve2 * 2 + 1] = qe;
                let Ye = We + xe.xMin * Fe2, $e = qe + xe.yMin * Fe2, nt = We + xe.xMax * Fe2, Je = qe + xe.yMax * Fe2;
                Ye < N[0] && (N[0] = Ye), $e < N[1] && (N[1] = $e), nt > N[2] && (N[2] = nt), Je > N[3] && (N[3] = Je), ve2 % G === 0 && (ke = { start: ve2, end: ve2, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, pe.push(ke)), ke.end++;
                let Re = ke.rect;
                if (Ye < Re[0] && (Re[0] = Ye), $e < Re[1] && (Re[1] = $e), nt > Re[2] && (Re[2] = nt), Je > Re[3] && (Re[3] = Je), z[ve2] = De, C2[ve2] = Be, E) {
                  let at2 = ve2 * 3;
                  $[at2] = Ae2 >> 16 & 255, $[at2 + 1] = Ae2 >> 8 & 255, $[at2 + 2] = Ae2 & 255;
                }
              }
            }
          }
        }), X) {
          let ge = p.length - fe;
          ge > 1 && s(X, fe, ge);
        }
      }
      let be = [];
      se.forEach(({ index: re, src: ae, unitsPerEm: fe, ascender: de, descender: ke, lineHeight: Ae2, capHeight: ge, xHeight: me }) => {
        be[re] = { src: ae, unitsPerEm: fe, ascender: de, descender: ke, lineHeight: Ae2, capHeight: ge, xHeight: me };
      }), S.typesetting = l() - j, v({ glyphIds: z, glyphFontIndices: C2, glyphPositions: P, glyphData: H, fontData: be, caretPositions: X, glyphColors: $, chunkedBounds: pe, fontSize: U, topBaseline: Y + he[0].baseline, blockBounds: [ne, Y - K, ne + ue, Y], visibleBounds: N, timings: S });
    });
  }
  function a(p, g) {
    o({ ...p, metricsOnly: true }, (m) => {
      let [B, U, _, T] = m.blockBounds;
      g({ width: _ - B, height: T - U });
    });
  }
  function i(p) {
    let g = p.match(/^([\d.]+)%$/), m = g ? parseFloat(g[1]) : NaN;
    return isNaN(m) ? 0 : m / 100;
  }
  function s(p, g, m) {
    let B = p[g * 4], U = p[g * 4 + 1], _ = p[g * 4 + 2], T = p[g * 4 + 3], w = (U - B) / m;
    for (let D = 0; D < m; D++) {
      let b = (g + D) * 4;
      p[b] = B + w * D, p[b + 1] = B + w * (D + 1), p[b + 2] = _, p[b + 3] = T;
    }
  }
  function l() {
    return (self.performance || Date).now();
  }
  function u() {
    this.data = [];
  }
  let d = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return u.prototype = { width: 0, lineHeight: 0, baseline: 0, cap: 0, ex: 0, isSoftWrapped: false, get count() {
    return Math.ceil(this.data.length / d.length);
  }, glyphAt(p) {
    let g = u.flyweight;
    return g.data = this.data, g.index = p, g;
  }, splitAt(p) {
    let g = new u();
    return g.data = this.data.splice(p * d.length), g;
  } }, u.flyweight = d.reduce((p, g, m, B) => (Object.defineProperty(p, g, { get() {
    return this.data[this.index * d.length + m];
  }, set(U) {
    this.data[this.index * d.length + m] = U;
  } }), p), { data: null, index: 0 }), { typeset: o, measure: a };
}
var lt = () => (self.performance || Date).now();
var $t = Mr();
var Rn;
function Oa(c2, r, h, f, t, e, n, o, a, i, s = true) {
  return s ? La(c2, r, h, f, t, e, n, o, a, i).then(null, (l) => (Rn || (console.warn("WebGL SDF generation failed, falling back to JS", l), Rn = true), Gn(c2, r, h, f, t, e, n, o, a, i))) : Gn(c2, r, h, f, t, e, n, o, a, i);
}
var Qt = [];
var Ra = 5;
var Or = 0;
function Hn() {
  let c2 = lt();
  for (; Qt.length && lt() - c2 < Ra; ) Qt.shift()();
  Or = Qt.length ? setTimeout(Hn, 0) : 0;
}
var La = (...c2) => new Promise((r, h) => {
  Qt.push(() => {
    let f = lt();
    try {
      $t.webgl.generateIntoCanvas(...c2), r({ timing: lt() - f });
    } catch (t) {
      h(t);
    }
  }), Or || (Or = setTimeout(Hn, 0));
});
var Ga = 4;
var Pa = 2e3;
var Ln = {};
var Ia = 0;
function Gn(c2, r, h, f, t, e, n, o, a, i) {
  let s = "TroikaTextSDFGenerator_JS_" + Ia++ % Ga, l = Ln[s];
  return l || (l = Ln[s] = { workerModule: it({ name: s, workerId: s, dependencies: [Mr, lt], init(u, d) {
    let p = u().javascript.generate;
    return function(...g) {
      let m = d();
      return { textureData: p(...g), timing: d() - m };
    };
  }, getTransferables(u) {
    return [u.textureData.buffer];
  } }), requests: 0, idleTimer: null }), l.requests++, clearTimeout(l.idleTimer), l.workerModule(c2, r, h, f, t, e).then(({ textureData: u, timing: d }) => {
    let p = lt(), g = new Uint8Array(u.length * 4);
    for (let m = 0; m < u.length; m++) g[m * 4 + i] = u[m];
    return $t.webglUtils.renderImageData(n, g, o, a, c2, r, 1 << 3 - i), d += lt() - p, --l.requests === 0 && (l.idleTimer = setTimeout(() => {
      An(s);
    }, Pa)), { timing: d };
  });
}
function za(c2) {
  c2._warm || ($t.webgl.isSupported(c2), c2._warm = true);
}
var Wa = $t.webglUtils.resizeWebGLCanvasWithoutClearing;
var rt = { defaultFontURL: null, unicodeFontsURL: null, sdfGlyphSize: 64, sdfMargin: 1 / 16, sdfExponent: 9, textureWidth: 2048, useWorker: true };
var Na = new Nt();
var Yn = false;
function vt() {
  return (self.performance || Date).now();
}
function Jn(c2) {
  Yn ? console.warn("configureTextBuilder called after first font request; will be ignored.") : Qn(rt, c2);
}
var Pn = /* @__PURE__ */ Object.create(null);
function Kn(c2, r) {
  Yn = true, c2 = Qn({}, c2);
  let h = vt(), { defaultFontURL: f } = rt, t = [];
  if (f && t.push({ label: "default", src: In(f) }), c2.font && t.push({ label: "user", src: In(c2.font) }), c2.font = t, c2.text = "" + c2.text, c2.sdfGlyphSize = c2.sdfGlyphSize || rt.sdfGlyphSize, c2.unicodeFontsURL = c2.unicodeFontsURL || rt.unicodeFontsURL, c2.colorRanges != null) {
    let d = {};
    for (let p in c2.colorRanges) if (c2.colorRanges.hasOwnProperty(p)) {
      let g = c2.colorRanges[p];
      typeof g != "number" && (g = Na.set(g).getHex()), d[p] = g;
    }
    c2.colorRanges = d;
  }
  Object.freeze(c2);
  let { textureWidth: e, sdfExponent: n } = rt, { sdfGlyphSize: o } = c2, a = e / o * 4, i = Pn[o];
  if (!i) {
    let d = document.createElement("canvas");
    d.width = e, d.height = o * 256 / a, i = Pn[o] = { glyphCount: 0, sdfGlyphSize: o, sdfCanvas: d, sdfTexture: new Ae(d, void 0, void 0, void 0, tn, tn), contextLost: false, glyphsByFont: /* @__PURE__ */ new Map() }, i.sdfTexture.generateMipmaps = false, Va(i);
  }
  let { sdfTexture: s, sdfCanvas: l } = i;
  (rt.useWorker ? $n : Xa)(c2).then((d) => {
    let { glyphIds: p, glyphFontIndices: g, fontData: m, glyphPositions: B, fontSize: U, timings: _ } = d, T = [], w = new Float32Array(p.length * 4), D = 0, b = 0, M = vt(), W = m.map((F) => {
      let V = i.glyphsByFont.get(F.src);
      return V || i.glyphsByFont.set(F.src, V = /* @__PURE__ */ new Map()), V;
    });
    p.forEach((F, V) => {
      let I = g[V], { src: Q, unitsPerEm: ie } = m[I], G = W[I].get(F);
      if (!G) {
        let { path: A, pathBounds: k } = d.glyphData[Q][F], z = Math.max(k[2] - k[0], k[3] - k[1]) / o * (rt.sdfMargin * o + 0.5), C2 = i.glyphCount++, P = [k[0] - z, k[1] - z, k[2] + z, k[3] + z];
        W[I].set(F, G = { path: A, atlasIndex: C2, sdfViewBox: P }), T.push(G);
      }
      let { sdfViewBox: E } = G, v = B[b++], x = B[b++], S = U / ie;
      w[D++] = v + E[0] * S, w[D++] = x + E[1] * S, w[D++] = v + E[2] * S, w[D++] = x + E[3] * S, p[V] = G.atlasIndex;
    }), _.quads = (_.quads || 0) + (vt() - M);
    let O = vt();
    _.sdf = {};
    let J = l.height, y = Math.ceil(i.glyphCount / a), R = Math.pow(2, Math.ceil(Math.log2(y * o)));
    R > J && (console.info(`Increasing SDF texture size ${J}->${R}`), Wa(l, e, R), s.dispose()), Promise.all(T.map((F) => Zn(F, i, c2.gpuAccelerateSDF).then(({ timing: V }) => {
      _.sdf[F.atlasIndex] = V;
    }))).then(() => {
      T.length && !i.contextLost && (qn(i), s.needsUpdate = true), _.sdfTotal = vt() - O, _.total = vt() - h, r(Object.freeze({ parameters: c2, sdfTexture: s, sdfGlyphSize: o, sdfExponent: n, glyphBounds: w, glyphAtlasIndices: p, glyphColors: d.glyphColors, caretPositions: d.caretPositions, chunkedBounds: d.chunkedBounds, ascender: d.ascender, descender: d.descender, lineHeight: d.lineHeight, capHeight: d.capHeight, xHeight: d.xHeight, topBaseline: d.topBaseline, blockBounds: d.blockBounds, visibleBounds: d.visibleBounds, timings: d.timings }));
    });
  }), Promise.resolve().then(() => {
    i.contextLost || za(l);
  });
}
function Zn({ path: c2, atlasIndex: r, sdfViewBox: h }, { sdfGlyphSize: f, sdfCanvas: t, contextLost: e }, n) {
  if (e) return Promise.resolve({ timing: -1 });
  let { textureWidth: o, sdfExponent: a } = rt, i = Math.max(h[2] - h[0], h[3] - h[1]), s = Math.floor(r / 4), l = s % (o / f) * f, u = Math.floor(s / (o / f)) * f, d = r % 4;
  return Oa(f, f, c2, h, i, a, t, l, u, d, n);
}
function Va(c2) {
  let r = c2.sdfCanvas;
  r.addEventListener("webglcontextlost", (h) => {
    console.log("Context Lost", h), h.preventDefault(), c2.contextLost = true;
  }), r.addEventListener("webglcontextrestored", (h) => {
    console.log("Context Restored", h), c2.contextLost = false;
    let f = [];
    c2.glyphsByFont.forEach((t) => {
      t.forEach((e) => {
        f.push(Zn(e, c2, true));
      });
    }), Promise.all(f).then(() => {
      qn(c2), c2.sdfTexture.needsUpdate = true;
    });
  });
}
function Pr({ font: c2, characters: r, sdfGlyphSize: h }, f) {
  let t = Array.isArray(r) ? r.join(`
`) : "" + r;
  Kn({ font: c2, sdfGlyphSize: h, text: t }, f);
}
function Qn(c2, r) {
  for (let h in r) r.hasOwnProperty(h) && (c2[h] = r[h]);
  return c2;
}
var Kt;
function In(c2) {
  return Kt || (Kt = typeof document > "u" ? {} : document.createElement("a")), Kt.href = c2, Kt.href;
}
function qn(c2) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    let { sdfCanvas: r, sdfTexture: h } = c2, { width: f, height: t } = r, e = c2.sdfCanvas.getContext("webgl"), n = h.image.data;
    (!n || n.length !== f * t * 4) && (n = new Uint8Array(f * t * 4), h.image = { width: f, height: t, data: n }, h.flipY = false, h.isDataTexture = true), e.readPixels(0, 0, f, t, e.RGBA, e.UNSIGNED_BYTE, n);
  }
}
var ja = it({ name: "Typesetter", dependencies: [Ba, Ea, Dn], init(c2, r, h) {
  return c2(r, h());
} });
var $n = it({ name: "Typesetter", dependencies: [ja], init(c2) {
  return function(r) {
    return new Promise((h) => {
      c2.typeset(r, h);
    });
  };
}, getTransferables(c2) {
  let r = [];
  for (let h in c2) c2[h] && c2[h].buffer && r.push(c2[h].buffer);
  return r;
} });
var Xa = $n.onMainThread;
var zn = {};
function Ha(c2) {
  let r = zn[c2];
  return r || (r = zn[c2] = new Ls(1, 1, c2, c2).translate(0.5, 0.5, 0)), r;
}
var qt = "aTroikaGlyphBounds";
var Bt = "aTroikaGlyphIndex";
var Ya = "aTroikaGlyphColor";
var Rr = class extends yl {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [{ start: 0, count: 1 / 0, materialIndex: 0 }, { start: 0, count: 1 / 0, materialIndex: 1 }], this.boundingSphere = new Te(), this.boundingBox = new Ie();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  set detail(r) {
    if (r !== this._detail) {
      this._detail = r, (typeof r != "number" || r < 1) && (r = 1);
      let h = Ha(r);
      ["position", "normal", "uv"].forEach((f) => {
        this.attributes[f] = h.attributes[f].clone();
      }), this.setIndex(h.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(r) {
    r !== this._curveRadius && (this._curveRadius = r, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  updateGlyphs(r, h, f, t, e) {
    this.updateAttributeData(qt, r, 4), this.updateAttributeData(Bt, h, 1), this.updateAttributeData(Ya, e, 3), this._blockBounds = f, this._chunkedBounds = t, this.instanceCount = h.length, this._updateBounds();
  }
  _updateBounds() {
    let r = this._blockBounds;
    if (r) {
      let { curveRadius: h, boundingBox: f } = this;
      if (h) {
        let { PI: t, floor: e, min: n, max: o, sin: a, cos: i } = Math, s = t / 2, l = t * 2, u = Math.abs(h), d = r[0] / u, p = r[2] / u, g = e((d + s) / l) !== e((p + s) / l) ? -u : n(a(d) * u, a(p) * u), m = e((d - s) / l) !== e((p - s) / l) ? u : o(a(d) * u, a(p) * u), B = e((d + t) / l) !== e((p + t) / l) ? u * 2 : o(u - i(d) * u, u - i(p) * u);
        f.min.set(g, r[1], h < 0 ? -B : 0), f.max.set(m, r[3], h < 0 ? 0 : B);
      } else f.min.set(r[0], r[1], 0), f.max.set(r[2], r[3], 0);
      f.getBoundingSphere(this.boundingSphere);
    }
  }
  applyClipRect(r) {
    let h = this.getAttribute(Bt).count, f = this._chunkedBounds;
    if (f) for (let t = f.length; t--; ) {
      h = f[t].end;
      let e = f[t].rect;
      if (e[1] < r.w && e[3] > r.y && e[0] < r.z && e[2] > r.x) break;
    }
    this.instanceCount = h;
  }
  updateAttributeData(r, h, f) {
    let t = this.getAttribute(r);
    h ? t && t.array.length === h.length ? (t.array.set(h), t.needsUpdate = true) : (this.setAttribute(r, new vs(h, f)), delete this._maxInstanceCount, this.dispose()) : t && this.deleteAttribute(r);
  }
};
var Ja = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaEdgeOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`;
var Ka = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`;
var Za = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaEdgeOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`;
var Qa = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function ea(c2) {
  let r = dt(c2, { chained: true, extensions: { derivatives: true }, uniforms: { uTroikaSDFTexture: { value: null }, uTroikaSDFTextureSize: { value: new at() }, uTroikaSDFGlyphSize: { value: 0 }, uTroikaSDFExponent: { value: 0 }, uTroikaTotalBounds: { value: new Jt(0, 0, 0, 0) }, uTroikaClipRect: { value: new Jt(0, 0, 0, 0) }, uTroikaEdgeOffset: { value: 0 }, uTroikaFillOpacity: { value: 1 }, uTroikaPositionOffset: { value: new at() }, uTroikaCurveRadius: { value: 0 }, uTroikaBlurRadius: { value: 0 }, uTroikaStrokeWidth: { value: 0 }, uTroikaStrokeColor: { value: new Nt() }, uTroikaStrokeOpacity: { value: 1 }, uTroikaOrient: { value: new Ot() }, uTroikaUseGlyphColors: { value: true }, uTroikaSDFDebug: { value: false } }, vertexDefs: Ja, vertexTransform: Ka, fragmentDefs: Za, fragmentColorTransform: Qa, customRewriter({ vertexShader: h, fragmentShader: f }) {
    let t = /\buniform\s+vec3\s+diffuse\b/;
    return t.test(f) && (f = f.replace(t, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), t.test(h) || (h = h.replace(Dr, `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`))), { vertexShader: h, fragmentShader: f };
  } });
  return r.transparent = true, r.forceSinglePass = true, Object.defineProperties(r, { isTroikaTextMaterial: { value: true }, shadowSide: { get() {
    return this.side;
  }, set() {
  } } }), r;
}
var Ir = new ps({ color: 16777215, side: ln, transparent: true });
var Wn = 8421504;
var Nn = new kt();
var Zt = new C();
var Cr = new C();
var Et = [];
var qa = new C();
var Er = "+x+y";
function Vn(c2) {
  return Array.isArray(c2) ? c2[0] : c2;
}
var ta = () => {
  let c2 = new ve(new Ls(1, 1), Ir);
  return ta = () => c2, c2;
};
var ra = () => {
  let c2 = new ve(new Ls(1, 1, 32, 1), Ir);
  return ra = () => c2, c2;
};
var $a = { type: "syncstart" };
var eo = { type: "synccomplete" };
var na = ["font", "fontSize", "fontStyle", "fontWeight", "lang", "letterSpacing", "lineHeight", "maxWidth", "overflowWrap", "text", "direction", "textAlign", "textIndent", "whiteSpace", "anchorX", "anchorY", "colorRanges", "sdfGlyphSize"];
var to = na.concat("material", "color", "depthOffset", "clipRect", "curveRadius", "orientation", "glyphGeometryDetail");
var Ze = class extends ve {
  constructor() {
    let r = new Rr();
    super(r, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.unicodeFontsURL = null, this.fontSize = 0.1, this.fontWeight = "normal", this.fontStyle = "normal", this.lang = null, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = Wn, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = Er, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = true, this.debugSDF = false;
  }
  sync(r) {
    this._needsSync && (this._needsSync = false, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(r) : (this._isSyncing = true, this.dispatchEvent($a), Kn({ text: this.text, font: this.font, lang: this.lang, fontSize: this.fontSize || 0.1, fontWeight: this.fontWeight || "normal", fontStyle: this.fontStyle || "normal", letterSpacing: this.letterSpacing || 0, lineHeight: this.lineHeight || "normal", maxWidth: this.maxWidth, direction: this.direction || "auto", textAlign: this.textAlign, textIndent: this.textIndent, whiteSpace: this.whiteSpace, overflowWrap: this.overflowWrap, anchorX: this.anchorX, anchorY: this.anchorY, colorRanges: this.colorRanges, includeCaretPositions: true, sdfGlyphSize: this.sdfGlyphSize, gpuAccelerateSDF: this.gpuAccelerateSDF, unicodeFontsURL: this.unicodeFontsURL }, (h) => {
      this._isSyncing = false, this._textRenderInfo = h, this.geometry.updateGlyphs(h.glyphBounds, h.glyphAtlasIndices, h.blockBounds, h.chunkedBounds, h.glyphColors);
      let f = this._queuedSyncs;
      f && (this._queuedSyncs = null, this._needsSync = true, this.sync(() => {
        f.forEach((t) => t && t());
      })), this.dispatchEvent(eo), r && r();
    })));
  }
  onBeforeRender(r, h, f, t, e, n) {
    this.sync(), e.isTroikaTextMaterial && this._prepareForRender(e);
  }
  dispose() {
    this.geometry.dispose();
  }
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  createDerivedMaterial(r) {
    return ea(r);
  }
  get material() {
    let r = this._derivedMaterial, h = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = Ir.clone());
    if ((!r || !r.isDerivedFrom(h)) && (r = this._derivedMaterial = this.createDerivedMaterial(h), h.addEventListener("dispose", function f() {
      h.removeEventListener("dispose", f), r.dispose();
    })), this.hasOutline()) {
      let f = r._outlineMtl;
      return f || (f = r._outlineMtl = Object.create(r, { id: { value: r.id + 0.1 } }), f.isTextOutlineMaterial = true, f.depthWrite = false, f.map = null, r.addEventListener("dispose", function t() {
        r.removeEventListener("dispose", t), f.dispose();
      })), [f, r];
    } else return r;
  }
  set material(r) {
    r && r.isTroikaTextMaterial ? (this._derivedMaterial = r, this._baseMaterial = r.baseMaterial) : this._baseMaterial = r;
  }
  hasOutline() {
    return !!(this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY);
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(r) {
    this.geometry.detail = r;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(r) {
    this.geometry.curveRadius = r;
  }
  get customDepthMaterial() {
    return Vn(this.material).getDepthMaterial();
  }
  set customDepthMaterial(r) {
  }
  get customDistanceMaterial() {
    return Vn(this.material).getDistanceMaterial();
  }
  set customDistanceMaterial(r) {
  }
  _prepareForRender(r) {
    let h = r.isTextOutlineMaterial, f = r.uniforms, t = this.textRenderInfo;
    if (t) {
      let { sdfTexture: o, blockBounds: a } = t;
      f.uTroikaSDFTexture.value = o, f.uTroikaSDFTextureSize.value.set(o.image.width, o.image.height), f.uTroikaSDFGlyphSize.value = t.sdfGlyphSize, f.uTroikaSDFExponent.value = t.sdfExponent, f.uTroikaTotalBounds.value.fromArray(a), f.uTroikaUseGlyphColors.value = !h && !!t.glyphColors;
      let i = 0, s = 0, l = 0, u, d, p, g = 0, m = 0;
      if (h) {
        let { outlineWidth: U, outlineOffsetX: _, outlineOffsetY: T, outlineBlur: w, outlineOpacity: D } = this;
        i = this._parsePercent(U) || 0, s = Math.max(0, this._parsePercent(w) || 0), u = D, g = this._parsePercent(_) || 0, m = this._parsePercent(T) || 0;
      } else l = Math.max(0, this._parsePercent(this.strokeWidth) || 0), l && (p = this.strokeColor, f.uTroikaStrokeColor.value.set(p ?? Wn), d = this.strokeOpacity, d == null && (d = 1)), u = this.fillOpacity;
      f.uTroikaEdgeOffset.value = i, f.uTroikaPositionOffset.value.set(g, m), f.uTroikaBlurRadius.value = s, f.uTroikaStrokeWidth.value = l, f.uTroikaStrokeOpacity.value = d, f.uTroikaFillOpacity.value = u ?? 1, f.uTroikaCurveRadius.value = this.curveRadius || 0;
      let B = this.clipRect;
      if (B && Array.isArray(B) && B.length === 4) f.uTroikaClipRect.value.fromArray(B);
      else {
        let U = (this.fontSize || 0.1) * 100;
        f.uTroikaClipRect.value.set(a[0] - U, a[1] - U, a[2] + U, a[3] + U);
      }
      this.geometry.applyClipRect(f.uTroikaClipRect.value);
    }
    f.uTroikaSDFDebug.value = !!this.debugSDF, r.polygonOffset = !!this.depthOffset, r.polygonOffsetFactor = r.polygonOffsetUnits = this.depthOffset || 0;
    let e = h ? this.outlineColor || 0 : this.color;
    if (e == null) delete r.color;
    else {
      let o = r.hasOwnProperty("color") ? r.color : r.color = new Nt();
      (e !== o._input || typeof e == "object") && o.set(o._input = e);
    }
    let n = this.orientation || Er;
    if (n !== r._orientation) {
      let o = f.uTroikaOrient.value;
      n = n.replace(/[^-+xyz]/g, "");
      let a = n !== Er && n.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (a) {
        let [, i, s, l, u] = a;
        Zt.set(0, 0, 0)[s] = i === "-" ? 1 : -1, Cr.set(0, 0, 0)[u] = l === "-" ? -1 : 1, Nn.lookAt(qa, Zt.cross(Cr), Cr), o.setFromMatrix4(Nn);
      } else o.identity();
      r._orientation = n;
    }
  }
  _parsePercent(r) {
    if (typeof r == "string") {
      let h = r.match(/^(-?[\d.]+)%$/), f = h ? parseFloat(h[1]) : NaN;
      r = (isNaN(f) ? 0 : f / 100) * this.fontSize;
    }
    return r;
  }
  localPositionToTextCoords(r, h = new at()) {
    h.copy(r);
    let f = this.curveRadius;
    return f && (h.x = Math.atan2(r.x, Math.abs(f) - Math.abs(r.z)) * Math.abs(f)), h;
  }
  worldPositionToTextCoords(r, h = new at()) {
    return Zt.copy(r), this.localPositionToTextCoords(this.worldToLocal(Zt), h);
  }
  raycast(r, h) {
    let { textRenderInfo: f, curveRadius: t } = this;
    if (f) {
      let e = f.blockBounds, n = t ? ra() : ta(), o = n.geometry, { position: a, uv: i } = o.attributes;
      for (let s = 0; s < i.count; s++) {
        let l = e[0] + i.getX(s) * (e[2] - e[0]), u = e[1] + i.getY(s) * (e[3] - e[1]), d = 0;
        t && (d = t - Math.cos(l / t) * t, l = Math.sin(l / t) * t), a.setXYZ(s, l, u, d);
      }
      o.boundingSphere = this.geometry.boundingSphere, o.boundingBox = this.geometry.boundingBox, n.matrixWorld = this.matrixWorld, n.material.side = this.material.side, Et.length = 0, n.raycast(r, Et);
      for (let s = 0; s < Et.length; s++) Et[s].object = this, h.push(Et[s]);
    }
  }
  copy(r) {
    let h = this.geometry;
    return super.copy(r), this.geometry = h, to.forEach((f) => {
      this[f] = r[f];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
na.forEach((c2) => {
  let r = "_private_" + c2;
  Object.defineProperty(Ze.prototype, c2, { get() {
    return this[r];
  }, set(h) {
    h !== this[r] && (this[r] = h, this._needsSync = true);
  } });
});
var ro = { type: "syncstart" };
var no = { type: "synccomplete" };
var pt = "aTroikaTextBatchMemberIndex";
var Lr = 32;
var jn = new Ie();
var Xn = new Nt();
var Gr = class c extends Ze {
  constructor() {
    super(), this._members = /* @__PURE__ */ new Map(), this._dataTextures = {}, this._onMemberSynced = (r) => {
      this._members.get(r.target).dirty = true;
    };
  }
  add(...r) {
    for (let h = 0; h < r.length; h++) r[h] instanceof Ze ? this.addText(r[h]) : super.add(r[h]);
    return this;
  }
  remove(...r) {
    for (let h = 0; h < r.length; h++) r[h] instanceof Ze ? this.removeText(r[h]) : super.remove(r[h]);
    return this;
  }
  addText(r) {
    this._members.has(r) || (this._members.set(r, { index: -1, glyphCount: -1, dirty: true }), r.addEventListener("synccomplete", this._onMemberSynced));
  }
  removeText(r) {
    this._needsRepack = true, r.removeEventListener("synccomplete", this._onMemberSynced), this._members.delete(r);
  }
  createDerivedMaterial(r) {
    return ao(r);
  }
  updateMatrixWorld(r) {
    super.updateMatrixWorld(r), this.updateBounds();
  }
  updateBounds() {
    let r = this.geometry.boundingBox.makeEmpty();
    this._members.forEach((h, f) => {
      f.matrixAutoUpdate && f.updateMatrix(), jn.copy(f.geometry.boundingBox).applyMatrix4(f.matrix), r.union(jn);
    }), r.getBoundingSphere(this.geometry.boundingSphere);
  }
  hasOutline() {
    for (let r of this._members.keys()) if (r.hasOutline()) return true;
    return false;
  }
  _prepareForRender(r) {
    let h = r.isTextOutlineMaterial;
    r.uniforms.uTroikaIsOutline.value = h;
    let f = this._dataTextures[h ? "outline" : "main"], t = Math.pow(2, Math.ceil(Math.log2(this._members.size * Lr)));
    if (!f || t !== f.image.data.length) {
      f && f.dispose();
      let o = Math.min(t / 4, 1024);
      f = this._dataTextures[h ? "outline" : "main"] = new On(new Float32Array(t), o, t / 4 / o, Pe, Fe);
    }
    let e = f.image.data, n = (o, a) => {
      a !== e[o] && (e[o] = a, f.needsUpdate = true);
    };
    this._members.forEach(({ index: o, dirty: a }, i) => {
      if (o > -1) {
        let s = o * Lr, l = i.matrix.elements;
        for (let b = 0; b < 16; b++) n(s + b, l[b]);
        i._prepareForRender(r);
        let { uTroikaTotalBounds: u, uTroikaClipRect: d, uTroikaPositionOffset: p, uTroikaEdgeOffset: g, uTroikaBlurRadius: m, uTroikaStrokeWidth: B, uTroikaStrokeColor: U, uTroikaStrokeOpacity: _, uTroikaFillOpacity: T, uTroikaCurveRadius: w } = r.uniforms;
        for (let b = 0; b < 4; b++) n(s + 16 + b, u.value.getComponent(b));
        for (let b = 0; b < 4; b++) n(s + 20 + b, d.value.getComponent(b));
        let D = h ? i.outlineColor || 0 : i.color;
        D == null && (D = this.color), D == null && (D = this.material.color), D == null && (D = 16777215), n(s + 24, Xn.set(D).getHex()), n(s + 25, T.value), n(s + 26, w.value), h ? (n(s + 28, p.value.x), n(s + 29, p.value.y), n(s + 30, g.value), n(s + 31, m.value)) : (n(s + 28, B.value), n(s + 29, Xn.set(U.value).getHex()), n(s + 30, _.value));
      }
    }), r.setMatrixTexture(f), super._prepareForRender(r);
  }
  sync(r) {
    let h = this._needsRepack ? [] : null;
    this._needsRepack = false, this._members.forEach((f, t) => {
      (f.dirty || t._needsSync) && (f.dirty = false, (h || (h = [])).push(new Promise((e) => {
        t._needsSync ? t.sync(e) : e();
      })));
    }), h && (this.dispatchEvent(ro), Promise.all(h).then(() => {
      let { geometry: f } = this, t = f.attributes, e = t[pt] && t[pt].array || new Uint16Array(0), n = t[Bt] && t[Bt].array || new Float32Array(0), o = t[qt] && t[qt].array || new Float32Array(0), a = 0;
      this._members.forEach((l, { textRenderInfo: u }) => {
        u && (a += u.glyphAtlasIndices.length, this._textRenderInfo = u);
      }), a !== e.length && (e = Br(e, a), n = Br(n, a), o = Br(o, a * 4));
      let i = 0, s = 0;
      this._members.forEach((l, { textRenderInfo: u }) => {
        if (u) {
          let d = u.glyphAtlasIndices.length;
          e.fill(i, s, s + d), n.set(u.glyphAtlasIndices, s, s + d), o.set(u.glyphBounds, s * 4, (s + d) * 4), s += d, l.index = i++;
        }
      }), f.updateAttributeData(pt, e, 1), f.getAttribute(pt).setUsage(id), f.updateAttributeData(Bt, n, 1), f.updateAttributeData(qt, o, 4), this.updateBounds(), this.dispatchEvent(no), r && r();
    }));
  }
  copy(r) {
    return r instanceof c && (super.copy(r), this._members.forEach((h, f) => this.removeText(f)), r._members.forEach((h, f) => this.addText(f))), this;
  }
  dispose() {
    super.dispose(), Object.values(this._dataTextures).forEach((r) => r.dispose());
  }
};
function Br(c2, r) {
  let h = new c2.constructor(r);
  return h.set(c2.subarray(0, r)), h;
}
function ao(c2) {
  let r = "uTroikaMatricesTexture", h = "uTroikaMatricesTextureSize", f = dt(c2, { chained: true, uniforms: { [h]: { value: new at() }, [r]: { value: null } }, vertexDefs: `
      uniform highp sampler2D ${r};
      uniform vec2 ${h};
      attribute float ${pt};

      vec4 troikaBatchTexel(float offset) {
        offset += ${pt} * ${Lr.toFixed(1)} / 4.0;
        float w = ${h}.x;
        vec2 uv = (vec2(mod(offset, w), floor(offset / w)) + 0.5) / ${h};
        return texture2D(${r}, uv);
      }
    `, vertexTransform: `
      mat4 matrix = mat4(
        troikaBatchTexel(0.0),
        troikaBatchTexel(1.0),
        troikaBatchTexel(2.0),
        troikaBatchTexel(3.0)
      );
      position.xyz = (matrix * vec4(position, 1.0)).xyz;
    ` });
  return f = ea(f), f = dt(f, { chained: true, uniforms: { uTroikaIsOutline: { value: false } }, customRewriter(t) {
    return ["uTroikaTotalBounds", "uTroikaClipRect", "uTroikaPositionOffset", "uTroikaEdgeOffset", "uTroikaBlurRadius", "uTroikaStrokeWidth", "uTroikaStrokeColor", "uTroikaStrokeOpacity", "uTroikaFillOpacity", "uTroikaCurveRadius", "diffuse"].forEach((n) => {
      t = oo(t, n);
    }), t;
  }, vertexDefs: `
      uniform bool uTroikaIsOutline;
      vec3 troikaFloatToColor(float v) {
        return mod(floor(vec3(v / 65536.0, v / 256.0, v)), 256.0) / 256.0;
      }
    `, vertexTransform: `
      uTroikaTotalBounds = troikaBatchTexel(4.0);
      uTroikaClipRect = troikaBatchTexel(5.0);
      
      vec4 data = troikaBatchTexel(6.0);
      diffuse = troikaFloatToColor(data.x);
      uTroikaFillOpacity = data.y;
      uTroikaCurveRadius = data.z;
      
      data = troikaBatchTexel(7.0);
      if (uTroikaIsOutline) {
        if (data == vec4(0.0)) { // degenerate if zero outline
          position = vec3(0.0);
        } else {
          uTroikaPositionOffset = data.xy;
          uTroikaEdgeOffset = data.z;
          uTroikaBlurRadius = data.w;
        }
      } else {
        uTroikaStrokeWidth = data.x;
        uTroikaStrokeColor = troikaFloatToColor(data.y);
        uTroikaStrokeOpacity = data.z;
      }
    ` }), f.setMatrixTexture = (t) => {
    f.uniforms[r].value = t, f.uniforms[h].value.set(t.image.width, t.image.height);
  }, f;
}
function oo({ vertexShader: c2, fragmentShader: r }, h, f = h) {
  let t = new RegExp(`uniform\\s+(bool|float|vec[234]|mat[34])\\s+${h}\\b`), e, n = false;
  r = r.replace(t, (a, i) => (n = true, `varying ${e = i} ${f}`));
  let o = false;
  return c2 = c2.replace(t, (a, i) => (o = true, `${n ? "varying" : ""} ${e = i} ${f}`)), o || (c2 = `${n ? "varying" : ""} ${e} ${f};
${c2}`), { vertexShader: c2, fragmentShader: r };
}
$i();
var aa = "abcdefghijklmnopqrstuvwxyz";
function oa(c2) {
  return new Promise((r, h) => {
    c2 ? typeof c2 == "string" ? Pr({ font: c2, characters: aa }, () => {
      r(c2);
    }) : h(new Error(`bad fontUrl ${c2}`)) : import("./roboto-regular-R5KXKW73-RSNJIGYL.js").then((f) => {
      Pr({ font: f.default, characters: aa }, () => {
        r(f.default);
      });
    });
  });
}
var zr = 0.1;
var io = new C();
function ia(c2, r, h, f) {
  return r <= 0 || h <= 0 ? Promise.reject(`incoorect dimension [${r}, ${h}]`) : new Promise((t, e) => {
    c2.sync(n);
    function n() {
      if (!c2.geometry.boundingBox) return;
      let { x: o, y: a } = c2.geometry.boundingBox.getSize(io);
      if (a > h || o > r) {
        if (c2.fontSize === zr) return e(`cannot find suitable font size for ${c2.text}. MaxSize: [${r}, ${h}],  Current size: [${o}, ${a}]. min font size${zr}.`);
        c2.fontSize = Math.max(zr, c2.fontSize - f), c2.sync(n);
      } else return t({ size: [o, a] });
    }
  });
}
function so(c2) {
  return new Promise((r) => {
    c2.sync(() => {
      r();
    });
  });
}
async function Wr() {
  return (await import("./roboto-regular-R5KXKW73-RSNJIGYL.js")).default;
}
function Po({ useWorker: c2 = true }) {
  Jn({ useWorker: c2 });
}
var er = new kt();
var He = new C();
var lo = new C(0, 0, 1);
async function Io(c2, r, h, f) {
  let t = r.feature.properties, e = new Ze();
  r.textMesh = e, e.text = t.text, e.anchorX = "center", e.anchorY = "middle", e.textAlign = t.align ?? "center", e.color = t.color ?? "black", e.fontSize = t.fontSize || 20;
  let n = h.font ?? FM.font;
  n ? e.font = n : gt ? e.font = await gt : e.font = await Wr(), e.outlineOpacity = h.outlineOpacity ?? FM.outlineOpacity, e.outlineColor = h.outlineColor ?? FM.outlineColor, e.outlineOffsetY = h.outlineOffsetY ?? FM.outlineOffsetY, e.outlineOffsetX = h.outlineOffsetX ?? FM.outlineOffsetX, e.outlineWidth = h.outlineWidth ?? FM.outlineWidth, e.outlineBlur = h.outlineBlur ?? FM.outlineBlur, e.strokeWidth = h.strokeWidth ?? FM.strokeWidth, e.strokeColor = h.strokeColor ?? FM.strokeColor, e.strokeOpacity = h.strokeOpacity ?? FM.strokeOpacity;
  let o = f(r.feature.geometry.coordinates);
  return e.position.copy(o), e.position.z = t.verticalOffset, e.rotation.z = yd.degToRad(-t.rotation), e.userData = { entityId: c2.toString(), rotationZ: -t.rotation }, { text: e };
}
async function zo(c2, r, h, f) {
  let t = r.feature.properties, { textArea: e } = t;
  if (!e) throw new Error("textArea is required");
  let n = h.margin ?? FM.margin, [o, a, i, s] = Array.isArray(n) ? n : [n, n, n, n], l = new Ze();
  l.text = t.content;
  let u = e.maxHeight - o - i, d = e.maxWidth - s - a;
  l.fontSize = Math.min(u, h.fontSize ?? FM.fontSize), l.color = h.color ?? FM.color, l.maxWidth = h.maxWidth ?? d, l.anchorX = "center", l.anchorY = "middle", l.textAlign = "center";
  let p = h.font ?? FM.font;
  p ? l.font = p : gt ? l.font = await gt : l.font = await Wr(), l.outlineOpacity = h.outlineOpacity ?? FM.outlineOpacity, l.outlineColor = h.outlineColor ?? FM.outlineColor, l.outlineOffsetY = h.outlineOffsetY ?? FM.outlineOffsetY, l.outlineOffsetX = h.outlineOffsetX ?? FM.outlineOffsetX, l.outlineWidth = h.outlineWidth ?? FM.outlineWidth, l.outlineBlur = h.outlineBlur ?? FM.outlineBlur, l.strokeWidth = h.strokeWidth ?? FM.strokeWidth, l.strokeColor = h.strokeColor ?? FM.strokeColor, l.strokeOpacity = h.strokeOpacity ?? FM.strokeOpacity;
  let g = f(e.position, He);
  l.position.copy(g);
  let m = qu(Math.PI / 2 - yd.degToRad(e.rotation));
  l.rotation.z = m, l.userData = { entityId: c2.toString(), rotationZ: m };
  let B, U;
  try {
    U = (await ia(l, d, u, l.fontSize * 0.2)).size;
  } catch (_) {
    throw l.dispose?.(), new Error(`Cannot fit text to area: entityId: ${r.polygonEntityId} ${_}`);
  }
  if (U) return er.identity(), He.set(0, 0, 1), er.makeRotationAxis(lo, m), He.set(e.align === "near" ? s + U[0] / 2 : e.maxWidth / 2, 0, 0), He.applyMatrix4(er), l.position.x -= He.x, l.position.y -= He.y, r.textMesh = l, B && (He.set(e.maxWidth / 2, 0, 0), He.applyMatrix4(er), B.position.x -= He.x, B.position.y -= He.y), { text: l };
}
var gt;
function Wo(c2) {
  return gt = oa(c2), gt;
}
export {
  Gr as BatchedText,
  Ze as Text,
  Po as configureTroikaTextBuilder,
  zo as createTroikaTextArea,
  Io as createTroikaTextPoint,
  gt as fontPreloadLoadPromise,
  Wo as preloadFont,
  so as syncText
};
//# sourceMappingURL=text3d-EZBY7L7A-DFM6IF44.js.map
