{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/lodash.defaultsdeep@4.6.1/node_modules/lodash.defaultsdeep/index.js", "../../src/search/internal.ts", "../../../../node_modules/.pnpm/minisearch@7.2.0/node_modules/minisearch/src/SearchableMap/TreeIterator.ts", "../../../../node_modules/.pnpm/minisearch@7.2.0/node_modules/minisearch/src/SearchableMap/fuzzySearch.ts", "../../../../node_modules/.pnpm/minisearch@7.2.0/node_modules/minisearch/src/SearchableMap/SearchableMap.ts", "../../../../node_modules/.pnpm/minisearch@7.2.0/node_modules/minisearch/src/MiniSearch.ts"],
  "sourcesContent": ["/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeMax = Math.max,\n    nativeNow = Date.now;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack);\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    var isArr = isArray(srcValue),\n        isBuff = !isArr && isBuffer(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      }\n      else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      }\n      else {\n        newValue = [];\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n * objects into destination objects that are passed thru.\n *\n * @private\n * @param {*} objValue The destination value.\n * @param {*} srcValue The source value.\n * @param {string} key The key of the property to merge.\n * @param {Object} object The parent object of `objValue`.\n * @param {Object} source The parent object of `srcValue`.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n * @returns {*} Returns the value to assign.\n */\nfunction customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n  if (isObject(objValue) && isObject(srcValue)) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, objValue);\n    baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n    stack['delete'](srcValue);\n  }\n  return objValue;\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction safeGet(object, key) {\n  if (key === 'constructor' && typeof object[key] === 'function') {\n    return;\n  }\n\n  if (key == '__proto__') {\n    return;\n  }\n\n  return object[key];\n}\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\n/**\n * This method is like `_.defaults` except that it recursively assigns\n * default properties.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 3.10.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaults\n * @example\n *\n * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n * // => { 'a': { 'b': 2, 'c': 3 } }\n */\nvar defaultsDeep = baseRest(function(args) {\n  args.push(undefined, customDefaultsMerge);\n  return apply(mergeWith, undefined, args);\n});\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\n/**\n * This method is like `_.merge` except that it accepts `customizer` which\n * is invoked to produce the merged values of the destination and source\n * properties. If `customizer` returns `undefined`, merging is handled by the\n * method instead. The `customizer` is invoked with six arguments:\n * (objValue, srcValue, key, object, source, stack).\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} sources The source objects.\n * @param {Function} customizer The function to customize assigned values.\n * @returns {Object} Returns `object`.\n * @example\n *\n * function customizer(objValue, srcValue) {\n *   if (_.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * }\n *\n * var object = { 'a': [1], 'b': [2] };\n * var other = { 'a': [3], 'b': [4] };\n *\n * _.mergeWith(object, other, customizer);\n * // => { 'a': [1, 3], 'b': [2, 4] }\n */\nvar mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n  baseMerge(object, source, srcIndex, customizer);\n});\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = defaultsDeep;\n", "import type { SearchResult as MiniSearchResult, Suggestion, MatchInfo } from 'minisearch';\nimport MiniSearch from 'minisearch';\nimport type { Places } from '../map-data-objects';\nimport { EnterpriseLocation, EnterpriseCategory, Facade, FloorStack, Node } from '../map-data-objects';\nimport type MapData from '../map-data';\nimport defaultsDeep from 'lodash.defaultsdeep';\nimport { z } from 'zod';\nimport { debounce } from '@packages/internal/common';\nimport type { RequiredDeep } from 'type-fest';\n\nexport class InternalSearch {\n\tprivate mapData: MapData;\n\tprivate indexes: {\n\t\tplaces: MiniSearch<Places>;\n\t\tenterpriseLocations?: MiniSearch<EnterpriseLocation>;\n\t\tenterpriseCategories?: MiniSearch<EnterpriseCategory>;\n\t};\n\tprivate ready: Promise<any>;\n\n\tconstructor(mapData: MapData) {\n\t\tthis.mapData = mapData;\n\t\tthis.indexes = buildIndexes(mapData);\n\t\tthis.ready = this.populate();\n\t\tthis.#trackSearchDebounced = debounce(this.#trackSearch.bind(this), 2000);\n\t}\n\t#trackSearchDebounced: (term: string) => void;\n\n\t/**\n\t * Populates the search indexes with the map data.\n\t * @returns A promise that resolves when the indexes are populated.\n\t */\n\tasync populate() {\n\t\tconst {\n\t\t\tplaces: placesIndex,\n\t\t\tenterpriseLocations: locationsIndex,\n\t\t\tenterpriseCategories: categoriesIndex,\n\t\t} = this.indexes;\n\t\tconst mapData = this.mapData;\n\t\tlet promises: Promise<any>[] = [];\n\n\t\tplacesIndex.removeAll();\n\t\tpromises = promises.concat([\n\t\t\tplacesIndex.addAllAsync(mapData.getByType('space')),\n\t\t\tplacesIndex.addAllAsync(mapData.getByType('point-of-interest')),\n\t\t\tplacesIndex.addAllAsync(mapData.getByType('object')),\n\t\t\tplacesIndex.addAllAsync(mapData.getByType('connection')),\n\t\t\tplacesIndex.addAllAsync(mapData.getByType('floor')),\n\t\t\tplacesIndex.addAllAsync(mapData.getByType('door')),\n\t\t\tplacesIndex.addAllAsync(mapData.getByType('annotation')),\n\t\t\tplacesIndex.addAllAsync(mapData.getByType('area')),\n\t\t]);\n\n\t\tif (locationsIndex) {\n\t\t\tlocationsIndex?.removeAll();\n\t\t\tpromises.push(locationsIndex.addAllAsync(mapData.getByType('enterprise-location')));\n\t\t}\n\n\t\tif (categoriesIndex) {\n\t\t\tcategoriesIndex?.removeAll();\n\t\t\tpromises.push(categoriesIndex.addAllAsync(mapData.getByType('enterprise-category')));\n\t\t}\n\n\t\treturn Promise.all(promises);\n\t}\n\n\tasync search(term: string, options: SearchOptions = {}): Promise<SearchResult> {\n\t\tawait this.ready;\n\t\tsearchOptionsSchema.parse(options);\n\t\tconst _options: RequiredDeep<SearchOptions> = defaultsDeep({}, options, DEFAULT_CONFIG);\n\n\t\tlet places = this.indexes.places.search(term, {\n\t\t\tfields: Object.keys(_options.places.fields).filter(key => _options.places.fields[key]),\n\t\t});\n\t\tif (_options.places.limit) {\n\t\t\tplaces = places.slice(0, _options.places.limit);\n\t\t}\n\n\t\tlet locations = this.indexes.enterpriseLocations?.search(term, {\n\t\t\tfields: Object.keys(_options.enterpriseLocations.fields).filter(key => _options.enterpriseLocations.fields[key]),\n\t\t});\n\t\tif (locations && _options.enterpriseLocations.limit) {\n\t\t\tlocations = locations.slice(0, _options.enterpriseLocations.limit);\n\t\t}\n\n\t\tlet categories = this.indexes.enterpriseCategories?.search(term, {\n\t\t\tfields: Object.keys(_options.enterpriseCategories.fields).filter(\n\t\t\t\tkey => _options.enterpriseCategories.fields[key],\n\t\t\t),\n\t\t});\n\t\tif (categories && _options.enterpriseCategories.limit) {\n\t\t\tcategories = categories.slice(0, _options.enterpriseCategories.limit);\n\t\t}\n\n\t\tconst result = processSearchResult(this.mapData, {\n\t\t\tplacesResult: places,\n\t\t\tlocationsResult: locations,\n\t\t\tcategoriesResult: categories,\n\t\t});\n\n\t\tthis.#trackSearchDebounced(term);\n\n\t\treturn result;\n\t}\n\n\t#trackSearch(term: string) {\n\t\tthis.mapData.Analytics.capture('$query-search', {\n\t\t\tquery: term,\n\t\t});\n\t}\n\n\tasync suggest(term: string, options: SuggestOptions = {}): Promise<Suggestion[]> {\n\t\tawait this.ready;\n\t\tsuggestOptionsSchema.parse(options);\n\t\tconst suggestions: Suggestion[] = [];\n\n\t\tconst {\n\t\t\tplaces: { enabled: includePlaces = true } = {},\n\t\t\tenterpriseLocations: { enabled: includeLocations = true } = {},\n\t\t} = options;\n\n\t\tif (includeLocations && this.indexes.enterpriseLocations) {\n\t\t\tthis.indexes.enterpriseLocations\n\t\t\t\t.autoSuggest(term, {\n\t\t\t\t\tfields: ['name', 'tags'],\n\t\t\t\t\tcombineWith: 'AND',\n\t\t\t\t\tprefix: true,\n\t\t\t\t\tboost: {\n\t\t\t\t\t\tname: 2,\n\t\t\t\t\t\ttags: 1,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\t.forEach(s => suggestions.push(s));\n\t\t}\n\n\t\tif (includePlaces) {\n\t\t\tthis.indexes.places\n\t\t\t\t.autoSuggest(term, {\n\t\t\t\t\tfields: ['name'],\n\t\t\t\t\tcombineWith: 'AND',\n\t\t\t\t\tprefix: true,\n\t\t\t\t})\n\t\t\t\t.forEach(s => suggestions.push(s));\n\t\t}\n\n\t\tsuggestions.sort((a, b) => b.score - a.score);\n\n\t\tthis.mapData.Analytics.capture('$query-suggest', {\n\t\t\tquery: term,\n\t\t\tsuggestions: suggestions.map(s => s.suggestion),\n\t\t});\n\n\t\t// Sort suggestions by score in descending order\n\t\treturn suggestions;\n\t}\n}\n\nfunction processSearchResult(\n\tmapData: MapData,\n\t{\n\t\tplacesResult,\n\t\tlocationsResult,\n\t\tcategoriesResult,\n\t}: {\n\t\tplacesResult: MiniSearchResult[];\n\t\tlocationsResult?: MiniSearchResult[];\n\t\tcategoriesResult?: MiniSearchResult[];\n\t},\n): SearchResult {\n\tconst places = placesResult.reduce((acc, { id, match, score, __type }) => {\n\t\tconst item = mapData.getById(__type, id);\n\t\tif (\n\t\t\titem != null &&\n\t\t\t!Node.is(item) &&\n\t\t\t!FloorStack.is(item) &&\n\t\t\t!Facade.is(item) &&\n\t\t\t!EnterpriseLocation.is(item) &&\n\t\t\t!EnterpriseCategory.is(item)\n\t\t) {\n\t\t\tacc.push({ type: item.__type, match, score, item });\n\t\t}\n\n\t\treturn acc;\n\t}, [] as SearchResultItem<Places>[]);\n\n\tlet locations: SearchResultItem<EnterpriseLocation>[] | undefined;\n\tif (locationsResult) {\n\t\tlocations = [];\n\t\tfor (const { id, match, score } of locationsResult) {\n\t\t\tconst item = mapData.getById('enterprise-location', id);\n\t\t\tif (item) {\n\t\t\t\tlocations.push({ type: item.__type, match, score, item });\n\t\t\t}\n\t\t}\n\t}\n\n\tlet categories: SearchResultItem<EnterpriseCategory>[] | undefined;\n\tif (categoriesResult) {\n\t\tcategories = [];\n\t\tfor (const { id, match, score } of categoriesResult) {\n\t\t\tconst item = mapData.getById('enterprise-category', id);\n\t\t\tif (item) {\n\t\t\t\tcategories.push({ type: item.__type, match, score, item });\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tplaces,\n\t\tenterpriseLocations: locations,\n\t\tenterpriseCategories: categories,\n\t};\n}\n\nexport type SearchResultItem<T extends Places | EnterpriseLocation | EnterpriseCategory> = {\n\ttype: T['__type'];\n\tmatch: MiniSearchResult['match'];\n\tscore: number;\n\titem: T;\n};\n\n/**\n * @interface\n */\nexport type SearchResultEnterpriseCategory = SearchResultItem<EnterpriseCategory>;\n\n/**\n * @interface\n */\nexport type SearchResultEnterpriseLocations = SearchResultItem<EnterpriseLocation>;\n\n/**\n * @interface\n */\nexport type SearchResultPlaces = SearchResultItem<Places>;\n\n/**\n * Search results\n */\nexport type SearchResult = {\n\t/**\n\t * Places search results\n\t */\n\tplaces: SearchResultPlaces[];\n\t/**\n\t * Enterprise Locations search results\n\t */\n\tenterpriseLocations?: SearchResultEnterpriseLocations[];\n\t/**\n\t * Enterprise Categories search results\n\t */\n\tenterpriseCategories?: SearchResultEnterpriseCategory[];\n};\n\nconst DEFAULT_CONFIG: Readonly<SearchOptions> = {\n\tplaces: {\n\t\tfields: {\n\t\t\tname: true,\n\t\t\tdescription: true,\n\t\t},\n\t},\n\tenterpriseCategories: {\n\t\tfields: {\n\t\t\tname: true,\n\t\t\tdescription: false,\n\t\t\t'locations.name': true,\n\t\t},\n\t},\n\tenterpriseLocations: {\n\t\tfields: {\n\t\t\tname: true,\n\t\t\ttags: true,\n\t\t\tdescription: true,\n\t\t},\n\t},\n};\n\nexport function removeAccents(it: string) {\n\tconst normalizedString = it\n\t\t.normalize('NFD')\n\t\t// eslint-disable-next-line no-useless-escape\n\t\t.replace(/[\\u0300-\\u036f|\\u2019|\\u0027|\\']/g, '')\n\t\t.toLowerCase();\n\n\treturn normalizedString;\n}\n\nfunction buildIndexes(mapData: MapData) {\n\tconst placesIndex = new MiniSearch({\n\t\tfields: ['name', 'description'],\n\t\tstoreFields: ['id', '__type'],\n\t\tsearchOptions: {\n\t\t\tfuzzy: 0.2,\n\t\t\tprefix: true,\n\t\t\tboost: {\n\t\t\t\tname: 2,\n\t\t\t},\n\t\t\tcombineWith: 'AND',\n\t\t},\n\t\textractField: (document, fieldName) => {\n\t\t\tconst value = document[fieldName];\n\t\t\tif (typeof value === 'string') {\n\t\t\t\treturn removeAccents(value);\n\t\t\t}\n\n\t\t\treturn document[fieldName];\n\t\t},\n\t\tprocessTerm: term => (STOP_WORDS.has(term) ? '' : term.toLowerCase()),\n\t});\n\n\tconst locations = mapData.getByType('enterprise-location');\n\tlet locationsIndex: MiniSearch<EnterpriseLocation> | undefined;\n\tif (locations) {\n\t\tlocationsIndex = new MiniSearch({\n\t\t\tfields: ['name', 'tags', 'description'],\n\t\t\tstoreFields: ['id', '__type'],\n\t\t\tsearchOptions: {\n\t\t\t\tcombineWith: 'OR',\n\t\t\t\tprefix: true,\n\t\t\t\tfuzzy: 0.2,\n\t\t\t\tboost: {\n\t\t\t\t\t// we want to boost the name over tags\n\t\t\t\t\tname: 3,\n\t\t\t\t\ttags: 2,\n\t\t\t\t\tdescription: 1,\n\t\t\t\t},\n\t\t\t},\n\t\t\textractField: (document, fieldName) => {\n\t\t\t\tif (Array.isArray(document[fieldName])) {\n\t\t\t\t\treturn document[fieldName].join(' ');\n\t\t\t\t} else if (typeof document[fieldName] === 'string') {\n\t\t\t\t\treturn removeAccents(document[fieldName]);\n\t\t\t\t}\n\n\t\t\t\treturn document[fieldName];\n\t\t\t},\n\t\t});\n\t}\n\n\tconst categories = mapData.getByType('enterprise-category');\n\tlet categoriesIndex: MiniSearch<EnterpriseCategory> | undefined;\n\tif (categories) {\n\t\tcategoriesIndex = new MiniSearch({\n\t\t\tfields: ['name', 'description', 'locations.name'],\n\t\t\tstoreFields: ['id', '__type'],\n\t\t\textractField(document, fieldName) {\n\t\t\t\tif (fieldName === 'locations.name') {\n\t\t\t\t\tconst locations = document['locations'];\n\n\t\t\t\t\treturn locations.reduce((r, t) => r + ` ${DELIMITER} ` + t.name, '') + ` ${DELIMITER}`;\n\t\t\t\t}\n\n\t\t\t\treturn typeof document[fieldName] === 'string' ? removeAccents(document[fieldName]) : document[fieldName];\n\t\t\t},\n\t\t\tsearchOptions: {\n\t\t\t\tcombineWith: 'OR',\n\t\t\t\tprefix: true,\n\t\t\t\tfuzzy: 0.2,\n\t\t\t\tboost: {\n\t\t\t\t\tname: 2,\n\t\t\t\t\t'locations.name': 2,\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\treturn {\n\t\tenterpriseCategories: categoriesIndex,\n\t\tenterpriseLocations: locationsIndex,\n\t\tplaces: placesIndex,\n\t};\n}\n\nconst searchOptionsSchema = z.object({\n\t/**\n\t * Options for searching places.\n\t * @property {Object} [fields] - Fields to search in places.\n\t * @property {boolean} [name] - Whether to search in the name field of places.\n\t * @property {boolean} [description] - Whether to search in the description field of places.\n\t * @property {number} [limit] - Maximum number of place results to return.\n\t */\n\tplaces: z\n\t\t.object({\n\t\t\t/**\n\t\t\t * Fields to search in places.\n\t\t\t * @property {boolean} [name] - Whether to search in the name field of places.\n\t\t\t * @property {boolean} [description] - Whether to search in the description field of places.\n\t\t\t */\n\t\t\tfields: z\n\t\t\t\t.object({\n\t\t\t\t\t/** Enable searching by place name */\n\t\t\t\t\tname: z.boolean().optional(),\n\t\t\t\t\t/** Enable searching by place description */\n\t\t\t\t\tdescription: z.boolean().optional(),\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/** Maximum number of place results to return */\n\t\t\tlimit: z.number().positive().optional(),\n\t\t})\n\t\t.optional(),\n\t/**\n\t * Options for searching categories.\n\t * @property {Object} [fields] - Fields to search in categories.\n\t * @property {boolean} [name] - Whether to search in the name field of categories.\n\t * @property {boolean} [description] - Whether to search in the description field of categories.\n\t * @property {boolean} ['locations.name'] - Whether to search in the locations' names of categories.\n\t * @property {number} [limit] - Maximum number of category results to return.\n\t */\n\tenterpriseCategories: z\n\t\t.object({\n\t\t\t/**\n\t\t\t * Fields to search in categories.\n\t\t\t * @property {boolean} [name] - Whether to search in the name field of categories.\n\t\t\t * @property {boolean} [description] - Whether to search in the description field of categories.\n\t\t\t * @property {boolean} ['locations.name'] - Whether to search in the locations' names of categories.\n\t\t\t */\n\t\t\tfields: z\n\t\t\t\t.object({\n\t\t\t\t\t/** Enable searching by category name */\n\t\t\t\t\tname: z.boolean().optional(),\n\t\t\t\t\t/** Enable searching by category description */\n\t\t\t\t\tdescription: z.boolean().optional(),\n\t\t\t\t\t/** Enable searching by names of locations within the category */\n\t\t\t\t\t'locations.name': z.boolean().optional(),\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/** Maximum number of category results to return */\n\t\t\tlimit: z.number().positive().optional(),\n\t\t})\n\t\t.optional(),\n\t/**\n\t * Options for searching locations.\n\t * @property {Object} [fields] - Fields to search in locations.\n\t * @property {boolean} [name] - Whether to search in the name field of locations.\n\t * @property {boolean} [tags] - Whether to search in the tags field of locations.\n\t * @property {boolean} [description] - Whether to search in the description field of locations.\n\t * @property {number} [limit] - Maximum number of location results to return.\n\t */\n\tenterpriseLocations: z\n\t\t.object({\n\t\t\t/**\n\t\t\t * Fields to search in locations.\n\t\t\t * @property {boolean} [name] - Whether to search in the name field of locations.\n\t\t\t * @property {boolean} [tags] - Whether to search in the tags field of locations.\n\t\t\t * @property {boolean} [description] - Whether to search in the description field of locations.\n\t\t\t */\n\t\t\tfields: z\n\t\t\t\t.object({\n\t\t\t\t\t/** Enable searching by location name */\n\t\t\t\t\tname: z.boolean().optional(),\n\t\t\t\t\t/** Enable searching by location tags */\n\t\t\t\t\ttags: z.boolean().optional(),\n\t\t\t\t\t/** Enable searching by location description */\n\t\t\t\t\tdescription: z.boolean().optional(),\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/** Maximum number of location results to return */\n\t\t\tlimit: z.number().positive().optional(),\n\t\t})\n\t\t.optional(),\n});\nconst suggestOptionsSchema = z.object({\n\t/**\n\t * Options for searching places.\n\t * @property {boolean} [enabled] - Whether to search in places.\n\t */\n\tplaces: z\n\t\t.object({\n\t\t\t/** Enable searching by place name */\n\t\t\tenabled: z.boolean().optional(),\n\t\t})\n\t\t.optional(),\n\t/**\n\t * Options for searching locations.\n\t * @property {boolean} [enabled] - Whether to search in locations.\n\t */\n\tenterpriseLocations: z\n\t\t.object({\n\t\t\t/** Enable searching by location name */\n\t\t\tenabled: z.boolean().optional(),\n\t\t})\n\t\t.optional(),\n});\n\n/**\n * @interface\n */\nexport type SearchOptions = z.infer<typeof searchOptionsSchema>;\n/**\n * @interface\n */\nexport type SuggestOptions = z.infer<typeof suggestOptionsSchema>;\n/**\n *TODO:  handle translation\n */\nconst STOP_WORDS = new Set(['the', 'an', 'and', 'or', 'of', 'in', 'on', 'at', 'to', 'from', 'with', 'by', 'for']);\nconst DELIMITER = '\\u0001';\n\nexport { Suggestion, MatchInfo };\n", "import type { RadixTree, Entry, LeafType } from './types'\n\n/** @ignore */\nconst ENTRIES = 'ENTRIES'\n\n/** @ignore */\nconst KEYS = 'KEYS'\n\n/** @ignore */\nconst VALUES = 'VALUES'\n\n/** @ignore */\nconst LEAF = '' as LeafType\n\ninterface Iterators<T> {\n  ENTRIES: Entry<T>\n  KEYS: string\n  VALUES: T\n}\n\ntype Kind<T> = keyof Iterators<T>\ntype Result<T, K extends keyof Iterators<T>> = Iterators<T>[K]\n\ntype IteratorPath<T> = {\n  node: RadixTree<T>,\n  keys: string[]\n}[]\n\nexport type IterableSet<T> = {\n  _tree: RadixTree<T>,\n  _prefix: string\n}\n\n/**\n * @private\n */\nclass TreeIterator<T, K extends Kind<T>> implements Iterator<Result<T, K>> {\n  set: IterableSet<T>\n  _type: K\n  _path: IteratorPath<T>\n\n  constructor (set: IterableSet<T>, type: K) {\n    const node = set._tree\n    const keys = Array.from(node.keys())\n    this.set = set\n    this._type = type\n    this._path = keys.length > 0 ? [{ node, keys }] : []\n  }\n\n  next (): IteratorResult<Result<T, K>> {\n    const value = this.dive()\n    this.backtrack()\n    return value\n  }\n\n  dive (): IteratorResult<Result<T, K>> {\n    if (this._path.length === 0) { return { done: true, value: undefined } }\n    const { node, keys } = last(this._path)!\n    if (last(keys) === LEAF) { return { done: false, value: this.result() } }\n\n    const child = node.get(last(keys)!)!\n    this._path.push({ node: child, keys: Array.from(child.keys()) })\n    return this.dive()\n  }\n\n  backtrack (): void {\n    if (this._path.length === 0) { return }\n    const keys = last(this._path)!.keys\n    keys.pop()\n    if (keys.length > 0) { return }\n    this._path.pop()\n    this.backtrack()\n  }\n\n  key (): string {\n    return this.set._prefix + this._path\n      .map(({ keys }) => last(keys))\n      .filter(key => key !== LEAF)\n      .join('')\n  }\n\n  value (): T {\n    return last(this._path)!.node.get(LEAF)!\n  }\n\n  result (): Result<T, K> {\n    switch (this._type) {\n      case VALUES: return this.value() as Result<T, K>\n      case KEYS: return this.key() as Result<T, K>\n      default: return [this.key(), this.value()] as Result<T, K>\n    }\n  }\n\n  [Symbol.iterator] () {\n    return this\n  }\n}\n\nconst last = <T>(array: T[]): T | undefined => {\n  return array[array.length - 1]\n}\n\nexport { TreeIterator, ENTRIES, KEYS, VALUES, LEAF }\n", "/* eslint-disable no-labels */\nimport { LEAF } from './TreeIterator'\nimport type { RadixTree } from './types'\n\nexport type FuzzyResult<T> = [T, number]\n\nexport type FuzzyResults<T> = Map<string, FuzzyResult<T>>\n\n/**\n * @ignore\n */\nexport const fuzzySearch = <T = any>(node: RadixTree<T>, query: string, maxDistance: number): FuzzyResults<T> => {\n  const results: FuzzyResults<T> = new Map()\n  if (query === undefined) return results\n\n  // Number of columns in the Levenshtein matrix.\n  const n = query.length + 1\n\n  // Matching terms can never be longer than N + maxDistance.\n  const m = n + maxDistance\n\n  // Fill first matrix row and column with numbers: 0 1 2 3 ...\n  const matrix = new Uint8Array(m * n).fill(maxDistance + 1)\n  for (let j = 0; j < n; ++j) matrix[j] = j\n  for (let i = 1; i < m; ++i) matrix[i * n] = i\n\n  recurse(\n    node,\n    query,\n    maxDistance,\n    results,\n    matrix,\n    1,\n    n,\n    ''\n  )\n\n  return results\n}\n\n// Modified version of http://stevehanov.ca/blog/?id=114\n\n// This builds a Levenshtein matrix for a given query and continuously updates\n// it for nodes in the radix tree that fall within the given maximum edit\n// distance. Keeping the same matrix around is beneficial especially for larger\n// edit distances.\n//\n//           k   a   t   e   <-- query\n//       0   1   2   3   4\n//   c   1   1   2   3   4\n//   a   2   2   1   2   3\n//   t   3   3   2   1  [2]  <-- edit distance\n//   ^\n//   ^ term in radix tree, rows are added and removed as needed\n\nconst recurse = <T = any>(\n  node: RadixTree<T>,\n  query: string,\n  maxDistance: number,\n  results: FuzzyResults<T>,\n  matrix: Uint8Array,\n  m: number,\n  n: number,\n  prefix: string\n): void => {\n  const offset = m * n\n\n  key: for (const key of node.keys()) {\n    if (key === LEAF) {\n      // We've reached a leaf node. Check if the edit distance acceptable and\n      // store the result if it is.\n      const distance = matrix[offset - 1]\n      if (distance <= maxDistance) {\n        results.set(prefix, [node.get(key)!, distance])\n      }\n    } else {\n      // Iterate over all characters in the key. Update the Levenshtein matrix\n      // and check if the minimum distance in the last row is still within the\n      // maximum edit distance. If it is, we can recurse over all child nodes.\n      let i = m\n      for (let pos = 0; pos < key.length; ++pos, ++i) {\n        const char = key[pos]\n        const thisRowOffset = n * i\n        const prevRowOffset = thisRowOffset - n\n\n        // Set the first column based on the previous row, and initialize the\n        // minimum distance in the current row.\n        let minDistance = matrix[thisRowOffset]\n\n        const jmin = Math.max(0, i - maxDistance - 1)\n        const jmax = Math.min(n - 1, i + maxDistance)\n\n        // Iterate over remaining columns (characters in the query).\n        for (let j = jmin; j < jmax; ++j) {\n          const different = char !== query[j]\n\n          // It might make sense to only read the matrix positions used for\n          // deletion/insertion if the characters are different. But we want to\n          // avoid conditional reads for performance reasons.\n          const rpl = matrix[prevRowOffset + j] + +different\n          const del = matrix[prevRowOffset + j + 1] + 1\n          const ins = matrix[thisRowOffset + j] + 1\n\n          const dist = matrix[thisRowOffset + j + 1] = Math.min(rpl, del, ins)\n\n          if (dist < minDistance) minDistance = dist\n        }\n\n        // Because distance will never decrease, we can stop. There will be no\n        // matching child nodes.\n        if (minDistance > maxDistance) {\n          continue key\n        }\n      }\n\n      recurse(\n        node.get(key)!,\n        query,\n        maxDistance,\n        results,\n        matrix,\n        i,\n        n,\n        prefix + key\n      )\n    }\n  }\n}\n\nexport default fuzzySearch\n", "/* eslint-disable no-labels */\nimport { TreeIterator, ENTRIES, KEYS, VALUES, LEAF } from './TreeIterator'\nimport fuzzySearch, { type FuzzyResults } from './fuzzySearch'\nimport type { RadixTree, Entry, Path } from './types'\n\n/**\n * A class implementing the same interface as a standard JavaScript\n * [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n * with string keys, but adding support for efficiently searching entries with\n * prefix or fuzzy search. This class is used internally by {@link MiniSearch}\n * as the inverted index data structure. The implementation is a radix tree\n * (compressed prefix tree).\n *\n * Since this class can be of general utility beyond _MiniSearch_, it is\n * exported by the `minisearch` package and can be imported (or required) as\n * `minisearch/SearchableMap`.\n *\n * @typeParam T  The type of the values stored in the map.\n */\nexport default class SearchableMap<T = any> {\n  /**\n   * @internal\n   */\n  _tree: RadixTree<T>\n\n  /**\n   * @internal\n   */\n  _prefix: string\n\n  private _size: number | undefined = undefined\n\n  /**\n   * The constructor is normally called without arguments, creating an empty\n   * map. In order to create a {@link SearchableMap} from an iterable or from an\n   * object, check {@link SearchableMap.from} and {@link\n   * SearchableMap.fromObject}.\n   *\n   * The constructor arguments are for internal use, when creating derived\n   * mutable views of a map at a prefix.\n   */\n  constructor (tree: RadixTree<T> = new Map(), prefix = '') {\n    this._tree = tree\n    this._prefix = prefix\n  }\n\n  /**\n   * Creates and returns a mutable view of this {@link SearchableMap},\n   * containing only entries that share the given prefix.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * let map = new SearchableMap()\n   * map.set(\"unicorn\", 1)\n   * map.set(\"universe\", 2)\n   * map.set(\"university\", 3)\n   * map.set(\"unique\", 4)\n   * map.set(\"hello\", 5)\n   *\n   * let uni = map.atPrefix(\"uni\")\n   * uni.get(\"unique\") // => 4\n   * uni.get(\"unicorn\") // => 1\n   * uni.get(\"hello\") // => undefined\n   *\n   * let univer = map.atPrefix(\"univer\")\n   * univer.get(\"unique\") // => undefined\n   * univer.get(\"universe\") // => 2\n   * univer.get(\"university\") // => 3\n   * ```\n   *\n   * @param prefix  The prefix\n   * @return A {@link SearchableMap} representing a mutable view of the original\n   * Map at the given prefix\n   */\n  atPrefix (prefix: string): SearchableMap<T> {\n    if (!prefix.startsWith(this._prefix)) { throw new Error('Mismatched prefix') }\n\n    const [node, path] = trackDown(this._tree, prefix.slice(this._prefix.length))\n\n    if (node === undefined) {\n      const [parentNode, key] = last(path)\n\n      for (const k of parentNode!.keys()) {\n        if (k !== LEAF && k.startsWith(key)) {\n          const node = new Map()\n          node.set(k.slice(key.length), parentNode!.get(k)!)\n          return new SearchableMap(node, prefix)\n        }\n      }\n    }\n\n    return new SearchableMap<T>(node, prefix)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear\n   */\n  clear (): void {\n    this._size = undefined\n    this._tree.clear()\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete\n   * @param key  Key to delete\n   */\n  delete (key: string): void {\n    this._size = undefined\n    return remove(this._tree, key)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries\n   * @return An iterator iterating through `[key, value]` entries.\n   */\n  entries () {\n    return new TreeIterator(this, ENTRIES)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach\n   * @param fn  Iteration function\n   */\n  forEach (fn: (key: string, value: T, map: SearchableMap) => void): void {\n    for (const [key, value] of this) {\n      fn(key, value, this)\n    }\n  }\n\n  /**\n   * Returns a Map of all the entries that have a key within the given edit\n   * distance from the search key. The keys of the returned Map are the matching\n   * keys, while the values are two-element arrays where the first element is\n   * the value associated to the key, and the second is the edit distance of the\n   * key to the search key.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * let map = new SearchableMap()\n   * map.set('hello', 'world')\n   * map.set('hell', 'yeah')\n   * map.set('ciao', 'mondo')\n   *\n   * // Get all entries that match the key 'hallo' with a maximum edit distance of 2\n   * map.fuzzyGet('hallo', 2)\n   * // => Map(2) { 'hello' => ['world', 1], 'hell' => ['yeah', 2] }\n   *\n   * // In the example, the \"hello\" key has value \"world\" and edit distance of 1\n   * // (change \"e\" to \"a\"), the key \"hell\" has value \"yeah\" and edit distance of 2\n   * // (change \"e\" to \"a\", delete \"o\")\n   * ```\n   *\n   * @param key  The search key\n   * @param maxEditDistance  The maximum edit distance (Levenshtein)\n   * @return A Map of the matching keys to their value and edit distance\n   */\n  fuzzyGet (key: string, maxEditDistance: number): FuzzyResults<T> {\n    return fuzzySearch<T>(this._tree, key, maxEditDistance)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get\n   * @param key  Key to get\n   * @return Value associated to the key, or `undefined` if the key is not\n   * found.\n   */\n  get (key: string): T | undefined {\n    const node = lookup<T>(this._tree, key)\n    return node !== undefined ? node.get(LEAF) : undefined\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has\n   * @param key  Key\n   * @return True if the key is in the map, false otherwise\n   */\n  has (key: string): boolean {\n    const node = lookup(this._tree, key)\n    return node !== undefined && node.has(LEAF)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys\n   * @return An `Iterable` iterating through keys\n   */\n  keys () {\n    return new TreeIterator(this, KEYS)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set\n   * @param key  Key to set\n   * @param value  Value to associate to the key\n   * @return The {@link SearchableMap} itself, to allow chaining\n   */\n  set (key: string, value: T): SearchableMap<T> {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    this._size = undefined\n    const node = createPath(this._tree, key)\n    node.set(LEAF, value)\n    return this\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size\n   */\n  get size (): number {\n    if (this._size) { return this._size }\n    /** @ignore */\n    this._size = 0\n\n    const iter = this.entries()\n    while (!iter.next().done) this._size! += 1\n\n    return this._size\n  }\n\n  /**\n   * Updates the value at the given key using the provided function. The function\n   * is called with the current value at the key, and its return value is used as\n   * the new value to be set.\n   *\n   * ### Example:\n   *\n   * ```javascript\n   * // Increment the current value by one\n   * searchableMap.update('somekey', (currentValue) => currentValue == null ? 0 : currentValue + 1)\n   * ```\n   *\n   * If the value at the given key is or will be an object, it might not require\n   * re-assignment. In that case it is better to use `fetch()`, because it is\n   * faster.\n   *\n   * @param key  The key to update\n   * @param fn  The function used to compute the new value from the current one\n   * @return The {@link SearchableMap} itself, to allow chaining\n   */\n  update (key: string, fn: (value: T | undefined) => T): SearchableMap<T> {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    this._size = undefined\n    const node = createPath(this._tree, key)\n    node.set(LEAF, fn(node.get(LEAF)))\n    return this\n  }\n\n  /**\n   * Fetches the value of the given key. If the value does not exist, calls the\n   * given function to create a new value, which is inserted at the given key\n   * and subsequently returned.\n   *\n   * ### Example:\n   *\n   * ```javascript\n   * const map = searchableMap.fetch('somekey', () => new Map())\n   * map.set('foo', 'bar')\n   * ```\n   *\n   * @param key  The key to update\n   * @param initial  A function that creates a new value if the key does not exist\n   * @return The existing or new value at the given key\n   */\n  fetch (key: string, initial: () => T): T {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    this._size = undefined\n    const node = createPath(this._tree, key)\n\n    let value = node.get(LEAF)\n    if (value === undefined) {\n      node.set(LEAF, value = initial())\n    }\n\n    return value\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values\n   * @return An `Iterable` iterating through values.\n   */\n  values () {\n    return new TreeIterator(this, VALUES)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator\n   */\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n\n  /**\n   * Creates a {@link SearchableMap} from an `Iterable` of entries\n   *\n   * @param entries  Entries to be inserted in the {@link SearchableMap}\n   * @return A new {@link SearchableMap} with the given entries\n   */\n  static from<T = any> (entries: Iterable<Entry<T>> | Entry<T>[]) {\n    const tree = new SearchableMap()\n    for (const [key, value] of entries) {\n      tree.set(key, value)\n    }\n    return tree\n  }\n\n  /**\n   * Creates a {@link SearchableMap} from the iterable properties of a JavaScript object\n   *\n   * @param object  Object of entries for the {@link SearchableMap}\n   * @return A new {@link SearchableMap} with the given entries\n   */\n  static fromObject<T = any> (object: { [key: string]: T }) {\n    return SearchableMap.from<T>(Object.entries(object))\n  }\n}\n\nconst trackDown = <T = any>(tree: RadixTree<T> | undefined, key: string, path: Path<T> = []): [RadixTree<T> | undefined, Path<T>] => {\n  if (key.length === 0 || tree == null) { return [tree, path] }\n\n  for (const k of tree.keys()) {\n    if (k !== LEAF && key.startsWith(k)) {\n      path.push([tree, k]) // performance: update in place\n      return trackDown(tree.get(k)!, key.slice(k.length), path)\n    }\n  }\n\n  path.push([tree, key]) // performance: update in place\n  return trackDown(undefined, '', path)\n}\n\nconst lookup = <T = any>(tree: RadixTree<T>, key: string): RadixTree<T> | undefined => {\n  if (key.length === 0 || tree == null) { return tree }\n\n  for (const k of tree.keys()) {\n    if (k !== LEAF && key.startsWith(k)) {\n      return lookup(tree.get(k)!, key.slice(k.length))\n    }\n  }\n}\n\n// Create a path in the radix tree for the given key, and returns the deepest\n// node. This function is in the hot path for indexing. It avoids unnecessary\n// string operations and recursion for performance.\nconst createPath = <T = any>(node: RadixTree<T>, key: string): RadixTree<T> => {\n  const keyLength = key.length\n\n  outer: for (let pos = 0; node && pos < keyLength;) {\n    for (const k of node.keys()) {\n      // Check whether this key is a candidate: the first characters must match.\n      if (k !== LEAF && key[pos] === k[0]) {\n        const len = Math.min(keyLength - pos, k.length)\n\n        // Advance offset to the point where key and k no longer match.\n        let offset = 1\n        while (offset < len && key[pos + offset] === k[offset]) ++offset\n\n        const child = node.get(k)!\n        if (offset === k.length) {\n          // The existing key is shorter than the key we need to create.\n          node = child\n        } else {\n          // Partial match: we need to insert an intermediate node to contain\n          // both the existing subtree and the new node.\n          const intermediate = new Map()\n          intermediate.set(k.slice(offset), child)\n          node.set(key.slice(pos, pos + offset), intermediate)\n          node.delete(k)\n          node = intermediate\n        }\n\n        pos += offset\n        continue outer\n      }\n    }\n\n    // Create a final child node to contain the final suffix of the key.\n    const child = new Map()\n    node.set(key.slice(pos), child)\n    return child\n  }\n\n  return node\n}\n\nconst remove = <T = any>(tree: RadixTree<T>, key: string): void => {\n  const [node, path] = trackDown(tree, key)\n  if (node === undefined) { return }\n  node.delete(LEAF)\n\n  if (node.size === 0) {\n    cleanup(path)\n  } else if (node.size === 1) {\n    const [key, value] = node.entries().next().value!\n    merge(path, key as string, value as RadixTree<T>)\n  }\n}\n\nconst cleanup = <T = any>(path: Path<T>): void => {\n  if (path.length === 0) { return }\n\n  const [node, key] = last(path)\n  node!.delete(key)\n\n  if (node!.size === 0) {\n    cleanup(path.slice(0, -1))\n  } else if (node!.size === 1) {\n    const [key, value] = node!.entries().next().value!\n    if (key !== LEAF) {\n      merge(path.slice(0, -1), key as string, value as RadixTree<T>)\n    }\n  }\n}\n\nconst merge = <T = any>(path: Path<T>, key: string, value: RadixTree<T>): void => {\n  if (path.length === 0) { return }\n\n  const [node, nodeKey] = last(path)\n  node!.set(nodeKey + key, value)\n  node!.delete(nodeKey)\n}\n\nconst last = <T = any>(array: T[]): T => {\n  return array[array.length - 1]\n}\n", "import SearchableMap from './SearchableMap/SearchableMap'\n\nexport type LowercaseCombinationOperator = 'or' | 'and' | 'and_not'\nexport type CombinationOperator = LowercaseCombinationOperator | Uppercase<LowercaseCombinationOperator> | Capitalize<LowercaseCombinationOperator>\n\nconst OR: LowercaseCombinationOperator = 'or'\nconst AND: LowercaseCombinationOperator = 'and'\nconst AND_NOT: LowercaseCombinationOperator = 'and_not'\n\n/**\n * Search options to customize the search behavior.\n */\nexport type SearchOptions = {\n  /**\n   * Names of the fields to search in. If omitted, all fields are searched.\n   */\n  fields?: string[],\n\n  /**\n   * Function used to filter search results, for example on the basis of stored\n   * fields. It takes as argument each search result and should return a boolean\n   * to indicate if the result should be kept or not.\n   */\n  filter?: (result: SearchResult) => boolean,\n\n  /**\n   * Key-value object of field names to boosting values. By default, fields are\n   * assigned a boosting factor of 1. If one assigns to a field a boosting value\n   * of 2, a result that matches the query in that field is assigned a score\n   * twice as high as a result matching the query in another field, all else\n   * being equal.\n   */\n  boost?: { [fieldName: string]: number },\n\n  /**\n   * Function to calculate a boost factor for each term.\n   *\n   * This function, if provided, is called for each query term (as split by\n   * `tokenize` and processed by `processTerm`). The arguments passed to the\n   * function are the query term, the positional index of the term in the query,\n   * and the array of all query terms. It is expected to return a numeric boost\n   * factor for the term. A factor lower than 1 reduces the importance of the\n   * term, a factor greater than 1 increases it. A factor of exactly 1 is\n   * neutral, and does not affect the term's importance.\n   */\n  boostTerm?: (term: string, i: number, terms: string[]) => number,\n\n  /**\n   * Relative weights to assign to prefix search results and fuzzy search\n   * results. Exact matches are assigned a weight of 1.\n   */\n  weights?: { fuzzy: number, prefix: number },\n\n  /**\n   * Function to calculate a boost factor for documents. It takes as arguments\n   * the document ID, and a term that matches the search in that document, and\n   * the value of the stored fields for the document (if any).  It should return\n   * a boosting factor: a number higher than 1 increases the computed score, a\n   * number lower than 1 decreases the score, and a falsy value skips the search\n   * result completely.\n   */\n  boostDocument?: (documentId: any, term: string, storedFields?: Record<string, unknown>) => number,\n\n  /**\n   * Controls whether to perform prefix search. It can be a simple boolean, or a\n   * function.\n   *\n   * If a boolean is passed, prefix search is performed if true.\n   *\n   * If a function is passed, it is called upon search with a search term, the\n   * positional index of that search term in the tokenized search query, and the\n   * tokenized search query. The function should return a boolean to indicate\n   * whether to perform prefix search for that search term.\n   */\n  prefix?: boolean | ((term: string, index: number, terms: string[]) => boolean),\n\n  /**\n   * Controls whether to perform fuzzy search. It can be a simple boolean, or a\n   * number, or a function.\n   *\n   * If a boolean is given, fuzzy search with a default fuzziness parameter is\n   * performed if true.\n   *\n   * If a number higher or equal to 1 is given, fuzzy search is performed, with\n   * a maximum edit distance (Levenshtein) equal to the number.\n   *\n   * If a number between 0 and 1 is given, fuzzy search is performed within a\n   * maximum edit distance corresponding to that fraction of the term length,\n   * approximated to the nearest integer. For example, 0.2 would mean an edit\n   * distance of 20% of the term length, so 1 character in a 5-characters term.\n   * The calculated fuzziness value is limited by the `maxFuzzy` option, to\n   * prevent slowdown for very long queries.\n   *\n   * If a function is passed, the function is called upon search with a search\n   * term, a positional index of that term in the tokenized search query, and\n   * the tokenized search query. It should return a boolean or a number, with\n   * the meaning documented above.\n   */\n  fuzzy?: boolean | number | ((term: string, index: number, terms: string[]) => boolean | number),\n\n  /**\n   * Controls the maximum fuzziness when using a fractional fuzzy value. This is\n   * set to 6 by default. Very high edit distances usually don't produce\n   * meaningful results, but can excessively impact search performance.\n   */\n  maxFuzzy?: number,\n\n  /**\n   * The operand to combine partial results for each term. By default it is\n   * \"OR\", so results matching _any_ of the search terms are returned by a\n   * search. If \"AND\" is given, only results matching _all_ the search terms are\n   * returned by a search.\n   */\n  combineWith?: CombinationOperator,\n\n  /**\n   * Function to tokenize the search query. By default, the same tokenizer used\n   * for indexing is used also for search.\n   *\n   * @remarks This function is called after `extractField` extracts a truthy\n   * value from a field. This function is then expected to split the extracted\n   * `text` document into tokens (more commonly referred to as \"terms\" in this\n   * context). The resulting split might be simple, like for example on word\n   * boundaries, or it might be more complex, taking into account certain\n   * encoding, or parsing needs, or even just special cases. Think about how one\n   * might need to go about indexing the term \"short-term\". You would likely\n   * want to treat this case specially, and return two terms instead, `[\n   * \"short\", \"term\" ]`.\n   *\n   * Or, you could let such a case be handled by the `processTerm` function,\n   * which is designed to turn each token/term into whole terms or sub-terms. In\n   * any case, the purpose of this function is to split apart the provided\n   * `text` document into parts that can be processed by the `processTerm`\n   * function.\n   */\n  tokenize?: (text: string) => string[],\n\n  /**\n   * Function to process or normalize terms in the search query. By default, the\n   * same term processor used for indexing is used also for search.\n   *\n   * @remarks\n   * During the document indexing phase, the first step is to call the\n   * `extractField` function to fetch the requested value/field from the\n   * document. This is then passed off to the `tokenize` function, which will\n   * break apart each value into \"terms\". These terms are then individually\n   * passed through this function to compute each term individually. A term\n   * might for example be something like \"lbs\", in which case one would likely\n   * want to return `[ \"lbs\", \"lb\", \"pound\", \"pounds\" ]`. You may also return\n   * just a single string, or a falsy value if you would like to skip indexing\n   * entirely for a specific term.\n   *\n   * Truthy return value(s) are then fed to the indexer as positive matches for\n   * this document. In our example above, all four of the `[ \"lbs\", \"lb\",\n   * \"pound\", \"pounds\" ]` terms would be added to the indexing engine, matching\n   * against the current document being computed.\n   *\n   * *Note: Whatever values are returned from this function will receive no\n   * further processing before being indexed. This means for example, if you\n   * include whitespace at the beginning or end of a word, it will also be\n   * indexed that way, with the included whitespace.*\n   */\n  processTerm?: (term: string) => string | string[] | null | undefined | false\n\n  /**\n   * BM25+ algorithm parameters. Customizing these is almost never necessary,\n   * and finetuning them requires an understanding of the BM25 scoring model. In\n   * most cases, it is best to omit this option to use defaults, and instead use\n   * boosting to tweak scoring for specific use cases.\n   */\n  bm25?: BM25Params\n}\n\ntype SearchOptionsWithDefaults = SearchOptions & {\n  boost: { [fieldName: string]: number },\n\n  weights: { fuzzy: number, prefix: number },\n\n  prefix: boolean | ((term: string, index: number, terms: string[]) => boolean),\n\n  fuzzy: boolean | number | ((term: string, index: number, terms: string[]) => boolean | number),\n\n  maxFuzzy: number,\n\n  combineWith: CombinationOperator\n\n  bm25: BM25Params\n}\n\n/**\n * Configuration options passed to the {@link MiniSearch} constructor\n *\n * @typeParam T  The type of documents being indexed.\n */\nexport type Options<T = any> = {\n   /**\n    * Names of the document fields to be indexed.\n    */\n  fields: string[],\n\n   /**\n    * Name of the ID field, uniquely identifying a document.\n    */\n  idField?: string,\n\n   /**\n    * Names of fields to store, so that search results would include them. By\n    * default none, so results would only contain the id field.\n    */\n  storeFields?: string[],\n\n   /**\n    * Function used to extract the value of each field in documents. By default,\n    * the documents are assumed to be plain objects with field names as keys,\n    * but by specifying a custom `extractField` function one can completely\n    * customize how the fields are extracted.\n    *\n    * The function takes as arguments the document, and the name of the field to\n    * extract from it. It should return the field value as a string.\n    *\n    * @remarks\n    * The returned string is fed into the `tokenize` function to split it up\n    * into tokens.\n    */\n  extractField?: (document: T, fieldName: string) => any,\n\n  /**\n   * Function used to turn field values into strings for indexing\n   *\n   * The function takes as arguments the field value, and the name of the field\n   * to stringify, so that its logic can be customized on specific fields. By\n   * default, it simply calls `toString()` on the field value (which in many\n   * cases is already a string).\n   *\n   * ### Example:\n   *\n   * ```javascript\n   * // Custom stringifier that formats dates as \"Tuesday, September 16, 2025\"\n   * const miniSearch = new MiniSearch({\n   *   fields: ['title', 'date'],\n   *   stringifyField: ((fieldValue, _fieldName) => {\n   *     if (fieldValue instanceof Date) {\n   *       return fieldValue.toLocaleDateString('en-US', {\n   *         weekday: 'long',\n   *         year: 'numeric',\n   *         month: 'long',\n   *         day: 'numeric'\n   *       })\n   *     } else {\n   *      return fieldValue.toString()\n   *     }\n   *   }\n   * })\n   * ```\n   */\n  stringifyField?: (fieldValue: any, fieldName: string) => string,\n\n   /**\n    * Function used to split a field value into individual terms to be indexed.\n    * The default tokenizer separates terms by space or punctuation, but a\n    * custom tokenizer can be provided for custom logic.\n    *\n    * The function takes as arguments string to tokenize, and the name of the\n    * field it comes from. It should return the terms as an array of strings.\n    * When used for tokenizing a search query instead of a document field, the\n    * `fieldName` is undefined.\n    *\n    * @remarks\n    * This function is called after `extractField` extracts a truthy value from a\n    * field. This function is then expected to split the extracted `text` document\n    * into tokens (more commonly referred to as \"terms\" in this context). The resulting\n    * split might be simple, like for example on word boundaries, or it might be more\n    * complex, taking into account certain encoding, or parsing needs, or even just\n    * special cases. Think about how one might need to go about indexing the term\n    * \"short-term\". You would likely want to treat this case specially, and return two\n    * terms instead, `[ \"short\", \"term\" ]`.\n    *\n    * Or, you could let such a case be handled by the `processTerm` function,\n    * which is designed to turn each token/term into whole terms or sub-terms. In any\n    * case, the purpose of this function is to split apart the provided `text` document\n    * into parts that can be processed by the `processTerm` function.\n    */\n  tokenize?: (text: string, fieldName?: string) => string[],\n\n   /**\n    * Function used to process a term before indexing or search. This can be\n    * used for normalization (such as stemming). By default, terms are\n    * downcased, and otherwise no other normalization is performed.\n    *\n    * The function takes as arguments a term to process, and the name of the\n    * field it comes from. It should return the processed term as a string, or a\n    * falsy value to reject the term entirely.\n    *\n    * It can also return an array of strings, in which case each string in the\n    * returned array is indexed as a separate term.\n    *\n    * @remarks\n    * During the document indexing phase, the first step is to call the `extractField`\n    * function to fetch the requested value/field from the document. This is then\n    * passed off to the `tokenizer`, which will break apart each value into \"terms\".\n    * These terms are then individually passed through the `processTerm` function\n    * to compute each term individually. A term might for example be something\n    * like \"lbs\", in which case one would likely want to return\n    * `[ \"lbs\", \"lb\", \"pound\", \"pounds\" ]`. You may also return a single string value,\n    * or a falsy value if you would like to skip indexing entirely for a specific term.\n    *\n    * Truthy return value(s) are then fed to the indexer as positive matches for this\n    * document. In our example above, all four of the `[ \"lbs\", \"lb\", \"pound\", \"pounds\" ]`\n    * terms would be added to the indexing engine, matching against the current document\n    * being computed.\n    *\n    * *Note: Whatever values are returned from this function will receive no further\n    * processing before being indexed. This means for example, if you include whitespace\n    * at the beginning or end of a word, it will also be indexed that way, with the\n    * included whitespace.*\n    */\n  processTerm?: (term: string, fieldName?: string) => string | string[] | null | undefined | false,\n\n  /**\n   * Function called to log messages. Arguments are a log level ('debug',\n   * 'info', 'warn', or 'error'), a log message, and an optional string code\n   * that identifies the reason for the log.\n   *\n   * The default implementation uses `console`, if defined.\n   */\n  logger?: (level: LogLevel, message: string, code?: string) => void\n\n  /**\n   * If `true` (the default), vacuuming is performed automatically as soon as\n   * {@link MiniSearch#discard} is called a certain number of times, cleaning up\n   * obsolete references from the index. If `false`, no automatic vacuuming is\n   * performed. Custom settings controlling auto vacuuming thresholds, as well\n   * as batching behavior, can be passed as an object (see the {@link\n   * AutoVacuumOptions} type).\n   */\n  autoVacuum?: boolean | AutoVacuumOptions\n\n   /**\n    * Default search options (see the {@link SearchOptions} type and the {@link\n    * MiniSearch#search} method for details)\n    */\n  searchOptions?: SearchOptions,\n\n   /**\n    * Default auto suggest options (see the {@link SearchOptions} type and the\n    * {@link MiniSearch#autoSuggest} method for details)\n    */\n  autoSuggestOptions?: SearchOptions\n}\n\ntype OptionsWithDefaults<T = any> = Options<T> & {\n  storeFields: string[]\n\n  idField: string\n\n  extractField: (document: T, fieldName: string) => any\n\n  stringifyField: (fieldValue: any, fieldName: string) => string\n\n  tokenize: (text: string, fieldName: string) => string[]\n\n  processTerm: (term: string, fieldName: string) => string | string[] | null | undefined | false\n\n  logger: (level: LogLevel, message: string, code?: string) => void\n\n  autoVacuum: false | AutoVacuumOptions\n\n  searchOptions: SearchOptionsWithDefaults\n\n  autoSuggestOptions: SearchOptions\n}\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error'\n\n/**\n * The type of auto-suggestions\n */\nexport type Suggestion = {\n  /**\n   * The suggestion\n   */\n  suggestion: string,\n\n  /**\n   * Suggestion as an array of terms\n   */\n  terms: string[],\n\n  /**\n   * Score for the suggestion\n   */\n  score: number\n}\n\n/**\n * Match information for a search result. It is a key-value object where keys\n * are terms that matched, and values are the list of fields that the term was\n * found in.\n */\nexport type MatchInfo = {\n  [term: string]: string[]\n}\n\n/**\n * Type of the search results. Each search result indicates the document ID, the\n * terms that matched, the match information, the score, and all the stored\n * fields.\n */\nexport type SearchResult = {\n  /**\n   * The document ID\n   */\n  id: any,\n\n  /**\n   * List of document terms that matched. For example, if a prefix search for\n   * `\"moto\"` matches `\"motorcycle\"`, `terms` will contain `\"motorcycle\"`.\n   */\n  terms: string[],\n\n  /**\n   * List of query terms that matched. For example, if a prefix search for\n   * `\"moto\"` matches `\"motorcycle\"`, `queryTerms` will contain `\"moto\"`.\n   */\n  queryTerms: string[],\n\n  /**\n   * Score of the search results\n   */\n  score: number,\n\n  /**\n   * Match information, see {@link MatchInfo}\n   */\n  match: MatchInfo,\n\n  /**\n   * Stored fields\n   */\n  [key: string]: any\n}\n\n/**\n * @ignore\n */\nexport type AsPlainObject = {\n  documentCount: number,\n  nextId: number,\n  documentIds: { [shortId: string]: any }\n  fieldIds: { [fieldName: string]: number }\n  fieldLength: { [shortId: string]: number[] }\n  averageFieldLength: number[],\n  storedFields: { [shortId: string]: any }\n  dirtCount?: number,\n  index: [string, { [fieldId: string]: SerializedIndexEntry }][]\n  serializationVersion: number\n}\n\nexport type QueryCombination = SearchOptions & { queries: Query[] }\n\n/**\n * Wildcard query, used to match all terms\n */\nexport type Wildcard = typeof MiniSearch.wildcard\n\n/**\n * Search query expression, either a query string or an expression tree\n * combining several queries with a combination of AND or OR.\n */\nexport type Query = QueryCombination | string | Wildcard\n\n/**\n * Options to control vacuuming behavior.\n *\n * Vacuuming cleans up document references made obsolete by {@link\n * MiniSearch.discard} from the index. On large indexes, vacuuming is\n * potentially costly, because it has to traverse the whole inverted index.\n * Therefore, in order to dilute this cost so it does not negatively affects the\n * application, vacuuming is performed in batches, with a delay between each\n * batch. These options are used to configure the batch size and the delay\n * between batches.\n */\nexport type VacuumOptions = {\n  /**\n   * Size of each vacuuming batch (the number of terms in the index that will be\n   * traversed in each batch). Defaults to 1000.\n   */\n  batchSize?: number,\n\n  /**\n   * Wait time between each vacuuming batch in milliseconds. Defaults to 10.\n   */\n  batchWait?: number\n}\n\n/**\n * Sets minimum thresholds for `dirtCount` and `dirtFactor` that trigger an\n * automatic vacuuming.\n */\nexport type VacuumConditions = {\n  /**\n   * Minimum `dirtCount` (number of discarded documents since the last vacuuming)\n   * under which auto vacuum is not triggered. It defaults to 20.\n   */\n  minDirtCount?: number\n\n  /**\n   * Minimum `dirtFactor` (proportion of discarded documents over the total)\n   * under which auto vacuum is not triggered. It defaults to 0.1.\n   */\n  minDirtFactor?: number,\n}\n\n/**\n * Options to control auto vacuum behavior. When discarding a document with\n * {@link MiniSearch#discard}, a vacuuming operation is automatically started if\n * the `dirtCount` and `dirtFactor` are above the `minDirtCount` and\n * `minDirtFactor` thresholds defined by this configuration. See {@link\n * VacuumConditions} for details on these.\n *\n * Also, `batchSize` and `batchWait` can be specified, controlling batching\n * behavior (see {@link VacuumOptions}).\n */\nexport type AutoVacuumOptions = VacuumOptions & VacuumConditions\n\ntype QuerySpec = {\n  prefix: boolean,\n  fuzzy: number | boolean,\n  term: string,\n  termBoost: number\n}\n\ntype DocumentTermFreqs = Map<number, number>\ntype FieldTermData = Map<number, DocumentTermFreqs>\n\ninterface RawResultValue {\n  // Intermediate score, before applying the final score based on number of\n  // matched terms.\n  score: number,\n\n  // Set of all query terms that were matched. They may not be present in the\n  // text exactly in the case of prefix/fuzzy matches. We must check for\n  // uniqueness before adding a new term. This is much faster than using a set,\n  // because the number of elements is relatively small.\n  terms: string[],\n\n  // All terms that were found in the content, including the fields in which\n  // they were present. This object will be provided as part of the final search\n  // results.\n  match: MatchInfo,\n}\n\ntype RawResult = Map<number, RawResultValue>\n\n/**\n * {@link MiniSearch} is the main entrypoint class, implementing a full-text\n * search engine in memory.\n *\n * @typeParam T  The type of the documents being indexed.\n *\n * ### Basic example:\n *\n * ```javascript\n * const documents = [\n *   {\n *     id: 1,\n *     title: 'Moby Dick',\n *     text: 'Call me Ishmael. Some years ago...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 2,\n *     title: 'Zen and the Art of Motorcycle Maintenance',\n *     text: 'I can see by my watch...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 3,\n *     title: 'Neuromancer',\n *     text: 'The sky above the port was...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 4,\n *     title: 'Zen and the Art of Archery',\n *     text: 'At first sight it must seem...',\n *     category: 'non-fiction'\n *   },\n *   // ...and more\n * ]\n *\n * // Create a search engine that indexes the 'title' and 'text' fields for\n * // full-text search. Search results will include 'title' and 'category' (plus the\n * // id field, that is always stored and returned)\n * const miniSearch = new MiniSearch({\n *   fields: ['title', 'text'],\n *   storeFields: ['title', 'category']\n * })\n *\n * // Add documents to the index\n * miniSearch.addAll(documents)\n *\n * // Search for documents:\n * let results = miniSearch.search('zen art motorcycle')\n * // => [\n * //   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258 },\n * //   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629 }\n * // ]\n * ```\n */\nexport default class MiniSearch<T = any> {\n  protected _options: OptionsWithDefaults<T>\n  protected _index: SearchableMap<FieldTermData>\n  protected _documentCount: number\n  protected _documentIds: Map<number, any>\n  protected _idToShortId: Map<any, number>\n  protected _fieldIds: { [key: string]: number }\n  protected _fieldLength: Map<number, number[]>\n  protected _avgFieldLength: number[]\n  protected _nextId: number\n  protected _storedFields: Map<number, Record<string, unknown>>\n  protected _dirtCount: number\n  private _currentVacuum: Promise<void> | null\n  private _enqueuedVacuum: Promise<void> | null\n  private _enqueuedVacuumConditions: VacuumConditions | undefined\n\n  /**\n   * The special wildcard symbol that can be passed to {@link MiniSearch#search}\n   * to match all documents\n   */\n  static readonly wildcard: unique symbol = Symbol('*')\n\n  /**\n   * @param options  Configuration options\n   *\n   * ### Examples:\n   *\n   * ```javascript\n   * // Create a search engine that indexes the 'title' and 'text' fields of your\n   * // documents:\n   * const miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n   * ```\n   *\n   * ### ID Field:\n   *\n   * ```javascript\n   * // Your documents are assumed to include a unique 'id' field, but if you want\n   * // to use a different field for document identification, you can set the\n   * // 'idField' option:\n   * const miniSearch = new MiniSearch({ idField: 'key', fields: ['title', 'text'] })\n   * ```\n   *\n   * ### Options and defaults:\n   *\n   * ```javascript\n   * // The full set of options (here with their default value) is:\n   * const miniSearch = new MiniSearch({\n   *   // idField: field that uniquely identifies a document\n   *   idField: 'id',\n   *\n   *   // extractField: function used to get the value of a field in a document.\n   *   // By default, it assumes the document is a flat object with field names as\n   *   // property keys and field values as string property values, but custom logic\n   *   // can be implemented by setting this option to a custom extractor function.\n   *   extractField: (document, fieldName) => document[fieldName],\n   *\n   *   // tokenize: function used to split fields into individual terms. By\n   *   // default, it is also used to tokenize search queries, unless a specific\n   *   // `tokenize` search option is supplied. When tokenizing an indexed field,\n   *   // the field name is passed as the second argument.\n   *   tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),\n   *\n   *   // processTerm: function used to process each tokenized term before\n   *   // indexing. It can be used for stemming and normalization. Return a falsy\n   *   // value in order to discard a term. By default, it is also used to process\n   *   // search queries, unless a specific `processTerm` option is supplied as a\n   *   // search option. When processing a term from a indexed field, the field\n   *   // name is passed as the second argument.\n   *   processTerm: (term, _fieldName) => term.toLowerCase(),\n   *\n   *   // searchOptions: default search options, see the `search` method for\n   *   // details\n   *   searchOptions: undefined,\n   *\n   *   // fields: document fields to be indexed. Mandatory, but not set by default\n   *   fields: undefined\n   *\n   *   // storeFields: document fields to be stored and returned as part of the\n   *   // search results.\n   *   storeFields: []\n   * })\n   * ```\n   */\n  constructor (options: Options<T>) {\n    if (options?.fields == null) {\n      throw new Error('MiniSearch: option \"fields\" must be provided')\n    }\n\n    const autoVacuum = (options.autoVacuum == null || options.autoVacuum === true) ? defaultAutoVacuumOptions : options.autoVacuum\n\n    this._options = {\n      ...defaultOptions,\n      ...options,\n      autoVacuum,\n      searchOptions: { ...defaultSearchOptions, ...(options.searchOptions || {}) },\n      autoSuggestOptions: { ...defaultAutoSuggestOptions, ...(options.autoSuggestOptions || {}) }\n    }\n\n    this._index = new SearchableMap()\n\n    this._documentCount = 0\n\n    this._documentIds = new Map()\n\n    this._idToShortId = new Map()\n\n    // Fields are defined during initialization, don't change, are few in\n    // number, rarely need iterating over, and have string keys. Therefore in\n    // this case an object is a better candidate than a Map to store the mapping\n    // from field key to ID.\n    this._fieldIds = {}\n\n    this._fieldLength = new Map()\n\n    this._avgFieldLength = []\n\n    this._nextId = 0\n\n    this._storedFields = new Map()\n\n    this._dirtCount = 0\n\n    this._currentVacuum = null\n\n    this._enqueuedVacuum = null\n    this._enqueuedVacuumConditions = defaultVacuumConditions\n\n    this.addFields(this._options.fields)\n  }\n\n  /**\n   * Adds a document to the index\n   *\n   * @param document  The document to be indexed\n   */\n  add (document: T): void {\n    const { extractField, stringifyField, tokenize, processTerm, fields, idField } = this._options\n    const id = extractField(document, idField)\n    if (id == null) {\n      throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`)\n    }\n\n    if (this._idToShortId.has(id)) {\n      throw new Error(`MiniSearch: duplicate ID ${id}`)\n    }\n\n    const shortDocumentId = this.addDocumentId(id)\n    this.saveStoredFields(shortDocumentId, document)\n\n    for (const field of fields) {\n      const fieldValue = extractField(document, field)\n      if (fieldValue == null) continue\n\n      const tokens = tokenize(stringifyField(fieldValue, field), field)\n      const fieldId = this._fieldIds[field]\n\n      const uniqueTerms = new Set(tokens).size\n      this.addFieldLength(shortDocumentId, fieldId, this._documentCount - 1, uniqueTerms)\n\n      for (const term of tokens) {\n        const processedTerm = processTerm(term, field)\n        if (Array.isArray(processedTerm)) {\n          for (const t of processedTerm) {\n            this.addTerm(fieldId, shortDocumentId, t)\n          }\n        } else if (processedTerm) {\n          this.addTerm(fieldId, shortDocumentId, processedTerm)\n        }\n      }\n    }\n  }\n\n  /**\n   * Adds all the given documents to the index\n   *\n   * @param documents  An array of documents to be indexed\n   */\n  addAll (documents: readonly T[]): void {\n    for (const document of documents) this.add(document)\n  }\n\n  /**\n   * Adds all the given documents to the index asynchronously.\n   *\n   * Returns a promise that resolves (to `undefined`) when the indexing is done.\n   * This method is useful when index many documents, to avoid blocking the main\n   * thread. The indexing is performed asynchronously and in chunks.\n   *\n   * @param documents  An array of documents to be indexed\n   * @param options  Configuration options\n   * @return A promise resolving to `undefined` when the indexing is done\n   */\n  addAllAsync (documents: readonly T[], options: { chunkSize?: number } = {}): Promise<void> {\n    const { chunkSize = 10 } = options\n    const acc: { chunk: T[], promise: Promise<void> } = { chunk: [], promise: Promise.resolve() }\n\n    const { chunk, promise } = documents.reduce(({ chunk, promise }, document: T, i: number) => {\n      chunk.push(document)\n      if ((i + 1) % chunkSize === 0) {\n        return {\n          chunk: [],\n          promise: promise\n            .then(() => new Promise(resolve => setTimeout(resolve, 0)))\n            .then(() => this.addAll(chunk))\n        }\n      } else {\n        return { chunk, promise }\n      }\n    }, acc)\n\n    return promise.then(() => this.addAll(chunk))\n  }\n\n  /**\n   * Removes the given document from the index.\n   *\n   * The document to remove must NOT have changed between indexing and removal,\n   * otherwise the index will be corrupted.\n   *\n   * This method requires passing the full document to be removed (not just the\n   * ID), and immediately removes the document from the inverted index, allowing\n   * memory to be released. A convenient alternative is {@link\n   * MiniSearch#discard}, which needs only the document ID, and has the same\n   * visible effect, but delays cleaning up the index until the next vacuuming.\n   *\n   * @param document  The document to be removed\n   */\n  remove (document: T): void {\n    const { tokenize, processTerm, extractField, stringifyField, fields, idField } = this._options\n    const id = extractField(document, idField)\n\n    if (id == null) {\n      throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`)\n    }\n\n    const shortId = this._idToShortId.get(id)\n\n    if (shortId == null) {\n      throw new Error(`MiniSearch: cannot remove document with ID ${id}: it is not in the index`)\n    }\n\n    for (const field of fields) {\n      const fieldValue = extractField(document, field)\n      if (fieldValue == null) continue\n\n      const tokens = tokenize(stringifyField(fieldValue, field), field)\n      const fieldId = this._fieldIds[field]\n\n      const uniqueTerms = new Set(tokens).size\n      this.removeFieldLength(shortId, fieldId, this._documentCount, uniqueTerms)\n\n      for (const term of tokens) {\n        const processedTerm = processTerm(term, field)\n        if (Array.isArray(processedTerm)) {\n          for (const t of processedTerm) {\n            this.removeTerm(fieldId, shortId, t)\n          }\n        } else if (processedTerm) {\n          this.removeTerm(fieldId, shortId, processedTerm)\n        }\n      }\n    }\n\n    this._storedFields.delete(shortId)\n    this._documentIds.delete(shortId)\n    this._idToShortId.delete(id)\n    this._fieldLength.delete(shortId)\n    this._documentCount -= 1\n  }\n\n  /**\n   * Removes all the given documents from the index. If called with no arguments,\n   * it removes _all_ documents from the index.\n   *\n   * @param documents  The documents to be removed. If this argument is omitted,\n   * all documents are removed. Note that, for removing all documents, it is\n   * more efficient to call this method with no arguments than to pass all\n   * documents.\n   */\n  removeAll (documents?: readonly T[]): void {\n    if (documents) {\n      for (const document of documents) this.remove(document)\n    } else if (arguments.length > 0) {\n      throw new Error('Expected documents to be present. Omit the argument to remove all documents.')\n    } else {\n      this._index = new SearchableMap()\n      this._documentCount = 0\n      this._documentIds = new Map()\n      this._idToShortId = new Map()\n      this._fieldLength = new Map()\n      this._avgFieldLength = []\n      this._storedFields = new Map()\n      this._nextId = 0\n    }\n  }\n\n  /**\n   * Discards the document with the given ID, so it won't appear in search results\n   *\n   * It has the same visible effect of {@link MiniSearch.remove} (both cause the\n   * document to stop appearing in searches), but a different effect on the\n   * internal data structures:\n   *\n   *   - {@link MiniSearch#remove} requires passing the full document to be\n   *   removed as argument, and removes it from the inverted index immediately.\n   *\n   *   - {@link MiniSearch#discard} instead only needs the document ID, and\n   *   works by marking the current version of the document as discarded, so it\n   *   is immediately ignored by searches. This is faster and more convenient\n   *   than {@link MiniSearch#remove}, but the index is not immediately\n   *   modified. To take care of that, vacuuming is performed after a certain\n   *   number of documents are discarded, cleaning up the index and allowing\n   *   memory to be released.\n   *\n   * After discarding a document, it is possible to re-add a new version, and\n   * only the new version will appear in searches. In other words, discarding\n   * and re-adding a document works exactly like removing and re-adding it. The\n   * {@link MiniSearch.replace} method can also be used to replace a document\n   * with a new version.\n   *\n   * #### Details about vacuuming\n   *\n   * Repetite calls to this method would leave obsolete document references in\n   * the index, invisible to searches. Two mechanisms take care of cleaning up:\n   * clean up during search, and vacuuming.\n   *\n   *   - Upon search, whenever a discarded ID is found (and ignored for the\n   *   results), references to the discarded document are removed from the\n   *   inverted index entries for the search terms. This ensures that subsequent\n   *   searches for the same terms do not need to skip these obsolete references\n   *   again.\n   *\n   *   - In addition, vacuuming is performed automatically by default (see the\n   *   `autoVacuum` field in {@link Options}) after a certain number of\n   *   documents are discarded. Vacuuming traverses all terms in the index,\n   *   cleaning up all references to discarded documents. Vacuuming can also be\n   *   triggered manually by calling {@link MiniSearch#vacuum}.\n   *\n   * @param id  The ID of the document to be discarded\n   */\n  discard (id: any): void {\n    const shortId = this._idToShortId.get(id)\n\n    if (shortId == null) {\n      throw new Error(`MiniSearch: cannot discard document with ID ${id}: it is not in the index`)\n    }\n\n    this._idToShortId.delete(id)\n    this._documentIds.delete(shortId)\n    this._storedFields.delete(shortId)\n\n    ;(this._fieldLength.get(shortId) || []).forEach((fieldLength, fieldId) => {\n      this.removeFieldLength(shortId, fieldId, this._documentCount, fieldLength)\n    })\n\n    this._fieldLength.delete(shortId)\n\n    this._documentCount -= 1\n    this._dirtCount += 1\n\n    this.maybeAutoVacuum()\n  }\n\n  private maybeAutoVacuum (): void {\n    if (this._options.autoVacuum === false) { return }\n\n    const { minDirtFactor, minDirtCount, batchSize, batchWait } = this._options.autoVacuum\n    this.conditionalVacuum({ batchSize, batchWait }, { minDirtCount, minDirtFactor })\n  }\n\n  /**\n   * Discards the documents with the given IDs, so they won't appear in search\n   * results\n   *\n   * It is equivalent to calling {@link MiniSearch#discard} for all the given\n   * IDs, but with the optimization of triggering at most one automatic\n   * vacuuming at the end.\n   *\n   * Note: to remove all documents from the index, it is faster and more\n   * convenient to call {@link MiniSearch.removeAll} with no argument, instead\n   * of passing all IDs to this method.\n   */\n  discardAll (ids: readonly any[]): void {\n    const autoVacuum = this._options.autoVacuum\n\n    try {\n      this._options.autoVacuum = false\n\n      for (const id of ids) {\n        this.discard(id)\n      }\n    } finally {\n      this._options.autoVacuum = autoVacuum\n    }\n\n    this.maybeAutoVacuum()\n  }\n\n  /**\n   * It replaces an existing document with the given updated version\n   *\n   * It works by discarding the current version and adding the updated one, so\n   * it is functionally equivalent to calling {@link MiniSearch#discard}\n   * followed by {@link MiniSearch#add}. The ID of the updated document should\n   * be the same as the original one.\n   *\n   * Since it uses {@link MiniSearch#discard} internally, this method relies on\n   * vacuuming to clean up obsolete document references from the index, allowing\n   * memory to be released (see {@link MiniSearch#discard}).\n   *\n   * @param updatedDocument  The updated document to replace the old version\n   * with\n   */\n  replace (updatedDocument: T): void {\n    const { idField, extractField } = this._options\n    const id = extractField(updatedDocument, idField)\n\n    this.discard(id)\n    this.add(updatedDocument)\n  }\n\n  /**\n   * Triggers a manual vacuuming, cleaning up references to discarded documents\n   * from the inverted index\n   *\n   * Vacuuming is only useful for applications that use the {@link\n   * MiniSearch#discard} or {@link MiniSearch#replace} methods.\n   *\n   * By default, vacuuming is performed automatically when needed (controlled by\n   * the `autoVacuum` field in {@link Options}), so there is usually no need to\n   * call this method, unless one wants to make sure to perform vacuuming at a\n   * specific moment.\n   *\n   * Vacuuming traverses all terms in the inverted index in batches, and cleans\n   * up references to discarded documents from the posting list, allowing memory\n   * to be released.\n   *\n   * The method takes an optional object as argument with the following keys:\n   *\n   *   - `batchSize`: the size of each batch (1000 by default)\n   *\n   *   - `batchWait`: the number of milliseconds to wait between batches (10 by\n   *   default)\n   *\n   * On large indexes, vacuuming could have a non-negligible cost: batching\n   * avoids blocking the thread for long, diluting this cost so that it is not\n   * negatively affecting the application. Nonetheless, this method should only\n   * be called when necessary, and relying on automatic vacuuming is usually\n   * better.\n   *\n   * It returns a promise that resolves (to undefined) when the clean up is\n   * completed. If vacuuming is already ongoing at the time this method is\n   * called, a new one is enqueued immediately after the ongoing one, and a\n   * corresponding promise is returned. However, no more than one vacuuming is\n   * enqueued on top of the ongoing one, even if this method is called more\n   * times (enqueuing multiple ones would be useless).\n   *\n   * @param options  Configuration options for the batch size and delay. See\n   * {@link VacuumOptions}.\n   */\n  vacuum (options: VacuumOptions = {}): Promise<void> {\n    return this.conditionalVacuum(options)\n  }\n\n  private conditionalVacuum (options: VacuumOptions, conditions?: VacuumConditions): Promise<void> {\n    // If a vacuum is already ongoing, schedule another as soon as it finishes,\n    // unless there's already one enqueued. If one was already enqueued, do not\n    // enqueue another on top, but make sure that the conditions are the\n    // broadest.\n    if (this._currentVacuum) {\n      this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && conditions\n      if (this._enqueuedVacuum != null) { return this._enqueuedVacuum }\n\n      this._enqueuedVacuum = this._currentVacuum.then(() => {\n        const conditions = this._enqueuedVacuumConditions\n        this._enqueuedVacuumConditions = defaultVacuumConditions\n        return this.performVacuuming(options, conditions)\n      })\n      return this._enqueuedVacuum\n    }\n\n    if (this.vacuumConditionsMet(conditions) === false) { return Promise.resolve() }\n\n    this._currentVacuum = this.performVacuuming(options)\n    return this._currentVacuum\n  }\n\n  private async performVacuuming (options: VacuumOptions, conditions?: VacuumConditions): Promise<void> {\n    const initialDirtCount = this._dirtCount\n\n    if (this.vacuumConditionsMet(conditions)) {\n      const batchSize = options.batchSize || defaultVacuumOptions.batchSize\n      const batchWait = options.batchWait || defaultVacuumOptions.batchWait\n      let i = 1\n\n      for (const [term, fieldsData] of this._index) {\n        for (const [fieldId, fieldIndex] of fieldsData) {\n          for (const [shortId] of fieldIndex) {\n            if (this._documentIds.has(shortId)) { continue }\n\n            if (fieldIndex.size <= 1) {\n              fieldsData.delete(fieldId)\n            } else {\n              fieldIndex.delete(shortId)\n            }\n          }\n        }\n\n        if (this._index.get(term)!.size === 0) {\n          this._index.delete(term)\n        }\n\n        if (i % batchSize === 0) {\n          await new Promise((resolve) => setTimeout(resolve, batchWait))\n        }\n\n        i += 1\n      }\n\n      this._dirtCount -= initialDirtCount\n    }\n\n    // Make the next lines always async, so they execute after this function returns\n    await null\n\n    this._currentVacuum = this._enqueuedVacuum\n    this._enqueuedVacuum = null\n  }\n\n  private vacuumConditionsMet (conditions?: VacuumConditions) {\n    if (conditions == null) { return true }\n\n    let { minDirtCount, minDirtFactor } = conditions\n    minDirtCount = minDirtCount || defaultAutoVacuumOptions.minDirtCount\n    minDirtFactor = minDirtFactor || defaultAutoVacuumOptions.minDirtFactor\n\n    return this.dirtCount >= minDirtCount && this.dirtFactor >= minDirtFactor\n  }\n\n  /**\n   * Is `true` if a vacuuming operation is ongoing, `false` otherwise\n   */\n  get isVacuuming (): boolean {\n    return this._currentVacuum != null\n  }\n\n  /**\n   * The number of documents discarded since the most recent vacuuming\n   */\n  get dirtCount (): number {\n    return this._dirtCount\n  }\n\n  /**\n   * A number between 0 and 1 giving an indication about the proportion of\n   * documents that are discarded, and can therefore be cleaned up by vacuuming.\n   * A value close to 0 means that the index is relatively clean, while a higher\n   * value means that the index is relatively dirty, and vacuuming could release\n   * memory.\n   */\n  get dirtFactor (): number {\n    return this._dirtCount / (1 + this._documentCount + this._dirtCount)\n  }\n\n  /**\n   * Returns `true` if a document with the given ID is present in the index and\n   * available for search, `false` otherwise\n   *\n   * @param id  The document ID\n   */\n  has (id: any): boolean {\n    return this._idToShortId.has(id)\n  }\n\n  /**\n   * Returns the stored fields (as configured in the `storeFields` constructor\n   * option) for the given document ID. Returns `undefined` if the document is\n   * not present in the index.\n   *\n   * @param id  The document ID\n   */\n  getStoredFields (id: any): Record<string, unknown> | undefined {\n    const shortId = this._idToShortId.get(id)\n\n    if (shortId == null) { return undefined }\n\n    return this._storedFields.get(shortId)\n  }\n\n  /**\n   * Search for documents matching the given search query.\n   *\n   * The result is a list of scored document IDs matching the query, sorted by\n   * descending score, and each including data about which terms were matched and\n   * in which fields.\n   *\n   * ### Basic usage:\n   *\n   * ```javascript\n   * // Search for \"zen art motorcycle\" with default options: terms have to match\n   * // exactly, and individual terms are joined with OR\n   * miniSearch.search('zen art motorcycle')\n   * // => [ { id: 2, score: 2.77258, match: { ... } }, { id: 4, score: 1.38629, match: { ... } } ]\n   * ```\n   *\n   * ### Restrict search to specific fields:\n   *\n   * ```javascript\n   * // Search only in the 'title' field\n   * miniSearch.search('zen', { fields: ['title'] })\n   * ```\n   *\n   * ### Field boosting:\n   *\n   * ```javascript\n   * // Boost a field\n   * miniSearch.search('zen', { boost: { title: 2 } })\n   * ```\n   *\n   * ### Prefix search:\n   *\n   * ```javascript\n   * // Search for \"moto\" with prefix search (it will match documents\n   * // containing terms that start with \"moto\" or \"neuro\")\n   * miniSearch.search('moto neuro', { prefix: true })\n   * ```\n   *\n   * ### Fuzzy search:\n   *\n   * ```javascript\n   * // Search for \"ismael\" with fuzzy search (it will match documents containing\n   * // terms similar to \"ismael\", with a maximum edit distance of 0.2 term.length\n   * // (rounded to nearest integer)\n   * miniSearch.search('ismael', { fuzzy: 0.2 })\n   * ```\n   *\n   * ### Combining strategies:\n   *\n   * ```javascript\n   * // Mix of exact match, prefix search, and fuzzy search\n   * miniSearch.search('ismael mob', {\n   *  prefix: true,\n   *  fuzzy: 0.2\n   * })\n   * ```\n   *\n   * ### Advanced prefix and fuzzy search:\n   *\n   * ```javascript\n   * // Perform fuzzy and prefix search depending on the search term. Here\n   * // performing prefix and fuzzy search only on terms longer than 3 characters\n   * miniSearch.search('ismael mob', {\n   *  prefix: term => term.length > 3\n   *  fuzzy: term => term.length > 3 ? 0.2 : null\n   * })\n   * ```\n   *\n   * ### Combine with AND:\n   *\n   * ```javascript\n   * // Combine search terms with AND (to match only documents that contain both\n   * // \"motorcycle\" and \"art\")\n   * miniSearch.search('motorcycle art', { combineWith: 'AND' })\n   * ```\n   *\n   * ### Combine with AND_NOT:\n   *\n   * There is also an AND_NOT combinator, that finds documents that match the\n   * first term, but do not match any of the other terms. This combinator is\n   * rarely useful with simple queries, and is meant to be used with advanced\n   * query combinations (see later for more details).\n   *\n   * ### Filtering results:\n   *\n   * ```javascript\n   * // Filter only results in the 'fiction' category (assuming that 'category'\n   * // is a stored field)\n   * miniSearch.search('motorcycle art', {\n   *   filter: (result) => result.category === 'fiction'\n   * })\n   * ```\n   *\n   * ### Wildcard query\n   *\n   * Searching for an empty string (assuming the default tokenizer) returns no\n   * results. Sometimes though, one needs to match all documents, like in a\n   * \"wildcard\" search. This is possible by passing the special value\n   * {@link MiniSearch.wildcard} as the query:\n   *\n   * ```javascript\n   * // Return search results for all documents\n   * miniSearch.search(MiniSearch.wildcard)\n   * ```\n   *\n   * Note that search options such as `filter` and `boostDocument` are still\n   * applied, influencing which results are returned, and their order:\n   *\n   * ```javascript\n   * // Return search results for all documents in the 'fiction' category\n   * miniSearch.search(MiniSearch.wildcard, {\n   *   filter: (result) => result.category === 'fiction'\n   * })\n   * ```\n   *\n   * ### Advanced combination of queries:\n   *\n   * It is possible to combine different subqueries with OR, AND, and AND_NOT,\n   * and even with different search options, by passing a query expression\n   * tree object as the first argument, instead of a string.\n   *\n   * ```javascript\n   * // Search for documents that contain \"zen\" and (\"motorcycle\" or \"archery\")\n   * miniSearch.search({\n   *   combineWith: 'AND',\n   *   queries: [\n   *     'zen',\n   *     {\n   *       combineWith: 'OR',\n   *       queries: ['motorcycle', 'archery']\n   *     }\n   *   ]\n   * })\n   *\n   * // Search for documents that contain (\"apple\" or \"pear\") but not \"juice\" and\n   * // not \"tree\"\n   * miniSearch.search({\n   *   combineWith: 'AND_NOT',\n   *   queries: [\n   *     {\n   *       combineWith: 'OR',\n   *       queries: ['apple', 'pear']\n   *     },\n   *     'juice',\n   *     'tree'\n   *   ]\n   * })\n   * ```\n   *\n   * Each node in the expression tree can be either a string, or an object that\n   * supports all {@link SearchOptions} fields, plus a `queries` array field for\n   * subqueries.\n   *\n   * Note that, while this can become complicated to do by hand for complex or\n   * deeply nested queries, it provides a formalized expression tree API for\n   * external libraries that implement a parser for custom query languages.\n   *\n   * @param query  Search query\n   * @param searchOptions  Search options. Each option, if not given, defaults to the corresponding value of `searchOptions` given to the constructor, or to the library default.\n   */\n  search (query: Query, searchOptions: SearchOptions = {}): SearchResult[] {\n    const { searchOptions: globalSearchOptions } = this._options\n    const searchOptionsWithDefaults: SearchOptionsWithDefaults = { ...globalSearchOptions, ...searchOptions }\n\n    const rawResults = this.executeQuery(query, searchOptions)\n    const results = []\n\n    for (const [docId, { score, terms, match }] of rawResults) {\n      // terms are the matched query terms, which will be returned to the user\n      // as queryTerms. The quality is calculated based on them, as opposed to\n      // the matched terms in the document (which can be different due to\n      // prefix and fuzzy match)\n      const quality = terms.length || 1\n\n      const result = {\n        id: this._documentIds.get(docId),\n        score: score * quality,\n        terms: Object.keys(match),\n        queryTerms: terms,\n        match\n      }\n\n      Object.assign(result, this._storedFields.get(docId))\n      if (searchOptionsWithDefaults.filter == null || searchOptionsWithDefaults.filter(result)) {\n        results.push(result)\n      }\n    }\n\n    // If it's a wildcard query, and no document boost is applied, skip sorting\n    // the results, as all results have the same score of 1\n    if (query === MiniSearch.wildcard && searchOptionsWithDefaults.boostDocument == null) {\n      return results\n    }\n\n    results.sort(byScore)\n    return results\n  }\n\n  /**\n   * Provide suggestions for the given search query\n   *\n   * The result is a list of suggested modified search queries, derived from the\n   * given search query, each with a relevance score, sorted by descending score.\n   *\n   * By default, it uses the same options used for search, except that by\n   * default it performs prefix search on the last term of the query, and\n   * combine terms with `'AND'` (requiring all query terms to match). Custom\n   * options can be passed as a second argument. Defaults can be changed upon\n   * calling the {@link MiniSearch} constructor, by passing a\n   * `autoSuggestOptions` option.\n   *\n   * ### Basic usage:\n   *\n   * ```javascript\n   * // Get suggestions for 'neuro':\n   * miniSearch.autoSuggest('neuro')\n   * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 0.46240 } ]\n   * ```\n   *\n   * ### Multiple words:\n   *\n   * ```javascript\n   * // Get suggestions for 'zen ar':\n   * miniSearch.autoSuggest('zen ar')\n   * // => [\n   * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n   * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n   * // ]\n   * ```\n   *\n   * ### Fuzzy suggestions:\n   *\n   * ```javascript\n   * // Correct spelling mistakes using fuzzy search:\n   * miniSearch.autoSuggest('neromancer', { fuzzy: 0.2 })\n   * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]\n   * ```\n   *\n   * ### Filtering:\n   *\n   * ```javascript\n   * // Get suggestions for 'zen ar', but only within the 'fiction' category\n   * // (assuming that 'category' is a stored field):\n   * miniSearch.autoSuggest('zen ar', {\n   *   filter: (result) => result.category === 'fiction'\n   * })\n   * // => [\n   * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n   * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n   * // ]\n   * ```\n   *\n   * @param queryString  Query string to be expanded into suggestions\n   * @param options  Search options. The supported options and default values\n   * are the same as for the {@link MiniSearch#search} method, except that by\n   * default prefix search is performed on the last term in the query, and terms\n   * are combined with `'AND'`.\n   * @return  A sorted array of suggestions sorted by relevance score.\n   */\n  autoSuggest (queryString: string, options: SearchOptions = {}): Suggestion[] {\n    options = { ...this._options.autoSuggestOptions, ...options }\n\n    const suggestions: Map<string, Omit<Suggestion, 'suggestion'> & { count: number }> = new Map()\n\n    for (const { score, terms } of this.search(queryString, options)) {\n      const phrase = terms.join(' ')\n      const suggestion = suggestions.get(phrase)\n      if (suggestion != null) {\n        suggestion.score += score\n        suggestion.count += 1\n      } else {\n        suggestions.set(phrase, { score, terms, count: 1 })\n      }\n    }\n\n    const results = []\n    for (const [suggestion, { score, terms, count }] of suggestions) {\n      results.push({ suggestion, terms, score: score / count })\n    }\n\n    results.sort(byScore)\n    return results\n  }\n\n  /**\n   * Total number of documents available to search\n   */\n  get documentCount (): number {\n    return this._documentCount\n  }\n\n  /**\n   * Number of terms in the index\n   */\n  get termCount (): number {\n    return this._index.size\n  }\n\n  /**\n   * Deserializes a JSON index (serialized with `JSON.stringify(miniSearch)`)\n   * and instantiates a MiniSearch instance. It should be given the same options\n   * originally used when serializing the index.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * // If the index was serialized with:\n   * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n   * miniSearch.addAll(documents)\n   *\n   * const json = JSON.stringify(miniSearch)\n   * // It can later be deserialized like this:\n   * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n   * ```\n   *\n   * @param json  JSON-serialized index\n   * @param options  configuration options, same as the constructor\n   * @return An instance of MiniSearch deserialized from the given JSON.\n   */\n  static loadJSON<T = any> (json: string, options: Options<T>): MiniSearch<T> {\n    if (options == null) {\n      throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index')\n    }\n    return this.loadJS(JSON.parse(json), options)\n  }\n\n  /**\n   * Async equivalent of {@link MiniSearch.loadJSON}\n   *\n   * This function is an alternative to {@link MiniSearch.loadJSON} that returns\n   * a promise, and loads the index in batches, leaving pauses between them to avoid\n   * blocking the main thread. It tends to be slower than the synchronous\n   * version, but does not block the main thread, so it can be a better choice\n   * when deserializing very large indexes.\n   *\n   * @param json  JSON-serialized index\n   * @param options  configuration options, same as the constructor\n   * @return A Promise that will resolve to an instance of MiniSearch deserialized from the given JSON.\n   */\n  static async loadJSONAsync<T = any> (json: string, options: Options<T>): Promise<MiniSearch<T>> {\n    if (options == null) {\n      throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index')\n    }\n    return this.loadJSAsync(JSON.parse(json), options)\n  }\n\n  /**\n   * Returns the default value of an option. It will throw an error if no option\n   * with the given name exists.\n   *\n   * @param optionName  Name of the option\n   * @return The default value of the given option\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * // Get default tokenizer\n   * MiniSearch.getDefault('tokenize')\n   *\n   * // Get default term processor\n   * MiniSearch.getDefault('processTerm')\n   *\n   * // Unknown options will throw an error\n   * MiniSearch.getDefault('notExisting')\n   * // => throws 'MiniSearch: unknown option \"notExisting\"'\n   * ```\n   */\n  static getDefault (optionName: string): any {\n    if (defaultOptions.hasOwnProperty(optionName)) {\n      return getOwnProperty(defaultOptions, optionName)\n    } else {\n      throw new Error(`MiniSearch: unknown option \"${optionName}\"`)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  static loadJS<T = any> (js: AsPlainObject, options: Options<T>): MiniSearch<T> {\n    const {\n      index,\n      documentIds,\n      fieldLength,\n      storedFields,\n      serializationVersion\n    } = js\n\n    const miniSearch = this.instantiateMiniSearch(js, options)\n\n    miniSearch._documentIds = objectToNumericMap(documentIds)\n    miniSearch._fieldLength = objectToNumericMap(fieldLength)\n    miniSearch._storedFields = objectToNumericMap(storedFields)\n\n    for (const [shortId, id] of miniSearch._documentIds) {\n      miniSearch._idToShortId.set(id, shortId)\n    }\n\n    for (const [term, data] of index) {\n      const dataMap = new Map() as FieldTermData\n\n      for (const fieldId of Object.keys(data)) {\n        let indexEntry = data[fieldId]\n\n        // Version 1 used to nest the index entry inside a field called ds\n        if (serializationVersion === 1) {\n          indexEntry = indexEntry.ds as unknown as SerializedIndexEntry\n        }\n\n        dataMap.set(parseInt(fieldId, 10), objectToNumericMap(indexEntry) as DocumentTermFreqs)\n      }\n\n      miniSearch._index.set(term, dataMap)\n    }\n\n    return miniSearch\n  }\n\n  /**\n   * @ignore\n   */\n  static async loadJSAsync<T = any> (js: AsPlainObject, options: Options<T>): Promise<MiniSearch<T>> {\n    const {\n      index,\n      documentIds,\n      fieldLength,\n      storedFields,\n      serializationVersion\n    } = js\n\n    const miniSearch = this.instantiateMiniSearch(js, options)\n\n    miniSearch._documentIds = await objectToNumericMapAsync(documentIds)\n    miniSearch._fieldLength = await objectToNumericMapAsync(fieldLength)\n    miniSearch._storedFields = await objectToNumericMapAsync(storedFields)\n\n    for (const [shortId, id] of miniSearch._documentIds) {\n      miniSearch._idToShortId.set(id, shortId)\n    }\n\n    let count = 0\n    for (const [term, data] of index) {\n      const dataMap = new Map() as FieldTermData\n\n      for (const fieldId of Object.keys(data)) {\n        let indexEntry = data[fieldId]\n\n        // Version 1 used to nest the index entry inside a field called ds\n        if (serializationVersion === 1) {\n          indexEntry = indexEntry.ds as unknown as SerializedIndexEntry\n        }\n\n        dataMap.set(parseInt(fieldId, 10), await objectToNumericMapAsync(indexEntry) as DocumentTermFreqs)\n      }\n\n      if (++count % 1000 === 0) await wait(0)\n      miniSearch._index.set(term, dataMap)\n    }\n\n    return miniSearch\n  }\n\n  /**\n   * @ignore\n   */\n  private static instantiateMiniSearch<T = any> (js: AsPlainObject, options: Options<T>): MiniSearch<T> {\n    const {\n      documentCount,\n      nextId,\n      fieldIds,\n      averageFieldLength,\n      dirtCount,\n      serializationVersion\n    } = js\n\n    if (serializationVersion !== 1 && serializationVersion !== 2) {\n      throw new Error('MiniSearch: cannot deserialize an index created with an incompatible version')\n    }\n\n    const miniSearch = new MiniSearch(options)\n\n    miniSearch._documentCount = documentCount\n    miniSearch._nextId = nextId\n    miniSearch._idToShortId = new Map<any, number>()\n    miniSearch._fieldIds = fieldIds\n    miniSearch._avgFieldLength = averageFieldLength\n    miniSearch._dirtCount = dirtCount || 0\n    miniSearch._index = new SearchableMap()\n\n    return miniSearch\n  }\n\n  /**\n   * @ignore\n   */\n  private executeQuery (query: Query, searchOptions: SearchOptions = {}): RawResult {\n    if (query === MiniSearch.wildcard) {\n      return this.executeWildcardQuery(searchOptions)\n    }\n\n    if (typeof query !== 'string') {\n      const options = { ...searchOptions, ...query, queries: undefined }\n      const results = query.queries.map((subquery) => this.executeQuery(subquery, options))\n      return this.combineResults(results, options.combineWith)\n    }\n\n    const { tokenize, processTerm, searchOptions: globalSearchOptions } = this._options\n    const options = { tokenize, processTerm, ...globalSearchOptions, ...searchOptions }\n    const { tokenize: searchTokenize, processTerm: searchProcessTerm } = options\n    const terms = searchTokenize(query)\n      .flatMap((term: string) => searchProcessTerm(term))\n      .filter((term) => !!term) as string[]\n    const queries: QuerySpec[] = terms.map(termToQuerySpec(options))\n    const results = queries.map(query => this.executeQuerySpec(query, options))\n\n    return this.combineResults(results, options.combineWith)\n  }\n\n  /**\n   * @ignore\n   */\n  private executeQuerySpec (query: QuerySpec, searchOptions: SearchOptions): RawResult {\n    const options: SearchOptionsWithDefaults = { ...this._options.searchOptions, ...searchOptions }\n\n    const boosts = (options.fields || this._options.fields).reduce((boosts, field) =>\n      ({ ...boosts, [field]: getOwnProperty(options.boost, field) || 1 }), {})\n\n    const {\n      boostDocument,\n      weights,\n      maxFuzzy,\n      bm25: bm25params\n    } = options\n\n    const { fuzzy: fuzzyWeight, prefix: prefixWeight } = { ...defaultSearchOptions.weights, ...weights }\n\n    const data = this._index.get(query.term)\n    const results = this.termResults(query.term, query.term, 1, query.termBoost, data, boosts, boostDocument, bm25params)\n\n    let prefixMatches\n    let fuzzyMatches\n\n    if (query.prefix) {\n      prefixMatches = this._index.atPrefix(query.term)\n    }\n\n    if (query.fuzzy) {\n      const fuzzy = (query.fuzzy === true) ? 0.2 : query.fuzzy\n      const maxDistance = fuzzy < 1 ? Math.min(maxFuzzy, Math.round(query.term.length * fuzzy)) : fuzzy\n      if (maxDistance) fuzzyMatches = this._index.fuzzyGet(query.term, maxDistance)\n    }\n\n    if (prefixMatches) {\n      for (const [term, data] of prefixMatches) {\n        const distance = term.length - query.term.length\n        if (!distance) { continue } // Skip exact match.\n\n        // Delete the term from fuzzy results (if present) if it is also a\n        // prefix result. This entry will always be scored as a prefix result.\n        fuzzyMatches?.delete(term)\n\n        // Weight gradually approaches 0 as distance goes to infinity, with the\n        // weight for the hypothetical distance 0 being equal to prefixWeight.\n        // The rate of change is much lower than that of fuzzy matches to\n        // account for the fact that prefix matches stay more relevant than\n        // fuzzy matches for longer distances.\n        const weight = prefixWeight * term.length / (term.length + 0.3 * distance)\n        this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results)\n      }\n    }\n\n    if (fuzzyMatches) {\n      for (const term of fuzzyMatches.keys()) {\n        const [data, distance] = fuzzyMatches.get(term)!\n        if (!distance) { continue } // Skip exact match.\n\n        // Weight gradually approaches 0 as distance goes to infinity, with the\n        // weight for the hypothetical distance 0 being equal to fuzzyWeight.\n        const weight = fuzzyWeight * term.length / (term.length + distance)\n        this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results)\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * @ignore\n   */\n  private executeWildcardQuery (searchOptions: SearchOptions): RawResult {\n    const results = new Map() as RawResult\n    const options: SearchOptionsWithDefaults = { ...this._options.searchOptions, ...searchOptions }\n\n    for (const [shortId, id] of this._documentIds) {\n      const score = options.boostDocument ? options.boostDocument(id, '', this._storedFields.get(shortId)) : 1\n      results.set(shortId, {\n        score,\n        terms: [],\n        match: {}\n      })\n    }\n\n    return results\n  }\n\n  /**\n   * @ignore\n   */\n  private combineResults (results: RawResult[], combineWith: CombinationOperator = OR): RawResult {\n    if (results.length === 0) { return new Map() }\n    const operator = combineWith.toLowerCase()\n    const combinator = (combinators as Record<string, CombinatorFunction>)[operator]\n\n    if (!combinator) {\n      throw new Error(`Invalid combination operator: ${combineWith}`)\n    }\n\n    return results.reduce(combinator) || new Map()\n  }\n\n  /**\n   * Allows serialization of the index to JSON, to possibly store it and later\n   * deserialize it with {@link MiniSearch.loadJSON}.\n   *\n   * Normally one does not directly call this method, but rather call the\n   * standard JavaScript `JSON.stringify()` passing the {@link MiniSearch}\n   * instance, and JavaScript will internally call this method. Upon\n   * deserialization, one must pass to {@link MiniSearch.loadJSON} the same\n   * options used to create the original instance that was serialized.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * // Serialize the index:\n   * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n   * miniSearch.addAll(documents)\n   * const json = JSON.stringify(miniSearch)\n   *\n   * // Later, to deserialize it:\n   * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n   * ```\n   *\n   * @return A plain-object serializable representation of the search index.\n   */\n  toJSON (): AsPlainObject {\n    const index: [string, { [key: string]: SerializedIndexEntry }][] = []\n\n    for (const [term, fieldIndex] of this._index) {\n      const data: { [key: string]: SerializedIndexEntry } = {}\n\n      for (const [fieldId, freqs] of fieldIndex) {\n        data[fieldId] = Object.fromEntries(freqs)\n      }\n\n      index.push([term, data])\n    }\n\n    return {\n      documentCount: this._documentCount,\n      nextId: this._nextId,\n      documentIds: Object.fromEntries(this._documentIds),\n      fieldIds: this._fieldIds,\n      fieldLength: Object.fromEntries(this._fieldLength),\n      averageFieldLength: this._avgFieldLength,\n      storedFields: Object.fromEntries(this._storedFields),\n      dirtCount: this._dirtCount,\n      index,\n      serializationVersion: 2\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private termResults (\n    sourceTerm: string,\n    derivedTerm: string,\n    termWeight: number,\n    termBoost: number,\n    fieldTermData: FieldTermData | undefined,\n    fieldBoosts: { [field: string]: number },\n    boostDocumentFn: ((id: any, term: string, storedFields?: Record<string, unknown>) => number) | undefined,\n    bm25params: BM25Params,\n    results: RawResult = new Map()\n  ): RawResult {\n    if (fieldTermData == null) return results\n\n    for (const field of Object.keys(fieldBoosts)) {\n      const fieldBoost = fieldBoosts[field]\n      const fieldId = this._fieldIds[field]\n\n      const fieldTermFreqs = fieldTermData.get(fieldId)\n      if (fieldTermFreqs == null) continue\n\n      let matchingFields = fieldTermFreqs.size\n      const avgFieldLength = this._avgFieldLength[fieldId]\n\n      for (const docId of fieldTermFreqs.keys()) {\n        if (!this._documentIds.has(docId)) {\n          this.removeTerm(fieldId, docId, derivedTerm)\n          matchingFields -= 1\n          continue\n        }\n\n        const docBoost = boostDocumentFn ? boostDocumentFn(this._documentIds.get(docId), derivedTerm, this._storedFields.get(docId)) : 1\n        if (!docBoost) continue\n\n        const termFreq = fieldTermFreqs.get(docId)!\n        const fieldLength = this._fieldLength.get(docId)![fieldId]\n\n        // NOTE: The total number of fields is set to the number of documents\n        // `this._documentCount`. It could also make sense to use the number of\n        // documents where the current field is non-blank as a normalization\n        // factor. This will make a difference in scoring if the field is rarely\n        // present. This is currently not supported, and may require further\n        // analysis to see if it is a valid use case.\n        const rawScore = calcBM25Score(termFreq, matchingFields, this._documentCount, fieldLength, avgFieldLength, bm25params)\n        const weightedScore = termWeight * termBoost * fieldBoost * docBoost * rawScore\n\n        const result = results.get(docId)\n        if (result) {\n          result.score += weightedScore\n          assignUniqueTerm(result.terms, sourceTerm)\n          const match = getOwnProperty(result.match, derivedTerm)\n          if (match) {\n            match.push(field)\n          } else {\n            result.match[derivedTerm] = [field]\n          }\n        } else {\n          results.set(docId, {\n            score: weightedScore,\n            terms: [sourceTerm],\n            match: { [derivedTerm]: [field] }\n          })\n        }\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * @ignore\n   */\n  private addTerm (fieldId: number, documentId: number, term: string): void {\n    const indexData = this._index.fetch(term, createMap)\n\n    let fieldIndex = indexData.get(fieldId)\n    if (fieldIndex == null) {\n      fieldIndex = new Map()\n      fieldIndex.set(documentId, 1)\n      indexData.set(fieldId, fieldIndex)\n    } else {\n      const docs = fieldIndex.get(documentId)\n      fieldIndex.set(documentId, (docs || 0) + 1)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private removeTerm (fieldId: number, documentId: number, term: string): void {\n    if (!this._index.has(term)) {\n      this.warnDocumentChanged(documentId, fieldId, term)\n      return\n    }\n\n    const indexData = this._index.fetch(term, createMap)\n\n    const fieldIndex = indexData.get(fieldId)\n    if (fieldIndex == null || fieldIndex.get(documentId) == null) {\n      this.warnDocumentChanged(documentId, fieldId, term)\n    } else if (fieldIndex.get(documentId)! <= 1) {\n      if (fieldIndex.size <= 1) {\n        indexData.delete(fieldId)\n      } else {\n        fieldIndex.delete(documentId)\n      }\n    } else {\n      fieldIndex.set(documentId, fieldIndex.get(documentId)! - 1)\n    }\n\n    if (this._index.get(term)!.size === 0) {\n      this._index.delete(term)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private warnDocumentChanged (shortDocumentId: number, fieldId: number, term: string): void {\n    for (const fieldName of Object.keys(this._fieldIds)) {\n      if (this._fieldIds[fieldName] === fieldId) {\n        this._options.logger('warn', `MiniSearch: document with ID ${this._documentIds.get(shortDocumentId)} has changed before removal: term \"${term}\" was not present in field \"${fieldName}\". Removing a document after it has changed can corrupt the index!`, 'version_conflict')\n        return\n      }\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private addDocumentId (documentId: any): number {\n    const shortDocumentId = this._nextId\n    this._idToShortId.set(documentId, shortDocumentId)\n    this._documentIds.set(shortDocumentId, documentId)\n    this._documentCount += 1\n    this._nextId += 1\n    return shortDocumentId\n  }\n\n  /**\n   * @ignore\n   */\n  private addFields (fields: string[]): void {\n    for (let i = 0; i < fields.length; i++) {\n      this._fieldIds[fields[i]] = i\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private addFieldLength (documentId: number, fieldId: number, count: number, length: number): void {\n    let fieldLengths = this._fieldLength.get(documentId)\n    if (fieldLengths == null) this._fieldLength.set(documentId, fieldLengths = [])\n    fieldLengths[fieldId] = length\n\n    const averageFieldLength = this._avgFieldLength[fieldId] || 0\n    const totalFieldLength = (averageFieldLength * count) + length\n    this._avgFieldLength[fieldId] = totalFieldLength / (count + 1)\n  }\n\n  /**\n   * @ignore\n   */\n  private removeFieldLength (documentId: number, fieldId: number, count: number, length: number): void {\n    if (count === 1) {\n      this._avgFieldLength[fieldId] = 0\n      return\n    }\n    const totalFieldLength = (this._avgFieldLength[fieldId] * count) - length\n    this._avgFieldLength[fieldId] = totalFieldLength / (count - 1)\n  }\n\n  /**\n   * @ignore\n   */\n  private saveStoredFields (documentId: number, doc: T): void {\n    const { storeFields, extractField } = this._options\n    if (storeFields == null || storeFields.length === 0) { return }\n\n    let documentFields = this._storedFields.get(documentId)\n    if (documentFields == null) this._storedFields.set(documentId, documentFields = {})\n\n    for (const fieldName of storeFields) {\n      const fieldValue = extractField(doc, fieldName)\n      if (fieldValue !== undefined) documentFields[fieldName] = fieldValue\n    }\n  }\n}\n\nconst getOwnProperty = (object: any, property: string) =>\n  Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined\n\ntype CombinatorFunction = (a: RawResult, b: RawResult) => RawResult\n\nconst combinators: Record<LowercaseCombinationOperator, CombinatorFunction> = {\n  [OR]: (a: RawResult, b: RawResult) => {\n    for (const docId of b.keys()) {\n      const existing = a.get(docId)\n      if (existing == null) {\n        a.set(docId, b.get(docId)!)\n      } else {\n        const { score, terms, match } = b.get(docId)!\n        existing.score = existing.score + score\n        existing.match = Object.assign(existing.match, match)\n        assignUniqueTerms(existing.terms, terms)\n      }\n    }\n\n    return a\n  },\n  [AND]: (a: RawResult, b: RawResult) => {\n    const combined = new Map()\n\n    for (const docId of b.keys()) {\n      const existing = a.get(docId)\n      if (existing == null) continue\n\n      const { score, terms, match } = b.get(docId)!\n      assignUniqueTerms(existing.terms, terms)\n      combined.set(docId, {\n        score: existing.score + score,\n        terms: existing.terms,\n        match: Object.assign(existing.match, match)\n      })\n    }\n\n    return combined\n  },\n  [AND_NOT]: (a: RawResult, b: RawResult) => {\n    for (const docId of b.keys()) a.delete(docId)\n    return a\n  }\n}\n\n/**\n * Parameters of the BM25+ scoring algorithm. Customizing these is almost never\n * necessary, and finetuning them requires an understanding of the BM25 scoring\n * model.\n *\n * Some information about BM25 (and BM25+) can be found at these links:\n *\n *   - https://en.wikipedia.org/wiki/Okapi_BM25\n *   - https://opensourceconnections.com/blog/2015/10/16/bm25-the-next-generation-of-lucene-relevation/\n */\nexport type BM25Params = {\n  /** Term frequency saturation point.\n   *\n   * Recommended values are between `1.2` and `2`. Higher values increase the\n   * difference in score between documents with higher and lower term\n   * frequencies. Setting this to `0` or a negative value is invalid. Defaults\n   * to `1.2`\n   */\n  k: number,\n\n  /**\n   * Length normalization impact.\n   *\n   * Recommended values are around `0.75`. Higher values increase the weight\n   * that field length has on scoring. Setting this to `0` (not recommended)\n   * means that the field length has no effect on scoring. Negative values are\n   * invalid. Defaults to `0.7`.\n   */\n  b: number,\n\n  /**\n   * BM25+ frequency normalization lower bound (usually called \u03B4).\n   *\n   * Recommended values are between `0.5` and `1`. Increasing this parameter\n   * increases the minimum relevance of one occurrence of a search term\n   * regardless of its (possibly very long) field length. Negative values are\n   * invalid. Defaults to `0.5`.\n   */\n  d: number\n}\n\nconst defaultBM25params: BM25Params = { k: 1.2, b: 0.7, d: 0.5 }\n\nconst calcBM25Score = (\n  termFreq: number,\n  matchingCount: number,\n  totalCount: number,\n  fieldLength: number,\n  avgFieldLength: number,\n  bm25params: BM25Params\n): number => {\n  const { k, b, d } = bm25params\n  const invDocFreq = Math.log(1 + (totalCount - matchingCount + 0.5) / (matchingCount + 0.5))\n  return invDocFreq * (d + termFreq * (k + 1) / (termFreq + k * (1 - b + b * fieldLength / avgFieldLength)))\n}\n\nconst termToQuerySpec = (options: SearchOptions) => (term: string, i: number, terms: string[]): QuerySpec => {\n  const fuzzy = (typeof options.fuzzy === 'function')\n    ? options.fuzzy(term, i, terms)\n    : (options.fuzzy || false)\n  const prefix = (typeof options.prefix === 'function')\n    ? options.prefix(term, i, terms)\n    : (options.prefix === true)\n  const termBoost = (typeof options.boostTerm === 'function')\n    ? options.boostTerm(term, i, terms)\n    : 1\n  return { term, fuzzy, prefix, termBoost }\n}\n\nconst defaultOptions = {\n  idField: 'id',\n  extractField: (document: any, fieldName: string) => document[fieldName],\n  stringifyField: (fieldValue: any, fieldName: string) => fieldValue.toString(),\n  tokenize: (text: string) => text.split(SPACE_OR_PUNCTUATION),\n  processTerm: (term: string) => term.toLowerCase(),\n  fields: undefined,\n  searchOptions: undefined,\n  storeFields: [],\n  logger: (level: LogLevel, message: string): void => {\n    if (typeof console?.[level] === 'function') console[level](message)\n  },\n  autoVacuum: true\n}\n\nconst defaultSearchOptions = {\n  combineWith: OR,\n  prefix: false,\n  fuzzy: false,\n  maxFuzzy: 6,\n  boost: {},\n  weights: { fuzzy: 0.45, prefix: 0.375 },\n  bm25: defaultBM25params\n}\n\nconst defaultAutoSuggestOptions = {\n  combineWith: AND,\n  prefix: (term: string, i: number, terms: string[]): boolean =>\n    i === terms.length - 1\n}\n\nconst defaultVacuumOptions = { batchSize: 1000, batchWait: 10 }\nconst defaultVacuumConditions = { minDirtFactor: 0.1, minDirtCount: 20 }\n\nconst defaultAutoVacuumOptions = { ...defaultVacuumOptions, ...defaultVacuumConditions }\n\nconst assignUniqueTerm = (target: string[], term: string): void => {\n  // Avoid adding duplicate terms.\n  if (!target.includes(term)) target.push(term)\n}\n\nconst assignUniqueTerms = (target: string[], source: readonly string[]): void => {\n  for (const term of source) {\n    // Avoid adding duplicate terms.\n    if (!target.includes(term)) target.push(term)\n  }\n}\n\ntype Scored = { score: number }\nconst byScore = ({ score: a }: Scored, { score: b }: Scored) => b - a\n\nconst createMap = () => new Map()\n\ninterface SerializedIndexEntry {\n  [key: string]: number\n}\n\nconst objectToNumericMap = <T>(object: { [key: string]: T }): Map<number, T> => {\n  const map = new Map()\n\n  for (const key of Object.keys(object)) {\n    map.set(parseInt(key, 10), object[key])\n  }\n\n  return map\n}\n\nconst objectToNumericMapAsync = async <T>(object: { [key: string]: T }): Promise<Map<number, T>> => {\n  const map = new Map()\n\n  let count = 0\n  for (const key of Object.keys(object)) {\n    map.set(parseInt(key, 10), object[key])\n    if (++count % 1000 === 0) {\n      await wait(0)\n    }\n  }\n\n  return map\n}\n\nconst wait = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))\n\n// This regular expression matches any Unicode space, newline, or punctuation\n// character\nconst SPACE_OR_PUNCTUATION = /[\\n\\r\\p{Z}\\p{P}]+/u\n"],
  "mappings": "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",
  "names": ["require_lodash", "__commonJSMin", "exports", "module", "init_define_process", "LARGE_ARRAY_SIZE", "HASH_UNDEFINED", "HOT_COUNT", "HOT_SPAN", "MAX_SAFE_INTEGER", "argsTag", "arrayTag", "asyncTag", "boolTag", "dateTag", "errorTag", "funcTag", "genTag", "mapTag", "numberTag", "nullTag", "objectTag", "proxyTag", "regexpTag", "setTag", "stringTag", "undefinedTag", "weakMapTag", "arrayBufferTag", "dataViewTag", "float32Tag", "float64Tag", "int8Tag", "int16Tag", "int32Tag", "uint8Tag", "uint8ClampedTag", "uint16Tag", "uint32Tag", "reRegExpChar", "reIsHostCtor", "reIsUint", "typedArrayTags", "freeGlobal", "freeSelf", "root", "freeExports", "freeModule", "moduleExports", "freeProcess", "nodeUtil", "types", "nodeIsTypedArray", "apply", "func", "thisArg", "args", "baseTimes", "n", "iteratee", "index", "result", "baseUnary", "value", "getValue", "object", "key", "overArg", "transform", "arg", "arrayProto", "funcProto", "objectProto", "coreJsData", "funcToString", "hasOwnProperty", "maskSrcKey", "uid", "nativeObjectToString", "objectCtorString", "reIsNative", "Buffer", "Symbol", "Uint8Array", "allocUnsafe", "getPrototype", "objectCreate", "propertyIsEnumerable", "splice", "symToStringTag", "defineProperty", "getNative", "nativeIsBuffer", "nativeMax", "nativeNow", "Map", "nativeCreate", "baseCreate", "proto", "isObject", "Hash", "entries", "length", "entry", "hashClear", "hashDelete", "hashGet", "data", "hashHas", "hashSet", "ListCache", "listCacheClear", "listCacheDelete", "assocIndexOf", "lastIndex", "listCacheGet", "listCacheHas", "listCacheSet", "MapCache", "mapCacheClear", "mapCacheDelete", "getMapData", "mapCacheGet", "mapCacheHas", "mapCacheSet", "size", "Stack", "stackClear", "stackDelete", "stackGet", "stackHas", "stackSet", "pairs", "arrayLikeKeys", "inherited", "isArr", "isArray", "isArg", "isArguments", "isBuff", "isBuffer", "isType", "isTypedArray", "skipIndexes", "isIndex", "assignMergeValue", "eq", "baseAssignValue", "assignValue", "objValue", "array", "baseFor", "createBaseFor", "baseGetTag", "getRawTag", "objectToString", "baseIsArguments", "isObjectLike", "baseIsNative", "isMasked", "pattern", "isFunction", "toSource", "baseIsTypedArray", "isLength", "baseKeysIn", "nativeKeysIn", "isProto", "isPrototype", "baseMerge", "source", "srcIndex", "customizer", "stack", "srcValue", "baseMergeDeep", "newValue", "safeGet", "keysIn", "mergeFunc", "stacked", "isCommon", "isTyped", "isArrayLikeObject", "copyArray", "cloneBuffer", "cloneTypedArray", "isPlainObject", "toPlainObject", "initCloneObject", "baseRest", "start", "setToString", "overRest", "identity", "baseSetToString", "string", "constant", "buffer", "isDeep", "cloneArrayBuffer", "arrayBuffer", "typedArray", "copyObject", "props", "isNew", "createAssigner", "assigner", "sources", "guard", "isIterateeCall", "fromRight", "keysFunc", "iterable", "customDefaultsMerge", "map", "isKeyable", "isOwn", "tag", "unmasked", "type", "isArrayLike", "Ctor", "otherArgs", "shortOut", "count", "lastCalled", "stamp", "remaining", "other", "stubFalse", "defaultsDeep", "mergeWith", "init_define_process", "init_define_process", "ENTRIES", "KEYS", "VALUES", "LEAF", "TreeIterator", "set", "type", "node", "keys", "value", "last", "child", "key", "array", "fuzzySearch", "query", "maxDistance", "results", "n", "m", "matrix", "j", "i", "recurse", "prefix", "offset", "distance", "pos", "char", "thisRowOffset", "prevRowOffset", "minDistance", "jmin", "jmax", "different", "rpl", "del", "ins", "dist", "SearchableMap", "_SearchableMap", "tree", "path", "trackDown", "parentNode", "k", "remove", "fn", "maxEditDistance", "lookup", "createPath", "iter", "initial", "entries", "object", "keyLength", "outer", "len", "intermediate", "cleanup", "merge", "nodeKey", "OR", "AND", "AND_NOT", "MiniSearch", "_MiniSearch", "options", "autoVacuum", "defaultAutoVacuumOptions", "defaultOptions", "defaultSearchOptions", "defaultAutoSuggestOptions", "defaultVacuumConditions", "document", "extractField", "stringifyField", "tokenize", "processTerm", "fields", "idField", "id", "shortDocumentId", "field", "fieldValue", "tokens", "fieldId", "uniqueTerms", "term", "processedTerm", "t", "documents", "chunkSize", "acc", "chunk", "promise", "resolve", "shortId", "fieldLength", "minDirtFactor", "minDirtCount", "batchSize", "batchWait", "ids", "updatedDocument", "conditions", "initialDirtCount", "defaultVacuumOptions", "fieldsData", "fieldIndex", "searchOptions", "globalSearchOptions", "searchOptionsWithDefaults", "rawResults", "docId", "score", "terms", "match", "quality", "result", "byScore", "queryString", "suggestions", "phrase", "suggestion", "count", "json", "optionName", "getOwnProperty", "js", "index", "documentIds", "storedFields", "serializationVersion", "miniSearch", "objectToNumericMap", "data", "dataMap", "indexEntry", "objectToNumericMapAsync", "wait", "documentCount", "nextId", "fieldIds", "averageFieldLength", "dirtCount", "subquery", "searchTokenize", "searchProcessTerm", "termToQuerySpec", "boosts", "boostDocument", "weights", "maxFuzzy", "bm25params", "fuzzyWeight", "prefixWeight", "prefixMatches", "fuzzyMatches", "fuzzy", "weight", "combineWith", "operator", "combinator", "combinators", "freqs", "sourceTerm", "derivedTerm", "termWeight", "termBoost", "fieldTermData", "fieldBoosts", "boostDocumentFn", "fieldBoost", "fieldTermFreqs", "matchingFields", "avgFieldLength", "docBoost", "termFreq", "rawScore", "calcBM25Score", "weightedScore", "assignUniqueTerm", "documentId", "indexData", "createMap", "docs", "fieldName", "length", "fieldLengths", "totalFieldLength", "doc", "storeFields", "documentFields", "property", "a", "b", "existing", "assignUniqueTerms", "combined", "defaultBM25params", "matchingCount", "totalCount", "d", "text", "SPACE_OR_PUNCTUATION", "level", "message", "target", "source", "map", "ms", "import_lodash", "z", "_trackSearchDebounced", "_InternalSearch_instances", "trackSearch_fn", "InternalSearch", "mapData", "__privateAdd", "__publicField", "buildIndexes", "__privateSet", "debounce", "__privateMethod", "placesIndex", "locationsIndex", "categoriesIndex", "promises", "term", "options", "searchOptionsSchema", "_options", "defaultsDeep", "DEFAULT_CONFIG", "places", "key", "locations", "categories", "result", "processSearchResult", "__privateGet", "suggestOptionsSchema", "suggestions", "includePlaces", "includeLocations", "s", "a", "b", "placesResult", "locationsResult", "categoriesResult", "acc", "id", "match", "score", "__type", "item", "node_default", "floor_stack_default", "facade_default", "location_default", "category_default", "removeAccents", "it", "MiniSearch", "document", "fieldName", "value", "STOP_WORDS", "r", "t", "DELIMITER", "z"]
}
